/*
 * This file is automatically generated.
 * Check the github repository for a readable version:
 * http://github.com/fsantanna/ceu
 *
 * CÃ©u is distributed under the MIT License:
 *

Copyright (C) 2012 Francisco Sant'Anna

Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the "Software"), to deal in
the Software without restriction, including without limitation the rights to
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
of the Software, and to permit persons to whom the Software is furnished to do
so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/
#line 1 "chaser.ceu"

#ifndef _CEU_APP_H
#define _CEU_APP_H

#include "ceu_types.h"

#define CEU_EXTS
#define CEU_ORGS_AWAIT
#define CEU_ORGS_NEWS_MALLOC
#define CEU_ADTS_NEWS
#define CEU_CLEAR
#define CEU_ORGS
#define CEU_ORGS_NEWS
#define CEU_GOTO
#define CEU_RET
#define CEU_ADTS_NEWS_MALLOC
#define CEU_ADTS_AWAIT
#define CEU_ADTS_AWAIT_BTree
     /* CEU_EXTS, CEU_WCLOCKS, CEU_INTS, ... */

/* TODO: lbl => unsigned */
#ifndef CEU_OS
typedef s8 tceu_nlbl;
#endif

#ifdef CEU_IFCS
/* (x) number of different classes */
typedef s16 tceu_ncls;
#endif

/* TODO: remove */
#define CEU_NTRAILS 13

#ifndef _CEU_OS_H
#define _CEU_OS_H

#include <stddef.h>
#include "ceu_types.h"

#ifdef CEU_DEBUG
#include <assert.h>
#endif

#if defined(CEU_OS) && defined(__AVR)
#error Understand this again!
#include "Arduino.h"
#define CEU_ISR
#define CEU_ISR_ON()  interrupts()
#define CEU_ISR_OFF() noInterrupts()
#else
#define CEU_ISR_ON()
#define CEU_ISR_OFF()
#endif

/*
#if defined(CEU_CLEAR) || defined(CEU_INTS) || defined(CEU_ORGS) || defined(CEU_REENTRANT)
*/
#if 1
#include <setjmp.h>
#define CEU_STACK
#endif

#if defined(CEU_OS_KERNEL) || defined(CEU_OS_APP)
#define CEU_OS
#endif

#if defined(CEU_ORGS_NEWS) || defined(CEU_ADTS_NEWS)
#define CEU_NEWS
#endif
#if defined(CEU_ORGS_NEWS_POOL) || defined(CEU_ADTS_NEWS_POOL)
#define CEU_NEWS_POOL
#endif
#if defined(CEU_ORGS_AWAIT) || defined(CEU_ADTS_AWAIT)
#define CEU_ORGS_OR_ADTS_AWAIT
#endif

#ifdef CEU_OS

    /* TODO: all should be configurable */
    #define CEU_EXTS
    #define CEU_WCLOCKS
    #define CEU_ASYNCS
    #define CEU_RET
    #define CEU_CLEAR
    #define CEU_STACK
#ifndef __AVR
#endif
    #define CEU_INTS
    #define CEU_ORGS
    /*#define CEU_PSES*/ /* TODO: never tried */
    #define CEU_NEWS
    #define CEU_NEWS_POOL
    #define CEU_ORGS_NEWS
    #define CEU_ORGS_NEWS_MALLOC
    #define CEU_ORGS_NEWS_POOL
    #define CEU_ADTS_NEWS
    #define CEU_ADTS_NEWS_MALLOC
    #define CEU_ADTS_NEWS_POOL
    #define CEU_ORGS_AWAIT
    #define CEU_ADTS_AWAIT
    #define CEU_ORGS_OR_ADTS_AWAIT
/*
    #define CEU_THREADS
*/

#ifdef __AVR
    #define CEU_QUEUE_MAX 256
#else
    #define CEU_QUEUE_MAX 65536
#endif

    #define CEU_IN__NONE          0
    #define CEU_IN__ORG         255
    #define CEU_IN__ORG_PSED    254
    #define CEU_IN__CLEAR       253
    #define CEU_IN__ok_killed   252
    #define CEU_IN__INIT        251     /* HIGHER EXTERNAL */
    #define CEU_IN__ASYNC       250
    #define CEU_IN__THREAD      249
    #define CEU_IN__WCLOCK      248
    #define CEU_IN_OS_START     247
    #define CEU_IN_OS_STOP      246
    #define CEU_IN_OS_DT        245
    #define CEU_IN_OS_INTERRUPT 244
#ifdef CEU_TIMEMACHINE
    #define CEU_IN__WCLOCK_     243
    #define CEU_IN              243
#else
    #define CEU_IN              242
#endif

    #define CEU_IN_higher       CEU_IN__INIT  /* _INIT = HIGHER EXTERNAL */
    #define CEU_IN_lower        128     /* TODO: not checked from up and down */

    typedef s8 tceu_nlbl;   /* TODO: to small!! */

#endif /* CEU_OS */

#ifdef CEU_OS_APP

    #define ceu_out_log(mode,str) \
        ((__typeof__(ceu_sys_log)*)((_ceu_app)->sys_vec[CEU_SYS_LOG]))(mode,str)

    #define ceu_out_assert(v) \
        ((__typeof__(ceu_sys_assert)*)((_ceu_app)->sys_vec[CEU_SYS_ASSERT]))(v)

    #define ceu_out_assert_msg_ex(v,msg,file,line)       \
        {                                                \
            int __ceu_v = v;                             \
            if ((!(__ceu_v)) && ((msg)!=NULL)) {         \
                ceu_out_log(0, (long)"[");               \
                ceu_out_log(0, (long)(file));            \
                ceu_out_log(0, (long)":");               \
                ceu_out_log(2, (line));                  \
                ceu_out_log(0, (long)"] ");              \
                ceu_out_log(0, (long)"runtime error: "); \
                ceu_out_log(0, (long)(msg));             \
                ceu_out_log(0, (long)"\n");              \
            }                                            \
            ((__typeof__(ceu_sys_assert)*)((_ceu_app)->sys_vec[CEU_SYS_ASSERT]))(__ceu_v); \
        }
    #define ceu_out_assert_msg(v,msg) ceu_out_assert_msg_ex((v),(msg),__FILE__,__LINE__)

    #define ceu_out_realloc(ptr, size) \
        ((__typeof__(ceu_sys_realloc)*)((_ceu_app)->sys_vec[CEU_SYS_REALLOC]))(ptr,size)

    #define ceu_out_req() \
        ((__typeof__(ceu_sys_req)*)((_ceu_app)->sys_vec[CEU_SYS_REQ]))()

    #define ceu_out_load(addr) \
        ((__typeof__(ceu_sys_load)*)((_ceu_app)->sys_vec[CEU_SYS_LOAD]))(addr)

#ifdef CEU_ISR
    #define ceu_out_isr(n,f) \
        ((__typeof__(ceu_sys_isr)*)((_ceu_app)->sys_vec[CEU_SYS_ISR]))(n,f,_ceu_app)
#endif

    #define ceu_out_org_init(app,org,n,lbl,cls,isDyn,parent_org,parent_trl) \
        ((__typeof__(ceu_sys_org_init)*)((app)->sys_vec[CEU_SYS_ORG]))(org,n,lbl,cls,isDyn,parent_org,parent_trl)
    #define ceu_out_start(app) \
        ((__typeof__(ceu_sys_start)*)((_ceu_app)->sys_vec[CEU_SYS_START]))(app)
    #define ceu_out_link(app1,evt1 , app2,evt2) \
        ((__typeof__(ceu_sys_link)*)((_ceu_app)->sys_vec[CEU_SYS_LINK]))(app1,evt1,app2,evt2)

    #define ceu_out_emit(app,id,sz,buf) \
        ((__typeof__(ceu_sys_emit)*)((app)->sys_vec[CEU_SYS_EMIT]))(app,id,sz,buf)

    #define ceu_out_call(app,id,param) \
        ((__typeof__(ceu_sys_call)*)((app)->sys_vec[CEU_SYS_CALL]))(app,id,param)

#ifdef CEU_WCLOCKS
    #define ceu_out_wclock(app,dt,set,get) \
        ((__typeof__(ceu_sys_wclock)*)((app)->sys_vec[CEU_SYS_WCLOCK]))(app,dt,set,get)
#ifdef CEU_TIMEMACHINE
    #error TIMEMACHINE
#endif
#endif

    #define ceu_out_go(app,evt,evtp) \
        ((__typeof__(ceu_sys_go)*)((app)->sys_vec[CEU_SYS_GO]))(app,evt,evtp)

#else /* ! CEU_OS_APP (!CEU_OS||CEU_OS_KERNEL) */

    #ifndef ceu_out_assert
        #error "Missing definition for macro \"ceu_out_assert\"."
    #endif

    #ifndef ceu_out_log
        #error "Missing definition for macro \"ceu_out_log\"."
    #endif

    #define ceu_out_assert_msg_ex(v,msg,file,line)          \
        {                                                   \
            int __ceu_v = v;                                \
            if ((!(__ceu_v)) && ((msg)!=NULL)) {            \
                ceu_out_log(0, (long)"[");                  \
                ceu_out_log(0, (long)(file));               \
                ceu_out_log(0, (long)":");                  \
                ceu_out_log(2, line);                       \
                ceu_out_log(0, (long)"] ");                 \
                ceu_out_log(0, (long)"runtime error: ");    \
                ceu_out_log(0, (long)(msg));                \
                ceu_out_log(0, (long)"\n");                 \
            }                                               \
            ceu_out_assert(__ceu_v);                        \
        }
    #define ceu_out_assert_msg(v,msg) ceu_out_assert_msg_ex((v),(msg),__FILE__,__LINE__)

    #define ceu_out_realloc(ptr,size) \
            ceu_sys_realloc(ptr,size)
    #define ceu_out_req() \
            ceu_sys_req()
    #define ceu_out_org_init(app,org,n,lbl,cls,isDyn,parent_org,parent_trl) \
            ceu_sys_org_init(org,n,lbl,cls,isDyn,parent_org,parent_trl)

#ifdef CEU_WCLOCKS
    #define ceu_out_wclock(app,dt,set,get) \
            ceu_sys_wclock(app,dt,set,get)
#ifdef CEU_TIMEMACHINE
    #define ceu_out_wclock_(app,dt,set,get) \
            ceu_sys_wclock_(app,dt,set,get)
#endif
#endif
    #define ceu_out_go(app,evt,evtp) \
            ceu_sys_go(app,evt,evtp)
    #define ceu_out_go_stk(app,evt,evtp,stk) \
            ceu_sys_go_stk(app,evt,evtp,stk)

#endif /* ! CEU_OS_APP (!CEU_OS||CEU_OS_KERNEL) */

#define ceu_in_emit(app,id,n,buf) \
    ceu_out_go_stk(app,id,buf,&stk_)

#ifdef CEU_THREADS
/* TODO: app */
#ifndef _CEU_THREADS_H
#define _CEU_THREADS_H

#include <pthread.h>
#define CEU_THREADS_T               pthread_t
#define CEU_THREADS_MUTEX_T         pthread_mutex_t
#define CEU_THREADS_COND_T          pthread_cond_t
#define CEU_THREADS_SELF()          pthread_self()
#define CEU_THREADS_CREATE(t,f,p)   pthread_create(t,NULL,f,p)
#define CEU_THREADS_DETACH(t)       pthread_detach(t)
/*
#define CEU_THREADS_MUTEX_LOCK(m)   pthread_mutex_lock(m); printf("L[%d]\n",__LINE__)
#define CEU_THREADS_MUTEX_UNLOCK(m) pthread_mutex_unlock(m); printf("U[%d]\n",__LINE__)
*/
#define CEU_THREADS_MUTEX_LOCK(m)   pthread_mutex_lock(m)
#define CEU_THREADS_MUTEX_UNLOCK(m) pthread_mutex_unlock(m);
/*
#define CEU_THREADS_COND_WAIT(c,m)  pthread_cond_wait(c,m)
#define CEU_THREADS_COND_SIGNAL(c)  pthread_cond_signal(c)
*/

#endif

#endif

#ifdef CEU_LUA
#include <stdio.h>      /* BUFSIZ */
#include <string.h>     /* strcpy */
#if defined(__ANDROID__) || defined(CEU_OS)
    #include "lua.h"
    #include "lauxlib.h"
    #include "lualib.h"
#else
    #include <lua5.1/lua.h>
    #include <lua5.1/lauxlib.h>
    #include <lua5.1/lualib.h>
#endif

#ifdef CEU_OS_APP
    #define ceu_luaL_newstate(set) { \
        set = ceu_out_call(_ceu_app, CEU_OUT_LUA_NEW, NULL); \
    }

    #define ceu_luaL_openlibs(l) { \
        lua_State* p = l;          \
        ceu_out_call(_ceu_app, CEU_OUT_LUAL_OPENLIBS, &p); \
    }

    #define ceu_lua_atpanic(l, f) {     \
    }

    #define ceu_luaL_loadstring(set, l, str) {  \
        tceu__lua_State___char_ p = { l, str }; \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUAL_LOADSTRING, &p); \
    }

    #define ceu_lua_pushnumber(l, v) {      \
        tceu__lua_State___int p = { l, v }; \
        ceu_out_call(_ceu_app, CEU_OUT_LUA_PUSHNUMBER, &p); \
    }

    #define ceu_lua_pushstring(l, v) {      \
        tceu__lua_State___char_ p = { l, v }; \
        ceu_out_call(_ceu_app, CEU_OUT_LUA_PUSHSTRING, &p); \
    }

    #define ceu_lua_pushlightuserdata(l, v) {   \
        tceu__lua_State___void_ p = { l, v };     \
        ceu_out_call(_ceu_app, CEU_OUT_LUA_PUSHLIGHTUSERDATA, &p); \
    }

    #define ceu_lua_pcall(set,l,nargs,nrets,err) {                  \
        tceu__lua_State___int__int__int p = { l, nargs, nrets, err }; \
        ceu_out_call(_ceu_app, CEU_OUT_LUA_PCALL, &p); \
    }

    #define ceu_lua_isnumber(set, l, idx) {     \
        tceu__lua_State___int p = { l, idx };   \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUA_ISNUMBER, &p); \
    }

    #define ceu_lua_tonumber(set, l, idx) {     \
        tceu__lua_State___int p = { l, idx };   \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUA_TONUMBER, &p); \
    }

    #define ceu_lua_isboolean(set, l, idx) {    \
        tceu__lua_State___int p = { l, idx };   \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUA_ISBOOLEAN, &p); \
    }

    #define ceu_lua_toboolean(set, l, idx) {    \
        tceu__lua_State___int p = { l, idx };   \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUA_TOBOOLEAN, &p); \
    }

    #define ceu_lua_pop(l, n) {             \
        tceu__lua_State___int p = { l, n }; \
        ceu_out_call(_ceu_app, CEU_OUT_LUA_POP, &p); \
    }

    #define ceu_lua_isstring(set, l, idx) {     \
        tceu__lua_State___int p = { l, idx };   \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUA_ISSTRING, &p); \
    }

    #define ceu_lua_tostring(set, l, idx) {     \
        tceu__lua_State___int p = { l, idx };   \
        set = ceu_out_call(_ceu_app, CEU_OUT_LUA_TOSTRING, &p); \
    }

    #define ceu_lua_islightuserdata(set, l, idx) {  \
        tceu__lua_State___int p = { l, idx };       \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUA_ISLIGHTUSERDATA, &p); \
    }

    #define ceu_lua_touserdata(set, l, idx) {   \
        tceu__lua_State___int p = { l, idx };   \
        set = ceu_out_call(_ceu_app, CEU_OUT_LUA_TOUSERDATA, &p); \
    }

    #define ceu_lua_error(l) {                          \
        lua_State** p = &l;                             \
        ceu_out_call(_ceu_app, CEU_OUT_LUA_ERROR, &p);  \
    }

    #define ceu_lua_objlen(set, l, idx) {                       \
        tceu__lua_State___int p = { l, idx };                   \
        set = ceu_out_call(_ceu_app, CEU_OUT_LUA_OBJLEN, &p);   \
    }

#else
    #define ceu_luaL_newstate(set)               set = luaL_newstate()
    #define ceu_luaL_openlibs(l)                 luaL_openlibs(l)
    #define ceu_lua_atpanic(l,f)                 lua_atpanic(l,f)
    #define ceu_luaL_loadstring(set,l,str)       set = luaL_loadstring(l,str)
    #define ceu_lua_pushnumber(l,v)              lua_pushnumber(l,v)
    #define ceu_lua_pushstring(l,v)              lua_pushstring(l,v)
    #define ceu_lua_pushlightuserdata(l,v)       lua_pushlightuserdata(l,v)
    #define ceu_lua_pcall(set,l,nargs,nrets,err) set = lua_pcall(l,nargs,nrets,err)
    #define ceu_lua_isnumber(set,l,idx)          set = lua_isnumber(l,idx)
    #define ceu_lua_tonumber(set,l,idx)          set = lua_tonumber(l,idx)
    #define ceu_lua_isboolean(set,l,idx)         set = lua_isboolean(l,idx)
    #define ceu_lua_toboolean(set,l,idx)         set = lua_toboolean(l,idx)
    #define ceu_lua_pop(l,n)                     lua_pop(l,n)
    #define ceu_lua_isstring(set,l,idx)          set = lua_isstring(l,idx)
    #define ceu_lua_tostring(set,l,idx)          set = lua_tostring(l,idx)
    #define ceu_lua_islightuserdata(set,l,idx)   set = lua_islightuserdata(l,idx)
    #define ceu_lua_touserdata(set,l,idx)        set = lua_touserdata(l,idx)
    #define ceu_lua_error(l)                     lua_error(l)
    #define ceu_lua_objlen(set,l,idx)            set = lua_objlen(l,idx)
#endif
#endif

typedef u8 tceu_nevt;   /* max number of events */
                        /* TODO: should "u8" be fixed? */

typedef u8 tceu_ntrl;   /* max number of trails per class */
                        /* TODO: should "u8" be fixed? */

#ifdef CEU_STACK
typedef u16 tceu_nstk;  /* max size of internal stack in bytes */
                        /* TODO: should "u16" be fixed? */
#endif

#ifdef __cplusplus
#define CEU_WCLOCK_INACTIVE 0x7fffffffL     /* TODO */
#else
#define CEU_WCLOCK_INACTIVE INT32_MAX
#endif
#define CEU_WCLOCK_EXPIRED (CEU_WCLOCK_INACTIVE-1)

/* TCEU_TRL */

struct tceu_org;
typedef union tceu_trl {
    tceu_nevt evt;

    /* normal await // IN__CLEAR */
    struct {                    /* TODO(ram): bitfields */
        tceu_nevt evt1;
        tceu_nlbl lbl;
        u8        seqno;        /* TODO(ram): 2 bits is enough */
#ifdef CEU_INTS                 /* R-9: size of trails for internal events */
#ifdef CEU_ORGS
        void*     evto;
#endif
#endif
    };

    /* IN__ORG */
#ifdef CEU_ORGS
    struct {                    /* TODO(ram): bad for alignment */
        tceu_nevt evt3;
        struct tceu_org* org;
    };
#endif

    /* _ok_killed */
#ifdef CEU_ORGS_OR_ADTS_AWAIT
    struct {
        tceu_nevt evt4;
        tceu_nlbl lbl4;
        void*     org_or_adt;
    };
#endif
} tceu_trl;

/* TCEU_EVT */

typedef struct tceu_evt {
    tceu_nevt id;
    void*     param;
#if defined(CEU_ORGS) && defined(CEU_INTS)
    void*     org;      /* emitting org */
#endif
} tceu_evt;

/* TCEU_ORG */

struct tceu_pool_orgs;
typedef struct tceu_org
{
#ifdef CEU_ORGS
    struct tceu_org* nxt; /* first field because of free list for orgs/adts */
    struct tceu_org* prv;
    struct tceu_org* parent_org;
    tceu_ntrl parent_trl;
#endif

#if defined(CEU_ORGS) || defined(CEU_OS)
    tceu_ntrl n;            /* number of trails (TODO(ram): opt, metadata) */
#endif

#ifdef CEU_ORGS

#ifdef CEU_IFCS
    tceu_ncls cls;          /* class id */
#endif
    u8 isAlive: 1;          /* Three purposes:
                             * - avoids double free
                             * - required by "watching o" to avoid awaiting a
                             *      dead org
                             * - required by "Do T" to avoid awaiting a dead 
                             *      org
                             */
#if defined(CEU_ORGS_NEWS) || defined(CEU_ORGS_AWAIT)
#endif
#ifdef CEU_ORGS_NEWS
    u8 isDyn: 1;            /* created w/ new or spawn? */
#endif
#ifdef CEU_ORGS_NEWS_POOL
    struct tceu_pool_orgs* pool;
#endif

#ifdef CEU_ORGS_AWAIT
    int ret;
#endif

#endif  /* CEU_ORGS */

    tceu_trl trls[0];       /* first trail */

} tceu_org;

/* TCEU_POOL_ORGS , TCEU_POOL_ADTS */

#if defined(CEU_ORGS_NEWS_POOL) || defined(CEU_ADTS_NEWS_POOL)
#ifndef _CEU_POOL_H
#define _CEU_POOL_H

#include "ceu_types.h"

/* TODO: all "int" here, should evaluate the correct unsigned type */

typedef struct {
    byte**  queue;
                    /* queue is in the next offset to distinguish dynamic(NULL)
                       from static pools(any-address) */
    int     size;
    int     free;
    int     index;
    int     unit;
    byte*   mem;
} tceu_pool;

#define CEU_POOL_DCL(name, type, size) \
    type*     name##_queue[size];      \
    type      name##_mem[size];        \
    tceu_pool name;

void ceu_pool_init (tceu_pool* pool, int size, int unit, byte** queue, byte* mem);
byte* ceu_pool_alloc (tceu_pool* pool);
void ceu_pool_free (tceu_pool* pool, byte* val);

#endif

#endif

#ifdef CEU_ORGS_NEWS
typedef struct tceu_pool_orgs {
    tceu_org* parent_org;
    tceu_ntrl parent_trl;
#ifdef CEU_ORGS_NEWS_POOL
    tceu_pool pool;
#endif
} tceu_pool_orgs;
#endif

#ifdef CEU_ADTS_NEWS
typedef struct {
    void* root;
#ifdef CEU_ADTS_NEWS_POOL
    void* pool;
#endif
} tceu_pool_adts;
#endif

/* TCEU_KILL */

#ifdef CEU_ORGS_OR_ADTS_AWAIT
typedef struct tceu_kill {
    void*     org_or_adt;
    int       ret;
} tceu_kill;
#endif

/* TCEU_LST */

#ifdef CEU_DEBUG
typedef struct tceu_lst {
#ifdef CEU_ORGS
    void*     org;
#endif
    tceu_trl* trl;
    tceu_nlbl lbl;
} tceu_lst;

#endif

/* TCEU_STK */

typedef struct tceu_stk {
    struct tceu_stk* up;
    tceu_org* org;
    tceu_ntrl trl1;
    tceu_ntrl trl2;
    jmp_buf   jmp;
} tceu_stk;

/* TCEU_JMP */

#ifdef CEU_STACK
typedef struct tceu_jmp {
#ifdef CEU_ORGS
    tceu_org* org;
#endif
    tceu_trl* trl;
    tceu_nlbl lbl;
} tceu_jmp;
#endif

/* TCEU_APP */

typedef struct tceu_app {
    /* global seqno: incremented on every reaction
     * awaiting trails matches only if trl->seqno < seqno,
     * i.e., previously awaiting the event
     */
    u8 seqno:          2;
#if defined(CEU_RET) || defined(CEU_OS)
    u8 isAlive:        1;
#endif
#ifdef CEU_ASYNCS
    u8 pendingAsyncs:  1;
#endif
#if defined(CEU_ORGS_NEWS_MALLOC) && defined(CEU_ORGS_AWAIT)
    u8 dont_emit_kill: 1;
#endif

#ifdef CEU_OS
    struct tceu_app* nxt;
#endif

#ifdef CEU_REENTRANT
    tceu_nstk stki;
#endif

#ifdef CEU_STACK
    tceu_stk* stk_bottom;
    tceu_jmp  stk_jmp;
#endif

#if defined(CEU_RET) || defined(CEU_ORGS_AWAIT)
    int ret;
#endif

#ifdef CEU_ORGS_NEWS_MALLOC
    tceu_org* tofree;
#endif

#ifdef CEU_WCLOCKS
    s32         wclk_late;
    s32         wclk_min_set;   /* used to set */
    s32         wclk_min_cmp;   /* used to compare */
                                /* cmp<-set every reaction */
#ifdef CEU_TIMEMACHINE
    s32         wclk_late_;
    s32         wclk_min_set_;
    s32         wclk_min_cmp_;
#endif
#endif

#ifndef CEU_OS
#ifdef CEU_DEBUG
    tceu_lst    lst; /* segfault printf */
#endif
#endif

#ifdef CEU_THREADS
    CEU_THREADS_MUTEX_T threads_mutex;
    /*CEU_THREADS_COND_T  threads_cond;*/
    u8                  threads_n;          /* number of running threads */
        /* TODO: u8? */
#endif
#if defined(CEU_LUA) || defined(CEU_OS)
#ifdef CEU_LUA
    lua_State*  lua;    /* TODO: move to data? */
#else
    void*       lua;
#endif
#endif

    void        (*code)  (struct tceu_app*,tceu_evt*,tceu_org*,tceu_trl*,tceu_stk*);
    void        (*init)  (struct tceu_app*);
#ifdef CEU_OS
    void*       (*calls) (struct tceu_app*,tceu_nevt,void*);
    void**      sys_vec;
    void*       addr;
#ifdef CEU_OS_LUAIFC
    char*       luaifc;
#endif
#endif
    tceu_org*   data;
} tceu_app;

#ifdef CEU_OS
typedef void (*tceu_init)   (tceu_app* app);
typedef void (*tceu_export) (uint* size, tceu_init** init
#ifdef CEU_OS_LUAIFC
                            , char** luaifc
#endif
);
#endif

/* TCEU_THREADS_P */

#ifdef CEU_THREADS
typedef struct {
    tceu_app* app;
    tceu_org* org;
    s8*       st; /* thread state:
                   * 0=ini (sync  spawns)
                   * 1=cpy (async copies)
                   * 2=lck (sync  locks)
                   * 3=end (sync/async terminates)
                   */
} tceu_threads_p;
#endif

#ifdef CEU_PSES
void ceu_pause (tceu_trl* trl, tceu_trl* trlF, int psed);
#endif

int  ceu_go_all    (tceu_app* app);

#ifdef CEU_WCLOCKS
int       ceu_sys_wclock (tceu_app* app, s32 dt, s32* set, s32* get);
#endif
void      ceu_sys_go     (tceu_app* app, int evt, void* evtp);

#ifdef CEU_OS

/* TCEU_LINK */

typedef struct tceu_lnk {
    tceu_app* src_app;
    tceu_nevt src_evt;
    tceu_app* dst_app;
    tceu_nevt dst_evt;
    struct tceu_lnk* nxt;
} tceu_lnk;

/* TCEU_QUEUE */

typedef struct {
    tceu_app* app;
    tceu_nevt evt;
#if CEU_QUEUE_MAX == 256
    s8        sz;
#else
    s16       sz;   /* signed because of fill */
#endif
    byte      buf[0];
} tceu_queue;

#ifdef CEU_ISR
typedef void(*tceu_isr_f)(tceu_app* app, tceu_org* org);
#endif

void ceu_os_init      (void);
int  ceu_os_scheduler (int(*dt)());
tceu_queue* ceu_sys_queue_nxt (void);
void        ceu_sys_queue_rem (void);

void      ceu_sys_assert    (int v);
void      ceu_sys_log       (int mode, long str);
void*     ceu_sys_realloc   (void* ptr, size_t size);
int       ceu_sys_req       (void);
tceu_app* ceu_sys_load      (void* addr);
#ifdef CEU_ISR
int       ceu_sys_isr       (int n, tceu_isr_f f, tceu_app* app);
#endif
void      ceu_sys_org_init  (tceu_org* org, int n, int lbl, int cls, int isDyn,
                             tceu_org* parent_org, tceu_ntrl parent_trl);
void      ceu_sys_start     (tceu_app* app);
int       ceu_sys_link      (tceu_app* src_app, tceu_nevt src_evt, tceu_app* dst_app, tceu_nevt dst_evt);
int       ceu_sys_unlink    (tceu_app* src_app, tceu_nevt src_evt, tceu_app* dst_app, tceu_nevt dst_evt);
int       ceu_sys_emit      (tceu_app* app, tceu_nevt evt, int sz, void* param);
void*     ceu_sys_call      (tceu_app* app, tceu_nevt evt, void* param);

enum {
    CEU_SYS_ASSERT = 0,
    CEU_SYS_LOG,
    CEU_SYS_REALLOC,
    CEU_SYS_REQ,
    CEU_SYS_LOAD,
#ifdef CEU_ISR
    CEU_SYS_ISR,
#endif
#ifdef CEU_CLEAR
    CEU_SYS_CLEAR,
#endif
    CEU_SYS_STACK_PUSH,
#ifdef CEU_ORGS
    CEU_SYS_STACK_CLEAR_ORG,
#endif
    CEU_SYS_ORG,
#ifdef CEU_ORGS
    CEU_SYS_ORG_TRAIL,
    CEU_SYS_ORG_SPAWN,
#endif
    CEU_SYS_START,
    CEU_SYS_LINK,
    CEU_SYS_UNLINK,
    CEU_SYS_EMIT,
    CEU_SYS_CALL,
#ifdef CEU_WCLOCKS
    CEU_SYS_WCLOCK,
#endif
    CEU_SYS_GO,
    CEU_SYS_MAX
};

/* SYS_VECTOR
 */
extern void* CEU_SYS_VEC[CEU_SYS_MAX];

#endif  /* CEU_OS */

#endif  /* _CEU_OS_H */


#ifdef CEU_NEWS_POOL
#ifndef _CEU_POOL_H
#define _CEU_POOL_H

#include "ceu_types.h"

/* TODO: all "int" here, should evaluate the correct unsigned type */

typedef struct {
    byte**  queue;
                    /* queue is in the next offset to distinguish dynamic(NULL)
                       from static pools(any-address) */
    int     size;
    int     free;
    int     index;
    int     unit;
    byte*   mem;
} tceu_pool;

#define CEU_POOL_DCL(name, type, size) \
    type*     name##_queue[size];      \
    type      name##_mem[size];        \
    tceu_pool name;

void ceu_pool_init (tceu_pool* pool, int size, int unit, byte** queue, byte* mem);
byte* ceu_pool_alloc (tceu_pool* pool);
void ceu_pool_free (tceu_pool* pool, byte* val);

#endif

#endif

#ifdef CEU_VECTOR
#ifndef _CEU_VECTOR_H
#define _CEU_VECTOR_H

#ifndef _CEU_OS_H
#define _CEU_OS_H

#include <stddef.h>
#include "ceu_types.h"

#ifdef CEU_DEBUG
#include <assert.h>
#endif

#if defined(CEU_OS) && defined(__AVR)
#error Understand this again!
#include "Arduino.h"
#define CEU_ISR
#define CEU_ISR_ON()  interrupts()
#define CEU_ISR_OFF() noInterrupts()
#else
#define CEU_ISR_ON()
#define CEU_ISR_OFF()
#endif

/*
#if defined(CEU_CLEAR) || defined(CEU_INTS) || defined(CEU_ORGS) || defined(CEU_REENTRANT)
*/
#if 1
#include <setjmp.h>
#define CEU_STACK
#endif

#if defined(CEU_OS_KERNEL) || defined(CEU_OS_APP)
#define CEU_OS
#endif

#if defined(CEU_ORGS_NEWS) || defined(CEU_ADTS_NEWS)
#define CEU_NEWS
#endif
#if defined(CEU_ORGS_NEWS_POOL) || defined(CEU_ADTS_NEWS_POOL)
#define CEU_NEWS_POOL
#endif
#if defined(CEU_ORGS_AWAIT) || defined(CEU_ADTS_AWAIT)
#define CEU_ORGS_OR_ADTS_AWAIT
#endif

#ifdef CEU_OS

    /* TODO: all should be configurable */
    #define CEU_EXTS
    #define CEU_WCLOCKS
    #define CEU_ASYNCS
    #define CEU_RET
    #define CEU_CLEAR
    #define CEU_STACK
#ifndef __AVR
#endif
    #define CEU_INTS
    #define CEU_ORGS
    /*#define CEU_PSES*/ /* TODO: never tried */
    #define CEU_NEWS
    #define CEU_NEWS_POOL
    #define CEU_ORGS_NEWS
    #define CEU_ORGS_NEWS_MALLOC
    #define CEU_ORGS_NEWS_POOL
    #define CEU_ADTS_NEWS
    #define CEU_ADTS_NEWS_MALLOC
    #define CEU_ADTS_NEWS_POOL
    #define CEU_ORGS_AWAIT
    #define CEU_ADTS_AWAIT
    #define CEU_ORGS_OR_ADTS_AWAIT
/*
    #define CEU_THREADS
*/

#ifdef __AVR
    #define CEU_QUEUE_MAX 256
#else
    #define CEU_QUEUE_MAX 65536
#endif

    #define CEU_IN__NONE          0
    #define CEU_IN__ORG         255
    #define CEU_IN__ORG_PSED    254
    #define CEU_IN__CLEAR       253
    #define CEU_IN__ok_killed   252
    #define CEU_IN__INIT        251     /* HIGHER EXTERNAL */
    #define CEU_IN__ASYNC       250
    #define CEU_IN__THREAD      249
    #define CEU_IN__WCLOCK      248
    #define CEU_IN_OS_START     247
    #define CEU_IN_OS_STOP      246
    #define CEU_IN_OS_DT        245
    #define CEU_IN_OS_INTERRUPT 244
#ifdef CEU_TIMEMACHINE
    #define CEU_IN__WCLOCK_     243
    #define CEU_IN              243
#else
    #define CEU_IN              242
#endif

    #define CEU_IN_higher       CEU_IN__INIT  /* _INIT = HIGHER EXTERNAL */
    #define CEU_IN_lower        128     /* TODO: not checked from up and down */

    typedef s8 tceu_nlbl;   /* TODO: to small!! */

#endif /* CEU_OS */

#ifdef CEU_OS_APP

    #define ceu_out_log(mode,str) \
        ((__typeof__(ceu_sys_log)*)((_ceu_app)->sys_vec[CEU_SYS_LOG]))(mode,str)

    #define ceu_out_assert(v) \
        ((__typeof__(ceu_sys_assert)*)((_ceu_app)->sys_vec[CEU_SYS_ASSERT]))(v)

    #define ceu_out_assert_msg_ex(v,msg,file,line)       \
        {                                                \
            int __ceu_v = v;                             \
            if ((!(__ceu_v)) && ((msg)!=NULL)) {         \
                ceu_out_log(0, (long)"[");               \
                ceu_out_log(0, (long)(file));            \
                ceu_out_log(0, (long)":");               \
                ceu_out_log(2, (line));                  \
                ceu_out_log(0, (long)"] ");              \
                ceu_out_log(0, (long)"runtime error: "); \
                ceu_out_log(0, (long)(msg));             \
                ceu_out_log(0, (long)"\n");              \
            }                                            \
            ((__typeof__(ceu_sys_assert)*)((_ceu_app)->sys_vec[CEU_SYS_ASSERT]))(__ceu_v); \
        }
    #define ceu_out_assert_msg(v,msg) ceu_out_assert_msg_ex((v),(msg),__FILE__,__LINE__)

    #define ceu_out_realloc(ptr, size) \
        ((__typeof__(ceu_sys_realloc)*)((_ceu_app)->sys_vec[CEU_SYS_REALLOC]))(ptr,size)

    #define ceu_out_req() \
        ((__typeof__(ceu_sys_req)*)((_ceu_app)->sys_vec[CEU_SYS_REQ]))()

    #define ceu_out_load(addr) \
        ((__typeof__(ceu_sys_load)*)((_ceu_app)->sys_vec[CEU_SYS_LOAD]))(addr)

#ifdef CEU_ISR
    #define ceu_out_isr(n,f) \
        ((__typeof__(ceu_sys_isr)*)((_ceu_app)->sys_vec[CEU_SYS_ISR]))(n,f,_ceu_app)
#endif

    #define ceu_out_org_init(app,org,n,lbl,cls,isDyn,parent_org,parent_trl) \
        ((__typeof__(ceu_sys_org_init)*)((app)->sys_vec[CEU_SYS_ORG]))(org,n,lbl,cls,isDyn,parent_org,parent_trl)
    #define ceu_out_start(app) \
        ((__typeof__(ceu_sys_start)*)((_ceu_app)->sys_vec[CEU_SYS_START]))(app)
    #define ceu_out_link(app1,evt1 , app2,evt2) \
        ((__typeof__(ceu_sys_link)*)((_ceu_app)->sys_vec[CEU_SYS_LINK]))(app1,evt1,app2,evt2)

    #define ceu_out_emit(app,id,sz,buf) \
        ((__typeof__(ceu_sys_emit)*)((app)->sys_vec[CEU_SYS_EMIT]))(app,id,sz,buf)

    #define ceu_out_call(app,id,param) \
        ((__typeof__(ceu_sys_call)*)((app)->sys_vec[CEU_SYS_CALL]))(app,id,param)

#ifdef CEU_WCLOCKS
    #define ceu_out_wclock(app,dt,set,get) \
        ((__typeof__(ceu_sys_wclock)*)((app)->sys_vec[CEU_SYS_WCLOCK]))(app,dt,set,get)
#ifdef CEU_TIMEMACHINE
    #error TIMEMACHINE
#endif
#endif

    #define ceu_out_go(app,evt,evtp) \
        ((__typeof__(ceu_sys_go)*)((app)->sys_vec[CEU_SYS_GO]))(app,evt,evtp)

#else /* ! CEU_OS_APP (!CEU_OS||CEU_OS_KERNEL) */

    #ifndef ceu_out_assert
        #error "Missing definition for macro \"ceu_out_assert\"."
    #endif

    #ifndef ceu_out_log
        #error "Missing definition for macro \"ceu_out_log\"."
    #endif

    #define ceu_out_assert_msg_ex(v,msg,file,line)          \
        {                                                   \
            int __ceu_v = v;                                \
            if ((!(__ceu_v)) && ((msg)!=NULL)) {            \
                ceu_out_log(0, (long)"[");                  \
                ceu_out_log(0, (long)(file));               \
                ceu_out_log(0, (long)":");                  \
                ceu_out_log(2, line);                       \
                ceu_out_log(0, (long)"] ");                 \
                ceu_out_log(0, (long)"runtime error: ");    \
                ceu_out_log(0, (long)(msg));                \
                ceu_out_log(0, (long)"\n");                 \
            }                                               \
            ceu_out_assert(__ceu_v);                        \
        }
    #define ceu_out_assert_msg(v,msg) ceu_out_assert_msg_ex((v),(msg),__FILE__,__LINE__)

    #define ceu_out_realloc(ptr,size) \
            ceu_sys_realloc(ptr,size)
    #define ceu_out_req() \
            ceu_sys_req()
    #define ceu_out_org_init(app,org,n,lbl,cls,isDyn,parent_org,parent_trl) \
            ceu_sys_org_init(org,n,lbl,cls,isDyn,parent_org,parent_trl)

#ifdef CEU_WCLOCKS
    #define ceu_out_wclock(app,dt,set,get) \
            ceu_sys_wclock(app,dt,set,get)
#ifdef CEU_TIMEMACHINE
    #define ceu_out_wclock_(app,dt,set,get) \
            ceu_sys_wclock_(app,dt,set,get)
#endif
#endif
    #define ceu_out_go(app,evt,evtp) \
            ceu_sys_go(app,evt,evtp)
    #define ceu_out_go_stk(app,evt,evtp,stk) \
            ceu_sys_go_stk(app,evt,evtp,stk)

#endif /* ! CEU_OS_APP (!CEU_OS||CEU_OS_KERNEL) */

#define ceu_in_emit(app,id,n,buf) \
    ceu_out_go_stk(app,id,buf,&stk_)

#ifdef CEU_THREADS
/* TODO: app */
#include "ceu_threads.h"
#endif

#ifdef CEU_LUA
#include <stdio.h>      /* BUFSIZ */
#include <string.h>     /* strcpy */
#if defined(__ANDROID__) || defined(CEU_OS)
    #include "lua.h"
    #include "lauxlib.h"
    #include "lualib.h"
#else
    #include <lua5.1/lua.h>
    #include <lua5.1/lauxlib.h>
    #include <lua5.1/lualib.h>
#endif

#ifdef CEU_OS_APP
    #define ceu_luaL_newstate(set) { \
        set = ceu_out_call(_ceu_app, CEU_OUT_LUA_NEW, NULL); \
    }

    #define ceu_luaL_openlibs(l) { \
        lua_State* p = l;          \
        ceu_out_call(_ceu_app, CEU_OUT_LUAL_OPENLIBS, &p); \
    }

    #define ceu_lua_atpanic(l, f) {     \
    }

    #define ceu_luaL_loadstring(set, l, str) {  \
        tceu__lua_State___char_ p = { l, str }; \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUAL_LOADSTRING, &p); \
    }

    #define ceu_lua_pushnumber(l, v) {      \
        tceu__lua_State___int p = { l, v }; \
        ceu_out_call(_ceu_app, CEU_OUT_LUA_PUSHNUMBER, &p); \
    }

    #define ceu_lua_pushstring(l, v) {      \
        tceu__lua_State___char_ p = { l, v }; \
        ceu_out_call(_ceu_app, CEU_OUT_LUA_PUSHSTRING, &p); \
    }

    #define ceu_lua_pushlightuserdata(l, v) {   \
        tceu__lua_State___void_ p = { l, v };     \
        ceu_out_call(_ceu_app, CEU_OUT_LUA_PUSHLIGHTUSERDATA, &p); \
    }

    #define ceu_lua_pcall(set,l,nargs,nrets,err) {                  \
        tceu__lua_State___int__int__int p = { l, nargs, nrets, err }; \
        ceu_out_call(_ceu_app, CEU_OUT_LUA_PCALL, &p); \
    }

    #define ceu_lua_isnumber(set, l, idx) {     \
        tceu__lua_State___int p = { l, idx };   \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUA_ISNUMBER, &p); \
    }

    #define ceu_lua_tonumber(set, l, idx) {     \
        tceu__lua_State___int p = { l, idx };   \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUA_TONUMBER, &p); \
    }

    #define ceu_lua_isboolean(set, l, idx) {    \
        tceu__lua_State___int p = { l, idx };   \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUA_ISBOOLEAN, &p); \
    }

    #define ceu_lua_toboolean(set, l, idx) {    \
        tceu__lua_State___int p = { l, idx };   \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUA_TOBOOLEAN, &p); \
    }

    #define ceu_lua_pop(l, n) {             \
        tceu__lua_State___int p = { l, n }; \
        ceu_out_call(_ceu_app, CEU_OUT_LUA_POP, &p); \
    }

    #define ceu_lua_isstring(set, l, idx) {     \
        tceu__lua_State___int p = { l, idx };   \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUA_ISSTRING, &p); \
    }

    #define ceu_lua_tostring(set, l, idx) {     \
        tceu__lua_State___int p = { l, idx };   \
        set = ceu_out_call(_ceu_app, CEU_OUT_LUA_TOSTRING, &p); \
    }

    #define ceu_lua_islightuserdata(set, l, idx) {  \
        tceu__lua_State___int p = { l, idx };       \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUA_ISLIGHTUSERDATA, &p); \
    }

    #define ceu_lua_touserdata(set, l, idx) {   \
        tceu__lua_State___int p = { l, idx };   \
        set = ceu_out_call(_ceu_app, CEU_OUT_LUA_TOUSERDATA, &p); \
    }

    #define ceu_lua_error(l) {                          \
        lua_State** p = &l;                             \
        ceu_out_call(_ceu_app, CEU_OUT_LUA_ERROR, &p);  \
    }

    #define ceu_lua_objlen(set, l, idx) {                       \
        tceu__lua_State___int p = { l, idx };                   \
        set = ceu_out_call(_ceu_app, CEU_OUT_LUA_OBJLEN, &p);   \
    }

#else
    #define ceu_luaL_newstate(set)               set = luaL_newstate()
    #define ceu_luaL_openlibs(l)                 luaL_openlibs(l)
    #define ceu_lua_atpanic(l,f)                 lua_atpanic(l,f)
    #define ceu_luaL_loadstring(set,l,str)       set = luaL_loadstring(l,str)
    #define ceu_lua_pushnumber(l,v)              lua_pushnumber(l,v)
    #define ceu_lua_pushstring(l,v)              lua_pushstring(l,v)
    #define ceu_lua_pushlightuserdata(l,v)       lua_pushlightuserdata(l,v)
    #define ceu_lua_pcall(set,l,nargs,nrets,err) set = lua_pcall(l,nargs,nrets,err)
    #define ceu_lua_isnumber(set,l,idx)          set = lua_isnumber(l,idx)
    #define ceu_lua_tonumber(set,l,idx)          set = lua_tonumber(l,idx)
    #define ceu_lua_isboolean(set,l,idx)         set = lua_isboolean(l,idx)
    #define ceu_lua_toboolean(set,l,idx)         set = lua_toboolean(l,idx)
    #define ceu_lua_pop(l,n)                     lua_pop(l,n)
    #define ceu_lua_isstring(set,l,idx)          set = lua_isstring(l,idx)
    #define ceu_lua_tostring(set,l,idx)          set = lua_tostring(l,idx)
    #define ceu_lua_islightuserdata(set,l,idx)   set = lua_islightuserdata(l,idx)
    #define ceu_lua_touserdata(set,l,idx)        set = lua_touserdata(l,idx)
    #define ceu_lua_error(l)                     lua_error(l)
    #define ceu_lua_objlen(set,l,idx)            set = lua_objlen(l,idx)
#endif
#endif

typedef u8 tceu_nevt;   /* max number of events */
                        /* TODO: should "u8" be fixed? */

typedef u8 tceu_ntrl;   /* max number of trails per class */
                        /* TODO: should "u8" be fixed? */

#ifdef CEU_STACK
typedef u16 tceu_nstk;  /* max size of internal stack in bytes */
                        /* TODO: should "u16" be fixed? */
#endif

#ifdef __cplusplus
#define CEU_WCLOCK_INACTIVE 0x7fffffffL     /* TODO */
#else
#define CEU_WCLOCK_INACTIVE INT32_MAX
#endif
#define CEU_WCLOCK_EXPIRED (CEU_WCLOCK_INACTIVE-1)

/* TCEU_TRL */

struct tceu_org;
typedef union tceu_trl {
    tceu_nevt evt;

    /* normal await // IN__CLEAR */
    struct {                    /* TODO(ram): bitfields */
        tceu_nevt evt1;
        tceu_nlbl lbl;
        u8        seqno;        /* TODO(ram): 2 bits is enough */
#ifdef CEU_INTS                 /* R-9: size of trails for internal events */
#ifdef CEU_ORGS
        void*     evto;
#endif
#endif
    };

    /* IN__ORG */
#ifdef CEU_ORGS
    struct {                    /* TODO(ram): bad for alignment */
        tceu_nevt evt3;
        struct tceu_org* org;
    };
#endif

    /* _ok_killed */
#ifdef CEU_ORGS_OR_ADTS_AWAIT
    struct {
        tceu_nevt evt4;
        tceu_nlbl lbl4;
        void*     org_or_adt;
    };
#endif
} tceu_trl;

/* TCEU_EVT */

typedef struct tceu_evt {
    tceu_nevt id;
    void*     param;
#if defined(CEU_ORGS) && defined(CEU_INTS)
    void*     org;      /* emitting org */
#endif
} tceu_evt;

/* TCEU_ORG */

struct tceu_pool_orgs;
typedef struct tceu_org
{
#ifdef CEU_ORGS
    struct tceu_org* nxt; /* first field because of free list for orgs/adts */
    struct tceu_org* prv;
    struct tceu_org* parent_org;
    tceu_ntrl parent_trl;
#endif

#if defined(CEU_ORGS) || defined(CEU_OS)
    tceu_ntrl n;            /* number of trails (TODO(ram): opt, metadata) */
#endif

#ifdef CEU_ORGS

#ifdef CEU_IFCS
    tceu_ncls cls;          /* class id */
#endif
    u8 isAlive: 1;          /* Three purposes:
                             * - avoids double free
                             * - required by "watching o" to avoid awaiting a
                             *      dead org
                             * - required by "Do T" to avoid awaiting a dead 
                             *      org
                             */
#if defined(CEU_ORGS_NEWS) || defined(CEU_ORGS_AWAIT)
#endif
#ifdef CEU_ORGS_NEWS
    u8 isDyn: 1;            /* created w/ new or spawn? */
#endif
#ifdef CEU_ORGS_NEWS_POOL
    struct tceu_pool_orgs* pool;
#endif

#ifdef CEU_ORGS_AWAIT
    int ret;
#endif

#endif  /* CEU_ORGS */

    tceu_trl trls[0];       /* first trail */

} tceu_org;

/* TCEU_POOL_ORGS , TCEU_POOL_ADTS */

#if defined(CEU_ORGS_NEWS_POOL) || defined(CEU_ADTS_NEWS_POOL)
#include "ceu_pool.h"
#endif

#ifdef CEU_ORGS_NEWS
typedef struct tceu_pool_orgs {
    tceu_org* parent_org;
    tceu_ntrl parent_trl;
#ifdef CEU_ORGS_NEWS_POOL
    tceu_pool pool;
#endif
} tceu_pool_orgs;
#endif

#ifdef CEU_ADTS_NEWS
typedef struct {
    void* root;
#ifdef CEU_ADTS_NEWS_POOL
    void* pool;
#endif
} tceu_pool_adts;
#endif

/* TCEU_KILL */

#ifdef CEU_ORGS_OR_ADTS_AWAIT
typedef struct tceu_kill {
    void*     org_or_adt;
    int       ret;
} tceu_kill;
#endif

/* TCEU_LST */

#ifdef CEU_DEBUG
typedef struct tceu_lst {
#ifdef CEU_ORGS
    void*     org;
#endif
    tceu_trl* trl;
    tceu_nlbl lbl;
} tceu_lst;

#endif

/* TCEU_STK */

typedef struct tceu_stk {
    struct tceu_stk* up;
    tceu_org* org;
    tceu_ntrl trl1;
    tceu_ntrl trl2;
    jmp_buf   jmp;
} tceu_stk;

/* TCEU_JMP */

#ifdef CEU_STACK
typedef struct tceu_jmp {
#ifdef CEU_ORGS
    tceu_org* org;
#endif
    tceu_trl* trl;
    tceu_nlbl lbl;
} tceu_jmp;
#endif

/* TCEU_APP */

typedef struct tceu_app {
    /* global seqno: incremented on every reaction
     * awaiting trails matches only if trl->seqno < seqno,
     * i.e., previously awaiting the event
     */
    u8 seqno:          2;
#if defined(CEU_RET) || defined(CEU_OS)
    u8 isAlive:        1;
#endif
#ifdef CEU_ASYNCS
    u8 pendingAsyncs:  1;
#endif
#if defined(CEU_ORGS_NEWS_MALLOC) && defined(CEU_ORGS_AWAIT)
    u8 dont_emit_kill: 1;
#endif

#ifdef CEU_OS
    struct tceu_app* nxt;
#endif

#ifdef CEU_REENTRANT
    tceu_nstk stki;
#endif

#ifdef CEU_STACK
    tceu_stk* stk_bottom;
    tceu_jmp  stk_jmp;
#endif

#if defined(CEU_RET) || defined(CEU_ORGS_AWAIT)
    int ret;
#endif

#ifdef CEU_ORGS_NEWS_MALLOC
    tceu_org* tofree;
#endif

#ifdef CEU_WCLOCKS
    s32         wclk_late;
    s32         wclk_min_set;   /* used to set */
    s32         wclk_min_cmp;   /* used to compare */
                                /* cmp<-set every reaction */
#ifdef CEU_TIMEMACHINE
    s32         wclk_late_;
    s32         wclk_min_set_;
    s32         wclk_min_cmp_;
#endif
#endif

#ifndef CEU_OS
#ifdef CEU_DEBUG
    tceu_lst    lst; /* segfault printf */
#endif
#endif

#ifdef CEU_THREADS
    CEU_THREADS_MUTEX_T threads_mutex;
    /*CEU_THREADS_COND_T  threads_cond;*/
    u8                  threads_n;          /* number of running threads */
        /* TODO: u8? */
#endif
#if defined(CEU_LUA) || defined(CEU_OS)
#ifdef CEU_LUA
    lua_State*  lua;    /* TODO: move to data? */
#else
    void*       lua;
#endif
#endif

    void        (*code)  (struct tceu_app*,tceu_evt*,tceu_org*,tceu_trl*,tceu_stk*);
    void        (*init)  (struct tceu_app*);
#ifdef CEU_OS
    void*       (*calls) (struct tceu_app*,tceu_nevt,void*);
    void**      sys_vec;
    void*       addr;
#ifdef CEU_OS_LUAIFC
    char*       luaifc;
#endif
#endif
    tceu_org*   data;
} tceu_app;

#ifdef CEU_OS
typedef void (*tceu_init)   (tceu_app* app);
typedef void (*tceu_export) (uint* size, tceu_init** init
#ifdef CEU_OS_LUAIFC
                            , char** luaifc
#endif
);
#endif

/* TCEU_THREADS_P */

#ifdef CEU_THREADS
typedef struct {
    tceu_app* app;
    tceu_org* org;
    s8*       st; /* thread state:
                   * 0=ini (sync  spawns)
                   * 1=cpy (async copies)
                   * 2=lck (sync  locks)
                   * 3=end (sync/async terminates)
                   */
} tceu_threads_p;
#endif

#ifdef CEU_PSES
void ceu_pause (tceu_trl* trl, tceu_trl* trlF, int psed);
#endif

int  ceu_go_all    (tceu_app* app);

#ifdef CEU_WCLOCKS
int       ceu_sys_wclock (tceu_app* app, s32 dt, s32* set, s32* get);
#endif
void      ceu_sys_go     (tceu_app* app, int evt, void* evtp);

#ifdef CEU_OS

/* TCEU_LINK */

typedef struct tceu_lnk {
    tceu_app* src_app;
    tceu_nevt src_evt;
    tceu_app* dst_app;
    tceu_nevt dst_evt;
    struct tceu_lnk* nxt;
} tceu_lnk;

/* TCEU_QUEUE */

typedef struct {
    tceu_app* app;
    tceu_nevt evt;
#if CEU_QUEUE_MAX == 256
    s8        sz;
#else
    s16       sz;   /* signed because of fill */
#endif
    byte      buf[0];
} tceu_queue;

#ifdef CEU_ISR
typedef void(*tceu_isr_f)(tceu_app* app, tceu_org* org);
#endif

void ceu_os_init      (void);
int  ceu_os_scheduler (int(*dt)());
tceu_queue* ceu_sys_queue_nxt (void);
void        ceu_sys_queue_rem (void);

void      ceu_sys_assert    (int v);
void      ceu_sys_log       (int mode, long str);
void*     ceu_sys_realloc   (void* ptr, size_t size);
int       ceu_sys_req       (void);
tceu_app* ceu_sys_load      (void* addr);
#ifdef CEU_ISR
int       ceu_sys_isr       (int n, tceu_isr_f f, tceu_app* app);
#endif
void      ceu_sys_org_init  (tceu_org* org, int n, int lbl, int cls, int isDyn,
                             tceu_org* parent_org, tceu_ntrl parent_trl);
void      ceu_sys_start     (tceu_app* app);
int       ceu_sys_link      (tceu_app* src_app, tceu_nevt src_evt, tceu_app* dst_app, tceu_nevt dst_evt);
int       ceu_sys_unlink    (tceu_app* src_app, tceu_nevt src_evt, tceu_app* dst_app, tceu_nevt dst_evt);
int       ceu_sys_emit      (tceu_app* app, tceu_nevt evt, int sz, void* param);
void*     ceu_sys_call      (tceu_app* app, tceu_nevt evt, void* param);

enum {
    CEU_SYS_ASSERT = 0,
    CEU_SYS_LOG,
    CEU_SYS_REALLOC,
    CEU_SYS_REQ,
    CEU_SYS_LOAD,
#ifdef CEU_ISR
    CEU_SYS_ISR,
#endif
#ifdef CEU_CLEAR
    CEU_SYS_CLEAR,
#endif
    CEU_SYS_STACK_PUSH,
#ifdef CEU_ORGS
    CEU_SYS_STACK_CLEAR_ORG,
#endif
    CEU_SYS_ORG,
#ifdef CEU_ORGS
    CEU_SYS_ORG_TRAIL,
    CEU_SYS_ORG_SPAWN,
#endif
    CEU_SYS_START,
    CEU_SYS_LINK,
    CEU_SYS_UNLINK,
    CEU_SYS_EMIT,
    CEU_SYS_CALL,
#ifdef CEU_WCLOCKS
    CEU_SYS_WCLOCK,
#endif
    CEU_SYS_GO,
    CEU_SYS_MAX
};

/* SYS_VECTOR
 */
extern void* CEU_SYS_VEC[CEU_SYS_MAX];

#endif  /* CEU_OS */

#endif  /* _CEU_OS_H */


typedef struct {
    int   max;
    int   nxt;
    int   unit;
    byte* mem;
} tceu_vector;

#define CEU_VECTOR_DCL(name, type, max)  \
    type        name##_mem[max+1];       \
    tceu_vector name;
                /* [STRING] max+1: extra space for '\0' */

#define ceu_vector_getlen(vec) ((vec)->nxt)
#define ceu_vector_getmax(vec) ((vec)->max > 0 ? (vec)->max : 0)

void  ceu_vector_init   (tceu_vector* vector, int max, int unit, byte* mem);
int   ceu_vector_setlen (tceu_vector* vector, int len);
byte* ceu_vector_geti   (tceu_vector* vector, int idx);
int   ceu_vector_seti   (tceu_vector* vector, int idx, byte* v);
int   ceu_vector_push   (tceu_vector* vector, byte* v);
int   ceu_vector_concat (tceu_vector* to, tceu_vector* fr);
int   ceu_vector_concat_buffer (tceu_vector* to, const char* fr, int n);
char* ceu_vector_tochar (tceu_vector* vector);

#if 0
byte* ceu_pool_alloc (tceu_pool* pool);
void ceu_pool_free (tceu_pool* pool, byte* val);
#endif
#endif

#endif


#define CEU_IN__NONE 0
#define CEU_IN__ORG 255
#define CEU_IN__ORG_PSED 254
#define CEU_IN__CLEAR 253
#define CEU_IN__ok_killed 252
#define CEU_IN__INIT 251
#define CEU_IN__ASYNC 250
#define CEU_IN__THREAD 249
#define CEU_IN__WCLOCK 248
#define CEU_IN_TICK 247
#define CEU_IN_higher CEU_IN__INIT
#define CEU_IN_lower 247
#define CEU_OUT_n 0
      /* CEU_IN_, CEU_OUT_ */
#define CEU_FUN_assert
   /* CEU_FUN_ */
typedef struct {
	int _1;
} tceu__int;
typedef struct {
	s32 _1;
} tceu__s32;


/* class/adts definitions */
/* may use types defined above in "NATIVE" */
/* each class may define new native code that appear after its struct declaration */

enum {
CEU_NONE11,
CEU_LEAF_SENSERIGHT,
CEU_LEAF_SENSELEFT,
CEU_LEAF_SENSEUP,
CEU_LEAF_SENSEDOWN,
CEU_LEAF_GORIGHT,
CEU_LEAF_GOLEFT,
CEU_LEAF_GOUP,
CEU_LEAF_GODOWN,
CEU_LEAF_SKIP
};

typedef struct CEU_Leaf {
    u8 tag;
    union {
                            struct { /* BLOCK ln=3 */
                            } SENSERIGHT;
                            struct { /* BLOCK ln=3 */
                            } SENSELEFT;
                            struct { /* BLOCK ln=3 */
                            } SENSEUP;
                            struct { /* BLOCK ln=3 */
                            } SENSEDOWN;
                            struct { /* BLOCK ln=3 */
                            } GORIGHT;
                            struct { /* BLOCK ln=3 */
                            } GOLEFT;
                            struct { /* BLOCK ln=3 */
                            } GOUP;
                            struct { /* BLOCK ln=3 */
                            } GODOWN;
                            struct { /* BLOCK ln=3 */
                            } SKIP;
    };
}
 CEU_Leaf;

typedef struct CEU_LeafHandler {
#ifdef CEU_ORGS
  struct tceu_org org;
#endif
  tceu_trl trls_[ 2 ];
                            struct { /* BLOCK ln=23 */
                              CEU_Leaf* leaf;
                              union {
                                  union {
                                  };
                                struct { /* BLOCK ln=23 */
                                  union {
                                      struct { /* BLOCK ln=26 */
                                        int answer;
                                        union {
                                          union {
                                          };
                                            struct { /* BLOCK ln=28 */
                                              union {
                                              };
                                            } ;
                                              struct { /* BLOCK ln=30 */
                                                union {
                                                };
                                              } ;
                                                struct { /* BLOCK ln=32 */
                                                  union {
                                                  };
                                                } ;
                                                  struct { /* BLOCK ln=34 */
                                                    union {
                                                    };
                                                  } ;
                                                    struct { /* BLOCK ln=36 */
                                                      union {
                                                      };
                                                    } ;
                                                      struct { /* BLOCK ln=39 */
                                                        union {
                                                        };
                                                      } ;
                                                        struct { /* BLOCK ln=42 */
                                                          union {
                                                          };
                                                        } ;
                                                          struct { /* BLOCK ln=45 */
                                                            union {
                                                            };
                                                          } ;
                                                            struct { /* BLOCK ln=48 */
                                                              union {
                                                              };
                                                            } ;
                                                            struct { /* BLOCK ln=52 */
                                                              union {
                                                              };
                                                            } ;
                                          union {
                                          };
                                        };
                                      } ;
                                  };
                                } ;
                              };
                            } ;

} CEU_LeafHandler;





enum {
CEU_NONE148,
CEU_BTREE_NIL,
CEU_BTREE_SEQUENCE,
CEU_BTREE_SELECTOR,
CEU_BTREE_LEAF
};

typedef struct CEU_BTree {
    u8 tag;
    union {
                            struct { /* BLOCK ln=11 */
                            } NIL;
                            struct { /* BLOCK ln=11 */
                              struct CEU_BTree* first;
                              struct CEU_BTree* second;
                            } SEQUENCE;
                            struct { /* BLOCK ln=11 */
                              struct CEU_BTree* first;
                              struct CEU_BTree* second;
                            } SELECTOR;
                            struct { /* BLOCK ln=11 */
                              CEU_Leaf leaf;
                            } LEAF;
    };
}
 CEU_BTree;

typedef struct CEU_Scope {
#ifdef CEU_ORGS
  struct tceu_org org;
#endif
  tceu_trl trls_[ 2 ];
                                                  struct { /* BLOCK ln=33 */
                                                    union {
                                                        union {
                                                        };
                                                      struct { /* BLOCK ln=33 */
                                                        union {
                                                          struct { /* BLOCK ln=33 */
                                                            union {
                                                            };
                                                          } ;
                                                        };
                                                      } ;
                                                    };
                                                  } ;

} CEU_Scope;





enum {
CEU_NONE1294,
CEU__OPTION__BODY_239__PTR_NIL,
CEU__OPTION__BODY_239__PTR_SOME
};

typedef struct CEU__Option__Body_239__ptr {
    u8 tag;
    union {
                                                                                                struct { /* BLOCK ln=36 */
                                                                                                } NIL;
                                                                                                struct { /* BLOCK ln=36 */
                                                                                                  struct CEU_Body_239* v;
                                                                                                } SOME;
    };
}
 CEU__Option__Body_239__ptr;

typedef struct CEU_Body_239 {
#ifdef CEU_ORGS
  struct tceu_org org;
#endif
  tceu_trl trls_[ 7 ];
                                                  struct { /* BLOCK ln=33 */
                                                    tceu_pool_orgs* _bodies;
;
                                                    struct CEU_Scope* _parent;
                                                    /*
 * REF:
 * tceu_pool_adts* x;  // root/pool always the same as the parent
 * PTR:
 * tceu_pool_adts x;   // pool: the same // root: may point to the middle
 */
tceu_pool_adts t;
;
                                                    struct CEU_BTreeTraverse* _out;
                                                    union {
                                                        union {
                                                        };
                                                      struct { /* BLOCK ln=33 */
                                                        int _ret_13;
                                                        union {
                                                            struct { /* BLOCK ln=33 */
                                                              union {
                                                                struct {
                                                                  struct { /* BLOCK ln=33 */
                                                                    union {
                                                                      union {
                                                                        union {
                                                                            struct { /* BLOCK ln=33 */
                                                                              union {
                                                                              };
                                                                            } ;
                                                                            struct { /* BLOCK ln=33 */
                                                                              union {
                                                                              };
                                                                            } ;
                                                                        };
                                                                      };
                                                                    };
                                                                  } ;
                                                                  struct { /* BLOCK ln=33 */
                                                                    union {
                                                                      struct { /* BLOCK ln=34 */
                                                                        union {
                                                                          struct {
                                                                            struct { /* BLOCK ln=34 */
                                                                              union {
                                                                                union {
                                                                                    struct { /* BLOCK ln=34 */
                                                                                      union {
                                                                                      };
                                                                                    } ;
                                                                                    struct { /* BLOCK ln=34 */
                                                                                      union {
                                                                                      };
                                                                                    } ;
                                                                                };
                                                                              };
                                                                            } ;
                                                                            struct { /* BLOCK ln=35 */
                                                                              union {
                                                                                  struct { /* BLOCK ln=36 */
                                                                                    int ok_14;
                                                                                    union {
                                                                                      union {
                                                                                        struct { /* BLOCK ln=36 */
                                                                                          struct CEU_Scope _s_16;
                                                                                          struct CEU__Option__Body_239__ptr _body_165_17;
                                                                                          union {
                                                                                                  union {
                                                                                                  };
                                                                                                  union {
                                                                                                  };
                                                                                                  struct { /* BLOCK ln=36 */
                                                                                                    union {
                                                                                                    };
                                                                                                  } ;
                                                                                              struct { /* BLOCK ln=36 */
                                                                                                union {
                                                                                                  union {
                                                                                                    union {
                                                                                                        struct { /* BLOCK ln=36 */
                                                                                                          union {
                                                                                                          };
                                                                                                        } ;
                                                                                                        struct { /* BLOCK ln=36 */
                                                                                                          union {
                                                                                                          };
                                                                                                        } ;
                                                                                                    };
                                                                                                  };
                                                                                                };
                                                                                              } ;
                                                                                              struct { /* BLOCK ln=36 */
                                                                                                union {
                                                                                                };
                                                                                              } ;
                                                                                          };
                                                                                        } ;
                                                                                      };
                                                                                        struct { /* BLOCK ln=38 */
                                                                                          union {
                                                                                            union {
                                                                                            };
                                                                                          };
                                                                                        } ;
                                                                                      struct { /* BLOCK ln=40 */
                                                                                        struct CEU_Scope _s_18;
                                                                                        struct CEU__Option__Body_239__ptr _body_180_19;
                                                                                        union {
                                                                                                struct { /* BLOCK ln=40 */
                                                                                                  union {
                                                                                                  };
                                                                                                } ;
                                                                                            struct { /* BLOCK ln=40 */
                                                                                              union {
                                                                                                union {
                                                                                                  union {
                                                                                                      struct { /* BLOCK ln=40 */
                                                                                                        union {
                                                                                                        };
                                                                                                      } ;
                                                                                                      struct { /* BLOCK ln=40 */
                                                                                                        union {
                                                                                                        };
                                                                                                      } ;
                                                                                                  };
                                                                                                };
                                                                                              };
                                                                                            } ;
                                                                                            struct { /* BLOCK ln=40 */
                                                                                              union {
                                                                                              };
                                                                                            } ;
                                                                                        };
                                                                                      } ;
                                                                                      union {
                                                                                      };
                                                                                    };
                                                                                  } ;
                                                                                    struct { /* BLOCK ln=43 */
                                                                                      int ok_20;
                                                                                      int ok_23;
                                                                                      union {
                                                                                        union {
                                                                                          struct { /* BLOCK ln=43 */
                                                                                            struct CEU_Scope _s_21;
                                                                                            struct CEU__Option__Body_239__ptr _body_193_22;
                                                                                            union {
                                                                                                    struct { /* BLOCK ln=43 */
                                                                                                      union {
                                                                                                      };
                                                                                                    } ;
                                                                                                struct { /* BLOCK ln=43 */
                                                                                                  union {
                                                                                                    union {
                                                                                                      union {
                                                                                                          struct { /* BLOCK ln=43 */
                                                                                                            union {
                                                                                                            };
                                                                                                          } ;
                                                                                                          struct { /* BLOCK ln=43 */
                                                                                                            union {
                                                                                                            };
                                                                                                          } ;
                                                                                                      };
                                                                                                    };
                                                                                                  };
                                                                                                } ;
                                                                                                struct { /* BLOCK ln=43 */
                                                                                                  union {
                                                                                                  };
                                                                                                } ;
                                                                                            };
                                                                                          } ;
                                                                                        };
                                                                                          struct { /* BLOCK ln=45 */
                                                                                            union {
                                                                                              union {
                                                                                              };
                                                                                            };
                                                                                          } ;
                                                                                        union {
                                                                                          struct { /* BLOCK ln=47 */
                                                                                            struct CEU_Scope _s_24;
                                                                                            struct CEU__Option__Body_239__ptr _body_208_25;
                                                                                            union {
                                                                                                    struct { /* BLOCK ln=47 */
                                                                                                      union {
                                                                                                      };
                                                                                                    } ;
                                                                                                struct { /* BLOCK ln=47 */
                                                                                                  union {
                                                                                                    union {
                                                                                                      union {
                                                                                                          struct { /* BLOCK ln=47 */
                                                                                                            union {
                                                                                                            };
                                                                                                          } ;
                                                                                                          struct { /* BLOCK ln=47 */
                                                                                                            union {
                                                                                                            };
                                                                                                          } ;
                                                                                                      };
                                                                                                    };
                                                                                                  };
                                                                                                } ;
                                                                                                struct { /* BLOCK ln=47 */
                                                                                                  union {
                                                                                                  };
                                                                                                } ;
                                                                                            };
                                                                                          } ;
                                                                                        };
                                                                                        union {
                                                                                        };
                                                                                      };
                                                                                    } ;
                                                                                      struct { /* BLOCK ln=50 */
                                                                                        int ok_26;
                                                                                        union {
                                                                                          union {
                                                                                              struct { /* BLOCK ln=51 */
                                                                                                struct CEU_LeafHandler _org_227_27;
                                                                                                union {
                                                                                                      struct { /* BLOCK ln=52 */
                                                                                                        union {
                                                                                                        };
                                                                                                      } ;
                                                                                                  union {
                                                                                                    union {
                                                                                                        struct { /* BLOCK ln=51 */
                                                                                                          union {
                                                                                                          };
                                                                                                        } ;
                                                                                                        struct { /* BLOCK ln=51 */
                                                                                                          union {
                                                                                                          };
                                                                                                        } ;
                                                                                                    };
                                                                                                  };
                                                                                                };
                                                                                              } ;
                                                                                          };
                                                                                          union {
                                                                                          };
                                                                                        };
                                                                                      } ;
                                                                              };
                                                                            } ;
                                                                          };
                                                                        };
                                                                      } ;
                                                                    };
                                                                  } ;
                                                                };
                                                                union {
                                                                };
                                                              };
                                                            } ;
                                                        };
                                                      } ;
                                                    };
                                                  } ;

} CEU_Body_239;





typedef struct CEU_BTreeTraverse {
#ifdef CEU_ORGS
  struct tceu_org org;
#endif
  tceu_trl trls_[ 11 ];
                            struct { /* BLOCK ln=29 */
                              /*
 * REF:
 * tceu_pool_adts* x;  // root/pool always the same as the parent
 * PTR:
 * tceu_pool_adts x;   // pool: the same // root: may point to the middle
 */
tceu_pool_adts* btree;
;
                              union {
                                  union {
                                  };
                                struct { /* BLOCK ln=29 */
                                  int _ret_7;
                                  union {
                                      struct { /* BLOCK ln=32 */
                                        tceu_pool_orgs _pool_239;
;
                                        int ok;
                                        union {
                                          union {
                                            union {
                                              union {
                                              };
                                              union {
                                              };
                                              struct { /* BLOCK ln=33 */
                                                struct CEU_Scope _s_10;
                                                struct CEU__Option__Body_239__ptr _body_239_11;
                                                union {
                                                        struct { /* BLOCK ln=33 */
                                                          union {
                                                          };
                                                        } ;
                                                    struct { /* BLOCK ln=33 */
                                                      union {
                                                        union {
                                                          union {
                                                              struct { /* BLOCK ln=33 */
                                                                union {
                                                                };
                                                              } ;
                                                              struct { /* BLOCK ln=33 */
                                                                union {
                                                                };
                                                              } ;
                                                          };
                                                        };
                                                      };
                                                    } ;
                                                    struct { /* BLOCK ln=33 */
                                                      union {
                                                      };
                                                    } ;
                                                };
                                              } ;
                                            };
                                          };
                                          union {
                                          };
                                        };
                                      } ;
                                  };
                                } ;
                              };
                            } ;

} CEU_BTreeTraverse;




typedef struct CEU_Main {
#ifdef CEU_ORGS
  struct tceu_org org;
#endif
  tceu_trl trls_[ 13 ];
    struct { /* BLOCK ln=1 */
      union {
          union {
          };
        struct { /* BLOCK ln=1 */
          union {
              struct { /* BLOCK ln=1 */
                union {
                  union {
                    struct { /* BLOCK ln=1 */
                      /*
 * REF:
 * tceu_pool_adts* x;  // root/pool always the same as the parent
 * PTR:
 * tceu_pool_adts x;   // pool: the same // root: may point to the middle
 */
tceu_pool_adts behavior;
;
                      union {
                        union {
                        };
                              union {
                              };
                              union {
                              };
                              union {
                              };
                              union {
                              };
                              union {
                              };
                              union {
                              };
                              union {
                              };
                              union {
                              };
                              union {
                              };
                        union {
                        };
                              union {
                              };
                              union {
                              };
                              union {
                              };
                              union {
                              };
                              union {
                              };
                              union {
                              };
                        union {
                        };
                        union {
                        };
                        struct { /* BLOCK ln=71 */
                          union {
                            union {
                            };
                              struct { /* BLOCK ln=72 */
                                union {
                                  union {
                                  };
                                    struct { /* BLOCK ln=72 */
                                      struct CEU_BTreeTraverse _org_336_7;
                                      union {
                                            struct { /* BLOCK ln=73 */
                                              union {
                                              };
                                            } ;
                                        union {
                                          union {
                                              struct { /* BLOCK ln=72 */
                                                union {
                                                };
                                              } ;
                                              struct { /* BLOCK ln=72 */
                                                union {
                                                };
                                              } ;
                                          };
                                        };
                                      };
                                    } ;
                                };
                              } ;
                          };
                        } ;
                      };
                    } ;
                  };
                };
              } ;
          };
        } ;
      };
    } ;

} CEU_Main;






#endif

#ifndef _CEU_OS_H
#define _CEU_OS_H

#include <stddef.h>
#include "ceu_types.h"

#ifdef CEU_DEBUG
#include <assert.h>
#endif

#if defined(CEU_OS) && defined(__AVR)
#error Understand this again!
#include "Arduino.h"
#define CEU_ISR
#define CEU_ISR_ON()  interrupts()
#define CEU_ISR_OFF() noInterrupts()
#else
#define CEU_ISR_ON()
#define CEU_ISR_OFF()
#endif

/*
#if defined(CEU_CLEAR) || defined(CEU_INTS) || defined(CEU_ORGS) || defined(CEU_REENTRANT)
*/
#if 1
#include <setjmp.h>
#define CEU_STACK
#endif

#if defined(CEU_OS_KERNEL) || defined(CEU_OS_APP)
#define CEU_OS
#endif

#if defined(CEU_ORGS_NEWS) || defined(CEU_ADTS_NEWS)
#define CEU_NEWS
#endif
#if defined(CEU_ORGS_NEWS_POOL) || defined(CEU_ADTS_NEWS_POOL)
#define CEU_NEWS_POOL
#endif
#if defined(CEU_ORGS_AWAIT) || defined(CEU_ADTS_AWAIT)
#define CEU_ORGS_OR_ADTS_AWAIT
#endif

#ifdef CEU_OS

    /* TODO: all should be configurable */
    #define CEU_EXTS
    #define CEU_WCLOCKS
    #define CEU_ASYNCS
    #define CEU_RET
    #define CEU_CLEAR
    #define CEU_STACK
#ifndef __AVR
#endif
    #define CEU_INTS
    #define CEU_ORGS
    /*#define CEU_PSES*/ /* TODO: never tried */
    #define CEU_NEWS
    #define CEU_NEWS_POOL
    #define CEU_ORGS_NEWS
    #define CEU_ORGS_NEWS_MALLOC
    #define CEU_ORGS_NEWS_POOL
    #define CEU_ADTS_NEWS
    #define CEU_ADTS_NEWS_MALLOC
    #define CEU_ADTS_NEWS_POOL
    #define CEU_ORGS_AWAIT
    #define CEU_ADTS_AWAIT
    #define CEU_ORGS_OR_ADTS_AWAIT
/*
    #define CEU_THREADS
*/

#ifdef __AVR
    #define CEU_QUEUE_MAX 256
#else
    #define CEU_QUEUE_MAX 65536
#endif

    #define CEU_IN__NONE          0
    #define CEU_IN__ORG         255
    #define CEU_IN__ORG_PSED    254
    #define CEU_IN__CLEAR       253
    #define CEU_IN__ok_killed   252
    #define CEU_IN__INIT        251     /* HIGHER EXTERNAL */
    #define CEU_IN__ASYNC       250
    #define CEU_IN__THREAD      249
    #define CEU_IN__WCLOCK      248
    #define CEU_IN_OS_START     247
    #define CEU_IN_OS_STOP      246
    #define CEU_IN_OS_DT        245
    #define CEU_IN_OS_INTERRUPT 244
#ifdef CEU_TIMEMACHINE
    #define CEU_IN__WCLOCK_     243
    #define CEU_IN              243
#else
    #define CEU_IN              242
#endif

    #define CEU_IN_higher       CEU_IN__INIT  /* _INIT = HIGHER EXTERNAL */
    #define CEU_IN_lower        128     /* TODO: not checked from up and down */

    typedef s8 tceu_nlbl;   /* TODO: to small!! */

#endif /* CEU_OS */

#ifdef CEU_OS_APP

    #define ceu_out_log(mode,str) \
        ((__typeof__(ceu_sys_log)*)((_ceu_app)->sys_vec[CEU_SYS_LOG]))(mode,str)

    #define ceu_out_assert(v) \
        ((__typeof__(ceu_sys_assert)*)((_ceu_app)->sys_vec[CEU_SYS_ASSERT]))(v)

    #define ceu_out_assert_msg_ex(v,msg,file,line)       \
        {                                                \
            int __ceu_v = v;                             \
            if ((!(__ceu_v)) && ((msg)!=NULL)) {         \
                ceu_out_log(0, (long)"[");               \
                ceu_out_log(0, (long)(file));            \
                ceu_out_log(0, (long)":");               \
                ceu_out_log(2, (line));                  \
                ceu_out_log(0, (long)"] ");              \
                ceu_out_log(0, (long)"runtime error: "); \
                ceu_out_log(0, (long)(msg));             \
                ceu_out_log(0, (long)"\n");              \
            }                                            \
            ((__typeof__(ceu_sys_assert)*)((_ceu_app)->sys_vec[CEU_SYS_ASSERT]))(__ceu_v); \
        }
    #define ceu_out_assert_msg(v,msg) ceu_out_assert_msg_ex((v),(msg),__FILE__,__LINE__)

    #define ceu_out_realloc(ptr, size) \
        ((__typeof__(ceu_sys_realloc)*)((_ceu_app)->sys_vec[CEU_SYS_REALLOC]))(ptr,size)

    #define ceu_out_req() \
        ((__typeof__(ceu_sys_req)*)((_ceu_app)->sys_vec[CEU_SYS_REQ]))()

    #define ceu_out_load(addr) \
        ((__typeof__(ceu_sys_load)*)((_ceu_app)->sys_vec[CEU_SYS_LOAD]))(addr)

#ifdef CEU_ISR
    #define ceu_out_isr(n,f) \
        ((__typeof__(ceu_sys_isr)*)((_ceu_app)->sys_vec[CEU_SYS_ISR]))(n,f,_ceu_app)
#endif

    #define ceu_out_org_init(app,org,n,lbl,cls,isDyn,parent_org,parent_trl) \
        ((__typeof__(ceu_sys_org_init)*)((app)->sys_vec[CEU_SYS_ORG]))(org,n,lbl,cls,isDyn,parent_org,parent_trl)
    #define ceu_out_start(app) \
        ((__typeof__(ceu_sys_start)*)((_ceu_app)->sys_vec[CEU_SYS_START]))(app)
    #define ceu_out_link(app1,evt1 , app2,evt2) \
        ((__typeof__(ceu_sys_link)*)((_ceu_app)->sys_vec[CEU_SYS_LINK]))(app1,evt1,app2,evt2)

    #define ceu_out_emit(app,id,sz,buf) \
        ((__typeof__(ceu_sys_emit)*)((app)->sys_vec[CEU_SYS_EMIT]))(app,id,sz,buf)

    #define ceu_out_call(app,id,param) \
        ((__typeof__(ceu_sys_call)*)((app)->sys_vec[CEU_SYS_CALL]))(app,id,param)

#ifdef CEU_WCLOCKS
    #define ceu_out_wclock(app,dt,set,get) \
        ((__typeof__(ceu_sys_wclock)*)((app)->sys_vec[CEU_SYS_WCLOCK]))(app,dt,set,get)
#ifdef CEU_TIMEMACHINE
    #error TIMEMACHINE
#endif
#endif

    #define ceu_out_go(app,evt,evtp) \
        ((__typeof__(ceu_sys_go)*)((app)->sys_vec[CEU_SYS_GO]))(app,evt,evtp)

#else /* ! CEU_OS_APP (!CEU_OS||CEU_OS_KERNEL) */

    #ifndef ceu_out_assert
        #error "Missing definition for macro \"ceu_out_assert\"."
    #endif

    #ifndef ceu_out_log
        #error "Missing definition for macro \"ceu_out_log\"."
    #endif

    #define ceu_out_assert_msg_ex(v,msg,file,line)          \
        {                                                   \
            int __ceu_v = v;                                \
            if ((!(__ceu_v)) && ((msg)!=NULL)) {            \
                ceu_out_log(0, (long)"[");                  \
                ceu_out_log(0, (long)(file));               \
                ceu_out_log(0, (long)":");                  \
                ceu_out_log(2, line);                       \
                ceu_out_log(0, (long)"] ");                 \
                ceu_out_log(0, (long)"runtime error: ");    \
                ceu_out_log(0, (long)(msg));                \
                ceu_out_log(0, (long)"\n");                 \
            }                                               \
            ceu_out_assert(__ceu_v);                        \
        }
    #define ceu_out_assert_msg(v,msg) ceu_out_assert_msg_ex((v),(msg),__FILE__,__LINE__)

    #define ceu_out_realloc(ptr,size) \
            ceu_sys_realloc(ptr,size)
    #define ceu_out_req() \
            ceu_sys_req()
    #define ceu_out_org_init(app,org,n,lbl,cls,isDyn,parent_org,parent_trl) \
            ceu_sys_org_init(org,n,lbl,cls,isDyn,parent_org,parent_trl)

#ifdef CEU_WCLOCKS
    #define ceu_out_wclock(app,dt,set,get) \
            ceu_sys_wclock(app,dt,set,get)
#ifdef CEU_TIMEMACHINE
    #define ceu_out_wclock_(app,dt,set,get) \
            ceu_sys_wclock_(app,dt,set,get)
#endif
#endif
    #define ceu_out_go(app,evt,evtp) \
            ceu_sys_go(app,evt,evtp)
    #define ceu_out_go_stk(app,evt,evtp,stk) \
            ceu_sys_go_stk(app,evt,evtp,stk)

#endif /* ! CEU_OS_APP (!CEU_OS||CEU_OS_KERNEL) */

#define ceu_in_emit(app,id,n,buf) \
    ceu_out_go_stk(app,id,buf,&stk_)

#ifdef CEU_THREADS
/* TODO: app */
#include "ceu_threads.h"
#endif

#ifdef CEU_LUA
#include <stdio.h>      /* BUFSIZ */
#include <string.h>     /* strcpy */
#if defined(__ANDROID__) || defined(CEU_OS)
    #include "lua.h"
    #include "lauxlib.h"
    #include "lualib.h"
#else
    #include <lua5.1/lua.h>
    #include <lua5.1/lauxlib.h>
    #include <lua5.1/lualib.h>
#endif

#ifdef CEU_OS_APP
    #define ceu_luaL_newstate(set) { \
        set = ceu_out_call(_ceu_app, CEU_OUT_LUA_NEW, NULL); \
    }

    #define ceu_luaL_openlibs(l) { \
        lua_State* p = l;          \
        ceu_out_call(_ceu_app, CEU_OUT_LUAL_OPENLIBS, &p); \
    }

    #define ceu_lua_atpanic(l, f) {     \
    }

    #define ceu_luaL_loadstring(set, l, str) {  \
        tceu__lua_State___char_ p = { l, str }; \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUAL_LOADSTRING, &p); \
    }

    #define ceu_lua_pushnumber(l, v) {      \
        tceu__lua_State___int p = { l, v }; \
        ceu_out_call(_ceu_app, CEU_OUT_LUA_PUSHNUMBER, &p); \
    }

    #define ceu_lua_pushstring(l, v) {      \
        tceu__lua_State___char_ p = { l, v }; \
        ceu_out_call(_ceu_app, CEU_OUT_LUA_PUSHSTRING, &p); \
    }

    #define ceu_lua_pushlightuserdata(l, v) {   \
        tceu__lua_State___void_ p = { l, v };     \
        ceu_out_call(_ceu_app, CEU_OUT_LUA_PUSHLIGHTUSERDATA, &p); \
    }

    #define ceu_lua_pcall(set,l,nargs,nrets,err) {                  \
        tceu__lua_State___int__int__int p = { l, nargs, nrets, err }; \
        ceu_out_call(_ceu_app, CEU_OUT_LUA_PCALL, &p); \
    }

    #define ceu_lua_isnumber(set, l, idx) {     \
        tceu__lua_State___int p = { l, idx };   \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUA_ISNUMBER, &p); \
    }

    #define ceu_lua_tonumber(set, l, idx) {     \
        tceu__lua_State___int p = { l, idx };   \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUA_TONUMBER, &p); \
    }

    #define ceu_lua_isboolean(set, l, idx) {    \
        tceu__lua_State___int p = { l, idx };   \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUA_ISBOOLEAN, &p); \
    }

    #define ceu_lua_toboolean(set, l, idx) {    \
        tceu__lua_State___int p = { l, idx };   \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUA_TOBOOLEAN, &p); \
    }

    #define ceu_lua_pop(l, n) {             \
        tceu__lua_State___int p = { l, n }; \
        ceu_out_call(_ceu_app, CEU_OUT_LUA_POP, &p); \
    }

    #define ceu_lua_isstring(set, l, idx) {     \
        tceu__lua_State___int p = { l, idx };   \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUA_ISSTRING, &p); \
    }

    #define ceu_lua_tostring(set, l, idx) {     \
        tceu__lua_State___int p = { l, idx };   \
        set = ceu_out_call(_ceu_app, CEU_OUT_LUA_TOSTRING, &p); \
    }

    #define ceu_lua_islightuserdata(set, l, idx) {  \
        tceu__lua_State___int p = { l, idx };       \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUA_ISLIGHTUSERDATA, &p); \
    }

    #define ceu_lua_touserdata(set, l, idx) {   \
        tceu__lua_State___int p = { l, idx };   \
        set = ceu_out_call(_ceu_app, CEU_OUT_LUA_TOUSERDATA, &p); \
    }

    #define ceu_lua_error(l) {                          \
        lua_State** p = &l;                             \
        ceu_out_call(_ceu_app, CEU_OUT_LUA_ERROR, &p);  \
    }

    #define ceu_lua_objlen(set, l, idx) {                       \
        tceu__lua_State___int p = { l, idx };                   \
        set = ceu_out_call(_ceu_app, CEU_OUT_LUA_OBJLEN, &p);   \
    }

#else
    #define ceu_luaL_newstate(set)               set = luaL_newstate()
    #define ceu_luaL_openlibs(l)                 luaL_openlibs(l)
    #define ceu_lua_atpanic(l,f)                 lua_atpanic(l,f)
    #define ceu_luaL_loadstring(set,l,str)       set = luaL_loadstring(l,str)
    #define ceu_lua_pushnumber(l,v)              lua_pushnumber(l,v)
    #define ceu_lua_pushstring(l,v)              lua_pushstring(l,v)
    #define ceu_lua_pushlightuserdata(l,v)       lua_pushlightuserdata(l,v)
    #define ceu_lua_pcall(set,l,nargs,nrets,err) set = lua_pcall(l,nargs,nrets,err)
    #define ceu_lua_isnumber(set,l,idx)          set = lua_isnumber(l,idx)
    #define ceu_lua_tonumber(set,l,idx)          set = lua_tonumber(l,idx)
    #define ceu_lua_isboolean(set,l,idx)         set = lua_isboolean(l,idx)
    #define ceu_lua_toboolean(set,l,idx)         set = lua_toboolean(l,idx)
    #define ceu_lua_pop(l,n)                     lua_pop(l,n)
    #define ceu_lua_isstring(set,l,idx)          set = lua_isstring(l,idx)
    #define ceu_lua_tostring(set,l,idx)          set = lua_tostring(l,idx)
    #define ceu_lua_islightuserdata(set,l,idx)   set = lua_islightuserdata(l,idx)
    #define ceu_lua_touserdata(set,l,idx)        set = lua_touserdata(l,idx)
    #define ceu_lua_error(l)                     lua_error(l)
    #define ceu_lua_objlen(set,l,idx)            set = lua_objlen(l,idx)
#endif
#endif

typedef u8 tceu_nevt;   /* max number of events */
                        /* TODO: should "u8" be fixed? */

typedef u8 tceu_ntrl;   /* max number of trails per class */
                        /* TODO: should "u8" be fixed? */

#ifdef CEU_STACK
typedef u16 tceu_nstk;  /* max size of internal stack in bytes */
                        /* TODO: should "u16" be fixed? */
#endif

#ifdef __cplusplus
#define CEU_WCLOCK_INACTIVE 0x7fffffffL     /* TODO */
#else
#define CEU_WCLOCK_INACTIVE INT32_MAX
#endif
#define CEU_WCLOCK_EXPIRED (CEU_WCLOCK_INACTIVE-1)

/* TCEU_TRL */

struct tceu_org;
typedef union tceu_trl {
    tceu_nevt evt;

    /* normal await // IN__CLEAR */
    struct {                    /* TODO(ram): bitfields */
        tceu_nevt evt1;
        tceu_nlbl lbl;
        u8        seqno;        /* TODO(ram): 2 bits is enough */
#ifdef CEU_INTS                 /* R-9: size of trails for internal events */
#ifdef CEU_ORGS
        void*     evto;
#endif
#endif
    };

    /* IN__ORG */
#ifdef CEU_ORGS
    struct {                    /* TODO(ram): bad for alignment */
        tceu_nevt evt3;
        struct tceu_org* org;
    };
#endif

    /* _ok_killed */
#ifdef CEU_ORGS_OR_ADTS_AWAIT
    struct {
        tceu_nevt evt4;
        tceu_nlbl lbl4;
        void*     org_or_adt;
    };
#endif
} tceu_trl;

/* TCEU_EVT */

typedef struct tceu_evt {
    tceu_nevt id;
    void*     param;
#if defined(CEU_ORGS) && defined(CEU_INTS)
    void*     org;      /* emitting org */
#endif
} tceu_evt;

/* TCEU_ORG */

struct tceu_pool_orgs;
typedef struct tceu_org
{
#ifdef CEU_ORGS
    struct tceu_org* nxt; /* first field because of free list for orgs/adts */
    struct tceu_org* prv;
    struct tceu_org* parent_org;
    tceu_ntrl parent_trl;
#endif

#if defined(CEU_ORGS) || defined(CEU_OS)
    tceu_ntrl n;            /* number of trails (TODO(ram): opt, metadata) */
#endif

#ifdef CEU_ORGS

#ifdef CEU_IFCS
    tceu_ncls cls;          /* class id */
#endif
    u8 isAlive: 1;          /* Three purposes:
                             * - avoids double free
                             * - required by "watching o" to avoid awaiting a
                             *      dead org
                             * - required by "Do T" to avoid awaiting a dead 
                             *      org
                             */
#if defined(CEU_ORGS_NEWS) || defined(CEU_ORGS_AWAIT)
#endif
#ifdef CEU_ORGS_NEWS
    u8 isDyn: 1;            /* created w/ new or spawn? */
#endif
#ifdef CEU_ORGS_NEWS_POOL
    struct tceu_pool_orgs* pool;
#endif

#ifdef CEU_ORGS_AWAIT
    int ret;
#endif

#endif  /* CEU_ORGS */

    tceu_trl trls[0];       /* first trail */

} tceu_org;

/* TCEU_POOL_ORGS , TCEU_POOL_ADTS */

#if defined(CEU_ORGS_NEWS_POOL) || defined(CEU_ADTS_NEWS_POOL)
#ifndef _CEU_POOL_H
#define _CEU_POOL_H

#include "ceu_types.h"

/* TODO: all "int" here, should evaluate the correct unsigned type */

typedef struct {
    byte**  queue;
                    /* queue is in the next offset to distinguish dynamic(NULL)
                       from static pools(any-address) */
    int     size;
    int     free;
    int     index;
    int     unit;
    byte*   mem;
} tceu_pool;

#define CEU_POOL_DCL(name, type, size) \
    type*     name##_queue[size];      \
    type      name##_mem[size];        \
    tceu_pool name;

void ceu_pool_init (tceu_pool* pool, int size, int unit, byte** queue, byte* mem);
byte* ceu_pool_alloc (tceu_pool* pool);
void ceu_pool_free (tceu_pool* pool, byte* val);

#endif

/*
 * Ceu pool.c is based on Contiki and TinyOS pools:
 * https://github.com/contiki-os/contiki/blob/master/core/lib/memb.c
 * https://github.com/tinyos/tinyos-main/blob/master/tos/system/PoolP.nc
 */
#ifndef _CEU_POOL_C
#define _CEU_POOL_C

#include <stdlib.h>


void ceu_pool_init (tceu_pool* pool, int size, int unit, byte** queue, byte* mem)
{
    int i;
    pool->size  = size;
    pool->free  = size;
    pool->index = 0;
    pool->unit  = unit;
    pool->queue = queue;
    pool->mem   = mem;
    for (i=0; i<size; i++) {
        queue[i] = &mem[i*unit];
    }
}

byte* ceu_pool_alloc (tceu_pool* pool) {
    byte* ret;

    if (pool->free == 0) {
        return NULL;
    }

    pool->free--;
    ret = pool->queue[pool->index];
    pool->queue[pool->index++] = NULL;
    if (pool->index == pool->size) {
        pool->index = 0;
    }
    return ret;
}

void ceu_pool_free (tceu_pool* pool, byte* val) {
    int empty = pool->index + pool->free;
    if (empty >= pool->size) {
        empty -= pool->size;
    }
    pool->queue[empty] = val;
    pool->free++;
}

/*
int ceu_pool_inside (tceu_pool* pool, byte* val) {
    return ((byte*)val >= pool->mem)
        && ((byte*)val < pool->mem+(pool->size*pool->unit));
}
*/

#endif

#endif

#ifdef CEU_ORGS_NEWS
typedef struct tceu_pool_orgs {
    tceu_org* parent_org;
    tceu_ntrl parent_trl;
#ifdef CEU_ORGS_NEWS_POOL
    tceu_pool pool;
#endif
} tceu_pool_orgs;
#endif

#ifdef CEU_ADTS_NEWS
typedef struct {
    void* root;
#ifdef CEU_ADTS_NEWS_POOL
    void* pool;
#endif
} tceu_pool_adts;
#endif

/* TCEU_KILL */

#ifdef CEU_ORGS_OR_ADTS_AWAIT
typedef struct tceu_kill {
    void*     org_or_adt;
    int       ret;
} tceu_kill;
#endif

/* TCEU_LST */

#ifdef CEU_DEBUG
typedef struct tceu_lst {
#ifdef CEU_ORGS
    void*     org;
#endif
    tceu_trl* trl;
    tceu_nlbl lbl;
} tceu_lst;

#endif

/* TCEU_STK */

typedef struct tceu_stk {
    struct tceu_stk* up;
    tceu_org* org;
    tceu_ntrl trl1;
    tceu_ntrl trl2;
    jmp_buf   jmp;
} tceu_stk;

/* TCEU_JMP */

#ifdef CEU_STACK
typedef struct tceu_jmp {
#ifdef CEU_ORGS
    tceu_org* org;
#endif
    tceu_trl* trl;
    tceu_nlbl lbl;
} tceu_jmp;
#endif

/* TCEU_APP */

typedef struct tceu_app {
    /* global seqno: incremented on every reaction
     * awaiting trails matches only if trl->seqno < seqno,
     * i.e., previously awaiting the event
     */
    u8 seqno:          2;
#if defined(CEU_RET) || defined(CEU_OS)
    u8 isAlive:        1;
#endif
#ifdef CEU_ASYNCS
    u8 pendingAsyncs:  1;
#endif
#if defined(CEU_ORGS_NEWS_MALLOC) && defined(CEU_ORGS_AWAIT)
    u8 dont_emit_kill: 1;
#endif

#ifdef CEU_OS
    struct tceu_app* nxt;
#endif

#ifdef CEU_REENTRANT
    tceu_nstk stki;
#endif

#ifdef CEU_STACK
    tceu_stk* stk_bottom;
    tceu_jmp  stk_jmp;
#endif

#if defined(CEU_RET) || defined(CEU_ORGS_AWAIT)
    int ret;
#endif

#ifdef CEU_ORGS_NEWS_MALLOC
    tceu_org* tofree;
#endif

#ifdef CEU_WCLOCKS
    s32         wclk_late;
    s32         wclk_min_set;   /* used to set */
    s32         wclk_min_cmp;   /* used to compare */
                                /* cmp<-set every reaction */
#ifdef CEU_TIMEMACHINE
    s32         wclk_late_;
    s32         wclk_min_set_;
    s32         wclk_min_cmp_;
#endif
#endif

#ifndef CEU_OS
#ifdef CEU_DEBUG
    tceu_lst    lst; /* segfault printf */
#endif
#endif

#ifdef CEU_THREADS
    CEU_THREADS_MUTEX_T threads_mutex;
    /*CEU_THREADS_COND_T  threads_cond;*/
    u8                  threads_n;          /* number of running threads */
        /* TODO: u8? */
#endif
#if defined(CEU_LUA) || defined(CEU_OS)
#ifdef CEU_LUA
    lua_State*  lua;    /* TODO: move to data? */
#else
    void*       lua;
#endif
#endif

    void        (*code)  (struct tceu_app*,tceu_evt*,tceu_org*,tceu_trl*,tceu_stk*);
    void        (*init)  (struct tceu_app*);
#ifdef CEU_OS
    void*       (*calls) (struct tceu_app*,tceu_nevt,void*);
    void**      sys_vec;
    void*       addr;
#ifdef CEU_OS_LUAIFC
    char*       luaifc;
#endif
#endif
    tceu_org*   data;
} tceu_app;

#ifdef CEU_OS
typedef void (*tceu_init)   (tceu_app* app);
typedef void (*tceu_export) (uint* size, tceu_init** init
#ifdef CEU_OS_LUAIFC
                            , char** luaifc
#endif
);
#endif

/* TCEU_THREADS_P */

#ifdef CEU_THREADS
typedef struct {
    tceu_app* app;
    tceu_org* org;
    s8*       st; /* thread state:
                   * 0=ini (sync  spawns)
                   * 1=cpy (async copies)
                   * 2=lck (sync  locks)
                   * 3=end (sync/async terminates)
                   */
} tceu_threads_p;
#endif

#ifdef CEU_PSES
void ceu_pause (tceu_trl* trl, tceu_trl* trlF, int psed);
#endif

int  ceu_go_all    (tceu_app* app);

#ifdef CEU_WCLOCKS
int       ceu_sys_wclock (tceu_app* app, s32 dt, s32* set, s32* get);
#endif
void      ceu_sys_go     (tceu_app* app, int evt, void* evtp);

#ifdef CEU_OS

/* TCEU_LINK */

typedef struct tceu_lnk {
    tceu_app* src_app;
    tceu_nevt src_evt;
    tceu_app* dst_app;
    tceu_nevt dst_evt;
    struct tceu_lnk* nxt;
} tceu_lnk;

/* TCEU_QUEUE */

typedef struct {
    tceu_app* app;
    tceu_nevt evt;
#if CEU_QUEUE_MAX == 256
    s8        sz;
#else
    s16       sz;   /* signed because of fill */
#endif
    byte      buf[0];
} tceu_queue;

#ifdef CEU_ISR
typedef void(*tceu_isr_f)(tceu_app* app, tceu_org* org);
#endif

void ceu_os_init      (void);
int  ceu_os_scheduler (int(*dt)());
tceu_queue* ceu_sys_queue_nxt (void);
void        ceu_sys_queue_rem (void);

void      ceu_sys_assert    (int v);
void      ceu_sys_log       (int mode, long str);
void*     ceu_sys_realloc   (void* ptr, size_t size);
int       ceu_sys_req       (void);
tceu_app* ceu_sys_load      (void* addr);
#ifdef CEU_ISR
int       ceu_sys_isr       (int n, tceu_isr_f f, tceu_app* app);
#endif
void      ceu_sys_org_init  (tceu_org* org, int n, int lbl, int cls, int isDyn,
                             tceu_org* parent_org, tceu_ntrl parent_trl);
void      ceu_sys_start     (tceu_app* app);
int       ceu_sys_link      (tceu_app* src_app, tceu_nevt src_evt, tceu_app* dst_app, tceu_nevt dst_evt);
int       ceu_sys_unlink    (tceu_app* src_app, tceu_nevt src_evt, tceu_app* dst_app, tceu_nevt dst_evt);
int       ceu_sys_emit      (tceu_app* app, tceu_nevt evt, int sz, void* param);
void*     ceu_sys_call      (tceu_app* app, tceu_nevt evt, void* param);

enum {
    CEU_SYS_ASSERT = 0,
    CEU_SYS_LOG,
    CEU_SYS_REALLOC,
    CEU_SYS_REQ,
    CEU_SYS_LOAD,
#ifdef CEU_ISR
    CEU_SYS_ISR,
#endif
#ifdef CEU_CLEAR
    CEU_SYS_CLEAR,
#endif
    CEU_SYS_STACK_PUSH,
#ifdef CEU_ORGS
    CEU_SYS_STACK_CLEAR_ORG,
#endif
    CEU_SYS_ORG,
#ifdef CEU_ORGS
    CEU_SYS_ORG_TRAIL,
    CEU_SYS_ORG_SPAWN,
#endif
    CEU_SYS_START,
    CEU_SYS_LINK,
    CEU_SYS_UNLINK,
    CEU_SYS_EMIT,
    CEU_SYS_CALL,
#ifdef CEU_WCLOCKS
    CEU_SYS_WCLOCK,
#endif
    CEU_SYS_GO,
    CEU_SYS_MAX
};

/* SYS_VECTOR
 */
extern void* CEU_SYS_VEC[CEU_SYS_MAX];

#endif  /* CEU_OS */

#endif  /* _CEU_OS_H */

#ifndef _CEU_OS_H
#define _CEU_OS_H

#include <stddef.h>
#include "ceu_types.h"

#ifdef CEU_DEBUG
#include <assert.h>
#endif

#if defined(CEU_OS) && defined(__AVR)
#error Understand this again!
#include "Arduino.h"
#define CEU_ISR
#define CEU_ISR_ON()  interrupts()
#define CEU_ISR_OFF() noInterrupts()
#else
#define CEU_ISR_ON()
#define CEU_ISR_OFF()
#endif

/*
#if defined(CEU_CLEAR) || defined(CEU_INTS) || defined(CEU_ORGS) || defined(CEU_REENTRANT)
*/
#if 1
#include <setjmp.h>
#define CEU_STACK
#endif

#if defined(CEU_OS_KERNEL) || defined(CEU_OS_APP)
#define CEU_OS
#endif

#if defined(CEU_ORGS_NEWS) || defined(CEU_ADTS_NEWS)
#define CEU_NEWS
#endif
#if defined(CEU_ORGS_NEWS_POOL) || defined(CEU_ADTS_NEWS_POOL)
#define CEU_NEWS_POOL
#endif
#if defined(CEU_ORGS_AWAIT) || defined(CEU_ADTS_AWAIT)
#define CEU_ORGS_OR_ADTS_AWAIT
#endif

#ifdef CEU_OS

    /* TODO: all should be configurable */
    #define CEU_EXTS
    #define CEU_WCLOCKS
    #define CEU_ASYNCS
    #define CEU_RET
    #define CEU_CLEAR
    #define CEU_STACK
#ifndef __AVR
#endif
    #define CEU_INTS
    #define CEU_ORGS
    /*#define CEU_PSES*/ /* TODO: never tried */
    #define CEU_NEWS
    #define CEU_NEWS_POOL
    #define CEU_ORGS_NEWS
    #define CEU_ORGS_NEWS_MALLOC
    #define CEU_ORGS_NEWS_POOL
    #define CEU_ADTS_NEWS
    #define CEU_ADTS_NEWS_MALLOC
    #define CEU_ADTS_NEWS_POOL
    #define CEU_ORGS_AWAIT
    #define CEU_ADTS_AWAIT
    #define CEU_ORGS_OR_ADTS_AWAIT
/*
    #define CEU_THREADS
*/

#ifdef __AVR
    #define CEU_QUEUE_MAX 256
#else
    #define CEU_QUEUE_MAX 65536
#endif

    #define CEU_IN__NONE          0
    #define CEU_IN__ORG         255
    #define CEU_IN__ORG_PSED    254
    #define CEU_IN__CLEAR       253
    #define CEU_IN__ok_killed   252
    #define CEU_IN__INIT        251     /* HIGHER EXTERNAL */
    #define CEU_IN__ASYNC       250
    #define CEU_IN__THREAD      249
    #define CEU_IN__WCLOCK      248
    #define CEU_IN_OS_START     247
    #define CEU_IN_OS_STOP      246
    #define CEU_IN_OS_DT        245
    #define CEU_IN_OS_INTERRUPT 244
#ifdef CEU_TIMEMACHINE
    #define CEU_IN__WCLOCK_     243
    #define CEU_IN              243
#else
    #define CEU_IN              242
#endif

    #define CEU_IN_higher       CEU_IN__INIT  /* _INIT = HIGHER EXTERNAL */
    #define CEU_IN_lower        128     /* TODO: not checked from up and down */

    typedef s8 tceu_nlbl;   /* TODO: to small!! */

#endif /* CEU_OS */

#ifdef CEU_OS_APP

    #define ceu_out_log(mode,str) \
        ((__typeof__(ceu_sys_log)*)((_ceu_app)->sys_vec[CEU_SYS_LOG]))(mode,str)

    #define ceu_out_assert(v) \
        ((__typeof__(ceu_sys_assert)*)((_ceu_app)->sys_vec[CEU_SYS_ASSERT]))(v)

    #define ceu_out_assert_msg_ex(v,msg,file,line)       \
        {                                                \
            int __ceu_v = v;                             \
            if ((!(__ceu_v)) && ((msg)!=NULL)) {         \
                ceu_out_log(0, (long)"[");               \
                ceu_out_log(0, (long)(file));            \
                ceu_out_log(0, (long)":");               \
                ceu_out_log(2, (line));                  \
                ceu_out_log(0, (long)"] ");              \
                ceu_out_log(0, (long)"runtime error: "); \
                ceu_out_log(0, (long)(msg));             \
                ceu_out_log(0, (long)"\n");              \
            }                                            \
            ((__typeof__(ceu_sys_assert)*)((_ceu_app)->sys_vec[CEU_SYS_ASSERT]))(__ceu_v); \
        }
    #define ceu_out_assert_msg(v,msg) ceu_out_assert_msg_ex((v),(msg),__FILE__,__LINE__)

    #define ceu_out_realloc(ptr, size) \
        ((__typeof__(ceu_sys_realloc)*)((_ceu_app)->sys_vec[CEU_SYS_REALLOC]))(ptr,size)

    #define ceu_out_req() \
        ((__typeof__(ceu_sys_req)*)((_ceu_app)->sys_vec[CEU_SYS_REQ]))()

    #define ceu_out_load(addr) \
        ((__typeof__(ceu_sys_load)*)((_ceu_app)->sys_vec[CEU_SYS_LOAD]))(addr)

#ifdef CEU_ISR
    #define ceu_out_isr(n,f) \
        ((__typeof__(ceu_sys_isr)*)((_ceu_app)->sys_vec[CEU_SYS_ISR]))(n,f,_ceu_app)
#endif

    #define ceu_out_org_init(app,org,n,lbl,cls,isDyn,parent_org,parent_trl) \
        ((__typeof__(ceu_sys_org_init)*)((app)->sys_vec[CEU_SYS_ORG]))(org,n,lbl,cls,isDyn,parent_org,parent_trl)
    #define ceu_out_start(app) \
        ((__typeof__(ceu_sys_start)*)((_ceu_app)->sys_vec[CEU_SYS_START]))(app)
    #define ceu_out_link(app1,evt1 , app2,evt2) \
        ((__typeof__(ceu_sys_link)*)((_ceu_app)->sys_vec[CEU_SYS_LINK]))(app1,evt1,app2,evt2)

    #define ceu_out_emit(app,id,sz,buf) \
        ((__typeof__(ceu_sys_emit)*)((app)->sys_vec[CEU_SYS_EMIT]))(app,id,sz,buf)

    #define ceu_out_call(app,id,param) \
        ((__typeof__(ceu_sys_call)*)((app)->sys_vec[CEU_SYS_CALL]))(app,id,param)

#ifdef CEU_WCLOCKS
    #define ceu_out_wclock(app,dt,set,get) \
        ((__typeof__(ceu_sys_wclock)*)((app)->sys_vec[CEU_SYS_WCLOCK]))(app,dt,set,get)
#ifdef CEU_TIMEMACHINE
    #error TIMEMACHINE
#endif
#endif

    #define ceu_out_go(app,evt,evtp) \
        ((__typeof__(ceu_sys_go)*)((app)->sys_vec[CEU_SYS_GO]))(app,evt,evtp)

#else /* ! CEU_OS_APP (!CEU_OS||CEU_OS_KERNEL) */

    #ifndef ceu_out_assert
        #error "Missing definition for macro \"ceu_out_assert\"."
    #endif

    #ifndef ceu_out_log
        #error "Missing definition for macro \"ceu_out_log\"."
    #endif

    #define ceu_out_assert_msg_ex(v,msg,file,line)          \
        {                                                   \
            int __ceu_v = v;                                \
            if ((!(__ceu_v)) && ((msg)!=NULL)) {            \
                ceu_out_log(0, (long)"[");                  \
                ceu_out_log(0, (long)(file));               \
                ceu_out_log(0, (long)":");                  \
                ceu_out_log(2, line);                       \
                ceu_out_log(0, (long)"] ");                 \
                ceu_out_log(0, (long)"runtime error: ");    \
                ceu_out_log(0, (long)(msg));                \
                ceu_out_log(0, (long)"\n");                 \
            }                                               \
            ceu_out_assert(__ceu_v);                        \
        }
    #define ceu_out_assert_msg(v,msg) ceu_out_assert_msg_ex((v),(msg),__FILE__,__LINE__)

    #define ceu_out_realloc(ptr,size) \
            ceu_sys_realloc(ptr,size)
    #define ceu_out_req() \
            ceu_sys_req()
    #define ceu_out_org_init(app,org,n,lbl,cls,isDyn,parent_org,parent_trl) \
            ceu_sys_org_init(org,n,lbl,cls,isDyn,parent_org,parent_trl)

#ifdef CEU_WCLOCKS
    #define ceu_out_wclock(app,dt,set,get) \
            ceu_sys_wclock(app,dt,set,get)
#ifdef CEU_TIMEMACHINE
    #define ceu_out_wclock_(app,dt,set,get) \
            ceu_sys_wclock_(app,dt,set,get)
#endif
#endif
    #define ceu_out_go(app,evt,evtp) \
            ceu_sys_go(app,evt,evtp)
    #define ceu_out_go_stk(app,evt,evtp,stk) \
            ceu_sys_go_stk(app,evt,evtp,stk)

#endif /* ! CEU_OS_APP (!CEU_OS||CEU_OS_KERNEL) */

#define ceu_in_emit(app,id,n,buf) \
    ceu_out_go_stk(app,id,buf,&stk_)

#ifdef CEU_THREADS
/* TODO: app */
#include "ceu_threads.h"
#endif

#ifdef CEU_LUA
#include <stdio.h>      /* BUFSIZ */
#include <string.h>     /* strcpy */
#if defined(__ANDROID__) || defined(CEU_OS)
    #include "lua.h"
    #include "lauxlib.h"
    #include "lualib.h"
#else
    #include <lua5.1/lua.h>
    #include <lua5.1/lauxlib.h>
    #include <lua5.1/lualib.h>
#endif

#ifdef CEU_OS_APP
    #define ceu_luaL_newstate(set) { \
        set = ceu_out_call(_ceu_app, CEU_OUT_LUA_NEW, NULL); \
    }

    #define ceu_luaL_openlibs(l) { \
        lua_State* p = l;          \
        ceu_out_call(_ceu_app, CEU_OUT_LUAL_OPENLIBS, &p); \
    }

    #define ceu_lua_atpanic(l, f) {     \
    }

    #define ceu_luaL_loadstring(set, l, str) {  \
        tceu__lua_State___char_ p = { l, str }; \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUAL_LOADSTRING, &p); \
    }

    #define ceu_lua_pushnumber(l, v) {      \
        tceu__lua_State___int p = { l, v }; \
        ceu_out_call(_ceu_app, CEU_OUT_LUA_PUSHNUMBER, &p); \
    }

    #define ceu_lua_pushstring(l, v) {      \
        tceu__lua_State___char_ p = { l, v }; \
        ceu_out_call(_ceu_app, CEU_OUT_LUA_PUSHSTRING, &p); \
    }

    #define ceu_lua_pushlightuserdata(l, v) {   \
        tceu__lua_State___void_ p = { l, v };     \
        ceu_out_call(_ceu_app, CEU_OUT_LUA_PUSHLIGHTUSERDATA, &p); \
    }

    #define ceu_lua_pcall(set,l,nargs,nrets,err) {                  \
        tceu__lua_State___int__int__int p = { l, nargs, nrets, err }; \
        ceu_out_call(_ceu_app, CEU_OUT_LUA_PCALL, &p); \
    }

    #define ceu_lua_isnumber(set, l, idx) {     \
        tceu__lua_State___int p = { l, idx };   \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUA_ISNUMBER, &p); \
    }

    #define ceu_lua_tonumber(set, l, idx) {     \
        tceu__lua_State___int p = { l, idx };   \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUA_TONUMBER, &p); \
    }

    #define ceu_lua_isboolean(set, l, idx) {    \
        tceu__lua_State___int p = { l, idx };   \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUA_ISBOOLEAN, &p); \
    }

    #define ceu_lua_toboolean(set, l, idx) {    \
        tceu__lua_State___int p = { l, idx };   \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUA_TOBOOLEAN, &p); \
    }

    #define ceu_lua_pop(l, n) {             \
        tceu__lua_State___int p = { l, n }; \
        ceu_out_call(_ceu_app, CEU_OUT_LUA_POP, &p); \
    }

    #define ceu_lua_isstring(set, l, idx) {     \
        tceu__lua_State___int p = { l, idx };   \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUA_ISSTRING, &p); \
    }

    #define ceu_lua_tostring(set, l, idx) {     \
        tceu__lua_State___int p = { l, idx };   \
        set = ceu_out_call(_ceu_app, CEU_OUT_LUA_TOSTRING, &p); \
    }

    #define ceu_lua_islightuserdata(set, l, idx) {  \
        tceu__lua_State___int p = { l, idx };       \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUA_ISLIGHTUSERDATA, &p); \
    }

    #define ceu_lua_touserdata(set, l, idx) {   \
        tceu__lua_State___int p = { l, idx };   \
        set = ceu_out_call(_ceu_app, CEU_OUT_LUA_TOUSERDATA, &p); \
    }

    #define ceu_lua_error(l) {                          \
        lua_State** p = &l;                             \
        ceu_out_call(_ceu_app, CEU_OUT_LUA_ERROR, &p);  \
    }

    #define ceu_lua_objlen(set, l, idx) {                       \
        tceu__lua_State___int p = { l, idx };                   \
        set = ceu_out_call(_ceu_app, CEU_OUT_LUA_OBJLEN, &p);   \
    }

#else
    #define ceu_luaL_newstate(set)               set = luaL_newstate()
    #define ceu_luaL_openlibs(l)                 luaL_openlibs(l)
    #define ceu_lua_atpanic(l,f)                 lua_atpanic(l,f)
    #define ceu_luaL_loadstring(set,l,str)       set = luaL_loadstring(l,str)
    #define ceu_lua_pushnumber(l,v)              lua_pushnumber(l,v)
    #define ceu_lua_pushstring(l,v)              lua_pushstring(l,v)
    #define ceu_lua_pushlightuserdata(l,v)       lua_pushlightuserdata(l,v)
    #define ceu_lua_pcall(set,l,nargs,nrets,err) set = lua_pcall(l,nargs,nrets,err)
    #define ceu_lua_isnumber(set,l,idx)          set = lua_isnumber(l,idx)
    #define ceu_lua_tonumber(set,l,idx)          set = lua_tonumber(l,idx)
    #define ceu_lua_isboolean(set,l,idx)         set = lua_isboolean(l,idx)
    #define ceu_lua_toboolean(set,l,idx)         set = lua_toboolean(l,idx)
    #define ceu_lua_pop(l,n)                     lua_pop(l,n)
    #define ceu_lua_isstring(set,l,idx)          set = lua_isstring(l,idx)
    #define ceu_lua_tostring(set,l,idx)          set = lua_tostring(l,idx)
    #define ceu_lua_islightuserdata(set,l,idx)   set = lua_islightuserdata(l,idx)
    #define ceu_lua_touserdata(set,l,idx)        set = lua_touserdata(l,idx)
    #define ceu_lua_error(l)                     lua_error(l)
    #define ceu_lua_objlen(set,l,idx)            set = lua_objlen(l,idx)
#endif
#endif

typedef u8 tceu_nevt;   /* max number of events */
                        /* TODO: should "u8" be fixed? */

typedef u8 tceu_ntrl;   /* max number of trails per class */
                        /* TODO: should "u8" be fixed? */

#ifdef CEU_STACK
typedef u16 tceu_nstk;  /* max size of internal stack in bytes */
                        /* TODO: should "u16" be fixed? */
#endif

#ifdef __cplusplus
#define CEU_WCLOCK_INACTIVE 0x7fffffffL     /* TODO */
#else
#define CEU_WCLOCK_INACTIVE INT32_MAX
#endif
#define CEU_WCLOCK_EXPIRED (CEU_WCLOCK_INACTIVE-1)

/* TCEU_TRL */

struct tceu_org;
typedef union tceu_trl {
    tceu_nevt evt;

    /* normal await // IN__CLEAR */
    struct {                    /* TODO(ram): bitfields */
        tceu_nevt evt1;
        tceu_nlbl lbl;
        u8        seqno;        /* TODO(ram): 2 bits is enough */
#ifdef CEU_INTS                 /* R-9: size of trails for internal events */
#ifdef CEU_ORGS
        void*     evto;
#endif
#endif
    };

    /* IN__ORG */
#ifdef CEU_ORGS
    struct {                    /* TODO(ram): bad for alignment */
        tceu_nevt evt3;
        struct tceu_org* org;
    };
#endif

    /* _ok_killed */
#ifdef CEU_ORGS_OR_ADTS_AWAIT
    struct {
        tceu_nevt evt4;
        tceu_nlbl lbl4;
        void*     org_or_adt;
    };
#endif
} tceu_trl;

/* TCEU_EVT */

typedef struct tceu_evt {
    tceu_nevt id;
    void*     param;
#if defined(CEU_ORGS) && defined(CEU_INTS)
    void*     org;      /* emitting org */
#endif
} tceu_evt;

/* TCEU_ORG */

struct tceu_pool_orgs;
typedef struct tceu_org
{
#ifdef CEU_ORGS
    struct tceu_org* nxt; /* first field because of free list for orgs/adts */
    struct tceu_org* prv;
    struct tceu_org* parent_org;
    tceu_ntrl parent_trl;
#endif

#if defined(CEU_ORGS) || defined(CEU_OS)
    tceu_ntrl n;            /* number of trails (TODO(ram): opt, metadata) */
#endif

#ifdef CEU_ORGS

#ifdef CEU_IFCS
    tceu_ncls cls;          /* class id */
#endif
    u8 isAlive: 1;          /* Three purposes:
                             * - avoids double free
                             * - required by "watching o" to avoid awaiting a
                             *      dead org
                             * - required by "Do T" to avoid awaiting a dead 
                             *      org
                             */
#if defined(CEU_ORGS_NEWS) || defined(CEU_ORGS_AWAIT)
#endif
#ifdef CEU_ORGS_NEWS
    u8 isDyn: 1;            /* created w/ new or spawn? */
#endif
#ifdef CEU_ORGS_NEWS_POOL
    struct tceu_pool_orgs* pool;
#endif

#ifdef CEU_ORGS_AWAIT
    int ret;
#endif

#endif  /* CEU_ORGS */

    tceu_trl trls[0];       /* first trail */

} tceu_org;

/* TCEU_POOL_ORGS , TCEU_POOL_ADTS */

#if defined(CEU_ORGS_NEWS_POOL) || defined(CEU_ADTS_NEWS_POOL)
#ifndef _CEU_POOL_H
#define _CEU_POOL_H

#include "ceu_types.h"

/* TODO: all "int" here, should evaluate the correct unsigned type */

typedef struct {
    byte**  queue;
                    /* queue is in the next offset to distinguish dynamic(NULL)
                       from static pools(any-address) */
    int     size;
    int     free;
    int     index;
    int     unit;
    byte*   mem;
} tceu_pool;

#define CEU_POOL_DCL(name, type, size) \
    type*     name##_queue[size];      \
    type      name##_mem[size];        \
    tceu_pool name;

void ceu_pool_init (tceu_pool* pool, int size, int unit, byte** queue, byte* mem);
byte* ceu_pool_alloc (tceu_pool* pool);
void ceu_pool_free (tceu_pool* pool, byte* val);

#endif

/*
 * Ceu pool.c is based on Contiki and TinyOS pools:
 * https://github.com/contiki-os/contiki/blob/master/core/lib/memb.c
 * https://github.com/tinyos/tinyos-main/blob/master/tos/system/PoolP.nc
 */
#ifndef _CEU_POOL_C
#define _CEU_POOL_C

#include <stdlib.h>


void ceu_pool_init (tceu_pool* pool, int size, int unit, byte** queue, byte* mem)
{
    int i;
    pool->size  = size;
    pool->free  = size;
    pool->index = 0;
    pool->unit  = unit;
    pool->queue = queue;
    pool->mem   = mem;
    for (i=0; i<size; i++) {
        queue[i] = &mem[i*unit];
    }
}

byte* ceu_pool_alloc (tceu_pool* pool) {
    byte* ret;

    if (pool->free == 0) {
        return NULL;
    }

    pool->free--;
    ret = pool->queue[pool->index];
    pool->queue[pool->index++] = NULL;
    if (pool->index == pool->size) {
        pool->index = 0;
    }
    return ret;
}

void ceu_pool_free (tceu_pool* pool, byte* val) {
    int empty = pool->index + pool->free;
    if (empty >= pool->size) {
        empty -= pool->size;
    }
    pool->queue[empty] = val;
    pool->free++;
}

/*
int ceu_pool_inside (tceu_pool* pool, byte* val) {
    return ((byte*)val >= pool->mem)
        && ((byte*)val < pool->mem+(pool->size*pool->unit));
}
*/

#endif

#endif

#ifdef CEU_ORGS_NEWS
typedef struct tceu_pool_orgs {
    tceu_org* parent_org;
    tceu_ntrl parent_trl;
#ifdef CEU_ORGS_NEWS_POOL
    tceu_pool pool;
#endif
} tceu_pool_orgs;
#endif

#ifdef CEU_ADTS_NEWS
typedef struct {
    void* root;
#ifdef CEU_ADTS_NEWS_POOL
    void* pool;
#endif
} tceu_pool_adts;
#endif

/* TCEU_KILL */

#ifdef CEU_ORGS_OR_ADTS_AWAIT
typedef struct tceu_kill {
    void*     org_or_adt;
    int       ret;
} tceu_kill;
#endif

/* TCEU_LST */

#ifdef CEU_DEBUG
typedef struct tceu_lst {
#ifdef CEU_ORGS
    void*     org;
#endif
    tceu_trl* trl;
    tceu_nlbl lbl;
} tceu_lst;

#endif

/* TCEU_STK */

typedef struct tceu_stk {
    struct tceu_stk* up;
    tceu_org* org;
    tceu_ntrl trl1;
    tceu_ntrl trl2;
    jmp_buf   jmp;
} tceu_stk;

/* TCEU_JMP */

#ifdef CEU_STACK
typedef struct tceu_jmp {
#ifdef CEU_ORGS
    tceu_org* org;
#endif
    tceu_trl* trl;
    tceu_nlbl lbl;
} tceu_jmp;
#endif

/* TCEU_APP */

typedef struct tceu_app {
    /* global seqno: incremented on every reaction
     * awaiting trails matches only if trl->seqno < seqno,
     * i.e., previously awaiting the event
     */
    u8 seqno:          2;
#if defined(CEU_RET) || defined(CEU_OS)
    u8 isAlive:        1;
#endif
#ifdef CEU_ASYNCS
    u8 pendingAsyncs:  1;
#endif
#if defined(CEU_ORGS_NEWS_MALLOC) && defined(CEU_ORGS_AWAIT)
    u8 dont_emit_kill: 1;
#endif

#ifdef CEU_OS
    struct tceu_app* nxt;
#endif

#ifdef CEU_REENTRANT
    tceu_nstk stki;
#endif

#ifdef CEU_STACK
    tceu_stk* stk_bottom;
    tceu_jmp  stk_jmp;
#endif

#if defined(CEU_RET) || defined(CEU_ORGS_AWAIT)
    int ret;
#endif

#ifdef CEU_ORGS_NEWS_MALLOC
    tceu_org* tofree;
#endif

#ifdef CEU_WCLOCKS
    s32         wclk_late;
    s32         wclk_min_set;   /* used to set */
    s32         wclk_min_cmp;   /* used to compare */
                                /* cmp<-set every reaction */
#ifdef CEU_TIMEMACHINE
    s32         wclk_late_;
    s32         wclk_min_set_;
    s32         wclk_min_cmp_;
#endif
#endif

#ifndef CEU_OS
#ifdef CEU_DEBUG
    tceu_lst    lst; /* segfault printf */
#endif
#endif

#ifdef CEU_THREADS
    CEU_THREADS_MUTEX_T threads_mutex;
    /*CEU_THREADS_COND_T  threads_cond;*/
    u8                  threads_n;          /* number of running threads */
        /* TODO: u8? */
#endif
#if defined(CEU_LUA) || defined(CEU_OS)
#ifdef CEU_LUA
    lua_State*  lua;    /* TODO: move to data? */
#else
    void*       lua;
#endif
#endif

    void        (*code)  (struct tceu_app*,tceu_evt*,tceu_org*,tceu_trl*,tceu_stk*);
    void        (*init)  (struct tceu_app*);
#ifdef CEU_OS
    void*       (*calls) (struct tceu_app*,tceu_nevt,void*);
    void**      sys_vec;
    void*       addr;
#ifdef CEU_OS_LUAIFC
    char*       luaifc;
#endif
#endif
    tceu_org*   data;
} tceu_app;

#ifdef CEU_OS
typedef void (*tceu_init)   (tceu_app* app);
typedef void (*tceu_export) (uint* size, tceu_init** init
#ifdef CEU_OS_LUAIFC
                            , char** luaifc
#endif
);
#endif

/* TCEU_THREADS_P */

#ifdef CEU_THREADS
typedef struct {
    tceu_app* app;
    tceu_org* org;
    s8*       st; /* thread state:
                   * 0=ini (sync  spawns)
                   * 1=cpy (async copies)
                   * 2=lck (sync  locks)
                   * 3=end (sync/async terminates)
                   */
} tceu_threads_p;
#endif

#ifdef CEU_PSES
void ceu_pause (tceu_trl* trl, tceu_trl* trlF, int psed);
#endif

int  ceu_go_all    (tceu_app* app);

#ifdef CEU_WCLOCKS
int       ceu_sys_wclock (tceu_app* app, s32 dt, s32* set, s32* get);
#endif
void      ceu_sys_go     (tceu_app* app, int evt, void* evtp);

#ifdef CEU_OS

/* TCEU_LINK */

typedef struct tceu_lnk {
    tceu_app* src_app;
    tceu_nevt src_evt;
    tceu_app* dst_app;
    tceu_nevt dst_evt;
    struct tceu_lnk* nxt;
} tceu_lnk;

/* TCEU_QUEUE */

typedef struct {
    tceu_app* app;
    tceu_nevt evt;
#if CEU_QUEUE_MAX == 256
    s8        sz;
#else
    s16       sz;   /* signed because of fill */
#endif
    byte      buf[0];
} tceu_queue;

#ifdef CEU_ISR
typedef void(*tceu_isr_f)(tceu_app* app, tceu_org* org);
#endif

void ceu_os_init      (void);
int  ceu_os_scheduler (int(*dt)());
tceu_queue* ceu_sys_queue_nxt (void);
void        ceu_sys_queue_rem (void);

void      ceu_sys_assert    (int v);
void      ceu_sys_log       (int mode, long str);
void*     ceu_sys_realloc   (void* ptr, size_t size);
int       ceu_sys_req       (void);
tceu_app* ceu_sys_load      (void* addr);
#ifdef CEU_ISR
int       ceu_sys_isr       (int n, tceu_isr_f f, tceu_app* app);
#endif
void      ceu_sys_org_init  (tceu_org* org, int n, int lbl, int cls, int isDyn,
                             tceu_org* parent_org, tceu_ntrl parent_trl);
void      ceu_sys_start     (tceu_app* app);
int       ceu_sys_link      (tceu_app* src_app, tceu_nevt src_evt, tceu_app* dst_app, tceu_nevt dst_evt);
int       ceu_sys_unlink    (tceu_app* src_app, tceu_nevt src_evt, tceu_app* dst_app, tceu_nevt dst_evt);
int       ceu_sys_emit      (tceu_app* app, tceu_nevt evt, int sz, void* param);
void*     ceu_sys_call      (tceu_app* app, tceu_nevt evt, void* param);

enum {
    CEU_SYS_ASSERT = 0,
    CEU_SYS_LOG,
    CEU_SYS_REALLOC,
    CEU_SYS_REQ,
    CEU_SYS_LOAD,
#ifdef CEU_ISR
    CEU_SYS_ISR,
#endif
#ifdef CEU_CLEAR
    CEU_SYS_CLEAR,
#endif
    CEU_SYS_STACK_PUSH,
#ifdef CEU_ORGS
    CEU_SYS_STACK_CLEAR_ORG,
#endif
    CEU_SYS_ORG,
#ifdef CEU_ORGS
    CEU_SYS_ORG_TRAIL,
    CEU_SYS_ORG_SPAWN,
#endif
    CEU_SYS_START,
    CEU_SYS_LINK,
    CEU_SYS_UNLINK,
    CEU_SYS_EMIT,
    CEU_SYS_CALL,
#ifdef CEU_WCLOCKS
    CEU_SYS_WCLOCK,
#endif
    CEU_SYS_GO,
    CEU_SYS_MAX
};

/* SYS_VECTOR
 */
extern void* CEU_SYS_VEC[CEU_SYS_MAX];

#endif  /* CEU_OS */

#endif  /* _CEU_OS_H */


#ifdef __AVR
#ifdef CEU_OS
#error Understand this again!
#include <avr/pgmspace.h>
void* CEU_APP_ADDR = NULL;
#endif
#endif

#include <string.h>

#ifdef CEU_DEBUG
#include <stdio.h>      /* printf */
#endif

#if defined(CEU_DEBUG) || defined(CEU_NEWS) || defined(CEU_THREADS) || defined(CEU_OS_KERNEL)
void *realloc(void *ptr, size_t size);
#endif

#ifdef CEU_NEWS_POOL
#ifndef _CEU_POOL_H
#define _CEU_POOL_H

#include "ceu_types.h"

/* TODO: all "int" here, should evaluate the correct unsigned type */

typedef struct {
    byte**  queue;
                    /* queue is in the next offset to distinguish dynamic(NULL)
                       from static pools(any-address) */
    int     size;
    int     free;
    int     index;
    int     unit;
    byte*   mem;
} tceu_pool;

#define CEU_POOL_DCL(name, type, size) \
    type*     name##_queue[size];      \
    type      name##_mem[size];        \
    tceu_pool name;

void ceu_pool_init (tceu_pool* pool, int size, int unit, byte** queue, byte* mem);
byte* ceu_pool_alloc (tceu_pool* pool);
void ceu_pool_free (tceu_pool* pool, byte* val);

#endif

/*
 * Ceu pool.c is based on Contiki and TinyOS pools:
 * https://github.com/contiki-os/contiki/blob/master/core/lib/memb.c
 * https://github.com/tinyos/tinyos-main/blob/master/tos/system/PoolP.nc
 */
#ifndef _CEU_POOL_C
#define _CEU_POOL_C

#include <stdlib.h>


void ceu_pool_init (tceu_pool* pool, int size, int unit, byte** queue, byte* mem)
{
    int i;
    pool->size  = size;
    pool->free  = size;
    pool->index = 0;
    pool->unit  = unit;
    pool->queue = queue;
    pool->mem   = mem;
    for (i=0; i<size; i++) {
        queue[i] = &mem[i*unit];
    }
}

byte* ceu_pool_alloc (tceu_pool* pool) {
    byte* ret;

    if (pool->free == 0) {
        return NULL;
    }

    pool->free--;
    ret = pool->queue[pool->index];
    pool->queue[pool->index++] = NULL;
    if (pool->index == pool->size) {
        pool->index = 0;
    }
    return ret;
}

void ceu_pool_free (tceu_pool* pool, byte* val) {
    int empty = pool->index + pool->free;
    if (empty >= pool->size) {
        empty -= pool->size;
    }
    pool->queue[empty] = val;
    pool->free++;
}

/*
int ceu_pool_inside (tceu_pool* pool, byte* val) {
    return ((byte*)val >= pool->mem)
        && ((byte*)val < pool->mem+(pool->size*pool->unit));
}
*/

#endif

#endif

/*
 * pthread_t thread;
 * pthread_mutex_t mutex;
 * pthread_cond_t  cond;
 * pthread_self();
        Uint32 SDL_ThreadID(void);
 * pthread_create(&thread, NULL, f, &p);
        SDL_Thread *SDL_CreateThread(int (*fn)(void *), void *data);
 * pthread_mutex_lock(&mutex);
 * pthread_mutex_unlock(&mutex);
 * pthread_cond_wait(&cond, &mutex);
 * pthread_cond_signal(&cond);
*/

/**********************************************************************
 * "APPS" running on the OS do not need any of the below.
 **********************************************************************/

#ifndef CEU_OS_APP

#ifdef CEU_NEWS
#ifdef CEU_RUNTESTS
#define CEU_MAX_DYNS 100
static int _ceu_dyns_ = 0;  /* check if total of alloc/free match */
#endif
#endif

#if defined(CEU_NEWS) || defined(CEU_THREADS) || defined(CEU_OS_KERNEL) || defined(CEU_VECTOR_MALLOC)
void* ceu_sys_realloc (void* ptr, size_t size) {
#ifdef CEU_NEWS
#ifdef CEU_RUNTESTS
    if (size == 0) {
        if (ptr != NULL) {
            _ceu_dyns_--;
        }
    } else {
        if (_ceu_dyns_ >= CEU_MAX_DYNS) {
            return NULL;
        }
        _ceu_dyns_++;           /* assumes no malloc fails */
    }
#endif
#endif
    return realloc(ptr, size);
}
#endif

#ifdef CEU_VECTOR
#ifndef _CEU_VECTOR_H
#define _CEU_VECTOR_H

#ifndef _CEU_OS_H
#define _CEU_OS_H

#include <stddef.h>
#include "ceu_types.h"

#ifdef CEU_DEBUG
#include <assert.h>
#endif

#if defined(CEU_OS) && defined(__AVR)
#error Understand this again!
#include "Arduino.h"
#define CEU_ISR
#define CEU_ISR_ON()  interrupts()
#define CEU_ISR_OFF() noInterrupts()
#else
#define CEU_ISR_ON()
#define CEU_ISR_OFF()
#endif

/*
#if defined(CEU_CLEAR) || defined(CEU_INTS) || defined(CEU_ORGS) || defined(CEU_REENTRANT)
*/
#if 1
#include <setjmp.h>
#define CEU_STACK
#endif

#if defined(CEU_OS_KERNEL) || defined(CEU_OS_APP)
#define CEU_OS
#endif

#if defined(CEU_ORGS_NEWS) || defined(CEU_ADTS_NEWS)
#define CEU_NEWS
#endif
#if defined(CEU_ORGS_NEWS_POOL) || defined(CEU_ADTS_NEWS_POOL)
#define CEU_NEWS_POOL
#endif
#if defined(CEU_ORGS_AWAIT) || defined(CEU_ADTS_AWAIT)
#define CEU_ORGS_OR_ADTS_AWAIT
#endif

#ifdef CEU_OS

    /* TODO: all should be configurable */
    #define CEU_EXTS
    #define CEU_WCLOCKS
    #define CEU_ASYNCS
    #define CEU_RET
    #define CEU_CLEAR
    #define CEU_STACK
#ifndef __AVR
#endif
    #define CEU_INTS
    #define CEU_ORGS
    /*#define CEU_PSES*/ /* TODO: never tried */
    #define CEU_NEWS
    #define CEU_NEWS_POOL
    #define CEU_ORGS_NEWS
    #define CEU_ORGS_NEWS_MALLOC
    #define CEU_ORGS_NEWS_POOL
    #define CEU_ADTS_NEWS
    #define CEU_ADTS_NEWS_MALLOC
    #define CEU_ADTS_NEWS_POOL
    #define CEU_ORGS_AWAIT
    #define CEU_ADTS_AWAIT
    #define CEU_ORGS_OR_ADTS_AWAIT
/*
    #define CEU_THREADS
*/

#ifdef __AVR
    #define CEU_QUEUE_MAX 256
#else
    #define CEU_QUEUE_MAX 65536
#endif

    #define CEU_IN__NONE          0
    #define CEU_IN__ORG         255
    #define CEU_IN__ORG_PSED    254
    #define CEU_IN__CLEAR       253
    #define CEU_IN__ok_killed   252
    #define CEU_IN__INIT        251     /* HIGHER EXTERNAL */
    #define CEU_IN__ASYNC       250
    #define CEU_IN__THREAD      249
    #define CEU_IN__WCLOCK      248
    #define CEU_IN_OS_START     247
    #define CEU_IN_OS_STOP      246
    #define CEU_IN_OS_DT        245
    #define CEU_IN_OS_INTERRUPT 244
#ifdef CEU_TIMEMACHINE
    #define CEU_IN__WCLOCK_     243
    #define CEU_IN              243
#else
    #define CEU_IN              242
#endif

    #define CEU_IN_higher       CEU_IN__INIT  /* _INIT = HIGHER EXTERNAL */
    #define CEU_IN_lower        128     /* TODO: not checked from up and down */

    typedef s8 tceu_nlbl;   /* TODO: to small!! */

#endif /* CEU_OS */

#ifdef CEU_OS_APP

    #define ceu_out_log(mode,str) \
        ((__typeof__(ceu_sys_log)*)((_ceu_app)->sys_vec[CEU_SYS_LOG]))(mode,str)

    #define ceu_out_assert(v) \
        ((__typeof__(ceu_sys_assert)*)((_ceu_app)->sys_vec[CEU_SYS_ASSERT]))(v)

    #define ceu_out_assert_msg_ex(v,msg,file,line)       \
        {                                                \
            int __ceu_v = v;                             \
            if ((!(__ceu_v)) && ((msg)!=NULL)) {         \
                ceu_out_log(0, (long)"[");               \
                ceu_out_log(0, (long)(file));            \
                ceu_out_log(0, (long)":");               \
                ceu_out_log(2, (line));                  \
                ceu_out_log(0, (long)"] ");              \
                ceu_out_log(0, (long)"runtime error: "); \
                ceu_out_log(0, (long)(msg));             \
                ceu_out_log(0, (long)"\n");              \
            }                                            \
            ((__typeof__(ceu_sys_assert)*)((_ceu_app)->sys_vec[CEU_SYS_ASSERT]))(__ceu_v); \
        }
    #define ceu_out_assert_msg(v,msg) ceu_out_assert_msg_ex((v),(msg),__FILE__,__LINE__)

    #define ceu_out_realloc(ptr, size) \
        ((__typeof__(ceu_sys_realloc)*)((_ceu_app)->sys_vec[CEU_SYS_REALLOC]))(ptr,size)

    #define ceu_out_req() \
        ((__typeof__(ceu_sys_req)*)((_ceu_app)->sys_vec[CEU_SYS_REQ]))()

    #define ceu_out_load(addr) \
        ((__typeof__(ceu_sys_load)*)((_ceu_app)->sys_vec[CEU_SYS_LOAD]))(addr)

#ifdef CEU_ISR
    #define ceu_out_isr(n,f) \
        ((__typeof__(ceu_sys_isr)*)((_ceu_app)->sys_vec[CEU_SYS_ISR]))(n,f,_ceu_app)
#endif

    #define ceu_out_org_init(app,org,n,lbl,cls,isDyn,parent_org,parent_trl) \
        ((__typeof__(ceu_sys_org_init)*)((app)->sys_vec[CEU_SYS_ORG]))(org,n,lbl,cls,isDyn,parent_org,parent_trl)
    #define ceu_out_start(app) \
        ((__typeof__(ceu_sys_start)*)((_ceu_app)->sys_vec[CEU_SYS_START]))(app)
    #define ceu_out_link(app1,evt1 , app2,evt2) \
        ((__typeof__(ceu_sys_link)*)((_ceu_app)->sys_vec[CEU_SYS_LINK]))(app1,evt1,app2,evt2)

    #define ceu_out_emit(app,id,sz,buf) \
        ((__typeof__(ceu_sys_emit)*)((app)->sys_vec[CEU_SYS_EMIT]))(app,id,sz,buf)

    #define ceu_out_call(app,id,param) \
        ((__typeof__(ceu_sys_call)*)((app)->sys_vec[CEU_SYS_CALL]))(app,id,param)

#ifdef CEU_WCLOCKS
    #define ceu_out_wclock(app,dt,set,get) \
        ((__typeof__(ceu_sys_wclock)*)((app)->sys_vec[CEU_SYS_WCLOCK]))(app,dt,set,get)
#ifdef CEU_TIMEMACHINE
    #error TIMEMACHINE
#endif
#endif

    #define ceu_out_go(app,evt,evtp) \
        ((__typeof__(ceu_sys_go)*)((app)->sys_vec[CEU_SYS_GO]))(app,evt,evtp)

#else /* ! CEU_OS_APP (!CEU_OS||CEU_OS_KERNEL) */

    #ifndef ceu_out_assert
        #error "Missing definition for macro \"ceu_out_assert\"."
    #endif

    #ifndef ceu_out_log
        #error "Missing definition for macro \"ceu_out_log\"."
    #endif

    #define ceu_out_assert_msg_ex(v,msg,file,line)          \
        {                                                   \
            int __ceu_v = v;                                \
            if ((!(__ceu_v)) && ((msg)!=NULL)) {            \
                ceu_out_log(0, (long)"[");                  \
                ceu_out_log(0, (long)(file));               \
                ceu_out_log(0, (long)":");                  \
                ceu_out_log(2, line);                       \
                ceu_out_log(0, (long)"] ");                 \
                ceu_out_log(0, (long)"runtime error: ");    \
                ceu_out_log(0, (long)(msg));                \
                ceu_out_log(0, (long)"\n");                 \
            }                                               \
            ceu_out_assert(__ceu_v);                        \
        }
    #define ceu_out_assert_msg(v,msg) ceu_out_assert_msg_ex((v),(msg),__FILE__,__LINE__)

    #define ceu_out_realloc(ptr,size) \
            ceu_sys_realloc(ptr,size)
    #define ceu_out_req() \
            ceu_sys_req()
    #define ceu_out_org_init(app,org,n,lbl,cls,isDyn,parent_org,parent_trl) \
            ceu_sys_org_init(org,n,lbl,cls,isDyn,parent_org,parent_trl)

#ifdef CEU_WCLOCKS
    #define ceu_out_wclock(app,dt,set,get) \
            ceu_sys_wclock(app,dt,set,get)
#ifdef CEU_TIMEMACHINE
    #define ceu_out_wclock_(app,dt,set,get) \
            ceu_sys_wclock_(app,dt,set,get)
#endif
#endif
    #define ceu_out_go(app,evt,evtp) \
            ceu_sys_go(app,evt,evtp)
    #define ceu_out_go_stk(app,evt,evtp,stk) \
            ceu_sys_go_stk(app,evt,evtp,stk)

#endif /* ! CEU_OS_APP (!CEU_OS||CEU_OS_KERNEL) */

#define ceu_in_emit(app,id,n,buf) \
    ceu_out_go_stk(app,id,buf,&stk_)

#ifdef CEU_THREADS
/* TODO: app */
#include "ceu_threads.h"
#endif

#ifdef CEU_LUA
#include <stdio.h>      /* BUFSIZ */
#include <string.h>     /* strcpy */
#if defined(__ANDROID__) || defined(CEU_OS)
    #include "lua.h"
    #include "lauxlib.h"
    #include "lualib.h"
#else
    #include <lua5.1/lua.h>
    #include <lua5.1/lauxlib.h>
    #include <lua5.1/lualib.h>
#endif

#ifdef CEU_OS_APP
    #define ceu_luaL_newstate(set) { \
        set = ceu_out_call(_ceu_app, CEU_OUT_LUA_NEW, NULL); \
    }

    #define ceu_luaL_openlibs(l) { \
        lua_State* p = l;          \
        ceu_out_call(_ceu_app, CEU_OUT_LUAL_OPENLIBS, &p); \
    }

    #define ceu_lua_atpanic(l, f) {     \
    }

    #define ceu_luaL_loadstring(set, l, str) {  \
        tceu__lua_State___char_ p = { l, str }; \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUAL_LOADSTRING, &p); \
    }

    #define ceu_lua_pushnumber(l, v) {      \
        tceu__lua_State___int p = { l, v }; \
        ceu_out_call(_ceu_app, CEU_OUT_LUA_PUSHNUMBER, &p); \
    }

    #define ceu_lua_pushstring(l, v) {      \
        tceu__lua_State___char_ p = { l, v }; \
        ceu_out_call(_ceu_app, CEU_OUT_LUA_PUSHSTRING, &p); \
    }

    #define ceu_lua_pushlightuserdata(l, v) {   \
        tceu__lua_State___void_ p = { l, v };     \
        ceu_out_call(_ceu_app, CEU_OUT_LUA_PUSHLIGHTUSERDATA, &p); \
    }

    #define ceu_lua_pcall(set,l,nargs,nrets,err) {                  \
        tceu__lua_State___int__int__int p = { l, nargs, nrets, err }; \
        ceu_out_call(_ceu_app, CEU_OUT_LUA_PCALL, &p); \
    }

    #define ceu_lua_isnumber(set, l, idx) {     \
        tceu__lua_State___int p = { l, idx };   \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUA_ISNUMBER, &p); \
    }

    #define ceu_lua_tonumber(set, l, idx) {     \
        tceu__lua_State___int p = { l, idx };   \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUA_TONUMBER, &p); \
    }

    #define ceu_lua_isboolean(set, l, idx) {    \
        tceu__lua_State___int p = { l, idx };   \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUA_ISBOOLEAN, &p); \
    }

    #define ceu_lua_toboolean(set, l, idx) {    \
        tceu__lua_State___int p = { l, idx };   \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUA_TOBOOLEAN, &p); \
    }

    #define ceu_lua_pop(l, n) {             \
        tceu__lua_State___int p = { l, n }; \
        ceu_out_call(_ceu_app, CEU_OUT_LUA_POP, &p); \
    }

    #define ceu_lua_isstring(set, l, idx) {     \
        tceu__lua_State___int p = { l, idx };   \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUA_ISSTRING, &p); \
    }

    #define ceu_lua_tostring(set, l, idx) {     \
        tceu__lua_State___int p = { l, idx };   \
        set = ceu_out_call(_ceu_app, CEU_OUT_LUA_TOSTRING, &p); \
    }

    #define ceu_lua_islightuserdata(set, l, idx) {  \
        tceu__lua_State___int p = { l, idx };       \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUA_ISLIGHTUSERDATA, &p); \
    }

    #define ceu_lua_touserdata(set, l, idx) {   \
        tceu__lua_State___int p = { l, idx };   \
        set = ceu_out_call(_ceu_app, CEU_OUT_LUA_TOUSERDATA, &p); \
    }

    #define ceu_lua_error(l) {                          \
        lua_State** p = &l;                             \
        ceu_out_call(_ceu_app, CEU_OUT_LUA_ERROR, &p);  \
    }

    #define ceu_lua_objlen(set, l, idx) {                       \
        tceu__lua_State___int p = { l, idx };                   \
        set = ceu_out_call(_ceu_app, CEU_OUT_LUA_OBJLEN, &p);   \
    }

#else
    #define ceu_luaL_newstate(set)               set = luaL_newstate()
    #define ceu_luaL_openlibs(l)                 luaL_openlibs(l)
    #define ceu_lua_atpanic(l,f)                 lua_atpanic(l,f)
    #define ceu_luaL_loadstring(set,l,str)       set = luaL_loadstring(l,str)
    #define ceu_lua_pushnumber(l,v)              lua_pushnumber(l,v)
    #define ceu_lua_pushstring(l,v)              lua_pushstring(l,v)
    #define ceu_lua_pushlightuserdata(l,v)       lua_pushlightuserdata(l,v)
    #define ceu_lua_pcall(set,l,nargs,nrets,err) set = lua_pcall(l,nargs,nrets,err)
    #define ceu_lua_isnumber(set,l,idx)          set = lua_isnumber(l,idx)
    #define ceu_lua_tonumber(set,l,idx)          set = lua_tonumber(l,idx)
    #define ceu_lua_isboolean(set,l,idx)         set = lua_isboolean(l,idx)
    #define ceu_lua_toboolean(set,l,idx)         set = lua_toboolean(l,idx)
    #define ceu_lua_pop(l,n)                     lua_pop(l,n)
    #define ceu_lua_isstring(set,l,idx)          set = lua_isstring(l,idx)
    #define ceu_lua_tostring(set,l,idx)          set = lua_tostring(l,idx)
    #define ceu_lua_islightuserdata(set,l,idx)   set = lua_islightuserdata(l,idx)
    #define ceu_lua_touserdata(set,l,idx)        set = lua_touserdata(l,idx)
    #define ceu_lua_error(l)                     lua_error(l)
    #define ceu_lua_objlen(set,l,idx)            set = lua_objlen(l,idx)
#endif
#endif

typedef u8 tceu_nevt;   /* max number of events */
                        /* TODO: should "u8" be fixed? */

typedef u8 tceu_ntrl;   /* max number of trails per class */
                        /* TODO: should "u8" be fixed? */

#ifdef CEU_STACK
typedef u16 tceu_nstk;  /* max size of internal stack in bytes */
                        /* TODO: should "u16" be fixed? */
#endif

#ifdef __cplusplus
#define CEU_WCLOCK_INACTIVE 0x7fffffffL     /* TODO */
#else
#define CEU_WCLOCK_INACTIVE INT32_MAX
#endif
#define CEU_WCLOCK_EXPIRED (CEU_WCLOCK_INACTIVE-1)

/* TCEU_TRL */

struct tceu_org;
typedef union tceu_trl {
    tceu_nevt evt;

    /* normal await // IN__CLEAR */
    struct {                    /* TODO(ram): bitfields */
        tceu_nevt evt1;
        tceu_nlbl lbl;
        u8        seqno;        /* TODO(ram): 2 bits is enough */
#ifdef CEU_INTS                 /* R-9: size of trails for internal events */
#ifdef CEU_ORGS
        void*     evto;
#endif
#endif
    };

    /* IN__ORG */
#ifdef CEU_ORGS
    struct {                    /* TODO(ram): bad for alignment */
        tceu_nevt evt3;
        struct tceu_org* org;
    };
#endif

    /* _ok_killed */
#ifdef CEU_ORGS_OR_ADTS_AWAIT
    struct {
        tceu_nevt evt4;
        tceu_nlbl lbl4;
        void*     org_or_adt;
    };
#endif
} tceu_trl;

/* TCEU_EVT */

typedef struct tceu_evt {
    tceu_nevt id;
    void*     param;
#if defined(CEU_ORGS) && defined(CEU_INTS)
    void*     org;      /* emitting org */
#endif
} tceu_evt;

/* TCEU_ORG */

struct tceu_pool_orgs;
typedef struct tceu_org
{
#ifdef CEU_ORGS
    struct tceu_org* nxt; /* first field because of free list for orgs/adts */
    struct tceu_org* prv;
    struct tceu_org* parent_org;
    tceu_ntrl parent_trl;
#endif

#if defined(CEU_ORGS) || defined(CEU_OS)
    tceu_ntrl n;            /* number of trails (TODO(ram): opt, metadata) */
#endif

#ifdef CEU_ORGS

#ifdef CEU_IFCS
    tceu_ncls cls;          /* class id */
#endif
    u8 isAlive: 1;          /* Three purposes:
                             * - avoids double free
                             * - required by "watching o" to avoid awaiting a
                             *      dead org
                             * - required by "Do T" to avoid awaiting a dead 
                             *      org
                             */
#if defined(CEU_ORGS_NEWS) || defined(CEU_ORGS_AWAIT)
#endif
#ifdef CEU_ORGS_NEWS
    u8 isDyn: 1;            /* created w/ new or spawn? */
#endif
#ifdef CEU_ORGS_NEWS_POOL
    struct tceu_pool_orgs* pool;
#endif

#ifdef CEU_ORGS_AWAIT
    int ret;
#endif

#endif  /* CEU_ORGS */

    tceu_trl trls[0];       /* first trail */

} tceu_org;

/* TCEU_POOL_ORGS , TCEU_POOL_ADTS */

#if defined(CEU_ORGS_NEWS_POOL) || defined(CEU_ADTS_NEWS_POOL)
#include "ceu_pool.h"
#endif

#ifdef CEU_ORGS_NEWS
typedef struct tceu_pool_orgs {
    tceu_org* parent_org;
    tceu_ntrl parent_trl;
#ifdef CEU_ORGS_NEWS_POOL
    tceu_pool pool;
#endif
} tceu_pool_orgs;
#endif

#ifdef CEU_ADTS_NEWS
typedef struct {
    void* root;
#ifdef CEU_ADTS_NEWS_POOL
    void* pool;
#endif
} tceu_pool_adts;
#endif

/* TCEU_KILL */

#ifdef CEU_ORGS_OR_ADTS_AWAIT
typedef struct tceu_kill {
    void*     org_or_adt;
    int       ret;
} tceu_kill;
#endif

/* TCEU_LST */

#ifdef CEU_DEBUG
typedef struct tceu_lst {
#ifdef CEU_ORGS
    void*     org;
#endif
    tceu_trl* trl;
    tceu_nlbl lbl;
} tceu_lst;

#endif

/* TCEU_STK */

typedef struct tceu_stk {
    struct tceu_stk* up;
    tceu_org* org;
    tceu_ntrl trl1;
    tceu_ntrl trl2;
    jmp_buf   jmp;
} tceu_stk;

/* TCEU_JMP */

#ifdef CEU_STACK
typedef struct tceu_jmp {
#ifdef CEU_ORGS
    tceu_org* org;
#endif
    tceu_trl* trl;
    tceu_nlbl lbl;
} tceu_jmp;
#endif

/* TCEU_APP */

typedef struct tceu_app {
    /* global seqno: incremented on every reaction
     * awaiting trails matches only if trl->seqno < seqno,
     * i.e., previously awaiting the event
     */
    u8 seqno:          2;
#if defined(CEU_RET) || defined(CEU_OS)
    u8 isAlive:        1;
#endif
#ifdef CEU_ASYNCS
    u8 pendingAsyncs:  1;
#endif
#if defined(CEU_ORGS_NEWS_MALLOC) && defined(CEU_ORGS_AWAIT)
    u8 dont_emit_kill: 1;
#endif

#ifdef CEU_OS
    struct tceu_app* nxt;
#endif

#ifdef CEU_REENTRANT
    tceu_nstk stki;
#endif

#ifdef CEU_STACK
    tceu_stk* stk_bottom;
    tceu_jmp  stk_jmp;
#endif

#if defined(CEU_RET) || defined(CEU_ORGS_AWAIT)
    int ret;
#endif

#ifdef CEU_ORGS_NEWS_MALLOC
    tceu_org* tofree;
#endif

#ifdef CEU_WCLOCKS
    s32         wclk_late;
    s32         wclk_min_set;   /* used to set */
    s32         wclk_min_cmp;   /* used to compare */
                                /* cmp<-set every reaction */
#ifdef CEU_TIMEMACHINE
    s32         wclk_late_;
    s32         wclk_min_set_;
    s32         wclk_min_cmp_;
#endif
#endif

#ifndef CEU_OS
#ifdef CEU_DEBUG
    tceu_lst    lst; /* segfault printf */
#endif
#endif

#ifdef CEU_THREADS
    CEU_THREADS_MUTEX_T threads_mutex;
    /*CEU_THREADS_COND_T  threads_cond;*/
    u8                  threads_n;          /* number of running threads */
        /* TODO: u8? */
#endif
#if defined(CEU_LUA) || defined(CEU_OS)
#ifdef CEU_LUA
    lua_State*  lua;    /* TODO: move to data? */
#else
    void*       lua;
#endif
#endif

    void        (*code)  (struct tceu_app*,tceu_evt*,tceu_org*,tceu_trl*,tceu_stk*);
    void        (*init)  (struct tceu_app*);
#ifdef CEU_OS
    void*       (*calls) (struct tceu_app*,tceu_nevt,void*);
    void**      sys_vec;
    void*       addr;
#ifdef CEU_OS_LUAIFC
    char*       luaifc;
#endif
#endif
    tceu_org*   data;
} tceu_app;

#ifdef CEU_OS
typedef void (*tceu_init)   (tceu_app* app);
typedef void (*tceu_export) (uint* size, tceu_init** init
#ifdef CEU_OS_LUAIFC
                            , char** luaifc
#endif
);
#endif

/* TCEU_THREADS_P */

#ifdef CEU_THREADS
typedef struct {
    tceu_app* app;
    tceu_org* org;
    s8*       st; /* thread state:
                   * 0=ini (sync  spawns)
                   * 1=cpy (async copies)
                   * 2=lck (sync  locks)
                   * 3=end (sync/async terminates)
                   */
} tceu_threads_p;
#endif

#ifdef CEU_PSES
void ceu_pause (tceu_trl* trl, tceu_trl* trlF, int psed);
#endif

int  ceu_go_all    (tceu_app* app);

#ifdef CEU_WCLOCKS
int       ceu_sys_wclock (tceu_app* app, s32 dt, s32* set, s32* get);
#endif
void      ceu_sys_go     (tceu_app* app, int evt, void* evtp);

#ifdef CEU_OS

/* TCEU_LINK */

typedef struct tceu_lnk {
    tceu_app* src_app;
    tceu_nevt src_evt;
    tceu_app* dst_app;
    tceu_nevt dst_evt;
    struct tceu_lnk* nxt;
} tceu_lnk;

/* TCEU_QUEUE */

typedef struct {
    tceu_app* app;
    tceu_nevt evt;
#if CEU_QUEUE_MAX == 256
    s8        sz;
#else
    s16       sz;   /* signed because of fill */
#endif
    byte      buf[0];
} tceu_queue;

#ifdef CEU_ISR
typedef void(*tceu_isr_f)(tceu_app* app, tceu_org* org);
#endif

void ceu_os_init      (void);
int  ceu_os_scheduler (int(*dt)());
tceu_queue* ceu_sys_queue_nxt (void);
void        ceu_sys_queue_rem (void);

void      ceu_sys_assert    (int v);
void      ceu_sys_log       (int mode, long str);
void*     ceu_sys_realloc   (void* ptr, size_t size);
int       ceu_sys_req       (void);
tceu_app* ceu_sys_load      (void* addr);
#ifdef CEU_ISR
int       ceu_sys_isr       (int n, tceu_isr_f f, tceu_app* app);
#endif
void      ceu_sys_org_init  (tceu_org* org, int n, int lbl, int cls, int isDyn,
                             tceu_org* parent_org, tceu_ntrl parent_trl);
void      ceu_sys_start     (tceu_app* app);
int       ceu_sys_link      (tceu_app* src_app, tceu_nevt src_evt, tceu_app* dst_app, tceu_nevt dst_evt);
int       ceu_sys_unlink    (tceu_app* src_app, tceu_nevt src_evt, tceu_app* dst_app, tceu_nevt dst_evt);
int       ceu_sys_emit      (tceu_app* app, tceu_nevt evt, int sz, void* param);
void*     ceu_sys_call      (tceu_app* app, tceu_nevt evt, void* param);

enum {
    CEU_SYS_ASSERT = 0,
    CEU_SYS_LOG,
    CEU_SYS_REALLOC,
    CEU_SYS_REQ,
    CEU_SYS_LOAD,
#ifdef CEU_ISR
    CEU_SYS_ISR,
#endif
#ifdef CEU_CLEAR
    CEU_SYS_CLEAR,
#endif
    CEU_SYS_STACK_PUSH,
#ifdef CEU_ORGS
    CEU_SYS_STACK_CLEAR_ORG,
#endif
    CEU_SYS_ORG,
#ifdef CEU_ORGS
    CEU_SYS_ORG_TRAIL,
    CEU_SYS_ORG_SPAWN,
#endif
    CEU_SYS_START,
    CEU_SYS_LINK,
    CEU_SYS_UNLINK,
    CEU_SYS_EMIT,
    CEU_SYS_CALL,
#ifdef CEU_WCLOCKS
    CEU_SYS_WCLOCK,
#endif
    CEU_SYS_GO,
    CEU_SYS_MAX
};

/* SYS_VECTOR
 */
extern void* CEU_SYS_VEC[CEU_SYS_MAX];

#endif  /* CEU_OS */

#endif  /* _CEU_OS_H */


typedef struct {
    int   max;
    int   nxt;
    int   unit;
    byte* mem;
} tceu_vector;

#define CEU_VECTOR_DCL(name, type, max)  \
    type        name##_mem[max+1];       \
    tceu_vector name;
                /* [STRING] max+1: extra space for '\0' */

#define ceu_vector_getlen(vec) ((vec)->nxt)
#define ceu_vector_getmax(vec) ((vec)->max > 0 ? (vec)->max : 0)

void  ceu_vector_init   (tceu_vector* vector, int max, int unit, byte* mem);
int   ceu_vector_setlen (tceu_vector* vector, int len);
byte* ceu_vector_geti   (tceu_vector* vector, int idx);
int   ceu_vector_seti   (tceu_vector* vector, int idx, byte* v);
int   ceu_vector_push   (tceu_vector* vector, byte* v);
int   ceu_vector_concat (tceu_vector* to, tceu_vector* fr);
int   ceu_vector_concat_buffer (tceu_vector* to, const char* fr, int n);
char* ceu_vector_tochar (tceu_vector* vector);

#if 0
byte* ceu_pool_alloc (tceu_pool* pool);
void ceu_pool_free (tceu_pool* pool, byte* val);
#endif
#endif

#ifndef _CEU_VECTOR_C
#define _CEU_VECTOR_C



void ceu_vector_init (tceu_vector* vector, int max, int unit, byte* mem) {
    vector->nxt  = 0;
    vector->max  = max;
    vector->unit = unit;
    vector->mem  = (max==0) ? NULL : mem;

    /* [STRING] */
    if (vector->mem != NULL) {
        vector->mem[0] = '\0';
    }
}

#ifdef CEU_VECTOR_MALLOC
static void* ceu_vector_resize (tceu_vector* vector, int n) {
    ceu_out_assert_msg(vector->max <= 0, "bug found");

    if (n == 0) {
        /* free */
        if (vector->mem != NULL) {
            vector->max = 0;
            ceu_out_realloc(vector->mem, 0);
            vector->mem = NULL;
        }
    } else {
        /* TODO: Java does the same? */
        n = (n*3/2) + 1;
        if (n < 10) {
            n = 10;
        }

        vector->max = -n;
        vector->mem = (byte*)ceu_out_realloc(vector->mem, n*vector->unit + 1);
                                                        /* [STRING] +1 */
    }

    return vector->mem;
}
#endif

/* can only decrease vector->nxt */
int ceu_vector_setlen (tceu_vector* vector, int nxt) {
    if (nxt > vector->nxt) {
        return 0;
    } else {
        vector->nxt = nxt;

        /* [STRING] */
        if (vector->mem != NULL) {
            vector->mem[nxt*vector->unit] = '\0';
        }

#ifdef CEU_VECTOR_MALLOC
        /* shrink malloc'ed arrays */
        if (vector->max <= 0) {
            if (ceu_vector_resize(vector,nxt)==NULL && nxt>0) {
                return 0;
            }
        }
#endif

        return 1;
    }
}

/* can only get within idx < vector->nxt */
byte* ceu_vector_geti (tceu_vector* vector, int idx) {
    if (idx >= vector->nxt) {
        return NULL;
    } else {
        return &vector->mem[idx*vector->unit];
    }
}

/* can only set within idx < vector->nxt */
int ceu_vector_seti (tceu_vector* vector, int idx, byte* v) {
    if (idx >= vector->nxt) {
        return 0;
    } else {
        memcpy(&vector->mem[idx*vector->unit], v, vector->unit);
        return 1;
    }
}

/* can only push within nxt < vector->max */
int ceu_vector_push (tceu_vector* vector, byte* v) {
#ifdef CEU_VECTOR_MALLOC
    /* grow malloc'ed arrays */
    if (vector->max <= 0) {
        while (vector->nxt >= -vector->max) {
            if (ceu_vector_resize(vector,vector->nxt+1) == NULL) {
                return 0;
            }
        }
    }
#endif
#ifdef CEU_VECTOR_MALLOC
#ifdef CEU_VECTOR_POOL
    else
#endif
#endif
#ifdef CEU_VECTOR_POOL
    if (vector->nxt >= vector->max) {
        return 0;
    }
#endif

    memcpy(&vector->mem[vector->nxt*vector->unit], v, vector->unit);
    vector->nxt++;
    vector->mem[vector->nxt*vector->unit] = '\0';    /* [STRING] */
    return 1;
}

int ceu_vector_concat (tceu_vector* to, tceu_vector* fr) {
    if (to == fr) {
        return 0;
    } else {
        /* TODO: memcpy */
        int i;
        for (i=0; i<fr->nxt; i++) {
            byte* v = ceu_vector_geti(fr, i);
            if (v == NULL) {
                return 0;
            } else if (!ceu_vector_push(to,v)) {
                return 0;
            }
        }
    }
    return 1;
}

int ceu_vector_concat_buffer (tceu_vector* to, const char* fr, int n) {
    /* TODO: memcpy */
    int i;
    for (i=0; i<n; i++) {
        if (!ceu_vector_push(to,(byte*)&fr[i])) {
            return 0;
        }
    }
    return 1;
}

char* ceu_vector_tochar (tceu_vector* vector) {
    if (vector->mem == NULL) {
        return "";
    } else {
        return (char*)vector->mem;
    }
}

#endif

byte* ceu_vector_geti_ex (tceu_vector* vector, int idx, char* file, int line) {
    byte* ret = ceu_vector_geti(vector, idx);
    ceu_out_assert_msg_ex(ret!=NULL, "access out of bounds", file, line);
    return ret;
}
#endif

int CEU_REQS = 0;
int ceu_sys_req (void) {
    CEU_REQS++;
    return CEU_REQS;
}

void ceu_sys_go_ex (tceu_app* app, tceu_evt* evt,
                    tceu_stk* stk,
                    tceu_org* org, tceu_trl* trl, void* stop);

/**********************************************************************/

void ceu_sys_org_init (tceu_org* org, int n, int lbl,
                       int cls, int isDyn,
                       tceu_org* parent_org, tceu_ntrl parent_trl)
{
    /* { evt=0, seqno=0, lbl=0 } for all trails */
    memset(&org->trls, 0, n*sizeof(tceu_trl));
    org->trls[0].lbl = lbl;

#if defined(CEU_ORGS) || defined(CEU_OS_KERNEL)
    org->n  = n;
#endif

#ifdef CEU_ORGS

#ifdef CEU_IFCS
    org->cls = cls;
#endif

#if defined(CEU_ORGS_NEWS) || defined(CEU_ORGS_AWAIT)
    org->isAlive = 1;
#endif

#ifdef CEU_ORGS_NEWS
    org->isDyn = isDyn;
#endif

    org->parent_org = parent_org;
    org->parent_trl = parent_trl;
    org->nxt = NULL;
    if (parent_org != NULL) {
        tceu_trl* trl = &parent_org->trls[parent_trl];
        if (trl == NULL) {
            org->prv = NULL; /* main class */
        } else {
            /* re-link */
            if (trl->org == NULL) {
                trl->org = org;
            } else {
                tceu_org* last = trl->org->prv;
                last->nxt = org;
                org->prv = last;
            }
            trl->org->prv = org;
        }
    }

#ifdef CEU_ORGS_AWAIT
    org->ret = 0;   /* TODO: still required? */
#endif

#endif  /* CEU_ORGS */
}

#ifdef CEU_ORGS

static void ceu_sys_org_free (tceu_app* app, tceu_org* org)
{
    /* TODO: try to not depend on this and remove this field */
    if (org->isAlive) {
        org->isAlive = 0;
    } else {
        return;
    }

    /* re-link PRV <-> NXT */
    /* relink also static orgs for efficiency */
    tceu_trl* trl = &org->parent_org->trls[org->parent_trl];
    if (trl->org == org) {
        trl->org = org->nxt;        /* subst 1st org */
    } else {
        org->prv->nxt = org->nxt;
    }
    if (org->nxt == NULL) {
        if (trl->org != NULL) {
            trl->org->prv = org->prv;   /* subst lst org */
        }
    } else {
        org->nxt->prv = org->prv;
    }

#ifdef CEU_ORGS_NEWS
    /* free */
    if (org->isDyn) {
#if    defined(CEU_ORGS_NEWS_POOL) && !defined(CEU_ORGS_NEWS_MALLOC)
        ceu_pool_free(&org->pool->pool, (byte*)org);
#elif  defined(CEU_ORGS_NEWS_POOL) &&  defined(CEU_ORGS_NEWS_MALLOC)
        if (org->pool->pool.queue == NULL) {
            org->nxt = app->tofree;
            app->tofree = org;
        } else {
            ceu_pool_free(&org->pool->pool, (byte*)org);
        }
#elif !defined(CEU_ORGS_NEWS_POOL) &&  defined(CEU_ORGS_NEWS_MALLOC)
        org->nxt = app->tofree;
        app->tofree = org;
#endif
    }
#endif
}

#endif  /* CEU_ORGS */

/**********************************************************************/

#ifdef CEU_STACK
void ceu_stack_dump (tceu_app* app) {
    tceu_stk* cur;
    printf(">>> STACK DUMP:\n");
    for (cur=app->stk_bottom; cur!=NULL; cur=cur->up) {
        printf("\t[%p] up=%p org=%p trls=[%d,%d]\n",
            cur, cur->up, cur->org, cur->trl1, cur->trl2);
    }
}
#endif

/*
 * Checks if "me" is cleared due to a clear in "clr_org".
 * ;
 */
#ifdef CEU_ORGS
static int ceu_org_is_cleared (void* me, void* clr_org,
                               tceu_ntrl clr_t1, tceu_ntrl clr_t2)
{
    tceu_org* cur_org;
    for (cur_org=me; cur_org!=NULL; cur_org=cur_org->parent_org) {
        if (cur_org->parent_org == clr_org) {
            if (cur_org->parent_trl>=clr_t1 && cur_org->parent_trl<=clr_t2) {
                return 1;
            }
        }
    }
    return 0;
}
#endif

/*
 * Trails [t1,t2] of "org" are dyeing.
 * Traverse the stack to see if a pending call is enclosed by this range.
 * If so, the whole stack has to unwind and continue from what we pass in 
 * lbl_or_org.
 */
void ceu_longjmp (tceu_app* app, tceu_org* org,
                  tceu_ntrl t1, tceu_ntrl t2) {
    tceu_stk* cur;
    tceu_stk* prv;
    for (prv=app->stk_bottom, cur=app->stk_bottom->up;
         cur != NULL;
         prv=cur,cur=cur->up)
    {
#ifdef CEU_ORGS
        if (cur->org != org) {
            if (ceu_org_is_cleared(cur->org, org, t1, t2)) {
                prv->up = NULL;
                longjmp(cur->jmp, 1);
            }
        }
        else
#endif
        {
            if (t1<=cur->trl1 && cur->trl2<=t2) {
                prv->up = NULL;
                longjmp(cur->jmp, 1);
            }
        }
    }
}

/**********************************************************************/

#ifdef CEU_WCLOCKS

/* TODO: wclk_min_cmp to be global among all apps */

int ceu_sys_wclock (tceu_app* app, s32 dt, s32* set, s32* get)
{
    s32 t;          /* expiring time of track to calculate */
    int ret = 0;    /* if track expired (only for "get") */

    /* SET */
    if (set != NULL) {
        t = dt - app->wclk_late;
        *set = t;

    /* CHECK */
    } else {
        t = *get;
        if ((t > app->wclk_min_cmp) || (t > dt)) {
            *get -= dt;    /* don't expire yet */
            t = *get;
        } else {
            ret = 1;    /* single "true" return */
        }
    }

    /* didn't awake, but can be the smallest wclk */
    if ( (!ret) && (app->wclk_min_set > t) ) {
        app->wclk_min_set = t;
#ifdef ceu_out_wclock_set
        ceu_out_wclock_set(t);
#endif
    }

    return ret;
}

#ifdef CEU_TIMEMACHINE
/* TODO: unify with above */
int ceu_sys_wclock_ (tceu_app* app, s32 dt, s32* set, s32* get)
{
    s32 t;          /* expiring time of track to calculate */
    int ret = 0;    /* if track expired (only for "get") */

    /* SET */
    if (set != NULL) {
        t = dt - app->wclk_late;
        *set = t;

    /* CHECK */
    } else {
        t = *get;
        if ((t > app->wclk_min_cmp_) || (t > dt)) {
            *get -= dt;    /* don't expire yet */
            t = *get;
        } else {
            ret = 1;    /* single "true" return */
        }
    }

    /* didn't awake, but can be the smallest wclk */
    if ( (!ret) && (app->wclk_min_set_ > t) ) {
        app->wclk_min_set_ = t;
#ifdef ceu_out_wclock_set
        ceu_out_wclock_set(t);
#endif
    }

    return ret;
}
#endif

#endif

/**********************************************************************/

#ifdef CEU_LUA
int ceu_lua_atpanic_f (lua_State* lua) {
#ifdef CEU_DEBUG
    char msg[255] = "LUA_ATPANIC: ";
    strncat(msg, lua_tostring(lua,-1), 100);
    strncat(msg, "\n", 1);
    ceu_out_assert_msg(0, msg);
/*
*/
#else
    ceu_out_assert_msg(0, "bug found");
#endif
    return 0;
}
#endif

/**********************************************************************/

#ifdef CEU_PSES
#ifdef CEU_OS_KERNEL
#error Not implemented!
#endif
void ceu_pause (tceu_trl* trl, tceu_trl* trlF, int psed) {
    do {
        if (psed) {
            if (trl->evt == CEU_IN__ORG) {
                trl->evt = CEU_IN__ORG_PSED;
            }
        } else {
            if (trl->evt == CEU_IN__ORG_PSED) {
                trl->evt = CEU_IN__ORG;
            }
        }
        if ( trl->evt == CEU_IN__ORG
        ||   trl->evt == CEU_IN__ORG_PSED ) {
            trl += 2;       /* jump [fst|lst] */
        }
    } while (++trl <= trlF);

#ifdef ceu_out_wclock_set
    if (!psed) {
        ceu_out_wclock_set(0);  /* TODO: recalculate MIN clock */
                                /*       between trl => trlF   */
    }
#endif
#ifdef CEU_TIMEMACHINE
#ifdef ceu_out_wclock_set_
    if (!psed) {
        ceu_out_wclock_set_(0);  /* TODO: recalculate MIN clock */
                                 /*       between trl => trlF   */
    }
#endif
#endif
}
#endif

/**********************************************************************/

#ifdef CEU_OS_KERNEL
u8 CEU_GC = 0;  /* execute __ceu_os_gc() when "true" */
#endif

#ifdef CEU_DEBUG_TRAILS
static int spc = -1;
#define SPC(n) { int i; for(i=0; i<(spc+n)*4; i++) printf(" "); };

void ceu_sys_go_ex_dbg (tceu_app* app, tceu_evt* evt,
                        tceu_stk* stk,
                        tceu_org* org, tceu_trl* trl, void* stop);
void ceu_sys_go_ex (tceu_app* app, tceu_evt* evt,
                    tceu_stk* stk,
                    tceu_org* org, tceu_trl* trl, void* stop) {
    spc++;
    SPC(0); printf(">>> GO-EX\n");
    SPC(0); printf("evt: %d\n", evt->id);
    #ifdef CEU_ORGS
    SPC(0); printf("org: %p\n", org);
    SPC(2); printf("[%p]=>[%p]\n", &org->trls[0],
                                   &org->trls[org->n]);
    #endif

    ceu_sys_go_ex_dbg(app,evt,stk,org,trl,stop);

    SPC(0); printf("<<< GO-EX\n");
    spc--;
}
#endif

#ifdef CEU_DEBUG_TRAILS
void ceu_sys_go_ex_dbg (tceu_app* app, tceu_evt* evt,
                        tceu_stk* stk,
                        tceu_org* org, tceu_trl* trl, void* stop)
#else
void ceu_sys_go_ex (tceu_app* app, tceu_evt* evt,
                    tceu_stk* stk,
                    tceu_org* org, tceu_trl* trl, void* stop)
    /* TODO: now all arguments are required in all configurations */
#endif
{
    for (;; trl++)
    {
#ifdef CEU_CLEAR
        if (trl == stop) {
            return;    /* bounded trail traversal */
        }
#endif

        /* STK_ORG has been traversed to the end? */
        if (trl ==
            &org->trls[
#if defined(CEU_ORGS) || defined(CEU_OS_KERNEL)
                org->n
#else
                CEU_NTRAILS
#endif
            ])
        {
#ifdef CEU_ORGS
            /* clearing the whole org (stop==NULL)? */
            if (org!=app->data && evt->id==CEU_IN__CLEAR && stop==NULL) {
                /* yes, relink and put it in the free list */
                ceu_sys_org_free(app, org);
#ifdef CEU_ORGS_AWAIT
#ifdef CEU_ORGS_NEWS_MALLOC
                if (!app->dont_emit_kill)
#endif
                {
                    /* signal ok_killed */
                    {
                        tceu_kill ps = { org, org->ret };
                        tceu_evt evt_;
                                 evt_.id = CEU_IN__ok_killed;
                                 evt_.param = &ps;
                        ceu_sys_go_ex(app, &evt_,
                                      stk,
                                      app->data, &app->data->trls[0], NULL);
                    }
                }
#endif
            }
#endif
            break;
        }

#ifdef CEU_DEBUG_TRAILS
SPC(1); printf("trl: %p\n", trl);
/*SPC(2); printf("seqno: %d\n", trl->seqno);*/
SPC(2); printf("evt: %d\n", trl->evt);
SPC(2); printf("lbl: %d\n", trl->lbl);
#endif

        /* continue traversing current org */

        /* jump into linked orgs */
#ifdef CEU_ORGS
        if ( (trl->evt == CEU_IN__ORG)
#ifdef CEU_PSES
          || (trl->evt==CEU_IN__ORG_PSED && evt->id==CEU_IN__CLEAR)
#endif
           )
        {
            tceu_org* cur = trl->org;

            if (evt->id == CEU_IN__CLEAR) {
                trl->evt = CEU_IN__NONE;    /* TODO: dup w/ below */
            }

            /* traverse all children */

            if (cur != NULL) {
                tceu_stk stk_ = { NULL, org, cur->parent_trl, cur->parent_trl, {} };

#if defined(CEU_ORGS_NEWS_MALLOC) && defined(CEU_ORGS_AWAIT)
                /* In the presence of ok_killed events, we cannot simply
                 * interrupt children traversal during a IN__CLEAR, because it 
                 * might lead to memory leaks if not all children are travesed.
                 */
                tceu_org* nxt;
                int has_aborted = 0;            /* normal execution */
                if (setjmp(stk_.jmp) != 0) {
                    has_aborted = 1;            /* detected abortion */
                    if (evt->id==CEU_IN__CLEAR) {
                        cur = nxt;              /* continue from nxt */
                        app->dont_emit_kill = 1;/* but stop emitting ok_killed */
                    } else {
                        cur = NULL;             /* safe to abort now */
                    }
                }
#else
                if (setjmp(stk_.jmp) != 0) {
                    app->stk_jmp.trl->lbl = app->stk_jmp.lbl;
                    app->code(app, evt, app->stk_jmp.org, app->stk_jmp.trl, stk);
                    return;
                }
#endif

                /* SETJMP: traversing children
                 * A child might emit a global event that awakes a par/or 
                 * enclosing the parent organism with the call point.
                 */
                stk->up = &stk_;
                while (cur != NULL) {
#if defined(CEU_ORGS_NEWS_MALLOC) && defined(CEU_ORGS_AWAIT)
#else
                    tceu_org*
#endif
                    nxt = cur->nxt;
                        /* save "nxt" before the call, which might kill "cur"
                         * and reset "nxt" for the freelist */
                    ceu_sys_go_ex(app, evt,
                                  &stk_,
                                  cur, &cur->trls[0], NULL);
                    cur = nxt;
                }
                stk->up = NULL;

#if defined(CEU_ORGS_NEWS_MALLOC) && defined(CEU_ORGS_AWAIT)
                if (has_aborted) {
                    app->dont_emit_kill = 0;
                    app->stk_jmp.trl->lbl = app->stk_jmp.lbl;
                    app->code(app, evt, app->stk_jmp.org, app->stk_jmp.trl, stk);
                    return;
                }
#endif
            }
            continue;   /* next trail after handling children */
        }
#endif /* CEU_ORGS */

        /* EXECUTE THIS TRAIL */
#if 0
printf("%d==%d && %d!=%d && %d>=%d\n",
        trl->evt, evt->id,
        trl->seqno, app->seqno,
        evt->id, CEU_IN_lower
);
if (evt->param != NULL) {
    printf("trl->org_or_adt=%p // param=%p\n", trl->org_or_adt,
                 ((tceu_kill*)evt->param)->org_or_adt);
}
#endif

        if (
#ifdef CEU_CLEAR
            /* if IN__CLEAR and "finalize" clause */
            (evt->id==CEU_IN__CLEAR && trl->evt==CEU_IN__CLEAR)
        ||
#endif
#ifdef CEU_ORGS_OR_ADTS_AWAIT
            /* if */
            (evt->id==CEU_IN__ok_killed && trl->evt==CEU_IN__ok_killed &&
                (trl->org_or_adt == NULL || /* for option ptrs, init'd w/ NULL  */
                 trl->org_or_adt == ((tceu_kill*)evt->param)->org_or_adt))
        ||
#endif
            /* if evt->id matches awaiting trail */
            (trl->evt==evt->id && trl->seqno!=app->seqno
#ifdef CEU_ORGS_OR_ADTS_AWAIT
                && (evt->id != CEU_IN__ok_killed)
                    /* TODO: simplify */
#endif
#ifdef CEU_INTS
#ifdef CEU_ORGS
                && (evt->id>=CEU_IN_lower || evt->org==trl->evto)
#endif
#endif
            )
           )
        {
#if defined(CEU_OS_KERNEL) && defined(__AVR)
            CEU_APP_ADDR = app->addr;
#endif

            /*** CODE ***/
            trl->evt = CEU_IN__NONE;    /* TODO: dup w/ above */
            app->code(app, evt, org, trl, stk);

#if defined(CEU_OS_KERNEL) && defined(__AVR)
            CEU_APP_ADDR = 0;
#endif

#if defined(CEU_OS_KERNEL) || defined(CEU_LUA)
            if (!app->isAlive) {
#ifdef CEU_OS_KERNEL
                CEU_GC = 1;
#endif
#ifdef CEU_LUA
                lua_close(app->lua);
#endif
            }
#endif
        }

        /* DON'T EXECUTE THIS TRAIL */
        else
        {
#ifdef CEU_DEBUG_TRAILS
SPC(1); printf("<<< NO\n");
#endif
#ifdef CEU_CLEAR
            if (evt->id==CEU_IN__CLEAR) {
                trl->evt = CEU_IN__NONE;    /* TODO: dup w/ above */
            }
#endif
        }

        /* NEXT TRAIL */

        if (trl->evt<=CEU_IN_higher && trl->seqno!=app->seqno) {
            trl->seqno = app->seqno-1;   /* keeps the gap tight */
        }
    }
}

void ceu_sys_go_stk (tceu_app* app, int evt, void* evtp, tceu_stk* stk) {
    app->seqno++;
#ifdef CEU_DEBUG_TRAILS
    printf("===> [%d] %d\n", evt, app->seqno);
#endif

    switch (evt) {
#ifdef CEU_ASYNCS
        case CEU_IN__ASYNC:
            app->pendingAsyncs = 0;
            break;
#endif
#ifdef CEU_WCLOCKS
        case CEU_IN__WCLOCK:
            app->wclk_min_cmp = app->wclk_min_set;      /* swap "cmp" to last "set" */
            app->wclk_min_set = CEU_WCLOCK_INACTIVE;    /* new "set" resets to inactive */
            if (app->wclk_min_cmp <= *((s32*)evtp)) {
                app->wclk_late = *((s32*)evtp) - app->wclk_min_cmp;
            }
            break;
#ifdef CEU_TIMEMACHINE
        case CEU_IN__WCLOCK_:
            app->wclk_min_cmp_ = app->wclk_min_set_;
            app->wclk_min_set_ = CEU_WCLOCK_INACTIVE;
            if (app->wclk_min_cmp_ <= *((s32*)evtp)) {
                app->wclk_late_ = *((s32*)evtp) - app->wclk_min_cmp_;
            }
            break;
#endif
#endif
    }

    {
        tceu_evt evt_;
                 evt_.id = evt;
                 evt_.param = &evtp;
        ceu_sys_go_ex(app, &evt_,
                      stk,
                      app->data, &app->data->trls[0], NULL);
    }

#ifdef CEU_WCLOCKS
    if (evt==CEU_IN__WCLOCK) {
#ifdef ceu_out_wclock_set
        /* no new sets, signal inactive */
        if (app->wclk_min_set == CEU_WCLOCK_INACTIVE) {
            ceu_out_wclock_set(CEU_WCLOCK_INACTIVE);
        }
#endif
        app->wclk_late = 0;
    }
#ifdef CEU_TIMEMACHINE
    if (evt==CEU_IN__WCLOCK_) {
#ifdef ceu_out_wclock_set
        if (app->wclk_min_set_ == CEU_WCLOCK_INACTIVE) {
            ceu_out_wclock_set(CEU_WCLOCK_INACTIVE);
        }
#endif
        app->wclk_late_ = 0;
    }
#endif
#endif

#ifdef CEU_ORGS_NEWS_MALLOC
    while (app->tofree != NULL) {
        tceu_org* nxt = app->tofree->nxt;
        ceu_sys_realloc(app->tofree, 0);
        app->tofree = nxt;
    }
#endif
}

void ceu_sys_go (tceu_app* app, int evt, void* evtp)
{
    tceu_stk stk_ = { NULL, NULL, 0, 0, {} };
    app->stk_bottom = &stk_;
    ceu_sys_go_stk(app, evt, evtp, &stk_);
}

int ceu_go_all (tceu_app* app)
{
    /* All code run atomically:
     * - the program is always locked as a whole
     * -    thread spawns will unlock => re-lock
     * - but program will still run to completion
     */
    app->init(app);     /* calls CEU_THREADS_MUTEX_LOCK() */

#ifdef CEU_IN_OS_START
#if defined(CEU_RET) || defined(CEU_OS_KERNEL)
    if (app->isAlive)
#endif
    {
        ceu_sys_go(app, CEU_IN_OS_START, NULL);
    }
#endif

#ifdef CEU_ASYNCS
    while(
#if defined(CEU_RET) || defined(CEU_OS_KERNEL)
            app->isAlive &&
#endif
            (
#ifdef CEU_THREADS
                app->threads_n>0 ||
#endif
                app->pendingAsyncs
            ) )
    {
        ceu_sys_go(app, CEU_IN__ASYNC, NULL);
#ifdef CEU_THREADS
        CEU_THREADS_MUTEX_UNLOCK(&app->threads_mutex);
        /* allow threads to also execute */
        CEU_THREADS_MUTEX_LOCK(&app->threads_mutex);
#endif
    }
#endif

#ifdef CEU_THREADS
    CEU_THREADS_MUTEX_UNLOCK(&app->threads_mutex);
#endif

#ifdef CEU_NEWS
#ifdef CEU_RUNTESTS
    ceu_out_assert_msg(_ceu_dyns_ == 0, "memory leak");
#endif
#endif

#ifdef CEU_RET
    return app->ret;
#else
    return 0;
#endif
}

/**********************************************************************
 * Only the OS kernel needs any of the below.
 **********************************************************************/

#ifdef CEU_OS_KERNEL

/*
 * SYS_VECTOR:
 */
void* CEU_SYS_VEC[CEU_SYS_MAX] __attribute__((used)) = {
    (void*) &ceu_out_assert,
    (void*) &ceu_out_log,
    (void*) &ceu_sys_realloc,
    (void*) &ceu_sys_req,
    (void*) &ceu_sys_load,
#ifdef CEU_ISR
    (void*) &ceu_sys_isr,
#endif
    (void*) &ceu_sys_org_init,
    (void*) &ceu_sys_start,
    (void*) &ceu_sys_link,
    (void*) &ceu_sys_unlink,
    (void*) &ceu_sys_emit,
    (void*) &ceu_sys_call,
#ifdef CEU_WCLOCKS
    (void*) &ceu_sys_wclock,
#endif
    (void*) &ceu_sys_go
};

/*****************************************************************************
 * QUEUE
 * - 256 avoids doing modulo operations
 * - n: number of entries
 * - 0: next position to consume
 * - i: next position to enqueue
 */
#if CEU_QUEUE_MAX == 256
    byte QUEUE[CEU_QUEUE_MAX] = {0};    /* {0} avoids .bss */
    int  QUEUE_tot = 0;
    u8   QUEUE_get = 0;
    u8   QUEUE_put = 0;
#else
    byte QUEUE[CEU_QUEUE_MAX] = {0};    /* {0} avoids .bss */
    int  QUEUE_tot = 0;
    u16  QUEUE_get = 0;
    u16  QUEUE_put = 0;
#endif

tceu_queue* ceu_sys_queue_get (void) {
    tceu_queue* ret;
    CEU_ISR_OFF();
    if (QUEUE_tot == 0) {
        ret = NULL;
    } else {
#ifdef CEU_DEBUG
        ceu_sys_assert(QUEUE_tot > 0);
#endif
        ret = (tceu_queue*) &QUEUE[QUEUE_get];
    }
    CEU_ISR_ON();
    return ret;
}

int ceu_sys_queue_put (tceu_app* app, tceu_nevt evt, int sz, byte* buf) {
    CEU_ISR_OFF();

    int n = sizeof(tceu_queue) + sz;

    if (QUEUE_tot+n > CEU_QUEUE_MAX) {
        return 0;   /* TODO: add event FULL when CEU_QUEUE_MAX-1 */
    }

    /* An event+data must be continuous in the QUEUE. */
    if (QUEUE_put+n+sizeof(tceu_queue)>=CEU_QUEUE_MAX && evt!=CEU_IN__NONE) {
        int fill = CEU_QUEUE_MAX - QUEUE_put - sizeof(tceu_queue);
        /*_ceu_sys_emit(app, CEU_IN__NONE, param, fill, NULL);*/
        tceu_queue* qu = (tceu_queue*) &QUEUE[QUEUE_put];
        qu->app = app;
        qu->evt = CEU_IN__NONE;
        qu->sz  = fill;
        QUEUE_put += sizeof(tceu_queue) + fill;
        QUEUE_tot += sizeof(tceu_queue) + fill;
    }

    {
        tceu_queue* qu = (tceu_queue*) &QUEUE[QUEUE_put];
        qu->app = app;
        qu->evt = evt;
        qu->sz  = sz;
        memcpy(qu->buf, buf, sz);
    }
    QUEUE_put += n;
    QUEUE_tot += n;

    CEU_ISR_ON();
    return 1;
}

void ceu_sys_queue_rem (void) {
    CEU_ISR_OFF();
    tceu_queue* qu = (tceu_queue*) &QUEUE[QUEUE_get];
    QUEUE_tot -= sizeof(tceu_queue) + qu->sz;
    QUEUE_get += sizeof(tceu_queue) + qu->sz;
    CEU_ISR_ON();
}

/*****************************************************************************/

static tceu_app* CEU_APPS = NULL;
static tceu_lnk* CEU_LNKS = NULL;

#ifdef CEU_RET
    int ok  = 0;
    int ret = 0;
#endif

/* TODO: remove this indirection */
int ceu_sys_emit (tceu_app* app, tceu_nevt evt, int sz, void* param) {
    return ceu_sys_queue_put(app, evt, sz, param);
}

void* ceu_sys_call (tceu_app* app, tceu_nevt evt, void* param) {
    tceu_lnk* lnk = CEU_LNKS;
    for (; lnk; lnk=lnk->nxt)
    {
        if (app!=lnk->src_app || evt!=lnk->src_evt) {
            continue;
        }
#if defined(CEU_OS_KERNEL) && defined(__AVR)
        void* __old = CEU_APP_ADDR; /* must remember to resume after call */
        CEU_APP_ADDR = lnk->dst_app->addr;
#endif
        void* ret = lnk->dst_app->calls(lnk->dst_app, lnk->dst_evt, param);
#if defined(CEU_OS_KERNEL) && defined(__AVR)
        CEU_APP_ADDR = __old;
#endif
        return ret;
    }
/* TODO: error? */
    return NULL;
}

static void _ceu_sys_unlink (tceu_lnk* lnk) {
    /* remove as head */
    if (CEU_LNKS == lnk) {
        CEU_LNKS = lnk->nxt;
/* TODO: prv */
    /* remove in the middle */
    } else {
        tceu_lnk* cur = CEU_LNKS;
        while (cur->nxt!=NULL && cur->nxt!=lnk) {
			cur = cur->nxt;
        }
        if (cur->nxt != NULL) {
            cur->nxt = lnk->nxt;
        }
	}

    /*lnk->nxt = NULL;*/
    ceu_sys_realloc(lnk, 0);
}

static void __ceu_os_gc (void)
{
    if (! CEU_GC) return;
    CEU_GC = 0;

    /* remove pending events */
    {
        CEU_ISR_OFF();
        int i = 0;
        while (i < QUEUE_tot) {
            tceu_queue* qu = (tceu_queue*) &QUEUE[QUEUE_get+i];
            if (qu->app!=NULL && !qu->app->isAlive) {
                qu->evt = CEU_IN__NONE;
            }
            i += sizeof(tceu_queue) + qu->sz;
        }
        CEU_ISR_ON();
    }

    /* remove broken links */
    {
        tceu_lnk* cur = CEU_LNKS;
        while (cur != NULL) {
            tceu_lnk* nxt = cur->nxt;
            if (!cur->src_app->isAlive || !cur->dst_app->isAlive) {
                _ceu_sys_unlink(cur);
            }
            cur = nxt;
        }
    }

    /* remove dead apps */
    tceu_app* app = CEU_APPS;
    tceu_app* prv = NULL;
    while (app)
    {
        tceu_app* nxt = app->nxt;

        if (app->isAlive) {
            prv = app;

        } else {
            if (CEU_APPS == app) {
                CEU_APPS = nxt;     /* remove as head */
            } else {
                prv->nxt = nxt;     /* remove in the middle */
            }

            /* unlink all "from app" or "to app" */
            ceu_sys_unlink(app,0, 0,0);
            ceu_sys_unlink(0,0, app,0);

#ifdef CEU_RET
            ok--;
            ret += app->ret;
#endif

            /* free app memory */
            ceu_sys_realloc(app->data, 0);
            ceu_sys_realloc(app, 0);
        }

        app = nxt;
    }
}

#ifdef CEU_ISR

typedef struct {
    tceu_isr_f f;
    tceu_app*  app;
} tceu_isr;

#define CEU_ISR_MAX 40
tceu_isr CEU_ISR_VEC[CEU_ISR_MAX];

int ceu_sys_isr (int n, tceu_isr_f f, tceu_app* app) {
    tceu_isr* isr = &CEU_ISR_VEC[(n-1)];
    if (f==NULL || isr->f==NULL) {
        isr->f   = ((word)app->addr>>1) + f;
        isr->app = app;
                           /* "f" is relative to "app", make it absolute */
        return 1;
    } else {
        return 0;
    }
}
#endif

void ceu_os_init (void) {
#ifdef CEU_ISR
    int i;
    for (i=0; i<CEU_ISR_MAX; i++) {
        CEU_ISR_VEC[i].f = NULL;      /* TODO: is this required? (bss=0) */
    }
    CEU_ISR_ON();       /* enable global interrupts to start */
#endif
}

int ceu_os_scheduler (int(*dt)())
{
    /*
     * Intercalate DT->WCLOCK->ASYNC->QUEUE->...
     * QUEUE last to separate app->init() from OS_START.
     * QUEUE handles one event at a time to intercalate with WCLOCK.
     * __ceu_os_gc() only if QUEUE is emtpy: has to keep data from events 
     * accessible.
     */

#ifdef CEU_RET
    while (ok > 0)
#else
    while (1)
#endif
    {
#if defined(CEU_WCLOCKS) || defined(CEU_IN_OS_DT)
        s32 _dt = dt();
#endif

        /* DT */
#ifdef CEU_IN_OS_DT
        {
            tceu_app* app = CEU_APPS;
            while (app) {
                ceu_sys_go(app, CEU_IN_OS_DT, &dt);
                app = app->nxt;
            }
        }
#endif	/* CEU_IN_OS_DT */

        /* WCLOCK */
#ifdef CEU_WCLOCKS
        {
            tceu_app* app = CEU_APPS;
            while (app) {
/*
#error TODO: CEU_IN__WCLOCK_
*/
                ceu_sys_go(app, CEU_IN__WCLOCK, &_dt);
                app = app->nxt;
            }
        }
#endif	/* CEU_WCLOCKS */

        /* ASYNC */
#ifdef CEU_ASYNCS
        {
            tceu_app* app = CEU_APPS;
            while (app) {
                ceu_sys_go(app, CEU_IN__ASYNC, NULL);
                app = app->nxt;
            }
        }
#endif	/* CEU_ASYNCS */

        /* EVENTS */
        {
            /* clear the current size (ignore events emitted here) */
            CEU_ISR_OFF();
            int tot = QUEUE_tot;
            CEU_ISR_ON();
            if (tot > 0)
            {
                tceu_queue* qu = ceu_sys_queue_get();
                tot -= sizeof(tceu_queue) + qu->sz;
                if (qu->evt == CEU_IN__NONE) {
                    /* nothing; */
                    /* "fill event" */

                /* global events (e.g. OS_START, OS_INTERRUPT) */
                } else if (qu->app == NULL) {
                    tceu_app* app = CEU_APPS;
                    while (app) {
                        ceu_sys_go(app, qu->evt, qu->buf);
                        app = app->nxt;
                    }

                } else {
                    /* linked events */
                    tceu_lnk* lnk = CEU_LNKS;
                    while (lnk) {
                        if ( qu->app==lnk->src_app
                        &&   qu->evt==lnk->src_evt
                        &&   lnk->dst_app->isAlive ) {
                            ceu_sys_go(lnk->dst_app, lnk->dst_evt, qu->buf);
                        }
                        lnk = lnk->nxt;
                    }
                }

                ceu_sys_queue_rem();
            }
            else
            {
                __ceu_os_gc();     /* only when queue is empty */
            }
        }
    }

#ifdef CEU_RET
    return ret;
#else
    return 0;
#endif
}

/* LOAD / START */

tceu_app* ceu_sys_load (void* addr)
{
    uint       size;
    tceu_init* init;
#ifdef CEU_OS_LUAIFC
    char*      luaifc;
#endif

#ifdef __AVR
    ((tceu_export) ((word)addr>>1))(&size, &init);
#else
    ((tceu_export) addr)(&size, &init
#ifdef CEU_OS_LUAIFC
                        , &luaifc
#endif
                        );
#endif

    tceu_app* app = (tceu_app*) ceu_sys_realloc(NULL, sizeof(tceu_app));
    if (app == NULL) {
        return NULL;
    }

    app->data = (tceu_org*) ceu_sys_realloc(NULL, size);
    if (app->data == NULL) {
        return NULL;
    }

    app->sys_vec = CEU_SYS_VEC;
    app->nxt = NULL;

    /* Assumes sizeof(void*)==sizeof(WORD) and
        that gcc will word-align SIZE/INIT */
#ifdef __AVR
    app->init = (tceu_init) (((word)addr>>1) + (word)init);
#else
    app->init = (tceu_init) ((word)init);
#endif
    app->addr = addr;

#ifdef CEU_OS_LUAIFC
    app->luaifc = luaifc;
#endif

    return app;
}

void ceu_sys_start (tceu_app* app)
{
    /* add as head */
	if (CEU_APPS == NULL) {
		CEU_APPS = app;

    /* add to tail */
    } else {
		tceu_app* cur = CEU_APPS;
        while (cur->nxt != NULL) {
            cur = cur->nxt;
        }
        cur->nxt = app;
    }

    /* MAX OK */
#ifdef CEU_RET
    ok++;
#endif

    /* INIT */

    app->init(app);

    /* OS_START */

#ifdef CEU_IN_OS_START
    ceu_sys_emit(NULL, CEU_IN_OS_START, 0, NULL);
#endif
}

/* LINK & UNLINK */

int ceu_sys_link (tceu_app* src_app, tceu_nevt src_evt,
                  tceu_app* dst_app, tceu_nevt dst_evt)
{
    tceu_lnk* lnk = (tceu_lnk*) ceu_sys_realloc(NULL, sizeof(tceu_lnk));
    if (lnk == NULL) {
        return 0;
    }

    lnk->src_app = src_app;
    lnk->src_evt = src_evt;
    lnk->dst_app = dst_app;
    lnk->dst_evt = dst_evt;
    lnk->nxt = NULL;

    /* add as head */
	if (CEU_LNKS == NULL) {
		CEU_LNKS = lnk;

    /* add to tail */
    } else {
		tceu_lnk* cur = CEU_LNKS;
        while (cur->nxt != NULL) {
            cur = cur->nxt;
        }
		cur->nxt = lnk;
    }

    return 1;
}

int ceu_sys_unlink (tceu_app* src_app, tceu_nevt src_evt,
                    tceu_app* dst_app, tceu_nevt dst_evt)
{
    tceu_lnk* cur = CEU_LNKS;
    while (cur != NULL) {
        tceu_lnk* nxt = cur->nxt;
        if ( (src_app==0 || src_app==cur->src_app)
          && (src_evt==0 || src_evt==cur->src_evt)
          && (dst_app==0 || dst_app==cur->dst_app)
          && (dst_evt==0 || dst_evt==cur->dst_evt) ) {
            _ceu_sys_unlink(cur);
        }
        cur = nxt;
    }
    return 0;
}

#ifdef CEU_ISR

/* Foreach ISR, call ceu_sys_emit(CEU_IN_OS_INTERRUPT). */

#define GEN_ISR(n)                                                  \
    ISR(__vector_ ## n, ISR_BLOCK) {                                \
        tceu_isr* isr = &CEU_ISR_VEC[n-1];                          \
        if (isr->f != NULL) {                                       \
            CEU_APP_ADDR = isr->app->addr;                          \
            isr->f(isr->app, isr->app->data);                       \
            CEU_APP_ADDR = 0;                                       \
        }                                                           \
        ceu_sys_emit(NULL,CEU_IN_OS_INTERRUPT,CEU_EVTP(n),0,NULL); \
    }
#define _GEN_ISR(n)

GEN_ISR(20);
/*
GEN_ISR( 1) GEN_ISR( 2) GEN_ISR( 3) GEN_ISR( 4) GEN_ISR( 5)
GEN_ISR( 6) GEN_ISR( 7) GEN_ISR( 8) GEN_ISR( 9) GEN_ISR(10)
GEN_ISR(11) GEN_ISR(12) GEN_ISR(13) GEN_ISR(14) GEN_ISR(15)
GEN_ISR(16) GEN_ISR(17) _GEN_ISR(18) GEN_ISR(19) GEN_ISR(20)
GEN_ISR(21) GEN_ISR(22) GEN_ISR(23) GEN_ISR(24) GEN_ISR(25)
GEN_ISR(26) GEN_ISR(27) GEN_ISR(28) GEN_ISR(29) GEN_ISR(30)
GEN_ISR(31) GEN_ISR(32) GEN_ISR(33) GEN_ISR(34) GEN_ISR(35)
GEN_ISR(36) GEN_ISR(37) GEN_ISR(38) GEN_ISR(39) GEN_ISR(40)
*/

#endif /* CEU_ISR */

#endif /* ifdef CEU_OS_KERNEL */

#endif /* ifndef CEU_OS_APP */


#include <stdlib.h>
#ifdef CEU_DEBUG
#include <stdio.h>      /* printf */
#include <signal.h>     /* signal */
#endif
#ifdef CEU_RUNTESTS
#include <string.h>     /* memset */
#endif

#ifdef CEU_THREADS
#   define CEU_ATOMIC(f)                                      \
            CEU_THREADS_MUTEX_LOCK(&_ceu_app->threads_mutex); \
                f                                             \
            CEU_THREADS_MUTEX_UNLOCK(&_ceu_app->threads_mutex);
#else
#   define CEU_ATOMIC(f) f
#endif

#ifdef CEU_NEWS_POOL
#ifndef _CEU_POOL_H
#define _CEU_POOL_H

#include "ceu_types.h"

/* TODO: all "int" here, should evaluate the correct unsigned type */

typedef struct {
    byte**  queue;
                    /* queue is in the next offset to distinguish dynamic(NULL)
                       from static pools(any-address) */
    int     size;
    int     free;
    int     index;
    int     unit;
    byte*   mem;
} tceu_pool;

#define CEU_POOL_DCL(name, type, size) \
    type*     name##_queue[size];      \
    type      name##_mem[size];        \
    tceu_pool name;

void ceu_pool_init (tceu_pool* pool, int size, int unit, byte** queue, byte* mem);
byte* ceu_pool_alloc (tceu_pool* pool);
void ceu_pool_free (tceu_pool* pool, byte* val);

#endif

/*
 * Ceu pool.c is based on Contiki and TinyOS pools:
 * https://github.com/contiki-os/contiki/blob/master/core/lib/memb.c
 * https://github.com/tinyos/tinyos-main/blob/master/tos/system/PoolP.nc
 */
#ifndef _CEU_POOL_C
#define _CEU_POOL_C

#include <stdlib.h>


void ceu_pool_init (tceu_pool* pool, int size, int unit, byte** queue, byte* mem)
{
    int i;
    pool->size  = size;
    pool->free  = size;
    pool->index = 0;
    pool->unit  = unit;
    pool->queue = queue;
    pool->mem   = mem;
    for (i=0; i<size; i++) {
        queue[i] = &mem[i*unit];
    }
}

byte* ceu_pool_alloc (tceu_pool* pool) {
    byte* ret;

    if (pool->free == 0) {
        return NULL;
    }

    pool->free--;
    ret = pool->queue[pool->index];
    pool->queue[pool->index++] = NULL;
    if (pool->index == pool->size) {
        pool->index = 0;
    }
    return ret;
}

void ceu_pool_free (tceu_pool* pool, byte* val) {
    int empty = pool->index + pool->free;
    if (empty >= pool->size) {
        empty -= pool->size;
    }
    pool->queue[empty] = val;
    pool->free++;
}

/*
int ceu_pool_inside (tceu_pool* pool, byte* val) {
    return ((byte*)val >= pool->mem)
        && ((byte*)val < pool->mem+(pool->size*pool->unit));
}
*/

#endif

#endif

#ifdef CEU_VECTOR
#ifndef _CEU_VECTOR_H
#define _CEU_VECTOR_H

#ifndef _CEU_OS_H
#define _CEU_OS_H

#include <stddef.h>
#include "ceu_types.h"

#ifdef CEU_DEBUG
#include <assert.h>
#endif

#if defined(CEU_OS) && defined(__AVR)
#error Understand this again!
#include "Arduino.h"
#define CEU_ISR
#define CEU_ISR_ON()  interrupts()
#define CEU_ISR_OFF() noInterrupts()
#else
#define CEU_ISR_ON()
#define CEU_ISR_OFF()
#endif

/*
#if defined(CEU_CLEAR) || defined(CEU_INTS) || defined(CEU_ORGS) || defined(CEU_REENTRANT)
*/
#if 1
#include <setjmp.h>
#define CEU_STACK
#endif

#if defined(CEU_OS_KERNEL) || defined(CEU_OS_APP)
#define CEU_OS
#endif

#if defined(CEU_ORGS_NEWS) || defined(CEU_ADTS_NEWS)
#define CEU_NEWS
#endif
#if defined(CEU_ORGS_NEWS_POOL) || defined(CEU_ADTS_NEWS_POOL)
#define CEU_NEWS_POOL
#endif
#if defined(CEU_ORGS_AWAIT) || defined(CEU_ADTS_AWAIT)
#define CEU_ORGS_OR_ADTS_AWAIT
#endif

#ifdef CEU_OS

    /* TODO: all should be configurable */
    #define CEU_EXTS
    #define CEU_WCLOCKS
    #define CEU_ASYNCS
    #define CEU_RET
    #define CEU_CLEAR
    #define CEU_STACK
#ifndef __AVR
#endif
    #define CEU_INTS
    #define CEU_ORGS
    /*#define CEU_PSES*/ /* TODO: never tried */
    #define CEU_NEWS
    #define CEU_NEWS_POOL
    #define CEU_ORGS_NEWS
    #define CEU_ORGS_NEWS_MALLOC
    #define CEU_ORGS_NEWS_POOL
    #define CEU_ADTS_NEWS
    #define CEU_ADTS_NEWS_MALLOC
    #define CEU_ADTS_NEWS_POOL
    #define CEU_ORGS_AWAIT
    #define CEU_ADTS_AWAIT
    #define CEU_ORGS_OR_ADTS_AWAIT
/*
    #define CEU_THREADS
*/

#ifdef __AVR
    #define CEU_QUEUE_MAX 256
#else
    #define CEU_QUEUE_MAX 65536
#endif

    #define CEU_IN__NONE          0
    #define CEU_IN__ORG         255
    #define CEU_IN__ORG_PSED    254
    #define CEU_IN__CLEAR       253
    #define CEU_IN__ok_killed   252
    #define CEU_IN__INIT        251     /* HIGHER EXTERNAL */
    #define CEU_IN__ASYNC       250
    #define CEU_IN__THREAD      249
    #define CEU_IN__WCLOCK      248
    #define CEU_IN_OS_START     247
    #define CEU_IN_OS_STOP      246
    #define CEU_IN_OS_DT        245
    #define CEU_IN_OS_INTERRUPT 244
#ifdef CEU_TIMEMACHINE
    #define CEU_IN__WCLOCK_     243
    #define CEU_IN              243
#else
    #define CEU_IN              242
#endif

    #define CEU_IN_higher       CEU_IN__INIT  /* _INIT = HIGHER EXTERNAL */
    #define CEU_IN_lower        128     /* TODO: not checked from up and down */

    typedef s8 tceu_nlbl;   /* TODO: to small!! */

#endif /* CEU_OS */

#ifdef CEU_OS_APP

    #define ceu_out_log(mode,str) \
        ((__typeof__(ceu_sys_log)*)((_ceu_app)->sys_vec[CEU_SYS_LOG]))(mode,str)

    #define ceu_out_assert(v) \
        ((__typeof__(ceu_sys_assert)*)((_ceu_app)->sys_vec[CEU_SYS_ASSERT]))(v)

    #define ceu_out_assert_msg_ex(v,msg,file,line)       \
        {                                                \
            int __ceu_v = v;                             \
            if ((!(__ceu_v)) && ((msg)!=NULL)) {         \
                ceu_out_log(0, (long)"[");               \
                ceu_out_log(0, (long)(file));            \
                ceu_out_log(0, (long)":");               \
                ceu_out_log(2, (line));                  \
                ceu_out_log(0, (long)"] ");              \
                ceu_out_log(0, (long)"runtime error: "); \
                ceu_out_log(0, (long)(msg));             \
                ceu_out_log(0, (long)"\n");              \
            }                                            \
            ((__typeof__(ceu_sys_assert)*)((_ceu_app)->sys_vec[CEU_SYS_ASSERT]))(__ceu_v); \
        }
    #define ceu_out_assert_msg(v,msg) ceu_out_assert_msg_ex((v),(msg),__FILE__,__LINE__)

    #define ceu_out_realloc(ptr, size) \
        ((__typeof__(ceu_sys_realloc)*)((_ceu_app)->sys_vec[CEU_SYS_REALLOC]))(ptr,size)

    #define ceu_out_req() \
        ((__typeof__(ceu_sys_req)*)((_ceu_app)->sys_vec[CEU_SYS_REQ]))()

    #define ceu_out_load(addr) \
        ((__typeof__(ceu_sys_load)*)((_ceu_app)->sys_vec[CEU_SYS_LOAD]))(addr)

#ifdef CEU_ISR
    #define ceu_out_isr(n,f) \
        ((__typeof__(ceu_sys_isr)*)((_ceu_app)->sys_vec[CEU_SYS_ISR]))(n,f,_ceu_app)
#endif

    #define ceu_out_org_init(app,org,n,lbl,cls,isDyn,parent_org,parent_trl) \
        ((__typeof__(ceu_sys_org_init)*)((app)->sys_vec[CEU_SYS_ORG]))(org,n,lbl,cls,isDyn,parent_org,parent_trl)
    #define ceu_out_start(app) \
        ((__typeof__(ceu_sys_start)*)((_ceu_app)->sys_vec[CEU_SYS_START]))(app)
    #define ceu_out_link(app1,evt1 , app2,evt2) \
        ((__typeof__(ceu_sys_link)*)((_ceu_app)->sys_vec[CEU_SYS_LINK]))(app1,evt1,app2,evt2)

    #define ceu_out_emit(app,id,sz,buf) \
        ((__typeof__(ceu_sys_emit)*)((app)->sys_vec[CEU_SYS_EMIT]))(app,id,sz,buf)

    #define ceu_out_call(app,id,param) \
        ((__typeof__(ceu_sys_call)*)((app)->sys_vec[CEU_SYS_CALL]))(app,id,param)

#ifdef CEU_WCLOCKS
    #define ceu_out_wclock(app,dt,set,get) \
        ((__typeof__(ceu_sys_wclock)*)((app)->sys_vec[CEU_SYS_WCLOCK]))(app,dt,set,get)
#ifdef CEU_TIMEMACHINE
    #error TIMEMACHINE
#endif
#endif

    #define ceu_out_go(app,evt,evtp) \
        ((__typeof__(ceu_sys_go)*)((app)->sys_vec[CEU_SYS_GO]))(app,evt,evtp)

#else /* ! CEU_OS_APP (!CEU_OS||CEU_OS_KERNEL) */

    #ifndef ceu_out_assert
        #error "Missing definition for macro \"ceu_out_assert\"."
    #endif

    #ifndef ceu_out_log
        #error "Missing definition for macro \"ceu_out_log\"."
    #endif

    #define ceu_out_assert_msg_ex(v,msg,file,line)          \
        {                                                   \
            int __ceu_v = v;                                \
            if ((!(__ceu_v)) && ((msg)!=NULL)) {            \
                ceu_out_log(0, (long)"[");                  \
                ceu_out_log(0, (long)(file));               \
                ceu_out_log(0, (long)":");                  \
                ceu_out_log(2, line);                       \
                ceu_out_log(0, (long)"] ");                 \
                ceu_out_log(0, (long)"runtime error: ");    \
                ceu_out_log(0, (long)(msg));                \
                ceu_out_log(0, (long)"\n");                 \
            }                                               \
            ceu_out_assert(__ceu_v);                        \
        }
    #define ceu_out_assert_msg(v,msg) ceu_out_assert_msg_ex((v),(msg),__FILE__,__LINE__)

    #define ceu_out_realloc(ptr,size) \
            ceu_sys_realloc(ptr,size)
    #define ceu_out_req() \
            ceu_sys_req()
    #define ceu_out_org_init(app,org,n,lbl,cls,isDyn,parent_org,parent_trl) \
            ceu_sys_org_init(org,n,lbl,cls,isDyn,parent_org,parent_trl)

#ifdef CEU_WCLOCKS
    #define ceu_out_wclock(app,dt,set,get) \
            ceu_sys_wclock(app,dt,set,get)
#ifdef CEU_TIMEMACHINE
    #define ceu_out_wclock_(app,dt,set,get) \
            ceu_sys_wclock_(app,dt,set,get)
#endif
#endif
    #define ceu_out_go(app,evt,evtp) \
            ceu_sys_go(app,evt,evtp)
    #define ceu_out_go_stk(app,evt,evtp,stk) \
            ceu_sys_go_stk(app,evt,evtp,stk)

#endif /* ! CEU_OS_APP (!CEU_OS||CEU_OS_KERNEL) */

#define ceu_in_emit(app,id,n,buf) \
    ceu_out_go_stk(app,id,buf,&stk_)

#ifdef CEU_THREADS
/* TODO: app */
#include "ceu_threads.h"
#endif

#ifdef CEU_LUA
#include <stdio.h>      /* BUFSIZ */
#include <string.h>     /* strcpy */
#if defined(__ANDROID__) || defined(CEU_OS)
    #include "lua.h"
    #include "lauxlib.h"
    #include "lualib.h"
#else
    #include <lua5.1/lua.h>
    #include <lua5.1/lauxlib.h>
    #include <lua5.1/lualib.h>
#endif

#ifdef CEU_OS_APP
    #define ceu_luaL_newstate(set) { \
        set = ceu_out_call(_ceu_app, CEU_OUT_LUA_NEW, NULL); \
    }

    #define ceu_luaL_openlibs(l) { \
        lua_State* p = l;          \
        ceu_out_call(_ceu_app, CEU_OUT_LUAL_OPENLIBS, &p); \
    }

    #define ceu_lua_atpanic(l, f) {     \
    }

    #define ceu_luaL_loadstring(set, l, str) {  \
        tceu__lua_State___char_ p = { l, str }; \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUAL_LOADSTRING, &p); \
    }

    #define ceu_lua_pushnumber(l, v) {      \
        tceu__lua_State___int p = { l, v }; \
        ceu_out_call(_ceu_app, CEU_OUT_LUA_PUSHNUMBER, &p); \
    }

    #define ceu_lua_pushstring(l, v) {      \
        tceu__lua_State___char_ p = { l, v }; \
        ceu_out_call(_ceu_app, CEU_OUT_LUA_PUSHSTRING, &p); \
    }

    #define ceu_lua_pushlightuserdata(l, v) {   \
        tceu__lua_State___void_ p = { l, v };     \
        ceu_out_call(_ceu_app, CEU_OUT_LUA_PUSHLIGHTUSERDATA, &p); \
    }

    #define ceu_lua_pcall(set,l,nargs,nrets,err) {                  \
        tceu__lua_State___int__int__int p = { l, nargs, nrets, err }; \
        ceu_out_call(_ceu_app, CEU_OUT_LUA_PCALL, &p); \
    }

    #define ceu_lua_isnumber(set, l, idx) {     \
        tceu__lua_State___int p = { l, idx };   \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUA_ISNUMBER, &p); \
    }

    #define ceu_lua_tonumber(set, l, idx) {     \
        tceu__lua_State___int p = { l, idx };   \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUA_TONUMBER, &p); \
    }

    #define ceu_lua_isboolean(set, l, idx) {    \
        tceu__lua_State___int p = { l, idx };   \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUA_ISBOOLEAN, &p); \
    }

    #define ceu_lua_toboolean(set, l, idx) {    \
        tceu__lua_State___int p = { l, idx };   \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUA_TOBOOLEAN, &p); \
    }

    #define ceu_lua_pop(l, n) {             \
        tceu__lua_State___int p = { l, n }; \
        ceu_out_call(_ceu_app, CEU_OUT_LUA_POP, &p); \
    }

    #define ceu_lua_isstring(set, l, idx) {     \
        tceu__lua_State___int p = { l, idx };   \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUA_ISSTRING, &p); \
    }

    #define ceu_lua_tostring(set, l, idx) {     \
        tceu__lua_State___int p = { l, idx };   \
        set = ceu_out_call(_ceu_app, CEU_OUT_LUA_TOSTRING, &p); \
    }

    #define ceu_lua_islightuserdata(set, l, idx) {  \
        tceu__lua_State___int p = { l, idx };       \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUA_ISLIGHTUSERDATA, &p); \
    }

    #define ceu_lua_touserdata(set, l, idx) {   \
        tceu__lua_State___int p = { l, idx };   \
        set = ceu_out_call(_ceu_app, CEU_OUT_LUA_TOUSERDATA, &p); \
    }

    #define ceu_lua_error(l) {                          \
        lua_State** p = &l;                             \
        ceu_out_call(_ceu_app, CEU_OUT_LUA_ERROR, &p);  \
    }

    #define ceu_lua_objlen(set, l, idx) {                       \
        tceu__lua_State___int p = { l, idx };                   \
        set = ceu_out_call(_ceu_app, CEU_OUT_LUA_OBJLEN, &p);   \
    }

#else
    #define ceu_luaL_newstate(set)               set = luaL_newstate()
    #define ceu_luaL_openlibs(l)                 luaL_openlibs(l)
    #define ceu_lua_atpanic(l,f)                 lua_atpanic(l,f)
    #define ceu_luaL_loadstring(set,l,str)       set = luaL_loadstring(l,str)
    #define ceu_lua_pushnumber(l,v)              lua_pushnumber(l,v)
    #define ceu_lua_pushstring(l,v)              lua_pushstring(l,v)
    #define ceu_lua_pushlightuserdata(l,v)       lua_pushlightuserdata(l,v)
    #define ceu_lua_pcall(set,l,nargs,nrets,err) set = lua_pcall(l,nargs,nrets,err)
    #define ceu_lua_isnumber(set,l,idx)          set = lua_isnumber(l,idx)
    #define ceu_lua_tonumber(set,l,idx)          set = lua_tonumber(l,idx)
    #define ceu_lua_isboolean(set,l,idx)         set = lua_isboolean(l,idx)
    #define ceu_lua_toboolean(set,l,idx)         set = lua_toboolean(l,idx)
    #define ceu_lua_pop(l,n)                     lua_pop(l,n)
    #define ceu_lua_isstring(set,l,idx)          set = lua_isstring(l,idx)
    #define ceu_lua_tostring(set,l,idx)          set = lua_tostring(l,idx)
    #define ceu_lua_islightuserdata(set,l,idx)   set = lua_islightuserdata(l,idx)
    #define ceu_lua_touserdata(set,l,idx)        set = lua_touserdata(l,idx)
    #define ceu_lua_error(l)                     lua_error(l)
    #define ceu_lua_objlen(set,l,idx)            set = lua_objlen(l,idx)
#endif
#endif

typedef u8 tceu_nevt;   /* max number of events */
                        /* TODO: should "u8" be fixed? */

typedef u8 tceu_ntrl;   /* max number of trails per class */
                        /* TODO: should "u8" be fixed? */

#ifdef CEU_STACK
typedef u16 tceu_nstk;  /* max size of internal stack in bytes */
                        /* TODO: should "u16" be fixed? */
#endif

#ifdef __cplusplus
#define CEU_WCLOCK_INACTIVE 0x7fffffffL     /* TODO */
#else
#define CEU_WCLOCK_INACTIVE INT32_MAX
#endif
#define CEU_WCLOCK_EXPIRED (CEU_WCLOCK_INACTIVE-1)

/* TCEU_TRL */

struct tceu_org;
typedef union tceu_trl {
    tceu_nevt evt;

    /* normal await // IN__CLEAR */
    struct {                    /* TODO(ram): bitfields */
        tceu_nevt evt1;
        tceu_nlbl lbl;
        u8        seqno;        /* TODO(ram): 2 bits is enough */
#ifdef CEU_INTS                 /* R-9: size of trails for internal events */
#ifdef CEU_ORGS
        void*     evto;
#endif
#endif
    };

    /* IN__ORG */
#ifdef CEU_ORGS
    struct {                    /* TODO(ram): bad for alignment */
        tceu_nevt evt3;
        struct tceu_org* org;
    };
#endif

    /* _ok_killed */
#ifdef CEU_ORGS_OR_ADTS_AWAIT
    struct {
        tceu_nevt evt4;
        tceu_nlbl lbl4;
        void*     org_or_adt;
    };
#endif
} tceu_trl;

/* TCEU_EVT */

typedef struct tceu_evt {
    tceu_nevt id;
    void*     param;
#if defined(CEU_ORGS) && defined(CEU_INTS)
    void*     org;      /* emitting org */
#endif
} tceu_evt;

/* TCEU_ORG */

struct tceu_pool_orgs;
typedef struct tceu_org
{
#ifdef CEU_ORGS
    struct tceu_org* nxt; /* first field because of free list for orgs/adts */
    struct tceu_org* prv;
    struct tceu_org* parent_org;
    tceu_ntrl parent_trl;
#endif

#if defined(CEU_ORGS) || defined(CEU_OS)
    tceu_ntrl n;            /* number of trails (TODO(ram): opt, metadata) */
#endif

#ifdef CEU_ORGS

#ifdef CEU_IFCS
    tceu_ncls cls;          /* class id */
#endif
    u8 isAlive: 1;          /* Three purposes:
                             * - avoids double free
                             * - required by "watching o" to avoid awaiting a
                             *      dead org
                             * - required by "Do T" to avoid awaiting a dead 
                             *      org
                             */
#if defined(CEU_ORGS_NEWS) || defined(CEU_ORGS_AWAIT)
#endif
#ifdef CEU_ORGS_NEWS
    u8 isDyn: 1;            /* created w/ new or spawn? */
#endif
#ifdef CEU_ORGS_NEWS_POOL
    struct tceu_pool_orgs* pool;
#endif

#ifdef CEU_ORGS_AWAIT
    int ret;
#endif

#endif  /* CEU_ORGS */

    tceu_trl trls[0];       /* first trail */

} tceu_org;

/* TCEU_POOL_ORGS , TCEU_POOL_ADTS */

#if defined(CEU_ORGS_NEWS_POOL) || defined(CEU_ADTS_NEWS_POOL)
#include "ceu_pool.h"
#endif

#ifdef CEU_ORGS_NEWS
typedef struct tceu_pool_orgs {
    tceu_org* parent_org;
    tceu_ntrl parent_trl;
#ifdef CEU_ORGS_NEWS_POOL
    tceu_pool pool;
#endif
} tceu_pool_orgs;
#endif

#ifdef CEU_ADTS_NEWS
typedef struct {
    void* root;
#ifdef CEU_ADTS_NEWS_POOL
    void* pool;
#endif
} tceu_pool_adts;
#endif

/* TCEU_KILL */

#ifdef CEU_ORGS_OR_ADTS_AWAIT
typedef struct tceu_kill {
    void*     org_or_adt;
    int       ret;
} tceu_kill;
#endif

/* TCEU_LST */

#ifdef CEU_DEBUG
typedef struct tceu_lst {
#ifdef CEU_ORGS
    void*     org;
#endif
    tceu_trl* trl;
    tceu_nlbl lbl;
} tceu_lst;

#endif

/* TCEU_STK */

typedef struct tceu_stk {
    struct tceu_stk* up;
    tceu_org* org;
    tceu_ntrl trl1;
    tceu_ntrl trl2;
    jmp_buf   jmp;
} tceu_stk;

/* TCEU_JMP */

#ifdef CEU_STACK
typedef struct tceu_jmp {
#ifdef CEU_ORGS
    tceu_org* org;
#endif
    tceu_trl* trl;
    tceu_nlbl lbl;
} tceu_jmp;
#endif

/* TCEU_APP */

typedef struct tceu_app {
    /* global seqno: incremented on every reaction
     * awaiting trails matches only if trl->seqno < seqno,
     * i.e., previously awaiting the event
     */
    u8 seqno:          2;
#if defined(CEU_RET) || defined(CEU_OS)
    u8 isAlive:        1;
#endif
#ifdef CEU_ASYNCS
    u8 pendingAsyncs:  1;
#endif
#if defined(CEU_ORGS_NEWS_MALLOC) && defined(CEU_ORGS_AWAIT)
    u8 dont_emit_kill: 1;
#endif

#ifdef CEU_OS
    struct tceu_app* nxt;
#endif

#ifdef CEU_REENTRANT
    tceu_nstk stki;
#endif

#ifdef CEU_STACK
    tceu_stk* stk_bottom;
    tceu_jmp  stk_jmp;
#endif

#if defined(CEU_RET) || defined(CEU_ORGS_AWAIT)
    int ret;
#endif

#ifdef CEU_ORGS_NEWS_MALLOC
    tceu_org* tofree;
#endif

#ifdef CEU_WCLOCKS
    s32         wclk_late;
    s32         wclk_min_set;   /* used to set */
    s32         wclk_min_cmp;   /* used to compare */
                                /* cmp<-set every reaction */
#ifdef CEU_TIMEMACHINE
    s32         wclk_late_;
    s32         wclk_min_set_;
    s32         wclk_min_cmp_;
#endif
#endif

#ifndef CEU_OS
#ifdef CEU_DEBUG
    tceu_lst    lst; /* segfault printf */
#endif
#endif

#ifdef CEU_THREADS
    CEU_THREADS_MUTEX_T threads_mutex;
    /*CEU_THREADS_COND_T  threads_cond;*/
    u8                  threads_n;          /* number of running threads */
        /* TODO: u8? */
#endif
#if defined(CEU_LUA) || defined(CEU_OS)
#ifdef CEU_LUA
    lua_State*  lua;    /* TODO: move to data? */
#else
    void*       lua;
#endif
#endif

    void        (*code)  (struct tceu_app*,tceu_evt*,tceu_org*,tceu_trl*,tceu_stk*);
    void        (*init)  (struct tceu_app*);
#ifdef CEU_OS
    void*       (*calls) (struct tceu_app*,tceu_nevt,void*);
    void**      sys_vec;
    void*       addr;
#ifdef CEU_OS_LUAIFC
    char*       luaifc;
#endif
#endif
    tceu_org*   data;
} tceu_app;

#ifdef CEU_OS
typedef void (*tceu_init)   (tceu_app* app);
typedef void (*tceu_export) (uint* size, tceu_init** init
#ifdef CEU_OS_LUAIFC
                            , char** luaifc
#endif
);
#endif

/* TCEU_THREADS_P */

#ifdef CEU_THREADS
typedef struct {
    tceu_app* app;
    tceu_org* org;
    s8*       st; /* thread state:
                   * 0=ini (sync  spawns)
                   * 1=cpy (async copies)
                   * 2=lck (sync  locks)
                   * 3=end (sync/async terminates)
                   */
} tceu_threads_p;
#endif

#ifdef CEU_PSES
void ceu_pause (tceu_trl* trl, tceu_trl* trlF, int psed);
#endif

int  ceu_go_all    (tceu_app* app);

#ifdef CEU_WCLOCKS
int       ceu_sys_wclock (tceu_app* app, s32 dt, s32* set, s32* get);
#endif
void      ceu_sys_go     (tceu_app* app, int evt, void* evtp);

#ifdef CEU_OS

/* TCEU_LINK */

typedef struct tceu_lnk {
    tceu_app* src_app;
    tceu_nevt src_evt;
    tceu_app* dst_app;
    tceu_nevt dst_evt;
    struct tceu_lnk* nxt;
} tceu_lnk;

/* TCEU_QUEUE */

typedef struct {
    tceu_app* app;
    tceu_nevt evt;
#if CEU_QUEUE_MAX == 256
    s8        sz;
#else
    s16       sz;   /* signed because of fill */
#endif
    byte      buf[0];
} tceu_queue;

#ifdef CEU_ISR
typedef void(*tceu_isr_f)(tceu_app* app, tceu_org* org);
#endif

void ceu_os_init      (void);
int  ceu_os_scheduler (int(*dt)());
tceu_queue* ceu_sys_queue_nxt (void);
void        ceu_sys_queue_rem (void);

void      ceu_sys_assert    (int v);
void      ceu_sys_log       (int mode, long str);
void*     ceu_sys_realloc   (void* ptr, size_t size);
int       ceu_sys_req       (void);
tceu_app* ceu_sys_load      (void* addr);
#ifdef CEU_ISR
int       ceu_sys_isr       (int n, tceu_isr_f f, tceu_app* app);
#endif
void      ceu_sys_org_init  (tceu_org* org, int n, int lbl, int cls, int isDyn,
                             tceu_org* parent_org, tceu_ntrl parent_trl);
void      ceu_sys_start     (tceu_app* app);
int       ceu_sys_link      (tceu_app* src_app, tceu_nevt src_evt, tceu_app* dst_app, tceu_nevt dst_evt);
int       ceu_sys_unlink    (tceu_app* src_app, tceu_nevt src_evt, tceu_app* dst_app, tceu_nevt dst_evt);
int       ceu_sys_emit      (tceu_app* app, tceu_nevt evt, int sz, void* param);
void*     ceu_sys_call      (tceu_app* app, tceu_nevt evt, void* param);

enum {
    CEU_SYS_ASSERT = 0,
    CEU_SYS_LOG,
    CEU_SYS_REALLOC,
    CEU_SYS_REQ,
    CEU_SYS_LOAD,
#ifdef CEU_ISR
    CEU_SYS_ISR,
#endif
#ifdef CEU_CLEAR
    CEU_SYS_CLEAR,
#endif
    CEU_SYS_STACK_PUSH,
#ifdef CEU_ORGS
    CEU_SYS_STACK_CLEAR_ORG,
#endif
    CEU_SYS_ORG,
#ifdef CEU_ORGS
    CEU_SYS_ORG_TRAIL,
    CEU_SYS_ORG_SPAWN,
#endif
    CEU_SYS_START,
    CEU_SYS_LINK,
    CEU_SYS_UNLINK,
    CEU_SYS_EMIT,
    CEU_SYS_CALL,
#ifdef CEU_WCLOCKS
    CEU_SYS_WCLOCK,
#endif
    CEU_SYS_GO,
    CEU_SYS_MAX
};

/* SYS_VECTOR
 */
extern void* CEU_SYS_VEC[CEU_SYS_MAX];

#endif  /* CEU_OS */

#endif  /* _CEU_OS_H */


typedef struct {
    int   max;
    int   nxt;
    int   unit;
    byte* mem;
} tceu_vector;

#define CEU_VECTOR_DCL(name, type, max)  \
    type        name##_mem[max+1];       \
    tceu_vector name;
                /* [STRING] max+1: extra space for '\0' */

#define ceu_vector_getlen(vec) ((vec)->nxt)
#define ceu_vector_getmax(vec) ((vec)->max > 0 ? (vec)->max : 0)

void  ceu_vector_init   (tceu_vector* vector, int max, int unit, byte* mem);
int   ceu_vector_setlen (tceu_vector* vector, int len);
byte* ceu_vector_geti   (tceu_vector* vector, int idx);
int   ceu_vector_seti   (tceu_vector* vector, int idx, byte* v);
int   ceu_vector_push   (tceu_vector* vector, byte* v);
int   ceu_vector_concat (tceu_vector* to, tceu_vector* fr);
int   ceu_vector_concat_buffer (tceu_vector* to, const char* fr, int n);
char* ceu_vector_tochar (tceu_vector* vector);

#if 0
byte* ceu_pool_alloc (tceu_pool* pool);
void ceu_pool_free (tceu_pool* pool, byte* val);
#endif
#endif

#ifndef _CEU_VECTOR_C
#define _CEU_VECTOR_C



void ceu_vector_init (tceu_vector* vector, int max, int unit, byte* mem) {
    vector->nxt  = 0;
    vector->max  = max;
    vector->unit = unit;
    vector->mem  = (max==0) ? NULL : mem;

    /* [STRING] */
    if (vector->mem != NULL) {
        vector->mem[0] = '\0';
    }
}

#ifdef CEU_VECTOR_MALLOC
static void* ceu_vector_resize (tceu_vector* vector, int n) {
    ceu_out_assert_msg(vector->max <= 0, "bug found");

    if (n == 0) {
        /* free */
        if (vector->mem != NULL) {
            vector->max = 0;
            ceu_out_realloc(vector->mem, 0);
            vector->mem = NULL;
        }
    } else {
        /* TODO: Java does the same? */
        n = (n*3/2) + 1;
        if (n < 10) {
            n = 10;
        }

        vector->max = -n;
        vector->mem = (byte*)ceu_out_realloc(vector->mem, n*vector->unit + 1);
                                                        /* [STRING] +1 */
    }

    return vector->mem;
}
#endif

/* can only decrease vector->nxt */
int ceu_vector_setlen (tceu_vector* vector, int nxt) {
    if (nxt > vector->nxt) {
        return 0;
    } else {
        vector->nxt = nxt;

        /* [STRING] */
        if (vector->mem != NULL) {
            vector->mem[nxt*vector->unit] = '\0';
        }

#ifdef CEU_VECTOR_MALLOC
        /* shrink malloc'ed arrays */
        if (vector->max <= 0) {
            if (ceu_vector_resize(vector,nxt)==NULL && nxt>0) {
                return 0;
            }
        }
#endif

        return 1;
    }
}

/* can only get within idx < vector->nxt */
byte* ceu_vector_geti (tceu_vector* vector, int idx) {
    if (idx >= vector->nxt) {
        return NULL;
    } else {
        return &vector->mem[idx*vector->unit];
    }
}

/* can only set within idx < vector->nxt */
int ceu_vector_seti (tceu_vector* vector, int idx, byte* v) {
    if (idx >= vector->nxt) {
        return 0;
    } else {
        memcpy(&vector->mem[idx*vector->unit], v, vector->unit);
        return 1;
    }
}

/* can only push within nxt < vector->max */
int ceu_vector_push (tceu_vector* vector, byte* v) {
#ifdef CEU_VECTOR_MALLOC
    /* grow malloc'ed arrays */
    if (vector->max <= 0) {
        while (vector->nxt >= -vector->max) {
            if (ceu_vector_resize(vector,vector->nxt+1) == NULL) {
                return 0;
            }
        }
    }
#endif
#ifdef CEU_VECTOR_MALLOC
#ifdef CEU_VECTOR_POOL
    else
#endif
#endif
#ifdef CEU_VECTOR_POOL
    if (vector->nxt >= vector->max) {
        return 0;
    }
#endif

    memcpy(&vector->mem[vector->nxt*vector->unit], v, vector->unit);
    vector->nxt++;
    vector->mem[vector->nxt*vector->unit] = '\0';    /* [STRING] */
    return 1;
}

int ceu_vector_concat (tceu_vector* to, tceu_vector* fr) {
    if (to == fr) {
        return 0;
    } else {
        /* TODO: memcpy */
        int i;
        for (i=0; i<fr->nxt; i++) {
            byte* v = ceu_vector_geti(fr, i);
            if (v == NULL) {
                return 0;
            } else if (!ceu_vector_push(to,v)) {
                return 0;
            }
        }
    }
    return 1;
}

int ceu_vector_concat_buffer (tceu_vector* to, const char* fr, int n) {
    /* TODO: memcpy */
    int i;
    for (i=0; i<n; i++) {
        if (!ceu_vector_push(to,(byte*)&fr[i])) {
            return 0;
        }
    }
    return 1;
}

char* ceu_vector_tochar (tceu_vector* vector) {
    if (vector->mem == NULL) {
        return "";
    } else {
        return (char*)vector->mem;
    }
}

#endif

#endif

#ifdef CEU_IFCS
#include <stddef.h>
/* TODO: === direto? */
#define CEU_NCLS       (=== CEU_NCLS ===)
#endif

/* native code from the Main class */


/* goto labels */
enum {
    Main_Set_out_0 = 0,
    LeafHandler_Set_out_1 = 1,
    Class_LeafHandler = 2,
    BTreeTraverse_Set_out_3 = 3,
    BTreeTraverse_Set_jmp_4 = 4,
    Class_Scope = 5,
    Body_239_Set_out_6 = 6,
    Body_239_Set_jmp_7 = 7,
    Body_239_ParOr_sub_1_8 = 8,
    Body_239_ParOr_out_9 = 9,
    Body_239_ParOr_jmp_10 = 10,
    Body_239_Awake__ok_killed_11 = 11,
    Body_239_ParOr_sub_1_12 = 12,
    Body_239_ParOr_out_13 = 13,
    Body_239_ParOr_jmp_14 = 14,
    Body_239_Awake__ok_killed_15 = 15,
    Body_239_Awake__ok_killed_16 = 16,
    Body_239_optorg_reset_17 = 17,
    Body_239_Block_jmp_18 = 18,
    Body_239_Awake__ok_killed_19 = 19,
    Body_239_optorg_reset_20 = 20,
    Body_239_Block_jmp_21 = 21,
    Body_239_Awake__ok_killed_22 = 22,
    Body_239_optorg_reset_23 = 23,
    Body_239_Block_jmp_24 = 24,
    Body_239_Awake__ok_killed_25 = 25,
    Body_239_optorg_reset_26 = 26,
    Body_239_Block_jmp_27 = 27,
    Body_239_Awake__ok_killed_28 = 28,
    Body_239_Block_jmp_29 = 29,
    Body_239_Block__fin_30 = 30,
    Body_239_Block_jmp_31 = 31,
    Class_Body_239 = 32,
    BTreeTraverse_Awake__ok_killed_33 = 33,
    BTreeTraverse_optorg_reset_34 = 34,
    BTreeTraverse_Block_jmp_35 = 35,
    BTreeTraverse_Block__fin_36 = 36,
    BTreeTraverse_Block_jmp_37 = 37,
    BTreeTraverse_Block__fin_38 = 38,
    BTreeTraverse_Block_jmp_39 = 39,
    Class_BTreeTraverse = 40,
    Main_Awake_TICK_41 = 41,
    Main_Awake__ok_killed_42 = 42,
    Main_Block_jmp_43 = 43,
    Main_Block__fin_44 = 44,
    Main_adt_fin_kill_free_45 = 45,
    Main_Block_jmp_46 = 46,
    Class_Main = 47,

};

typedef struct {
#ifdef CEU_IFCS
#ifdef CEU_OS_APP
#error remove from RAM!
#endif
    s8        ifcs_clss[CEU_NCLS][=== IFCS_NIFCS ===];
            /* Does "cls" implements "ifc?"
             * (I*) ifc = (I*) cls;     // returns null if not
             * TODO(ram): bitfield
             */

    u16       ifcs_flds[CEU_NCLS][=== IFCS_NFLDS ===];
    u16       ifcs_evts[CEU_NCLS][=== IFCS_NEVTS ===];
    void*     ifcs_funs[CEU_NCLS][=== IFCS_NFUNS ===];
#endif
} _tceu_app;

/* TODO: remove from RAM */
#ifdef CEU_IFCS
static _tceu_app _CEU_APP = {
#ifdef CEU_OS_APP
#error remove from RAM!
#endif
    {
=== IFCS_CLSS ===
    },
    {
=== IFCS_FLDS ===
    },
    {
=== IFCS_EVTS ===
    },
    {
=== IFCS_FUNS ===
    }
};
#endif

void CEU_Leaf_free (void* pool, CEU_Leaf* me);

CEU_Leaf* CEU_LEAF_SENSERIGHT_assert (tceu_app* app, CEU_Leaf* me, char* file, int line) {
    ceu_out_assert_msg_ex(me->tag == CEU_LEAF_SENSERIGHT, "invalid tag", file, line);
    return me;
}

void CEU_LEAF_SENSERIGHT_free (void* pool, CEU_Leaf* me) {
    /* FREE (before ok_killed) */
#if    defined(CEU_ADTS_NEWS_POOL) && !defined(CEU_ADTS_NEWS_MALLOC)
            ceu_pool_free(pool, (void*)me);
#elif  defined(CEU_ADTS_NEWS_POOL) &&  defined(CEU_ADTS_NEWS_MALLOC)
            if (pool == NULL) {
                ceu_out_realloc(me, 0);
            } else {
                ceu_pool_free(pool, (void*)me);
            }
#elif !defined(CEU_ADTS_NEWS_POOL) &&  defined(CEU_ADTS_NEWS_MALLOC)
            ceu_out_realloc(me, 0);
#endif
}

CEU_Leaf* CEU_LEAF_SENSELEFT_assert (tceu_app* app, CEU_Leaf* me, char* file, int line) {
    ceu_out_assert_msg_ex(me->tag == CEU_LEAF_SENSELEFT, "invalid tag", file, line);
    return me;
}

void CEU_LEAF_SENSELEFT_free (void* pool, CEU_Leaf* me) {
    /* FREE (before ok_killed) */
#if    defined(CEU_ADTS_NEWS_POOL) && !defined(CEU_ADTS_NEWS_MALLOC)
            ceu_pool_free(pool, (void*)me);
#elif  defined(CEU_ADTS_NEWS_POOL) &&  defined(CEU_ADTS_NEWS_MALLOC)
            if (pool == NULL) {
                ceu_out_realloc(me, 0);
            } else {
                ceu_pool_free(pool, (void*)me);
            }
#elif !defined(CEU_ADTS_NEWS_POOL) &&  defined(CEU_ADTS_NEWS_MALLOC)
            ceu_out_realloc(me, 0);
#endif
}

CEU_Leaf* CEU_LEAF_SENSEUP_assert (tceu_app* app, CEU_Leaf* me, char* file, int line) {
    ceu_out_assert_msg_ex(me->tag == CEU_LEAF_SENSEUP, "invalid tag", file, line);
    return me;
}

void CEU_LEAF_SENSEUP_free (void* pool, CEU_Leaf* me) {
    /* FREE (before ok_killed) */
#if    defined(CEU_ADTS_NEWS_POOL) && !defined(CEU_ADTS_NEWS_MALLOC)
            ceu_pool_free(pool, (void*)me);
#elif  defined(CEU_ADTS_NEWS_POOL) &&  defined(CEU_ADTS_NEWS_MALLOC)
            if (pool == NULL) {
                ceu_out_realloc(me, 0);
            } else {
                ceu_pool_free(pool, (void*)me);
            }
#elif !defined(CEU_ADTS_NEWS_POOL) &&  defined(CEU_ADTS_NEWS_MALLOC)
            ceu_out_realloc(me, 0);
#endif
}

CEU_Leaf* CEU_LEAF_SENSEDOWN_assert (tceu_app* app, CEU_Leaf* me, char* file, int line) {
    ceu_out_assert_msg_ex(me->tag == CEU_LEAF_SENSEDOWN, "invalid tag", file, line);
    return me;
}

void CEU_LEAF_SENSEDOWN_free (void* pool, CEU_Leaf* me) {
    /* FREE (before ok_killed) */
#if    defined(CEU_ADTS_NEWS_POOL) && !defined(CEU_ADTS_NEWS_MALLOC)
            ceu_pool_free(pool, (void*)me);
#elif  defined(CEU_ADTS_NEWS_POOL) &&  defined(CEU_ADTS_NEWS_MALLOC)
            if (pool == NULL) {
                ceu_out_realloc(me, 0);
            } else {
                ceu_pool_free(pool, (void*)me);
            }
#elif !defined(CEU_ADTS_NEWS_POOL) &&  defined(CEU_ADTS_NEWS_MALLOC)
            ceu_out_realloc(me, 0);
#endif
}

CEU_Leaf* CEU_LEAF_GORIGHT_assert (tceu_app* app, CEU_Leaf* me, char* file, int line) {
    ceu_out_assert_msg_ex(me->tag == CEU_LEAF_GORIGHT, "invalid tag", file, line);
    return me;
}

void CEU_LEAF_GORIGHT_free (void* pool, CEU_Leaf* me) {
    /* FREE (before ok_killed) */
#if    defined(CEU_ADTS_NEWS_POOL) && !defined(CEU_ADTS_NEWS_MALLOC)
            ceu_pool_free(pool, (void*)me);
#elif  defined(CEU_ADTS_NEWS_POOL) &&  defined(CEU_ADTS_NEWS_MALLOC)
            if (pool == NULL) {
                ceu_out_realloc(me, 0);
            } else {
                ceu_pool_free(pool, (void*)me);
            }
#elif !defined(CEU_ADTS_NEWS_POOL) &&  defined(CEU_ADTS_NEWS_MALLOC)
            ceu_out_realloc(me, 0);
#endif
}

CEU_Leaf* CEU_LEAF_GOLEFT_assert (tceu_app* app, CEU_Leaf* me, char* file, int line) {
    ceu_out_assert_msg_ex(me->tag == CEU_LEAF_GOLEFT, "invalid tag", file, line);
    return me;
}

void CEU_LEAF_GOLEFT_free (void* pool, CEU_Leaf* me) {
    /* FREE (before ok_killed) */
#if    defined(CEU_ADTS_NEWS_POOL) && !defined(CEU_ADTS_NEWS_MALLOC)
            ceu_pool_free(pool, (void*)me);
#elif  defined(CEU_ADTS_NEWS_POOL) &&  defined(CEU_ADTS_NEWS_MALLOC)
            if (pool == NULL) {
                ceu_out_realloc(me, 0);
            } else {
                ceu_pool_free(pool, (void*)me);
            }
#elif !defined(CEU_ADTS_NEWS_POOL) &&  defined(CEU_ADTS_NEWS_MALLOC)
            ceu_out_realloc(me, 0);
#endif
}

CEU_Leaf* CEU_LEAF_GOUP_assert (tceu_app* app, CEU_Leaf* me, char* file, int line) {
    ceu_out_assert_msg_ex(me->tag == CEU_LEAF_GOUP, "invalid tag", file, line);
    return me;
}

void CEU_LEAF_GOUP_free (void* pool, CEU_Leaf* me) {
    /* FREE (before ok_killed) */
#if    defined(CEU_ADTS_NEWS_POOL) && !defined(CEU_ADTS_NEWS_MALLOC)
            ceu_pool_free(pool, (void*)me);
#elif  defined(CEU_ADTS_NEWS_POOL) &&  defined(CEU_ADTS_NEWS_MALLOC)
            if (pool == NULL) {
                ceu_out_realloc(me, 0);
            } else {
                ceu_pool_free(pool, (void*)me);
            }
#elif !defined(CEU_ADTS_NEWS_POOL) &&  defined(CEU_ADTS_NEWS_MALLOC)
            ceu_out_realloc(me, 0);
#endif
}

CEU_Leaf* CEU_LEAF_GODOWN_assert (tceu_app* app, CEU_Leaf* me, char* file, int line) {
    ceu_out_assert_msg_ex(me->tag == CEU_LEAF_GODOWN, "invalid tag", file, line);
    return me;
}

void CEU_LEAF_GODOWN_free (void* pool, CEU_Leaf* me) {
    /* FREE (before ok_killed) */
#if    defined(CEU_ADTS_NEWS_POOL) && !defined(CEU_ADTS_NEWS_MALLOC)
            ceu_pool_free(pool, (void*)me);
#elif  defined(CEU_ADTS_NEWS_POOL) &&  defined(CEU_ADTS_NEWS_MALLOC)
            if (pool == NULL) {
                ceu_out_realloc(me, 0);
            } else {
                ceu_pool_free(pool, (void*)me);
            }
#elif !defined(CEU_ADTS_NEWS_POOL) &&  defined(CEU_ADTS_NEWS_MALLOC)
            ceu_out_realloc(me, 0);
#endif
}

CEU_Leaf* CEU_LEAF_SKIP_assert (tceu_app* app, CEU_Leaf* me, char* file, int line) {
    ceu_out_assert_msg_ex(me->tag == CEU_LEAF_SKIP, "invalid tag", file, line);
    return me;
}

void CEU_LEAF_SKIP_free (void* pool, CEU_Leaf* me) {
    /* FREE (before ok_killed) */
#if    defined(CEU_ADTS_NEWS_POOL) && !defined(CEU_ADTS_NEWS_MALLOC)
            ceu_pool_free(pool, (void*)me);
#elif  defined(CEU_ADTS_NEWS_POOL) &&  defined(CEU_ADTS_NEWS_MALLOC)
            if (pool == NULL) {
                ceu_out_realloc(me, 0);
            } else {
                ceu_pool_free(pool, (void*)me);
            }
#elif !defined(CEU_ADTS_NEWS_POOL) &&  defined(CEU_ADTS_NEWS_MALLOC)
            ceu_out_realloc(me, 0);
#endif
}

void CEU_Leaf_free (void* pool, CEU_Leaf* me) {
    switch (me->tag) {
        case CEU_LEAF_SENSERIGHT:
            CEU_LEAF_SENSERIGHT_free(pool, me);
            break;
        case CEU_LEAF_SENSELEFT:
            CEU_LEAF_SENSELEFT_free(pool, me);
            break;
        case CEU_LEAF_SENSEUP:
            CEU_LEAF_SENSEUP_free(pool, me);
            break;
        case CEU_LEAF_SENSEDOWN:
            CEU_LEAF_SENSEDOWN_free(pool, me);
            break;
        case CEU_LEAF_GORIGHT:
            CEU_LEAF_GORIGHT_free(pool, me);
            break;
        case CEU_LEAF_GOLEFT:
            CEU_LEAF_GOLEFT_free(pool, me);
            break;
        case CEU_LEAF_GOUP:
            CEU_LEAF_GOUP_free(pool, me);
            break;
        case CEU_LEAF_GODOWN:
            CEU_LEAF_GODOWN_free(pool, me);
            break;
        case CEU_LEAF_SKIP:
            CEU_LEAF_SKIP_free(pool, me);
            break;
#ifdef CEU_DEBUG
        default:
            ceu_out_assert_msg(0, "invalid tag");
#endif
    }
}



static CEU_BTree CEU_BTREE_BASE;
void CEU_BTree_free (void* pool, CEU_BTree* me);

CEU_BTree* CEU_BTREE_NIL_assert (tceu_app* app, CEU_BTree* me, char* file, int line) {
    ceu_out_assert_msg_ex(me->tag == CEU_BTREE_NIL, "invalid tag", file, line);
    return me;
}

CEU_BTree* CEU_BTREE_SEQUENCE_assert (tceu_app* app, CEU_BTree* me, char* file, int line) {
    ceu_out_assert_msg_ex(me->tag == CEU_BTREE_SEQUENCE, "invalid tag", file, line);
    return me;
}

void CEU_BTREE_SEQUENCE_free (void* pool, CEU_BTree* me) {
    CEU_BTree_free(pool, me->SEQUENCE.first);
    CEU_BTree_free(pool, me->SEQUENCE.second);
    /* FREE (before ok_killed) */
#if    defined(CEU_ADTS_NEWS_POOL) && !defined(CEU_ADTS_NEWS_MALLOC)
            ceu_pool_free(pool, (void*)me);
#elif  defined(CEU_ADTS_NEWS_POOL) &&  defined(CEU_ADTS_NEWS_MALLOC)
            if (pool == NULL) {
                ceu_out_realloc(me, 0);
            } else {
                ceu_pool_free(pool, (void*)me);
            }
#elif !defined(CEU_ADTS_NEWS_POOL) &&  defined(CEU_ADTS_NEWS_MALLOC)
            ceu_out_realloc(me, 0);
#endif
}

CEU_BTree* CEU_BTREE_SELECTOR_assert (tceu_app* app, CEU_BTree* me, char* file, int line) {
    ceu_out_assert_msg_ex(me->tag == CEU_BTREE_SELECTOR, "invalid tag", file, line);
    return me;
}

void CEU_BTREE_SELECTOR_free (void* pool, CEU_BTree* me) {
    CEU_BTree_free(pool, me->SELECTOR.first);
    CEU_BTree_free(pool, me->SELECTOR.second);
    /* FREE (before ok_killed) */
#if    defined(CEU_ADTS_NEWS_POOL) && !defined(CEU_ADTS_NEWS_MALLOC)
            ceu_pool_free(pool, (void*)me);
#elif  defined(CEU_ADTS_NEWS_POOL) &&  defined(CEU_ADTS_NEWS_MALLOC)
            if (pool == NULL) {
                ceu_out_realloc(me, 0);
            } else {
                ceu_pool_free(pool, (void*)me);
            }
#elif !defined(CEU_ADTS_NEWS_POOL) &&  defined(CEU_ADTS_NEWS_MALLOC)
            ceu_out_realloc(me, 0);
#endif
}

CEU_BTree* CEU_BTREE_LEAF_assert (tceu_app* app, CEU_BTree* me, char* file, int line) {
    ceu_out_assert_msg_ex(me->tag == CEU_BTREE_LEAF, "invalid tag", file, line);
    return me;
}

void CEU_BTREE_LEAF_free (void* pool, CEU_BTree* me) {
    /* FREE (before ok_killed) */
#if    defined(CEU_ADTS_NEWS_POOL) && !defined(CEU_ADTS_NEWS_MALLOC)
            ceu_pool_free(pool, (void*)me);
#elif  defined(CEU_ADTS_NEWS_POOL) &&  defined(CEU_ADTS_NEWS_MALLOC)
            if (pool == NULL) {
                ceu_out_realloc(me, 0);
            } else {
                ceu_pool_free(pool, (void*)me);
            }
#elif !defined(CEU_ADTS_NEWS_POOL) &&  defined(CEU_ADTS_NEWS_MALLOC)
            ceu_out_realloc(me, 0);
#endif
}

void CEU_BTree_free (void* pool, CEU_BTree* me) {
    switch (me->tag) {
        case CEU_BTREE_NIL:
            /* base case */
            break;
        case CEU_BTREE_SEQUENCE:
            CEU_BTREE_SEQUENCE_free(pool, me);
            break;
        case CEU_BTREE_SELECTOR:
            CEU_BTREE_SELECTOR_free(pool, me);
            break;
        case CEU_BTREE_LEAF:
            CEU_BTREE_LEAF_free(pool, me);
            break;
#ifdef CEU_DEBUG
        default:
            ceu_out_assert_msg(0, "invalid tag");
#endif
    }
}



void CEU__Option__Body_239__ptr_free (void* pool, CEU__Option__Body_239__ptr* me);

CEU__Option__Body_239__ptr* CEU__OPTION__BODY_239__PTR_NIL_assert (tceu_app* app, CEU__Option__Body_239__ptr* me, char* file, int line) {
    ceu_out_assert_msg_ex(me->tag == CEU__OPTION__BODY_239__PTR_NIL, "invalid tag", file, line);
    return me;
}

void CEU__OPTION__BODY_239__PTR_NIL_free (void* pool, CEU__Option__Body_239__ptr* me) {
    /* FREE (before ok_killed) */
#if    defined(CEU_ADTS_NEWS_POOL) && !defined(CEU_ADTS_NEWS_MALLOC)
            ceu_pool_free(pool, (void*)me);
#elif  defined(CEU_ADTS_NEWS_POOL) &&  defined(CEU_ADTS_NEWS_MALLOC)
            if (pool == NULL) {
                ceu_out_realloc(me, 0);
            } else {
                ceu_pool_free(pool, (void*)me);
            }
#elif !defined(CEU_ADTS_NEWS_POOL) &&  defined(CEU_ADTS_NEWS_MALLOC)
            ceu_out_realloc(me, 0);
#endif
}

CEU__Option__Body_239__ptr* CEU__OPTION__BODY_239__PTR_SOME_assert (tceu_app* app, CEU__Option__Body_239__ptr* me, char* file, int line) {
    ceu_out_assert_msg_ex(me->tag == CEU__OPTION__BODY_239__PTR_SOME, "invalid tag", file, line);
    return me;
}

void CEU__OPTION__BODY_239__PTR_SOME_free (void* pool, CEU__Option__Body_239__ptr* me) {
    /* FREE (before ok_killed) */
#if    defined(CEU_ADTS_NEWS_POOL) && !defined(CEU_ADTS_NEWS_MALLOC)
            ceu_pool_free(pool, (void*)me);
#elif  defined(CEU_ADTS_NEWS_POOL) &&  defined(CEU_ADTS_NEWS_MALLOC)
            if (pool == NULL) {
                ceu_out_realloc(me, 0);
            } else {
                ceu_pool_free(pool, (void*)me);
            }
#elif !defined(CEU_ADTS_NEWS_POOL) &&  defined(CEU_ADTS_NEWS_MALLOC)
            ceu_out_realloc(me, 0);
#endif
}

void CEU__Option__Body_239__ptr_free (void* pool, CEU__Option__Body_239__ptr* me) {
    switch (me->tag) {
        case CEU__OPTION__BODY_239__PTR_NIL:
            CEU__OPTION__BODY_239__PTR_NIL_free(pool, me);
            break;
        case CEU__OPTION__BODY_239__PTR_SOME:
            CEU__OPTION__BODY_239__PTR_SOME_free(pool, me);
            break;
#ifdef CEU_DEBUG
        default:
            ceu_out_assert_msg(0, "invalid tag");
#endif
    }
}

CEU__Option__Body_239__ptr CEU__OPTION__BODY_239__PTR_pack (struct CEU_Body_239* ptr) {
    CEU__Option__Body_239__ptr ret;
    if (ptr == NULL) {
        ret.tag = CEU__OPTION__BODY_239__PTR_NIL;
    } else {
        ret.tag = CEU__OPTION__BODY_239__PTR_SOME;
        ret.SOME.v = ptr;
    }
    return ret;
}
#if 0
// TODO: now requires explicit conversions
struct CEU_Body_239* CEU__OPTION__BODY_239__PTR_unpack (CEU__Option__Body_239__ptr me) {
    if (me.tag == CEU__OPTION__BODY_239__PTR_NIL) {
        return NULL;
    } else {
        return me.SOME.v;
    }
}
#endif




/**********************************************************************/

#ifndef CEU_OS_APP
#ifdef CEU_DEBUG
tceu_app* CEU_APP_SIG = NULL;
static void ceu_segfault (int sig_num) {
#ifdef CEU_ORGS
    printf("SEGFAULT on %p : %d\n", CEU_APP_SIG->lst.org, CEU_APP_SIG->lst.lbl);
#else
    printf("SEGFAULT on %d\n", CEU_APP_SIG->lst.lbl);
#endif
    exit(0);
}
#endif
#endif

#ifdef CEU_RUNTESTS
static void ceu_stack_clr () {
    int a[1000];
    memset(a, 0, sizeof(a));
}
#endif

/**********************************************************************/

#ifdef CEU_ORGS

#endif

#ifdef CEU_ORGS
static void _ceu_constr_644 (tceu_app* _ceu_app, tceu_org* __ceu_this, tceu_org* _ceu_org) {
/* NODE: Dcl_constr 644 */
/* NODE: Block 643 */

#line 36 "btree-1.ceu"
    {/* NODE: Stmts 642 */

#line 36 "btree-1.ceu"
    {/* NODE: Set 670 */

#line 36 "btree-1.ceu"
/* SET: . *//* NODE: Op1_& 632 */

#line 36 "btree-1.ceu"
    (((*((CEU_Body_239*)__ceu_this))._bodies)) = (((*((CEU_Body_239*)_ceu_org))._bodies));/* NODE: Set 671 */

#line 36 "btree-1.ceu"
/* SET: . *//* NODE: Op1_&& 637 */

#line 36 "btree-1.ceu"
    (((*((CEU_Body_239*)__ceu_this))._parent)) = (&((CEU_Body_239*)_ceu_org)->_s_16);/* NODE: Set 672 */

#line 36 "btree-1.ceu"
/* SET: . *//* NODE: Op1_&& 164 */

#line 36 "btree-1.ceu"
    #ifdef CEU_ADTS_NEWS_POOL
(&((*((CEU_Body_239*)__ceu_this)).t))->pool = (&((CEU_Body_239*)_ceu_org)->t)->pool;
#endif
(&((*((CEU_Body_239*)__ceu_this)).t))->root = ((((CEU_BTREE_SEQUENCE_assert(_ceu_app, (((CEU_BTree *)(  ((tceu_pool_adts*) (&((CEU_Body_239*)_ceu_org)->t))->root))), __FILE__, __LINE__)->SEQUENCE)).first));

#line 36 "btree-1.ceu"
    }
#line 36 "btree-1.ceu"
/* CLEAR: Block (36) */
#line 36 "btree-1.ceu"
    if (0) {

#line 36 "btree-1.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
}
static void _ceu_constr_754 (tceu_app* _ceu_app, tceu_org* __ceu_this, tceu_org* _ceu_org) {
/* NODE: Dcl_constr 754 */
/* NODE: Block 753 */

#line 40 "btree-1.ceu"
    {/* NODE: Stmts 752 */

#line 40 "btree-1.ceu"
    {/* NODE: Set 780 */

#line 40 "btree-1.ceu"
/* SET: . *//* NODE: Op1_& 742 */

#line 40 "btree-1.ceu"
    (((*((CEU_Body_239*)__ceu_this))._bodies)) = (((*((CEU_Body_239*)_ceu_org))._bodies));/* NODE: Set 781 */

#line 40 "btree-1.ceu"
/* SET: . *//* NODE: Op1_&& 747 */

#line 40 "btree-1.ceu"
    (((*((CEU_Body_239*)__ceu_this))._parent)) = (&((CEU_Body_239*)_ceu_org)->_s_18);/* NODE: Set 782 */

#line 40 "btree-1.ceu"
/* SET: . *//* NODE: Op1_&& 179 */

#line 40 "btree-1.ceu"
    #ifdef CEU_ADTS_NEWS_POOL
(&((*((CEU_Body_239*)__ceu_this)).t))->pool = (&((CEU_Body_239*)_ceu_org)->t)->pool;
#endif
(&((*((CEU_Body_239*)__ceu_this)).t))->root = ((((CEU_BTREE_SEQUENCE_assert(_ceu_app, (((CEU_BTree *)(  ((tceu_pool_adts*) (&((CEU_Body_239*)_ceu_org)->t))->root))), __FILE__, __LINE__)->SEQUENCE)).second));

#line 40 "btree-1.ceu"
    }
#line 40 "btree-1.ceu"
/* CLEAR: Block (40) */
#line 40 "btree-1.ceu"
    if (0) {

#line 40 "btree-1.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
}
static void _ceu_constr_869 (tceu_app* _ceu_app, tceu_org* __ceu_this, tceu_org* _ceu_org) {
/* NODE: Dcl_constr 869 */
/* NODE: Block 868 */

#line 43 "btree-1.ceu"
    {/* NODE: Stmts 867 */

#line 43 "btree-1.ceu"
    {/* NODE: Set 895 */

#line 43 "btree-1.ceu"
/* SET: . *//* NODE: Op1_& 857 */

#line 43 "btree-1.ceu"
    (((*((CEU_Body_239*)__ceu_this))._bodies)) = (((*((CEU_Body_239*)_ceu_org))._bodies));/* NODE: Set 896 */

#line 43 "btree-1.ceu"
/* SET: . *//* NODE: Op1_&& 862 */

#line 43 "btree-1.ceu"
    (((*((CEU_Body_239*)__ceu_this))._parent)) = (&((CEU_Body_239*)_ceu_org)->_s_21);/* NODE: Set 897 */

#line 43 "btree-1.ceu"
/* SET: . *//* NODE: Op1_&& 192 */

#line 43 "btree-1.ceu"
    #ifdef CEU_ADTS_NEWS_POOL
(&((*((CEU_Body_239*)__ceu_this)).t))->pool = (&((CEU_Body_239*)_ceu_org)->t)->pool;
#endif
(&((*((CEU_Body_239*)__ceu_this)).t))->root = ((((CEU_BTREE_SELECTOR_assert(_ceu_app, (((CEU_BTree *)(  ((tceu_pool_adts*) (&((CEU_Body_239*)_ceu_org)->t))->root))), __FILE__, __LINE__)->SELECTOR)).first));

#line 43 "btree-1.ceu"
    }
#line 43 "btree-1.ceu"
/* CLEAR: Block (43) */
#line 43 "btree-1.ceu"
    if (0) {

#line 43 "btree-1.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
}
static void _ceu_constr_984 (tceu_app* _ceu_app, tceu_org* __ceu_this, tceu_org* _ceu_org) {
/* NODE: Dcl_constr 984 */
/* NODE: Block 983 */

#line 47 "btree-1.ceu"
    {/* NODE: Stmts 982 */

#line 47 "btree-1.ceu"
    {/* NODE: Set 1010 */

#line 47 "btree-1.ceu"
/* SET: . *//* NODE: Op1_& 972 */

#line 47 "btree-1.ceu"
    (((*((CEU_Body_239*)__ceu_this))._bodies)) = (((*((CEU_Body_239*)_ceu_org))._bodies));/* NODE: Set 1011 */

#line 47 "btree-1.ceu"
/* SET: . *//* NODE: Op1_&& 977 */

#line 47 "btree-1.ceu"
    (((*((CEU_Body_239*)__ceu_this))._parent)) = (&((CEU_Body_239*)_ceu_org)->_s_24);/* NODE: Set 1012 */

#line 47 "btree-1.ceu"
/* SET: . *//* NODE: Op1_&& 207 */

#line 47 "btree-1.ceu"
    #ifdef CEU_ADTS_NEWS_POOL
(&((*((CEU_Body_239*)__ceu_this)).t))->pool = (&((CEU_Body_239*)_ceu_org)->t)->pool;
#endif
(&((*((CEU_Body_239*)__ceu_this)).t))->root = ((((CEU_BTREE_SELECTOR_assert(_ceu_app, (((CEU_BTree *)(  ((tceu_pool_adts*) (&((CEU_Body_239*)_ceu_org)->t))->root))), __FILE__, __LINE__)->SELECTOR)).second));

#line 47 "btree-1.ceu"
    }
#line 47 "btree-1.ceu"
/* CLEAR: Block (47) */
#line 47 "btree-1.ceu"
    if (0) {

#line 47 "btree-1.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
}
static void _ceu_constr_226 (tceu_app* _ceu_app, tceu_org* __ceu_this, tceu_org* _ceu_org) {
/* NODE: Dcl_constr 226 */
/* NODE: Block 225 */

#line 52 "btree-1.ceu"
    {/* NODE: Stmts 224 */

#line 52 "btree-1.ceu"
    {/* NODE: Set 1088 */

#line 52 "btree-1.ceu"
/* SET: . *//* NODE: Op1_& 222 */

#line 52 "btree-1.ceu"
    (((*((CEU_LeafHandler*)__ceu_this)).leaf)) = (&(((CEU_BTREE_LEAF_assert(_ceu_app, (((CEU_BTree *)(  ((tceu_pool_adts*) (&((CEU_Body_239*)_ceu_org)->t))->root))), __FILE__, __LINE__)->LEAF)).leaf));
#line 52 "btree-1.ceu"
    }
#line 52 "btree-1.ceu"
/* CLEAR: Block (52) */
#line 52 "btree-1.ceu"
    if (0) {

#line 52 "btree-1.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
}
static void _ceu_constr_492 (tceu_app* _ceu_app, tceu_org* __ceu_this, tceu_org* _ceu_org) {
/* NODE: Dcl_constr 492 */
/* NODE: Block 491 */

#line 33 "btree-1.ceu"
    {/* NODE: Stmts 490 */

#line 33 "btree-1.ceu"
    {/* NODE: Set 1148 */

#line 33 "btree-1.ceu"
/* SET: . *//* NODE: Op1_& 480 */

#line 33 "btree-1.ceu"
    (((*((CEU_Body_239*)__ceu_this))._bodies)) = (&((CEU_BTreeTraverse*)_ceu_org)->_pool_239);/* NODE: Set 1149 */

#line 33 "btree-1.ceu"
/* SET: . *//* NODE: Op1_&& 485 */

#line 33 "btree-1.ceu"
    (((*((CEU_Body_239*)__ceu_this))._parent)) = (&((CEU_BTreeTraverse*)_ceu_org)->_s_10);/* NODE: Set 1150 */

#line 33 "btree-1.ceu"
/* SET: . *//* NODE: Op1_&& 449 */

#line 33 "btree-1.ceu"
    #ifdef CEU_ADTS_NEWS_POOL
(&((*((CEU_Body_239*)__ceu_this)).t))->pool = (*((CEU_BTreeTraverse*)_ceu_org)->btree).pool;
#endif
(&((*((CEU_Body_239*)__ceu_this)).t))->root = ((CEU_BTree *)(  ((tceu_pool_adts*) (((CEU_BTreeTraverse*)_ceu_org)->btree))->root));

#line 33 "btree-1.ceu"
    }
#line 33 "btree-1.ceu"
/* CLEAR: Block (33) */
#line 33 "btree-1.ceu"
    if (0) {

#line 33 "btree-1.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
}
static void _ceu_constr_335 (tceu_app* _ceu_app, tceu_org* __ceu_this, tceu_org* _ceu_org) {
/* NODE: Dcl_constr 335 */
/* NODE: Block 334 */

#line 73 "chaser.ceu"
    {/* NODE: Stmts 333 */

#line 73 "chaser.ceu"
    {/* NODE: Set 1259 */

#line 73 "chaser.ceu"
/* SET: . *//* NODE: Op1_& 331 */

#line 73 "chaser.ceu"
    (((*((CEU_BTreeTraverse*)__ceu_this)).btree)) = ((tceu_pool_adts*)(&((CEU_Main*)_ceu_org)->behavior));

#line 73 "chaser.ceu"
    }
#line 73 "chaser.ceu"
/* CLEAR: Block (73) */
#line 73 "chaser.ceu"
    if (0) {

#line 73 "chaser.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
}

#endif

#ifdef CEU_THREADS
/* THREADS_C */

#endif

/* FUNCTIONS_C */


#ifdef CEU_OS_APP
static void* ceu_app_calls (tceu_app* _ceu_app, tceu_nevt evt, void* param) {
    switch (evt) {
        /* STUBS */
        
        /*
        case CEU_IN_XXX:
            return CEU_Main_XXX(param);
        */
        default:;
#ifdef CEU_DEBUG
        ceu_out_log(0, (long)"invalid call\n");
#endif
    }
    return NULL;
}
#endif

static void ceu_app_go (tceu_app* _ceu_app, tceu_evt* _ceu_evt, tceu_org* _ceu_org, tceu_trl* _ceu_trl,
                        tceu_stk* _ceu_stk)
{
    tceu_nlbl _ceu_lbl = _ceu_trl->lbl;

#ifdef CEU_GOTO
_CEU_GOTO_:
#endif

#ifdef CEU_DEBUG
#ifndef CEU_OS_APP
#ifdef CEU_ORGS
    _ceu_app->lst.org = _ceu_org;
#endif
    _ceu_app->lst.trl = _ceu_trl;
    _ceu_app->lst.lbl = _ceu_lbl;
#endif
#ifdef CEU_DEBUG_TRAILS
#ifndef CEU_OS_APP
printf("OK : lbl=%d : org=%p\n", _ceu_lbl, _ceu_org);
#endif
#endif
#endif

#ifdef CEU_RUNTESTS
    ceu_stack_clr();
#endif

    switch (_ceu_lbl) {
        /* NODE: Root 355 */
/* NODE: Dcl_cls 0 */

#line 1 "chaser.ceu"
case Class_Main:;/* NODE: Block 1288 */

#line 1 "chaser.ceu"
    {/* NODE: Stmts 1287 */

#line 1 "chaser.ceu"
    {/* NODE: Block 361 */

#line 1 "chaser.ceu"
    {
#line 1 "chaser.ceu"
    #ifdef CEU_RET

#line 1 "chaser.ceu"
    int __ceu__ret_0;

#line 1 "chaser.ceu"
    #endif
/* NODE: Stmts 360 */

#line 1 "chaser.ceu"
    {/* NODE: Dcl_var 357 */
/* NODE: SetBlock 359 */
/* NODE: Block 353 */

#line 1 "chaser.ceu"
    {/* NODE: Stmts 352 */

#line 1 "chaser.ceu"
    {/* NODE: Stmts 349 */

#line 1 "chaser.ceu"
    {/* NODE: Block 342 */

#line 1 "chaser.ceu"
    /*  FINALIZE */
_ceu_org->trls[ 12 ].evt = CEU_IN__CLEAR;
_ceu_org->trls[ 12 ].lbl = Main_Block__fin_44;

#line 1 "chaser.ceu"
    {
#line 1 "chaser.ceu"
    #ifdef CEU_ADTS_NEWS_POOL
(&((CEU_Main*)_ceu_org)->behavior)->pool = NULL;
#endif

#line 1 "chaser.ceu"
    (&((CEU_Main*)_ceu_org)->behavior)->root = &CEU_BTREE_BASE;

/*  FINALIZE ADT */
_ceu_org->trls[ 0 ].evt = CEU_IN__CLEAR;
_ceu_org->trls[ 0 ].lbl = Main_adt_fin_kill_free_45;

#line 1 "chaser.ceu"
    _ceu_trl = &_ceu_org->trls[ 1 ];
/* NODE: Stmts 340 */

#line 1 "chaser.ceu"
    {/* NODE: Stmts 365 */

#line 1 "chaser.ceu"
    {/* NODE: Dcl_ext 364 */

#line 1 "chaser.ceu"
    }/* NODE: Dcl_adt 11 */
/* NODE: Stmts 414 */

#line 23 "chaser.ceu"
    {
#line 23 "chaser.ceu"
    }/* NODE: Dcl_adt 148 */
/* NODE: Stmts 1211 */

#line 29 "btree-1.ceu"
    {
#line 29 "btree-1.ceu"
    }/* NODE: Stmts 1216 */

#line 60 "chaser.ceu"
    {/* NODE: Dcl_pool 1213 */
/* NODE: Set 1217 */

#line 60 "chaser.ceu"
/* SET: behavior *//* NODE: Adt_constr_root 325 */

#line 61 "chaser.ceu"
    {
#line 61 "chaser.ceu"
    {
    void* __ceu_old = ((CEU_BTree *)(  ((tceu_pool_adts*) (&((CEU_Main*)_ceu_org)->behavior))->root));    /* will kill/free old */

#line 61 "chaser.ceu"
    #ifdef CEU_ADTS_NEWS_POOL
    tceu_org* __ceu_stk_org = _ceu_org;
#endif
/* NODE: Adt_constr_one 324 */

#line 61 "chaser.ceu"
    CEU_BTree* __ceu_adt_324;

#line 61 "chaser.ceu"
    #if defined(CEU_ADTS_NEWS_MALLOC) && defined(CEU_ADTS_NEWS_POOL)
if (((&((CEU_Main*)_ceu_org)->behavior)->pool) == NULL) {
    __ceu_adt_324 = (CEU_BTree*) ceu_out_realloc(NULL, sizeof(CEU_BTree));
} else {
    __ceu_adt_324 = (CEU_BTree*) ceu_pool_alloc((tceu_pool*)((&((CEU_Main*)_ceu_org)->behavior)->pool));
}
#elif defined(CEU_ADTS_NEWS_MALLOC)
    __ceu_adt_324 = (CEU_BTree*) ceu_out_realloc(NULL, sizeof(CEU_BTree));
#elif defined(CEU_ADTS_NEWS_POOL)
    __ceu_adt_324 = (CEU_BTree*) ceu_pool_alloc((tceu_pool*)((&((CEU_Main*)_ceu_org)->behavior)->pool));
#endif

#line 61 "chaser.ceu"
    if (__ceu_adt_324 == NULL) {
    __ceu_adt_324 = &CEU_BTREE_BASE;
} else  /* rely on {,} that follows */

#line 61 "chaser.ceu"
    {/* NODE: ExpList 323 */
/* NODE: Adt_constr_one 262 */

#line 62 "chaser.ceu"
    CEU_BTree* __ceu_adt_262;

#line 62 "chaser.ceu"
    #if defined(CEU_ADTS_NEWS_MALLOC) && defined(CEU_ADTS_NEWS_POOL)
if (((&((CEU_Main*)_ceu_org)->behavior)->pool) == NULL) {
    __ceu_adt_262 = (CEU_BTree*) ceu_out_realloc(NULL, sizeof(CEU_BTree));
} else {
    __ceu_adt_262 = (CEU_BTree*) ceu_pool_alloc((tceu_pool*)((&((CEU_Main*)_ceu_org)->behavior)->pool));
}
#elif defined(CEU_ADTS_NEWS_MALLOC)
    __ceu_adt_262 = (CEU_BTree*) ceu_out_realloc(NULL, sizeof(CEU_BTree));
#elif defined(CEU_ADTS_NEWS_POOL)
    __ceu_adt_262 = (CEU_BTree*) ceu_pool_alloc((tceu_pool*)((&((CEU_Main*)_ceu_org)->behavior)->pool));
#endif

#line 62 "chaser.ceu"
    if (__ceu_adt_262 == NULL) {
    __ceu_adt_262 = &CEU_BTREE_BASE;
} else  /* rely on {,} that follows */

#line 62 "chaser.ceu"
    {/* NODE: ExpList 261 */
/* NODE: Adt_constr_one 254 */

#line 62 "chaser.ceu"
    CEU_BTree* __ceu_adt_254;

#line 62 "chaser.ceu"
    #if defined(CEU_ADTS_NEWS_MALLOC) && defined(CEU_ADTS_NEWS_POOL)
if (((&((CEU_Main*)_ceu_org)->behavior)->pool) == NULL) {
    __ceu_adt_254 = (CEU_BTree*) ceu_out_realloc(NULL, sizeof(CEU_BTree));
} else {
    __ceu_adt_254 = (CEU_BTree*) ceu_pool_alloc((tceu_pool*)((&((CEU_Main*)_ceu_org)->behavior)->pool));
}
#elif defined(CEU_ADTS_NEWS_MALLOC)
    __ceu_adt_254 = (CEU_BTree*) ceu_out_realloc(NULL, sizeof(CEU_BTree));
#elif defined(CEU_ADTS_NEWS_POOL)
    __ceu_adt_254 = (CEU_BTree*) ceu_pool_alloc((tceu_pool*)((&((CEU_Main*)_ceu_org)->behavior)->pool));
#endif

#line 62 "chaser.ceu"
    if (__ceu_adt_254 == NULL) {
    __ceu_adt_254 = &CEU_BTREE_BASE;
} else  /* rely on {,} that follows */

#line 62 "chaser.ceu"
    {/* NODE: ExpList 253 */
/* NODE: Adt_constr_one 252 */

#line 62 "chaser.ceu"
    CEU_Leaf __ceu_adt_252;

#line 62 "chaser.ceu"
    {/* NODE: ExpList 251 */

#line 62 "chaser.ceu"
    __ceu_adt_252.tag = CEU_LEAF_SENSERIGHT;
#line 62 "chaser.ceu"
    }
#line 62 "chaser.ceu"
    __ceu_adt_254->tag = CEU_BTREE_LEAF;
#line 62 "chaser.ceu"
    __ceu_adt_254->LEAF.leaf = __ceu_adt_252;
#line 62 "chaser.ceu"
    }/* NODE: Adt_constr_one 260 */

#line 62 "chaser.ceu"
    CEU_BTree* __ceu_adt_260;

#line 62 "chaser.ceu"
    #if defined(CEU_ADTS_NEWS_MALLOC) && defined(CEU_ADTS_NEWS_POOL)
if (((&((CEU_Main*)_ceu_org)->behavior)->pool) == NULL) {
    __ceu_adt_260 = (CEU_BTree*) ceu_out_realloc(NULL, sizeof(CEU_BTree));
} else {
    __ceu_adt_260 = (CEU_BTree*) ceu_pool_alloc((tceu_pool*)((&((CEU_Main*)_ceu_org)->behavior)->pool));
}
#elif defined(CEU_ADTS_NEWS_MALLOC)
    __ceu_adt_260 = (CEU_BTree*) ceu_out_realloc(NULL, sizeof(CEU_BTree));
#elif defined(CEU_ADTS_NEWS_POOL)
    __ceu_adt_260 = (CEU_BTree*) ceu_pool_alloc((tceu_pool*)((&((CEU_Main*)_ceu_org)->behavior)->pool));
#endif

#line 62 "chaser.ceu"
    if (__ceu_adt_260 == NULL) {
    __ceu_adt_260 = &CEU_BTREE_BASE;
} else  /* rely on {,} that follows */

#line 62 "chaser.ceu"
    {/* NODE: ExpList 259 */
/* NODE: Adt_constr_one 258 */

#line 62 "chaser.ceu"
    CEU_Leaf __ceu_adt_258;

#line 62 "chaser.ceu"
    {/* NODE: ExpList 257 */

#line 62 "chaser.ceu"
    __ceu_adt_258.tag = CEU_LEAF_GORIGHT;
#line 62 "chaser.ceu"
    }
#line 62 "chaser.ceu"
    __ceu_adt_260->tag = CEU_BTREE_LEAF;
#line 62 "chaser.ceu"
    __ceu_adt_260->LEAF.leaf = __ceu_adt_258;
#line 62 "chaser.ceu"
    }
#line 62 "chaser.ceu"
    __ceu_adt_262->tag = CEU_BTREE_SEQUENCE;
#line 62 "chaser.ceu"
    __ceu_adt_262->SEQUENCE.first = __ceu_adt_254;
#line 62 "chaser.ceu"
    __ceu_adt_262->SEQUENCE.second = __ceu_adt_260;
#line 62 "chaser.ceu"
    }/* NODE: Adt_constr_one 322 */

#line 63 "chaser.ceu"
    CEU_BTree* __ceu_adt_322;

#line 63 "chaser.ceu"
    #if defined(CEU_ADTS_NEWS_MALLOC) && defined(CEU_ADTS_NEWS_POOL)
if (((&((CEU_Main*)_ceu_org)->behavior)->pool) == NULL) {
    __ceu_adt_322 = (CEU_BTree*) ceu_out_realloc(NULL, sizeof(CEU_BTree));
} else {
    __ceu_adt_322 = (CEU_BTree*) ceu_pool_alloc((tceu_pool*)((&((CEU_Main*)_ceu_org)->behavior)->pool));
}
#elif defined(CEU_ADTS_NEWS_MALLOC)
    __ceu_adt_322 = (CEU_BTree*) ceu_out_realloc(NULL, sizeof(CEU_BTree));
#elif defined(CEU_ADTS_NEWS_POOL)
    __ceu_adt_322 = (CEU_BTree*) ceu_pool_alloc((tceu_pool*)((&((CEU_Main*)_ceu_org)->behavior)->pool));
#endif

#line 63 "chaser.ceu"
    if (__ceu_adt_322 == NULL) {
    __ceu_adt_322 = &CEU_BTREE_BASE;
} else  /* rely on {,} that follows */

#line 63 "chaser.ceu"
    {/* NODE: ExpList 321 */
/* NODE: Adt_constr_one 278 */

#line 64 "chaser.ceu"
    CEU_BTree* __ceu_adt_278;

#line 64 "chaser.ceu"
    #if defined(CEU_ADTS_NEWS_MALLOC) && defined(CEU_ADTS_NEWS_POOL)
if (((&((CEU_Main*)_ceu_org)->behavior)->pool) == NULL) {
    __ceu_adt_278 = (CEU_BTree*) ceu_out_realloc(NULL, sizeof(CEU_BTree));
} else {
    __ceu_adt_278 = (CEU_BTree*) ceu_pool_alloc((tceu_pool*)((&((CEU_Main*)_ceu_org)->behavior)->pool));
}
#elif defined(CEU_ADTS_NEWS_MALLOC)
    __ceu_adt_278 = (CEU_BTree*) ceu_out_realloc(NULL, sizeof(CEU_BTree));
#elif defined(CEU_ADTS_NEWS_POOL)
    __ceu_adt_278 = (CEU_BTree*) ceu_pool_alloc((tceu_pool*)((&((CEU_Main*)_ceu_org)->behavior)->pool));
#endif

#line 64 "chaser.ceu"
    if (__ceu_adt_278 == NULL) {
    __ceu_adt_278 = &CEU_BTREE_BASE;
} else  /* rely on {,} that follows */

#line 64 "chaser.ceu"
    {/* NODE: ExpList 277 */
/* NODE: Adt_constr_one 270 */

#line 64 "chaser.ceu"
    CEU_BTree* __ceu_adt_270;

#line 64 "chaser.ceu"
    #if defined(CEU_ADTS_NEWS_MALLOC) && defined(CEU_ADTS_NEWS_POOL)
if (((&((CEU_Main*)_ceu_org)->behavior)->pool) == NULL) {
    __ceu_adt_270 = (CEU_BTree*) ceu_out_realloc(NULL, sizeof(CEU_BTree));
} else {
    __ceu_adt_270 = (CEU_BTree*) ceu_pool_alloc((tceu_pool*)((&((CEU_Main*)_ceu_org)->behavior)->pool));
}
#elif defined(CEU_ADTS_NEWS_MALLOC)
    __ceu_adt_270 = (CEU_BTree*) ceu_out_realloc(NULL, sizeof(CEU_BTree));
#elif defined(CEU_ADTS_NEWS_POOL)
    __ceu_adt_270 = (CEU_BTree*) ceu_pool_alloc((tceu_pool*)((&((CEU_Main*)_ceu_org)->behavior)->pool));
#endif

#line 64 "chaser.ceu"
    if (__ceu_adt_270 == NULL) {
    __ceu_adt_270 = &CEU_BTREE_BASE;
} else  /* rely on {,} that follows */

#line 64 "chaser.ceu"
    {/* NODE: ExpList 269 */
/* NODE: Adt_constr_one 268 */

#line 64 "chaser.ceu"
    CEU_Leaf __ceu_adt_268;

#line 64 "chaser.ceu"
    {/* NODE: ExpList 267 */

#line 64 "chaser.ceu"
    __ceu_adt_268.tag = CEU_LEAF_SENSELEFT;
#line 64 "chaser.ceu"
    }
#line 64 "chaser.ceu"
    __ceu_adt_270->tag = CEU_BTREE_LEAF;
#line 64 "chaser.ceu"
    __ceu_adt_270->LEAF.leaf = __ceu_adt_268;
#line 64 "chaser.ceu"
    }/* NODE: Adt_constr_one 276 */

#line 64 "chaser.ceu"
    CEU_BTree* __ceu_adt_276;

#line 64 "chaser.ceu"
    #if defined(CEU_ADTS_NEWS_MALLOC) && defined(CEU_ADTS_NEWS_POOL)
if (((&((CEU_Main*)_ceu_org)->behavior)->pool) == NULL) {
    __ceu_adt_276 = (CEU_BTree*) ceu_out_realloc(NULL, sizeof(CEU_BTree));
} else {
    __ceu_adt_276 = (CEU_BTree*) ceu_pool_alloc((tceu_pool*)((&((CEU_Main*)_ceu_org)->behavior)->pool));
}
#elif defined(CEU_ADTS_NEWS_MALLOC)
    __ceu_adt_276 = (CEU_BTree*) ceu_out_realloc(NULL, sizeof(CEU_BTree));
#elif defined(CEU_ADTS_NEWS_POOL)
    __ceu_adt_276 = (CEU_BTree*) ceu_pool_alloc((tceu_pool*)((&((CEU_Main*)_ceu_org)->behavior)->pool));
#endif

#line 64 "chaser.ceu"
    if (__ceu_adt_276 == NULL) {
    __ceu_adt_276 = &CEU_BTREE_BASE;
} else  /* rely on {,} that follows */

#line 64 "chaser.ceu"
    {/* NODE: ExpList 275 */
/* NODE: Adt_constr_one 274 */

#line 64 "chaser.ceu"
    CEU_Leaf __ceu_adt_274;

#line 64 "chaser.ceu"
    {/* NODE: ExpList 273 */

#line 64 "chaser.ceu"
    __ceu_adt_274.tag = CEU_LEAF_GOLEFT;
#line 64 "chaser.ceu"
    }
#line 64 "chaser.ceu"
    __ceu_adt_276->tag = CEU_BTREE_LEAF;
#line 64 "chaser.ceu"
    __ceu_adt_276->LEAF.leaf = __ceu_adt_274;
#line 64 "chaser.ceu"
    }
#line 64 "chaser.ceu"
    __ceu_adt_278->tag = CEU_BTREE_SEQUENCE;
#line 64 "chaser.ceu"
    __ceu_adt_278->SEQUENCE.first = __ceu_adt_270;
#line 64 "chaser.ceu"
    __ceu_adt_278->SEQUENCE.second = __ceu_adt_276;
#line 64 "chaser.ceu"
    }/* NODE: Adt_constr_one 320 */

#line 65 "chaser.ceu"
    CEU_BTree* __ceu_adt_320;

#line 65 "chaser.ceu"
    #if defined(CEU_ADTS_NEWS_MALLOC) && defined(CEU_ADTS_NEWS_POOL)
if (((&((CEU_Main*)_ceu_org)->behavior)->pool) == NULL) {
    __ceu_adt_320 = (CEU_BTree*) ceu_out_realloc(NULL, sizeof(CEU_BTree));
} else {
    __ceu_adt_320 = (CEU_BTree*) ceu_pool_alloc((tceu_pool*)((&((CEU_Main*)_ceu_org)->behavior)->pool));
}
#elif defined(CEU_ADTS_NEWS_MALLOC)
    __ceu_adt_320 = (CEU_BTree*) ceu_out_realloc(NULL, sizeof(CEU_BTree));
#elif defined(CEU_ADTS_NEWS_POOL)
    __ceu_adt_320 = (CEU_BTree*) ceu_pool_alloc((tceu_pool*)((&((CEU_Main*)_ceu_org)->behavior)->pool));
#endif

#line 65 "chaser.ceu"
    if (__ceu_adt_320 == NULL) {
    __ceu_adt_320 = &CEU_BTREE_BASE;
} else  /* rely on {,} that follows */

#line 65 "chaser.ceu"
    {/* NODE: ExpList 319 */
/* NODE: Adt_constr_one 294 */

#line 66 "chaser.ceu"
    CEU_BTree* __ceu_adt_294;

#line 66 "chaser.ceu"
    #if defined(CEU_ADTS_NEWS_MALLOC) && defined(CEU_ADTS_NEWS_POOL)
if (((&((CEU_Main*)_ceu_org)->behavior)->pool) == NULL) {
    __ceu_adt_294 = (CEU_BTree*) ceu_out_realloc(NULL, sizeof(CEU_BTree));
} else {
    __ceu_adt_294 = (CEU_BTree*) ceu_pool_alloc((tceu_pool*)((&((CEU_Main*)_ceu_org)->behavior)->pool));
}
#elif defined(CEU_ADTS_NEWS_MALLOC)
    __ceu_adt_294 = (CEU_BTree*) ceu_out_realloc(NULL, sizeof(CEU_BTree));
#elif defined(CEU_ADTS_NEWS_POOL)
    __ceu_adt_294 = (CEU_BTree*) ceu_pool_alloc((tceu_pool*)((&((CEU_Main*)_ceu_org)->behavior)->pool));
#endif

#line 66 "chaser.ceu"
    if (__ceu_adt_294 == NULL) {
    __ceu_adt_294 = &CEU_BTREE_BASE;
} else  /* rely on {,} that follows */

#line 66 "chaser.ceu"
    {/* NODE: ExpList 293 */
/* NODE: Adt_constr_one 286 */

#line 66 "chaser.ceu"
    CEU_BTree* __ceu_adt_286;

#line 66 "chaser.ceu"
    #if defined(CEU_ADTS_NEWS_MALLOC) && defined(CEU_ADTS_NEWS_POOL)
if (((&((CEU_Main*)_ceu_org)->behavior)->pool) == NULL) {
    __ceu_adt_286 = (CEU_BTree*) ceu_out_realloc(NULL, sizeof(CEU_BTree));
} else {
    __ceu_adt_286 = (CEU_BTree*) ceu_pool_alloc((tceu_pool*)((&((CEU_Main*)_ceu_org)->behavior)->pool));
}
#elif defined(CEU_ADTS_NEWS_MALLOC)
    __ceu_adt_286 = (CEU_BTree*) ceu_out_realloc(NULL, sizeof(CEU_BTree));
#elif defined(CEU_ADTS_NEWS_POOL)
    __ceu_adt_286 = (CEU_BTree*) ceu_pool_alloc((tceu_pool*)((&((CEU_Main*)_ceu_org)->behavior)->pool));
#endif

#line 66 "chaser.ceu"
    if (__ceu_adt_286 == NULL) {
    __ceu_adt_286 = &CEU_BTREE_BASE;
} else  /* rely on {,} that follows */

#line 66 "chaser.ceu"
    {/* NODE: ExpList 285 */
/* NODE: Adt_constr_one 284 */

#line 66 "chaser.ceu"
    CEU_Leaf __ceu_adt_284;

#line 66 "chaser.ceu"
    {/* NODE: ExpList 283 */

#line 66 "chaser.ceu"
    __ceu_adt_284.tag = CEU_LEAF_SENSEUP;
#line 66 "chaser.ceu"
    }
#line 66 "chaser.ceu"
    __ceu_adt_286->tag = CEU_BTREE_LEAF;
#line 66 "chaser.ceu"
    __ceu_adt_286->LEAF.leaf = __ceu_adt_284;
#line 66 "chaser.ceu"
    }/* NODE: Adt_constr_one 292 */

#line 66 "chaser.ceu"
    CEU_BTree* __ceu_adt_292;

#line 66 "chaser.ceu"
    #if defined(CEU_ADTS_NEWS_MALLOC) && defined(CEU_ADTS_NEWS_POOL)
if (((&((CEU_Main*)_ceu_org)->behavior)->pool) == NULL) {
    __ceu_adt_292 = (CEU_BTree*) ceu_out_realloc(NULL, sizeof(CEU_BTree));
} else {
    __ceu_adt_292 = (CEU_BTree*) ceu_pool_alloc((tceu_pool*)((&((CEU_Main*)_ceu_org)->behavior)->pool));
}
#elif defined(CEU_ADTS_NEWS_MALLOC)
    __ceu_adt_292 = (CEU_BTree*) ceu_out_realloc(NULL, sizeof(CEU_BTree));
#elif defined(CEU_ADTS_NEWS_POOL)
    __ceu_adt_292 = (CEU_BTree*) ceu_pool_alloc((tceu_pool*)((&((CEU_Main*)_ceu_org)->behavior)->pool));
#endif

#line 66 "chaser.ceu"
    if (__ceu_adt_292 == NULL) {
    __ceu_adt_292 = &CEU_BTREE_BASE;
} else  /* rely on {,} that follows */

#line 66 "chaser.ceu"
    {/* NODE: ExpList 291 */
/* NODE: Adt_constr_one 290 */

#line 66 "chaser.ceu"
    CEU_Leaf __ceu_adt_290;

#line 66 "chaser.ceu"
    {/* NODE: ExpList 289 */

#line 66 "chaser.ceu"
    __ceu_adt_290.tag = CEU_LEAF_GOUP;
#line 66 "chaser.ceu"
    }
#line 66 "chaser.ceu"
    __ceu_adt_292->tag = CEU_BTREE_LEAF;
#line 66 "chaser.ceu"
    __ceu_adt_292->LEAF.leaf = __ceu_adt_290;
#line 66 "chaser.ceu"
    }
#line 66 "chaser.ceu"
    __ceu_adt_294->tag = CEU_BTREE_SEQUENCE;
#line 66 "chaser.ceu"
    __ceu_adt_294->SEQUENCE.first = __ceu_adt_286;
#line 66 "chaser.ceu"
    __ceu_adt_294->SEQUENCE.second = __ceu_adt_292;
#line 66 "chaser.ceu"
    }/* NODE: Adt_constr_one 318 */

#line 67 "chaser.ceu"
    CEU_BTree* __ceu_adt_318;

#line 67 "chaser.ceu"
    #if defined(CEU_ADTS_NEWS_MALLOC) && defined(CEU_ADTS_NEWS_POOL)
if (((&((CEU_Main*)_ceu_org)->behavior)->pool) == NULL) {
    __ceu_adt_318 = (CEU_BTree*) ceu_out_realloc(NULL, sizeof(CEU_BTree));
} else {
    __ceu_adt_318 = (CEU_BTree*) ceu_pool_alloc((tceu_pool*)((&((CEU_Main*)_ceu_org)->behavior)->pool));
}
#elif defined(CEU_ADTS_NEWS_MALLOC)
    __ceu_adt_318 = (CEU_BTree*) ceu_out_realloc(NULL, sizeof(CEU_BTree));
#elif defined(CEU_ADTS_NEWS_POOL)
    __ceu_adt_318 = (CEU_BTree*) ceu_pool_alloc((tceu_pool*)((&((CEU_Main*)_ceu_org)->behavior)->pool));
#endif

#line 67 "chaser.ceu"
    if (__ceu_adt_318 == NULL) {
    __ceu_adt_318 = &CEU_BTREE_BASE;
} else  /* rely on {,} that follows */

#line 67 "chaser.ceu"
    {/* NODE: ExpList 317 */
/* NODE: Adt_constr_one 310 */

#line 68 "chaser.ceu"
    CEU_BTree* __ceu_adt_310;

#line 68 "chaser.ceu"
    #if defined(CEU_ADTS_NEWS_MALLOC) && defined(CEU_ADTS_NEWS_POOL)
if (((&((CEU_Main*)_ceu_org)->behavior)->pool) == NULL) {
    __ceu_adt_310 = (CEU_BTree*) ceu_out_realloc(NULL, sizeof(CEU_BTree));
} else {
    __ceu_adt_310 = (CEU_BTree*) ceu_pool_alloc((tceu_pool*)((&((CEU_Main*)_ceu_org)->behavior)->pool));
}
#elif defined(CEU_ADTS_NEWS_MALLOC)
    __ceu_adt_310 = (CEU_BTree*) ceu_out_realloc(NULL, sizeof(CEU_BTree));
#elif defined(CEU_ADTS_NEWS_POOL)
    __ceu_adt_310 = (CEU_BTree*) ceu_pool_alloc((tceu_pool*)((&((CEU_Main*)_ceu_org)->behavior)->pool));
#endif

#line 68 "chaser.ceu"
    if (__ceu_adt_310 == NULL) {
    __ceu_adt_310 = &CEU_BTREE_BASE;
} else  /* rely on {,} that follows */

#line 68 "chaser.ceu"
    {/* NODE: ExpList 309 */
/* NODE: Adt_constr_one 302 */

#line 68 "chaser.ceu"
    CEU_BTree* __ceu_adt_302;

#line 68 "chaser.ceu"
    #if defined(CEU_ADTS_NEWS_MALLOC) && defined(CEU_ADTS_NEWS_POOL)
if (((&((CEU_Main*)_ceu_org)->behavior)->pool) == NULL) {
    __ceu_adt_302 = (CEU_BTree*) ceu_out_realloc(NULL, sizeof(CEU_BTree));
} else {
    __ceu_adt_302 = (CEU_BTree*) ceu_pool_alloc((tceu_pool*)((&((CEU_Main*)_ceu_org)->behavior)->pool));
}
#elif defined(CEU_ADTS_NEWS_MALLOC)
    __ceu_adt_302 = (CEU_BTree*) ceu_out_realloc(NULL, sizeof(CEU_BTree));
#elif defined(CEU_ADTS_NEWS_POOL)
    __ceu_adt_302 = (CEU_BTree*) ceu_pool_alloc((tceu_pool*)((&((CEU_Main*)_ceu_org)->behavior)->pool));
#endif

#line 68 "chaser.ceu"
    if (__ceu_adt_302 == NULL) {
    __ceu_adt_302 = &CEU_BTREE_BASE;
} else  /* rely on {,} that follows */

#line 68 "chaser.ceu"
    {/* NODE: ExpList 301 */
/* NODE: Adt_constr_one 300 */

#line 68 "chaser.ceu"
    CEU_Leaf __ceu_adt_300;

#line 68 "chaser.ceu"
    {/* NODE: ExpList 299 */

#line 68 "chaser.ceu"
    __ceu_adt_300.tag = CEU_LEAF_SENSEDOWN;
#line 68 "chaser.ceu"
    }
#line 68 "chaser.ceu"
    __ceu_adt_302->tag = CEU_BTREE_LEAF;
#line 68 "chaser.ceu"
    __ceu_adt_302->LEAF.leaf = __ceu_adt_300;
#line 68 "chaser.ceu"
    }/* NODE: Adt_constr_one 308 */

#line 68 "chaser.ceu"
    CEU_BTree* __ceu_adt_308;

#line 68 "chaser.ceu"
    #if defined(CEU_ADTS_NEWS_MALLOC) && defined(CEU_ADTS_NEWS_POOL)
if (((&((CEU_Main*)_ceu_org)->behavior)->pool) == NULL) {
    __ceu_adt_308 = (CEU_BTree*) ceu_out_realloc(NULL, sizeof(CEU_BTree));
} else {
    __ceu_adt_308 = (CEU_BTree*) ceu_pool_alloc((tceu_pool*)((&((CEU_Main*)_ceu_org)->behavior)->pool));
}
#elif defined(CEU_ADTS_NEWS_MALLOC)
    __ceu_adt_308 = (CEU_BTree*) ceu_out_realloc(NULL, sizeof(CEU_BTree));
#elif defined(CEU_ADTS_NEWS_POOL)
    __ceu_adt_308 = (CEU_BTree*) ceu_pool_alloc((tceu_pool*)((&((CEU_Main*)_ceu_org)->behavior)->pool));
#endif

#line 68 "chaser.ceu"
    if (__ceu_adt_308 == NULL) {
    __ceu_adt_308 = &CEU_BTREE_BASE;
} else  /* rely on {,} that follows */

#line 68 "chaser.ceu"
    {/* NODE: ExpList 307 */
/* NODE: Adt_constr_one 306 */

#line 68 "chaser.ceu"
    CEU_Leaf __ceu_adt_306;

#line 68 "chaser.ceu"
    {/* NODE: ExpList 305 */

#line 68 "chaser.ceu"
    __ceu_adt_306.tag = CEU_LEAF_GODOWN;
#line 68 "chaser.ceu"
    }
#line 68 "chaser.ceu"
    __ceu_adt_308->tag = CEU_BTREE_LEAF;
#line 68 "chaser.ceu"
    __ceu_adt_308->LEAF.leaf = __ceu_adt_306;
#line 68 "chaser.ceu"
    }
#line 68 "chaser.ceu"
    __ceu_adt_310->tag = CEU_BTREE_SEQUENCE;
#line 68 "chaser.ceu"
    __ceu_adt_310->SEQUENCE.first = __ceu_adt_302;
#line 68 "chaser.ceu"
    __ceu_adt_310->SEQUENCE.second = __ceu_adt_308;
#line 68 "chaser.ceu"
    }/* NODE: Adt_constr_one 316 */

#line 69 "chaser.ceu"
    CEU_BTree* __ceu_adt_316;

#line 69 "chaser.ceu"
    #if defined(CEU_ADTS_NEWS_MALLOC) && defined(CEU_ADTS_NEWS_POOL)
if (((&((CEU_Main*)_ceu_org)->behavior)->pool) == NULL) {
    __ceu_adt_316 = (CEU_BTree*) ceu_out_realloc(NULL, sizeof(CEU_BTree));
} else {
    __ceu_adt_316 = (CEU_BTree*) ceu_pool_alloc((tceu_pool*)((&((CEU_Main*)_ceu_org)->behavior)->pool));
}
#elif defined(CEU_ADTS_NEWS_MALLOC)
    __ceu_adt_316 = (CEU_BTree*) ceu_out_realloc(NULL, sizeof(CEU_BTree));
#elif defined(CEU_ADTS_NEWS_POOL)
    __ceu_adt_316 = (CEU_BTree*) ceu_pool_alloc((tceu_pool*)((&((CEU_Main*)_ceu_org)->behavior)->pool));
#endif

#line 69 "chaser.ceu"
    if (__ceu_adt_316 == NULL) {
    __ceu_adt_316 = &CEU_BTREE_BASE;
} else  /* rely on {,} that follows */

#line 69 "chaser.ceu"
    {/* NODE: ExpList 315 */
/* NODE: Adt_constr_one 314 */

#line 69 "chaser.ceu"
    CEU_Leaf __ceu_adt_314;

#line 69 "chaser.ceu"
    {/* NODE: ExpList 313 */

#line 69 "chaser.ceu"
    __ceu_adt_314.tag = CEU_LEAF_SKIP;
#line 69 "chaser.ceu"
    }
#line 69 "chaser.ceu"
    __ceu_adt_316->tag = CEU_BTREE_LEAF;
#line 69 "chaser.ceu"
    __ceu_adt_316->LEAF.leaf = __ceu_adt_314;
#line 69 "chaser.ceu"
    }
#line 67 "chaser.ceu"
    __ceu_adt_318->tag = CEU_BTREE_SELECTOR;
#line 67 "chaser.ceu"
    __ceu_adt_318->SELECTOR.first = __ceu_adt_310;
#line 67 "chaser.ceu"
    __ceu_adt_318->SELECTOR.second = __ceu_adt_316;
#line 67 "chaser.ceu"
    }
#line 65 "chaser.ceu"
    __ceu_adt_320->tag = CEU_BTREE_SELECTOR;
#line 65 "chaser.ceu"
    __ceu_adt_320->SELECTOR.first = __ceu_adt_294;
#line 65 "chaser.ceu"
    __ceu_adt_320->SELECTOR.second = __ceu_adt_318;
#line 65 "chaser.ceu"
    }
#line 63 "chaser.ceu"
    __ceu_adt_322->tag = CEU_BTREE_SELECTOR;
#line 63 "chaser.ceu"
    __ceu_adt_322->SELECTOR.first = __ceu_adt_278;
#line 63 "chaser.ceu"
    __ceu_adt_322->SELECTOR.second = __ceu_adt_320;
#line 63 "chaser.ceu"
    }
#line 61 "chaser.ceu"
    __ceu_adt_324->tag = CEU_BTREE_SELECTOR;
#line 61 "chaser.ceu"
    __ceu_adt_324->SELECTOR.first = __ceu_adt_262;
#line 61 "chaser.ceu"
    __ceu_adt_324->SELECTOR.second = __ceu_adt_322;
#line 61 "chaser.ceu"
    }
#line 61 "chaser.ceu"
    (  ((tceu_pool_adts*) (&((CEU_Main*)_ceu_org)->behavior))->root) = __ceu_adt_324;

#line 61 "chaser.ceu"
                         /* 3. free */
    CEU_BTree_free(NULL, __ceu_old);

#line 61 "chaser.ceu"
    
#ifdef CEU_ADTS_AWAIT_BTree
    /* OK_KILLED (after free) */        /* 4. kill */
{
    tceu_stk stk_ = { NULL, _ceu_org, 1, 11, {} };
    if (setjmp(stk_.jmp) != 0) {
#ifdef CEU_ORGS
        _ceu_org = _ceu_app->stk_jmp.org;
#endif
        _ceu_trl = _ceu_app->stk_jmp.trl;

#line 61 "chaser.ceu"
    _ceu_lbl = _ceu_app->stk_jmp.lbl;
goto _CEU_GOTO_;

#line 61 "chaser.ceu"
        }

    /* SETJMP: mutating an adt
     * The mutation frees a subtree that might awake a par/or enclosing the 
     * call point.
     */
    {
        tceu_evt evt;
                 evt.id = CEU_IN__ok_killed;
                 evt.param = &__ceu_old;
        _ceu_stk->up = &stk_;
        ceu_sys_go_ex(_ceu_app, &evt, &stk_,
                      _ceu_app->data, &_ceu_app->data->trls[0], NULL);
        _ceu_stk->up = NULL;
    }
}
#endif

#line 61 "chaser.ceu"
    }

#line 61 "chaser.ceu"
    }
#line 60 "chaser.ceu"
    }/* NODE: Block 1224 */

#line 71 "chaser.ceu"
    {/* NODE: Stmts 1223 */

#line 71 "chaser.ceu"
    {/* NODE: Stmts 1222 */

#line 71 "chaser.ceu"
    {
#line 71 "chaser.ceu"
    }/* NODE: Loop 1221 */

#line 71 "chaser.ceu"
    for (;;) {
/* NODE: Block 338 */

#line 72 "chaser.ceu"
    {/* NODE: Stmts 337 */

#line 72 "chaser.ceu"
    {/* NODE: Stmts 1251 */

#line 71 "chaser.ceu"
    {/* NODE: Nothing 1225 */
/* NODE: Await 1218 */

#line 71 "chaser.ceu"
    _CEU_NO_1218_:
if (0) { goto _CEU_NO_1218_; /* avoids "not used" warning */ }

#line 71 "chaser.ceu"
    _ceu_trl->evt = CEU_IN_TICK;
_ceu_trl->lbl = Main_Awake_TICK_41;
_ceu_trl->seqno = _ceu_app->seqno;

#line 71 "chaser.ceu"
    return;

case Main_Awake_TICK_41:;

#line 71 "chaser.ceu"
    #ifdef CEU_DEBUG_TRAILS
#ifndef CEU_OS
printf("\tOK!\n");
#endif
#endif
/* NODE: Nothing 1382 */
/* NODE: Nothing 1383 */

#line 71 "chaser.ceu"
    }/* NODE: Do 1258 */
/* NODE: Block 1257 */

#line 72 "chaser.ceu"
    {
#line 72 "chaser.ceu"
    #ifdef CEU_ORGS
_ceu_org->trls[ 1 ].evt = CEU_IN__ORG;
_ceu_org->trls[ 1 ].org = NULL;
#endif

#line 72 "chaser.ceu"
    _ceu_trl = &_ceu_org->trls[ 2 ];
/* NODE: Stmts 1256 */

#line 72 "chaser.ceu"
    {/* NODE: Dcl_var 1255 */

#line 72 "chaser.ceu"
/* start org: _org_336 */
#line 72 "chaser.ceu"
        /* resets org memory and starts org.trail[0]=Class_XXX */
    /* TODO: BUG: _ceu_org is not necessarily the parent for pool allocations */
    ceu_out_org_init(_ceu_app, ((tceu_org*) &(((CEU_Main*)_ceu_org)->_org_336_7)),11,Class_BTreeTraverse,
                     2,
                     0,
                     _ceu_org,1);
/* TODO: currently idx is always "1" for all interfaces access because pools 
 * are all together there. When we have separate trls for pools, we'll have to 
 * indirectly access the offset in the interface. */

#line 72 "chaser.ceu"
        _ceu_constr_335(_ceu_app, ((tceu_org*) &(((CEU_Main*)_ceu_org)->_org_336_7)), _ceu_org);

#line 72 "chaser.ceu"
    {
    tceu_stk stk_ = { NULL, ((tceu_org*) &(((CEU_Main*)_ceu_org)->_org_336_7)), 0, ((tceu_org*) &(((CEU_Main*)_ceu_org)->_org_336_7))->n, {} };
    if (setjmp(stk_.jmp) != 0) {
#ifdef CEU_ORGS
        _ceu_org = _ceu_app->stk_jmp.org;
#endif
        _ceu_trl = _ceu_app->stk_jmp.trl;

#line 72 "chaser.ceu"
    _ceu_lbl = _ceu_app->stk_jmp.lbl;
goto _CEU_GOTO_;

#line 72 "chaser.ceu"
        }

    /* SETJMP: spawning a new org
     * The new org might emit a global event that awakes a par/or enclosing the 
     * call point.
     */
    _ceu_stk->up = &stk_;
    ceu_app_go(_ceu_app,NULL,
               ((tceu_org*) &(((CEU_Main*)_ceu_org)->_org_336_7)), &((tceu_org*) &(((CEU_Main*)_ceu_org)->_org_336_7))->trls[0],
               &stk_);
    _ceu_stk->up = NULL;

#line 72 "chaser.ceu"
    }
/* NODE: Stmts 1286 */

#line 72 "chaser.ceu"
    {/* NODE: Nothing 1260 */
/* NODE: Nothing 1385 */
/* NODE: Nothing 1386 */
/* NODE: Stmts 1285 */

#line 72 "chaser.ceu"
    {/* NODE: If 1284 */

#line 72 "chaser.ceu"
    if ((!(((*((tceu_org*)(&((CEU_Main*)_ceu_org)->_org_336_7))).isAlive)))) {
/* NODE: Block 1281 */

#line 72 "chaser.ceu"
    {/* NODE: Stmts 1280 */

#line 72 "chaser.ceu"
    {/* NODE: Nothing 1264 */

#line 72 "chaser.ceu"
    }
#line 72 "chaser.ceu"
/* CLEAR: Block (72) */
#line 72 "chaser.ceu"
    if (0) {

#line 72 "chaser.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
} else {
/* NODE: Block 1283 */

#line 72 "chaser.ceu"
    {/* NODE: Stmts 1282 */

#line 72 "chaser.ceu"
    {/* NODE: Await 1263 */

#line 72 "chaser.ceu"
    _CEU_NO_1263_:
if (0) { goto _CEU_NO_1263_; /* avoids "not used" warning */ }

#line 72 "chaser.ceu"
    _ceu_trl->evt = CEU_IN__ok_killed;
_ceu_trl->lbl = Main_Awake__ok_killed_42;
_ceu_trl->seqno = _ceu_app->seqno;

#line 72 "chaser.ceu"
    _ceu_trl->org_or_adt = (void*)(&((CEU_Main*)_ceu_org)->_org_336_7);

#line 72 "chaser.ceu"
    return;

case Main_Awake__ok_killed_42:;

#line 72 "chaser.ceu"
    #ifdef CEU_DEBUG_TRAILS
#ifndef CEU_OS
printf("\tOK!\n");
#endif
#endif

#line 72 "chaser.ceu"
    }
#line 72 "chaser.ceu"
/* CLEAR: Block (72) */
#line 72 "chaser.ceu"
    if (0) {

#line 72 "chaser.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
}

#line 72 "chaser.ceu"
    }
#line 72 "chaser.ceu"
    }
#line 72 "chaser.ceu"
    }
#line 72 "chaser.ceu"
/* CLEAR: Block (72) */
#line 72 "chaser.ceu"
    {
    tceu_evt evt;
             evt.id = CEU_IN__CLEAR;
    ceu_sys_go_ex(_ceu_app, &evt,
                  _ceu_stk,
                  _ceu_org,
                  &_ceu_org->trls[ 1 ],
                  &_ceu_org->trls[ 3 ]);
                                        /* excludes +1 */
}

/* LONGJMP
 * Block termination: we will abort all trails between [t1,t2].
 * Return status=1 to distinguish from longjmp from organism termination.
 * We want to continue from "me.lbl_jmp" below.
 */
#ifdef CEU_ORGS
_ceu_app->stk_jmp.org = _ceu_org;
#endif
_ceu_app->stk_jmp.trl = _ceu_trl;
_ceu_app->stk_jmp.lbl = Main_Block_jmp_43;
ceu_longjmp(_ceu_app, _ceu_org,
            1,2);

#line 72 "chaser.ceu"
case Main_Block_jmp_43:;
#line 72 "chaser.ceu"
    if (0) {

#line 72 "chaser.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 72 "chaser.ceu"
    }
#line 72 "chaser.ceu"
/* CLEAR: Block (72) */
#line 72 "chaser.ceu"
    if (0) {

#line 72 "chaser.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 71 "chaser.ceu"
    }

#line 71 "chaser.ceu"
    }
#line 71 "chaser.ceu"
/* CLEAR: Block (71) */
#line 71 "chaser.ceu"
    if (0) {

#line 71 "chaser.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 1 "chaser.ceu"
    }
#line 1 "chaser.ceu"
/* CLEAR: Block (1) */
#line 1 "chaser.ceu"
    if (0) {

#line 1 "chaser.ceu"
case Main_Block__fin_44:;
#line 1 "chaser.ceu"
    return;
#line 1 "chaser.ceu"
case Main_adt_fin_kill_free_45:;
#line 1 "chaser.ceu"
    #if 0
"kill" only while in scope
CEU_BTree_kill(_ceu_app, ((CEU_BTree *)(  ((tceu_pool_adts*) (&((CEU_Main*)_ceu_org)->behavior))->root)));
#endif

#line 1 "chaser.ceu"
    CEU_BTree_free(NULL, ((CEU_BTree *)(  ((tceu_pool_adts*) (&((CEU_Main*)_ceu_org)->behavior))->root)));

#line 1 "chaser.ceu"
    return;
#line 1 "chaser.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 1 "chaser.ceu"
    }
#line 1 "chaser.ceu"
    }
#line 1 "chaser.ceu"
/* CLEAR: Block (1) */
#line 1 "chaser.ceu"
    if (0) {

#line 1 "chaser.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 1 "chaser.ceu"
    return;
#line 1 "chaser.ceu"
    }
#line 1 "chaser.ceu"
/* CLEAR: Block (1) */
#line 1 "chaser.ceu"
    if (0) {

#line 1 "chaser.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 1 "chaser.ceu"
    }
#line 1 "chaser.ceu"
/* CLEAR: Block (1) */
#line 1 "chaser.ceu"
    if (0) {

#line 1 "chaser.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
/* NODE: Dcl_cls 1 */

#line 23 "chaser.ceu"
case Class_LeafHandler:;/* NODE: Block 413 */

#line 23 "chaser.ceu"
    {/* NODE: Stmts 412 */

#line 23 "chaser.ceu"
    {/* NODE: Block 371 */

#line 23 "chaser.ceu"
    {
#line 23 "chaser.ceu"
    #ifdef CEU_RET

#line 23 "chaser.ceu"
    int __ceu__ret_2;

#line 23 "chaser.ceu"
    #endif
/* NODE: Stmts 370 */

#line 23 "chaser.ceu"
    {/* NODE: Dcl_var 367 */
/* NODE: SetBlock 369 */
/* NODE: Block 132 */

#line 26 "chaser.ceu"
    {/* NODE: Stmts 131 */

#line 26 "chaser.ceu"
    {/* NODE: Stmts 382 */

#line 26 "chaser.ceu"
    {/* NODE: Dcl_var 379 */
/* NODE: Set 383 */

#line 26 "chaser.ceu"
/* SET: answer *//* NODE: NUMBER 16 */

#line 26 "chaser.ceu"
    (((CEU_LeafHandler*)_ceu_org)->answer) = 0;
#line 26 "chaser.ceu"
    }/* NODE: If 392 */

#line 27 "chaser.ceu"
    if ((((((CEU_LeafHandler*)_ceu_org)->leaf)->tag == CEU_LEAF_SENSEUP) /* XXXX */)) {
/* NODE: Block 28 */

#line 28 "chaser.ceu"
    {/* NODE: Stmts 27 */

#line 28 "chaser.ceu"
    {/* NODE: Set 393 */

#line 28 "chaser.ceu"
/* SET: answer *//* NODE: Op2_< 25 */

#line 28 "chaser.ceu"
    (((CEU_LeafHandler*)_ceu_org)->answer) = ((player_y+25)<chaser_y);
#line 28 "chaser.ceu"
    }
#line 28 "chaser.ceu"
/* CLEAR: Block (28) */
#line 28 "chaser.ceu"
    if (0) {

#line 28 "chaser.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
} else {
/* NODE: If 391 */

#line 29 "chaser.ceu"
    if ((((((CEU_LeafHandler*)_ceu_org)->leaf)->tag == CEU_LEAF_SENSEDOWN) /* XXXX */)) {
/* NODE: Block 39 */

#line 30 "chaser.ceu"
    {/* NODE: Stmts 38 */

#line 30 "chaser.ceu"
    {/* NODE: Set 394 */

#line 30 "chaser.ceu"
/* SET: answer *//* NODE: Op2_> 36 */

#line 30 "chaser.ceu"
    (((CEU_LeafHandler*)_ceu_org)->answer) = ((player_y-25)>chaser_y);
#line 30 "chaser.ceu"
    }
#line 30 "chaser.ceu"
/* CLEAR: Block (30) */
#line 30 "chaser.ceu"
    if (0) {

#line 30 "chaser.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
} else {
/* NODE: If 390 */

#line 31 "chaser.ceu"
    if ((((((CEU_LeafHandler*)_ceu_org)->leaf)->tag == CEU_LEAF_SENSELEFT) /* XXXX */)) {
/* NODE: Block 50 */

#line 32 "chaser.ceu"
    {/* NODE: Stmts 49 */

#line 32 "chaser.ceu"
    {/* NODE: Set 395 */

#line 32 "chaser.ceu"
/* SET: answer *//* NODE: Op2_< 47 */

#line 32 "chaser.ceu"
    (((CEU_LeafHandler*)_ceu_org)->answer) = ((player_x+25)<chaser_x);
#line 32 "chaser.ceu"
    }
#line 32 "chaser.ceu"
/* CLEAR: Block (32) */
#line 32 "chaser.ceu"
    if (0) {

#line 32 "chaser.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
} else {
/* NODE: If 389 */

#line 33 "chaser.ceu"
    if ((((((CEU_LeafHandler*)_ceu_org)->leaf)->tag == CEU_LEAF_SENSERIGHT) /* XXXX */)) {
/* NODE: Block 61 */

#line 34 "chaser.ceu"
    {/* NODE: Stmts 60 */

#line 34 "chaser.ceu"
    {/* NODE: Set 396 */

#line 34 "chaser.ceu"
/* SET: answer *//* NODE: Op2_> 58 */

#line 34 "chaser.ceu"
    (((CEU_LeafHandler*)_ceu_org)->answer) = ((player_x-25)>chaser_x);
#line 34 "chaser.ceu"
    }
#line 34 "chaser.ceu"
/* CLEAR: Block (34) */
#line 34 "chaser.ceu"
    if (0) {

#line 34 "chaser.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
} else {
/* NODE: If 388 */

#line 35 "chaser.ceu"
    if ((((((CEU_LeafHandler*)_ceu_org)->leaf)->tag == CEU_LEAF_GOUP) /* XXXX */)) {
/* NODE: Block 74 */

#line 36 "chaser.ceu"
    {/* NODE: Stmts 73 */

#line 36 "chaser.ceu"
    {/* NODE: Set 397 */

#line 36 "chaser.ceu"
/* SET: _chaser_dy *//* NODE: Op2_* 68 */

#line 36 "chaser.ceu"
    chaser_dy = ((-1)*CHASER_SPEED);/* NODE: Set 398 */

#line 37 "chaser.ceu"
/* SET: answer *//* NODE: NUMBER 71 */

#line 37 "chaser.ceu"
    (((CEU_LeafHandler*)_ceu_org)->answer) = 1;
#line 36 "chaser.ceu"
    }
#line 36 "chaser.ceu"
/* CLEAR: Block (36) */
#line 36 "chaser.ceu"
    if (0) {

#line 36 "chaser.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
} else {
/* NODE: If 387 */

#line 38 "chaser.ceu"
    if ((((((CEU_LeafHandler*)_ceu_org)->leaf)->tag == CEU_LEAF_GODOWN) /* XXXX */)) {
/* NODE: Block 84 */

#line 39 "chaser.ceu"
    {/* NODE: Stmts 83 */

#line 39 "chaser.ceu"
    {/* NODE: Set 399 */

#line 39 "chaser.ceu"
/* SET: _chaser_dy *//* NODE: Nat 78 */

#line 39 "chaser.ceu"
    chaser_dy = CHASER_SPEED;/* NODE: Set 400 */

#line 40 "chaser.ceu"
/* SET: answer *//* NODE: NUMBER 81 */

#line 40 "chaser.ceu"
    (((CEU_LeafHandler*)_ceu_org)->answer) = 1;
#line 39 "chaser.ceu"
    }
#line 39 "chaser.ceu"
/* CLEAR: Block (39) */
#line 39 "chaser.ceu"
    if (0) {

#line 39 "chaser.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
} else {
/* NODE: If 386 */

#line 41 "chaser.ceu"
    if ((((((CEU_LeafHandler*)_ceu_org)->leaf)->tag == CEU_LEAF_GOLEFT) /* XXXX */)) {
/* NODE: Block 97 */

#line 42 "chaser.ceu"
    {/* NODE: Stmts 96 */

#line 42 "chaser.ceu"
    {/* NODE: Set 401 */

#line 42 "chaser.ceu"
/* SET: _chaser_dx *//* NODE: Op2_* 91 */

#line 42 "chaser.ceu"
    chaser_dx = ((-1)*CHASER_SPEED);/* NODE: Set 402 */

#line 43 "chaser.ceu"
/* SET: answer *//* NODE: NUMBER 94 */

#line 43 "chaser.ceu"
    (((CEU_LeafHandler*)_ceu_org)->answer) = 1;
#line 42 "chaser.ceu"
    }
#line 42 "chaser.ceu"
/* CLEAR: Block (42) */
#line 42 "chaser.ceu"
    if (0) {

#line 42 "chaser.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
} else {
/* NODE: If 385 */

#line 44 "chaser.ceu"
    if ((((((CEU_LeafHandler*)_ceu_org)->leaf)->tag == CEU_LEAF_GORIGHT) /* XXXX */)) {
/* NODE: Block 107 */

#line 45 "chaser.ceu"
    {/* NODE: Stmts 106 */

#line 45 "chaser.ceu"
    {/* NODE: Set 403 */

#line 45 "chaser.ceu"
/* SET: _chaser_dx *//* NODE: Nat 101 */

#line 45 "chaser.ceu"
    chaser_dx = CHASER_SPEED;/* NODE: Set 404 */

#line 46 "chaser.ceu"
/* SET: answer *//* NODE: NUMBER 104 */

#line 46 "chaser.ceu"
    (((CEU_LeafHandler*)_ceu_org)->answer) = 1;
#line 45 "chaser.ceu"
    }
#line 45 "chaser.ceu"
/* CLEAR: Block (45) */
#line 45 "chaser.ceu"
    if (0) {

#line 45 "chaser.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
} else {
/* NODE: If 384 */

#line 47 "chaser.ceu"
    if ((((((CEU_LeafHandler*)_ceu_org)->leaf)->tag == CEU_LEAF_SKIP) /* XXXX */)) {
/* NODE: Block 120 */

#line 48 "chaser.ceu"
    {/* NODE: Stmts 119 */

#line 48 "chaser.ceu"
    {/* NODE: Set 405 */

#line 48 "chaser.ceu"
/* SET: _chaser_dx *//* NODE: NUMBER 111 */

#line 48 "chaser.ceu"
    chaser_dx = 0;/* NODE: Set 406 */

#line 49 "chaser.ceu"
/* SET: _chaser_dy *//* NODE: NUMBER 114 */

#line 49 "chaser.ceu"
    chaser_dy = 0;/* NODE: Set 407 */

#line 50 "chaser.ceu"
/* SET: answer *//* NODE: NUMBER 117 */

#line 50 "chaser.ceu"
    (((CEU_LeafHandler*)_ceu_org)->answer) = 1;
#line 48 "chaser.ceu"
    }
#line 48 "chaser.ceu"
/* CLEAR: Block (48) */
#line 48 "chaser.ceu"
    if (0) {

#line 48 "chaser.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
} else {
/* NODE: Block 127 */

#line 52 "chaser.ceu"
    {/* NODE: Stmts 126 */

#line 52 "chaser.ceu"
    {/* NODE: CallStmt 125 */

#line 52 "chaser.ceu"
    assert(0);
#line 52 "chaser.ceu"
    }
#line 52 "chaser.ceu"
/* CLEAR: Block (52) */
#line 52 "chaser.ceu"
    if (0) {

#line 52 "chaser.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
}
}
}
}
}
}
}
}
}
/* NODE: Stmts 411 */

#line 54 "chaser.ceu"
    {/* NODE: Set 409 */

#line 54 "chaser.ceu"
/* SET: _ret *//* NODE: Var 129 */

#line 54 "chaser.ceu"
    (__ceu__ret_2) = (((CEU_LeafHandler*)_ceu_org)->answer);
#line 54 "chaser.ceu"
    #ifdef CEU_ORGS_AWAIT
    _ceu_org->ret = (__ceu__ret_2);
    /* HACK_8: result of immediate spawn termination */
    _ceu_app->ret = _ceu_org->ret;
#endif
/* NODE: Escape 410 */

#line 54 "chaser.ceu"
    _ceu_lbl = LeafHandler_Set_out_1;
goto _CEU_GOTO_;

#line 54 "chaser.ceu"
    }
#line 26 "chaser.ceu"
    }
#line 26 "chaser.ceu"
/* CLEAR: Block (26) */
#line 26 "chaser.ceu"
    if (0) {

#line 26 "chaser.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 23 "chaser.ceu"
    return;
#line 23 "chaser.ceu"
case LeafHandler_Set_out_1:;
#line 23 "chaser.ceu"
/* CLEAR: SetBlock (23) */
#line 23 "chaser.ceu"
    }
#line 23 "chaser.ceu"
/* CLEAR: Block (23) */
#line 23 "chaser.ceu"
    if (0) {

#line 23 "chaser.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 23 "chaser.ceu"
    }
#line 23 "chaser.ceu"
/* CLEAR: Block (23) */
#line 23 "chaser.ceu"
    if (0) {

#line 23 "chaser.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 23 "chaser.ceu"
    {
    tceu_evt evt;
             evt.id = CEU_IN__CLEAR;
    ceu_sys_go_ex(_ceu_app, &evt,
                  _ceu_stk,
                  _ceu_org,
                  &_ceu_org->trls[_ceu_org->n], /* to the end, only free it */
                  NULL);
}

#line 23 "chaser.ceu"
    return;/* NODE: Dcl_cls 2 */

#line 29 "btree-1.ceu"
case Class_BTreeTraverse:;/* NODE: Block 1210 */

#line 29 "btree-1.ceu"
    /*  FINALIZE */
_ceu_org->trls[ 9 ].evt = CEU_IN__CLEAR;
_ceu_org->trls[ 9 ].lbl = BTreeTraverse_Block__fin_38;

#line 29 "btree-1.ceu"
    {/* NODE: Stmts 1209 */

#line 29 "btree-1.ceu"
    {/* NODE: Block 435 */

#line 29 "btree-1.ceu"
    {/* NODE: Stmts 434 */

#line 29 "btree-1.ceu"
    {/* NODE: Dcl_var 431 */
/* NODE: SetBlock 433 */
/* NODE: Block 244 */

#line 32 "btree-1.ceu"
    /*  FINALIZE */
_ceu_org->trls[ 8 ].evt = CEU_IN__CLEAR;
_ceu_org->trls[ 8 ].lbl = BTreeTraverse_Block__fin_36;

#line 32 "btree-1.ceu"
    {
#line 32 "btree-1.ceu"
    (((CEU_BTreeTraverse*)_ceu_org)->_pool_239).parent_org = _ceu_org;
(((CEU_BTreeTraverse*)_ceu_org)->_pool_239).parent_trl = 0;
#ifdef CEU_ORGS_NEWS_POOL
(((CEU_BTreeTraverse*)_ceu_org)->_pool_239).pool.queue = NULL;            /* dynamic pool */
#endif

#line 32 "btree-1.ceu"
    #ifdef CEU_ORGS
_ceu_org->trls[ 0 ].evt = CEU_IN__ORG;
_ceu_org->trls[ 0 ].org = NULL;
#endif

#line 32 "btree-1.ceu"
    _ceu_trl = &_ceu_org->trls[ 1 ];
/* NODE: Stmts 243 */

#line 32 "btree-1.ceu"
    {/* NODE: Stmts 446 */

#line 32 "btree-1.ceu"
    {/* NODE: Dcl_var 443 */
/* NODE: Stmts 524 */

#line 33 "btree-1.ceu"
    {/* NODE: Stmts 535 */

#line 33 "btree-1.ceu"
    {
#line 33 "btree-1.ceu"
    }/* NODE: Nothing 453 */
/* NODE: Stmts 1146 */

#line 33 "btree-1.ceu"
    {
#line 33 "btree-1.ceu"
    }/* NODE: Dcl_pool 455 */
/* NODE: Block 516 */

#line 33 "btree-1.ceu"
    {
#line 33 "btree-1.ceu"
    #ifdef CEU_ORGS
_ceu_org->trls[ 1 ].evt = CEU_IN__ORG;
_ceu_org->trls[ 1 ].org = NULL;
#endif

#line 33 "btree-1.ceu"
    (((CEU_BTreeTraverse*)_ceu_org)->_body_239_11).tag = CEU__OPTION__BODY_239__PTR_NIL;

#line 33 "btree-1.ceu"
    /*  RESET OPT-ORG TO NULL */
_ceu_org->trls[ 2 ].evt = CEU_IN__ok_killed;
_ceu_org->trls[ 2 ].lbl = BTreeTraverse_optorg_reset_34;
_ceu_org->trls[ 2 ].org_or_adt = NULL;

#line 33 "btree-1.ceu"
    _ceu_trl = &_ceu_org->trls[ 3 ];
/* NODE: Stmts 515 */

#line 33 "btree-1.ceu"
    {/* NODE: Dcl_var 503 */

#line 33 "btree-1.ceu"
/* start org: _s */
#line 33 "btree-1.ceu"
        /* resets org memory and starts org.trail[0]=Class_XXX */
    /* TODO: BUG: _ceu_org is not necessarily the parent for pool allocations */
    ceu_out_org_init(_ceu_app, ((tceu_org*) &(((CEU_BTreeTraverse*)_ceu_org)->_s_10)),2,Class_Scope,
                     3,
                     0,
                     _ceu_org,1);
/* TODO: currently idx is always "1" for all interfaces access because pools 
 * are all together there. When we have separate trls for pools, we'll have to 
 * indirectly access the offset in the interface. */

#line 33 "btree-1.ceu"
    {
    tceu_stk stk_ = { NULL, ((tceu_org*) &(((CEU_BTreeTraverse*)_ceu_org)->_s_10)), 0, ((tceu_org*) &(((CEU_BTreeTraverse*)_ceu_org)->_s_10))->n, {} };
    if (setjmp(stk_.jmp) != 0) {
#ifdef CEU_ORGS
        _ceu_org = _ceu_app->stk_jmp.org;
#endif
        _ceu_trl = _ceu_app->stk_jmp.trl;

#line 33 "btree-1.ceu"
    _ceu_lbl = _ceu_app->stk_jmp.lbl;
goto _CEU_GOTO_;

#line 33 "btree-1.ceu"
        }

    /* SETJMP: spawning a new org
     * The new org might emit a global event that awakes a par/or enclosing the 
     * call point.
     */
    _ceu_stk->up = &stk_;
    ceu_app_go(_ceu_app,NULL,
               ((tceu_org*) &(((CEU_BTreeTraverse*)_ceu_org)->_s_10)), &((tceu_org*) &(((CEU_BTreeTraverse*)_ceu_org)->_s_10))->trls[0],
               &stk_);
    _ceu_stk->up = NULL;

#line 33 "btree-1.ceu"
    }
/* NODE: Dcl_var 505 */
/* NODE: Set 1147 */

#line 33 "btree-1.ceu"
/* SET: _body_239 *//* NODE: Spawn 493 */

#line 33 "btree-1.ceu"
    /*{*/
    tceu_org* __ceu_new_493;

#line 33 "btree-1.ceu"
        __ceu_new_493 = (tceu_org*) ceu_out_realloc(NULL, sizeof(CEU_Body_239));

#line 33 "btree-1.ceu"
    (((CEU_BTreeTraverse*)_ceu_org)->_body_239_11) = (CEU__OPTION__BODY_239__PTR_pack(((CEU_Body_239*)__ceu_new_493)));
#line 33 "btree-1.ceu"
        if (__ceu_new_493 != NULL) {

#line 33 "btree-1.ceu"
    #ifdef CEU_ORGS_NEWS_POOL
        __ceu_new_493->pool = &(((CEU_BTreeTraverse*)_ceu_org)->_pool_239);
#endif

#line 33 "btree-1.ceu"
/* start org: dyn */
#line 33 "btree-1.ceu"
        /* resets org memory and starts org.trail[0]=Class_XXX */
    /* TODO: BUG: _ceu_org is not necessarily the parent for pool allocations */
    ceu_out_org_init(_ceu_app, ((tceu_org*) &(*((CEU_Body_239*)__ceu_new_493))),7,Class_Body_239,
                     4,
                     1,
                     (((CEU_BTreeTraverse*)_ceu_org)->_pool_239).parent_org,(((CEU_BTreeTraverse*)_ceu_org)->_pool_239).parent_trl);
/* TODO: currently idx is always "1" for all interfaces access because pools 
 * are all together there. When we have separate trls for pools, we'll have to 
 * indirectly access the offset in the interface. */

#line 33 "btree-1.ceu"
        ((CEU_Body_239*)((tceu_org*) &(*((CEU_Body_239*)__ceu_new_493))))->_out = 
        (__typeof__(((CEU_Body_239*)((tceu_org*) &(*((CEU_Body_239*)__ceu_new_493))))->_out)) _ceu_org;

#line 33 "btree-1.ceu"
        _ceu_constr_492(_ceu_app, ((tceu_org*) &(*((CEU_Body_239*)__ceu_new_493))), _ceu_org);

#line 33 "btree-1.ceu"
    {
    tceu_stk stk_ = { NULL, ((tceu_org*) &(*((CEU_Body_239*)__ceu_new_493))), 0, ((tceu_org*) &(*((CEU_Body_239*)__ceu_new_493)))->n, {} };
    if (setjmp(stk_.jmp) != 0) {
#ifdef CEU_ORGS
        _ceu_org = _ceu_app->stk_jmp.org;
#endif
        _ceu_trl = _ceu_app->stk_jmp.trl;

#line 33 "btree-1.ceu"
    _ceu_lbl = _ceu_app->stk_jmp.lbl;
goto _CEU_GOTO_;

#line 33 "btree-1.ceu"
        }

    /* SETJMP: spawning a new org
     * The new org might emit a global event that awakes a par/or enclosing the 
     * call point.
     */
    _ceu_stk->up = &stk_;
    ceu_app_go(_ceu_app,NULL,
               ((tceu_org*) &(*((CEU_Body_239*)__ceu_new_493))), &((tceu_org*) &(*((CEU_Body_239*)__ceu_new_493)))->trls[0],
               &stk_);
    _ceu_stk->up = NULL;

#line 33 "btree-1.ceu"
        if (!((tceu_org*) &(*((CEU_Body_239*)__ceu_new_493)))->isAlive) {
        (((CEU_BTreeTraverse*)_ceu_org)->_body_239_11) = CEU__OPTION__BODY_239__PTR_pack(NULL);
    }

#line 33 "btree-1.ceu"
    }

#line 33 "btree-1.ceu"
        }
/*}*/
/* NODE: If 514 */

#line 33 "btree-1.ceu"
    if (((((CEU_BTreeTraverse*)_ceu_org)->_body_239_11).tag != CEU__OPTION__BODY_239__PTR_NIL)) {
/* NODE: Block 511 */

#line 33 "btree-1.ceu"
    {/* NODE: Stmts 510 */

#line 33 "btree-1.ceu"
    {/* NODE: Stmts 1199 */

#line 33 "btree-1.ceu"
    {/* NODE: Nothing 1153 */
/* NODE: Nothing 1380 */
/* NODE: Nothing 1381 */
/* NODE: Stmts 1198 */

#line 33 "btree-1.ceu"
    {/* NODE: If 1197 */

#line 33 "btree-1.ceu"
    if ((!(((*((tceu_org*)(((CEU__OPTION__BODY_239__PTR_SOME_assert(_ceu_app, (&((CEU_BTreeTraverse*)_ceu_org)->_body_239_11),__FILE__,__LINE__)->SOME.v))))).isAlive)))) {
/* NODE: Block 1194 */

#line 33 "btree-1.ceu"
    {/* NODE: Stmts 1193 */

#line 33 "btree-1.ceu"
    {/* NODE: Set 1173 */

#line 33 "btree-1.ceu"
/* SET: ok *//* NODE: Op1_cast 1171 */

#line 33 "btree-1.ceu"
    (((CEU_BTreeTraverse*)_ceu_org)->ok) = ((int)(((*((tceu_org*)(((CEU__OPTION__BODY_239__PTR_SOME_assert(_ceu_app, (&((CEU_BTreeTraverse*)_ceu_org)->_body_239_11),__FILE__,__LINE__)->SOME.v))))).ret)));
#line 33 "btree-1.ceu"
    }
#line 33 "btree-1.ceu"
/* CLEAR: Block (33) */
#line 33 "btree-1.ceu"
    if (0) {

#line 33 "btree-1.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
} else {
/* NODE: Block 1196 */

#line 33 "btree-1.ceu"
    {/* NODE: Stmts 1195 */

#line 33 "btree-1.ceu"
    {/* NODE: Set 1203 */

#line 33 "btree-1.ceu"
/* SET: table: 0xdf65a0 *//* NODE: Await 1158 */

#line 33 "btree-1.ceu"
    _CEU_NO_1158_:
if (0) { goto _CEU_NO_1158_; /* avoids "not used" warning */ }

#line 33 "btree-1.ceu"
    _ceu_trl->evt = CEU_IN__ok_killed;
_ceu_trl->lbl = BTreeTraverse_Awake__ok_killed_33;
_ceu_trl->seqno = _ceu_app->seqno;

#line 33 "btree-1.ceu"
    _ceu_trl->org_or_adt = (void*)(((CEU__OPTION__BODY_239__PTR_SOME_assert(_ceu_app, (&((CEU_BTreeTraverse*)_ceu_org)->_body_239_11),__FILE__,__LINE__)->SOME.v)));

#line 33 "btree-1.ceu"
    return;

case BTreeTraverse_Awake__ok_killed_33:;

#line 33 "btree-1.ceu"
    #ifdef CEU_DEBUG_TRAILS
#ifndef CEU_OS
printf("\tOK!\n");
#endif
#endif

#line 33 "btree-1.ceu"
    {

#line 33 "btree-1.ceu"
        tceu_kill* __ceu_casted = (tceu_kill*) _ceu_evt->param;

#line 33 "btree-1.ceu"
        (((CEU_BTreeTraverse*)_ceu_org)->ok) = ((__ceu_casted)->ret);
}

#line 33 "btree-1.ceu"
    }
#line 33 "btree-1.ceu"
/* CLEAR: Block (33) */
#line 33 "btree-1.ceu"
    if (0) {

#line 33 "btree-1.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
}

#line 33 "btree-1.ceu"
    }
#line 33 "btree-1.ceu"
    }
#line 33 "btree-1.ceu"
    }
#line 33 "btree-1.ceu"
/* CLEAR: Block (33) */
#line 33 "btree-1.ceu"
    if (0) {

#line 33 "btree-1.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
} else {
/* NODE: Block 513 */

#line 33 "btree-1.ceu"
    {/* NODE: Stmts 512 */

#line 33 "btree-1.ceu"
    {/* NODE: Set 1204 */

#line 33 "btree-1.ceu"
/* SET: ok *//* NODE: RawExp 500 */

#line 33 "btree-1.ceu"
    (((CEU_BTreeTraverse*)_ceu_org)->ok) = _ceu_app->ret;
#line 33 "btree-1.ceu"
    }
#line 33 "btree-1.ceu"
/* CLEAR: Block (33) */
#line 33 "btree-1.ceu"
    if (0) {

#line 33 "btree-1.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
}

#line 33 "btree-1.ceu"
    }
#line 33 "btree-1.ceu"
/* CLEAR: Block (33) */
#line 33 "btree-1.ceu"
    {
    tceu_evt evt;
             evt.id = CEU_IN__CLEAR;
    ceu_sys_go_ex(_ceu_app, &evt,
                  _ceu_stk,
                  _ceu_org,
                  &_ceu_org->trls[ 1 ],
                  &_ceu_org->trls[ 8 ]);
                                        /* excludes +1 */
}

/* LONGJMP
 * Block termination: we will abort all trails between [t1,t2].
 * Return status=1 to distinguish from longjmp from organism termination.
 * We want to continue from "me.lbl_jmp" below.
 */
#ifdef CEU_ORGS
_ceu_app->stk_jmp.org = _ceu_org;
#endif
_ceu_app->stk_jmp.trl = _ceu_trl;
_ceu_app->stk_jmp.lbl = BTreeTraverse_Block_jmp_35;
ceu_longjmp(_ceu_app, _ceu_org,
            1,7);

#line 33 "btree-1.ceu"
case BTreeTraverse_Block_jmp_35:;
#line 33 "btree-1.ceu"
    if (0) {

#line 33 "btree-1.ceu"
case BTreeTraverse_optorg_reset_34:;
#line 33 "btree-1.ceu"
        {
        tceu_kill* __ceu_casted = (tceu_kill*)_ceu_evt->param;
        if ( ((((CEU_BTreeTraverse*)_ceu_org)->_body_239_11).tag != CEU__OPTION__BODY_239__PTR_NIL) &&
             ((((CEU_BTreeTraverse*)_ceu_org)->_body_239_11).SOME.v == __ceu_casted->org_or_adt) )
        {
            (((CEU_BTreeTraverse*)_ceu_org)->_body_239_11) = CEU__OPTION__BODY_239__PTR_pack(NULL);
        }
    }

#line 33 "btree-1.ceu"
    /*  RESET OPT-ORG TO NULL */
_ceu_org->trls[ 2 ].evt = CEU_IN__ok_killed;
_ceu_org->trls[ 2 ].lbl = BTreeTraverse_optorg_reset_34;

#line 33 "btree-1.ceu"
    return;
#line 33 "btree-1.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 33 "btree-1.ceu"
    }
#line 32 "btree-1.ceu"
    }/* NODE: Stmts 1208 */

#line 58 "btree-1.ceu"
    {/* NODE: Set 1206 */

#line 58 "btree-1.ceu"
/* SET: _ret *//* NODE: Var 241 */

#line 58 "btree-1.ceu"
    (((CEU_BTreeTraverse*)_ceu_org)->_ret_7) = (((CEU_BTreeTraverse*)_ceu_org)->ok);
#line 58 "btree-1.ceu"
    #ifdef CEU_ORGS_AWAIT
    _ceu_org->ret = (((CEU_BTreeTraverse*)_ceu_org)->_ret_7);
    /* HACK_8: result of immediate spawn termination */
    _ceu_app->ret = _ceu_org->ret;
#endif
/* NODE: Escape 1207 */

#line 58 "btree-1.ceu"
    _ceu_lbl = BTreeTraverse_Set_out_3;
goto _CEU_GOTO_;

#line 58 "btree-1.ceu"
    }
#line 32 "btree-1.ceu"
    }
#line 32 "btree-1.ceu"
/* CLEAR: Block (32) */
#line 32 "btree-1.ceu"
    if (0) {

#line 32 "btree-1.ceu"
case BTreeTraverse_Block__fin_36:;
#line 32 "btree-1.ceu"
    return;
#line 32 "btree-1.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 29 "btree-1.ceu"
    return;
#line 29 "btree-1.ceu"
case BTreeTraverse_Set_out_3:;
#line 29 "btree-1.ceu"
/* CLEAR: SetBlock (29) */
#line 29 "btree-1.ceu"
    {
    tceu_evt evt;
             evt.id = CEU_IN__CLEAR;
    ceu_sys_go_ex(_ceu_app, &evt,
                  _ceu_stk,
                  _ceu_org,
                  &_ceu_org->trls[ 0 ],
                  &_ceu_org->trls[ 9 ]);
                                        /* excludes +1 */
}

/* LONGJMP
 * Block termination: we will abort all trails between [t1,t2].
 * Return status=1 to distinguish from longjmp from organism termination.
 * We want to continue from "me.lbl_jmp" below.
 */
#ifdef CEU_ORGS
_ceu_app->stk_jmp.org = _ceu_org;
#endif
_ceu_app->stk_jmp.trl = _ceu_trl;
_ceu_app->stk_jmp.lbl = BTreeTraverse_Set_jmp_4;
ceu_longjmp(_ceu_app, _ceu_org,
            0,8);

#line 29 "btree-1.ceu"
case BTreeTraverse_Set_jmp_4:;
#line 29 "btree-1.ceu"
    }
#line 29 "btree-1.ceu"
/* CLEAR: Block (29) */
#line 29 "btree-1.ceu"
    if (0) {

#line 29 "btree-1.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 29 "btree-1.ceu"
    }
#line 29 "btree-1.ceu"
/* CLEAR: Block (29) */
#line 29 "btree-1.ceu"
    {
    tceu_evt evt;
             evt.id = CEU_IN__CLEAR;
    ceu_sys_go_ex(_ceu_app, &evt,
                  _ceu_stk,
                  _ceu_org,
                  &_ceu_org->trls[ 0 ],
                  &_ceu_org->trls[ 11 ]);
                                        /* excludes +1 */
}

/* LONGJMP
 * Block termination: we will abort all trails between [t1,t2].
 * Return status=1 to distinguish from longjmp from organism termination.
 * We want to continue from "me.lbl_jmp" below.
 */
#ifdef CEU_ORGS
_ceu_app->stk_jmp.org = _ceu_org;
#endif
_ceu_app->stk_jmp.trl = _ceu_trl;
_ceu_app->stk_jmp.lbl = BTreeTraverse_Block_jmp_39;
ceu_longjmp(_ceu_app, _ceu_org,
            0,10);

#line 29 "btree-1.ceu"
case BTreeTraverse_Block_jmp_39:;
#line 29 "btree-1.ceu"
    if (0) {

#line 29 "btree-1.ceu"
case BTreeTraverse_Block__fin_38:;
#line 29 "btree-1.ceu"
    return;
#line 29 "btree-1.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 29 "btree-1.ceu"
    {
    tceu_evt evt;
             evt.id = CEU_IN__CLEAR;
    ceu_sys_go_ex(_ceu_app, &evt,
                  _ceu_stk,
                  _ceu_org,
                  &_ceu_org->trls[_ceu_org->n], /* to the end, only free it */
                  NULL);
}

#line 29 "btree-1.ceu"
    return;/* NODE: Dcl_cls 3 */

#line 33 "btree-1.ceu"
case Class_Scope:;/* NODE: Block 533 */

#line 33 "btree-1.ceu"
    {/* NODE: Stmts 532 */

#line 33 "btree-1.ceu"
    {/* NODE: Block 530 */

#line 33 "btree-1.ceu"
    {/* NODE: Stmts 534 */

#line 33 "btree-1.ceu"
    {/* NODE: Block 522 */

#line 33 "btree-1.ceu"
    {/* NODE: Stmts 521 */

#line 33 "btree-1.ceu"
    {/* NODE: AwaitN 520 */

#line 33 "btree-1.ceu"
    return;
#line 33 "btree-1.ceu"
    }
#line 33 "btree-1.ceu"
/* CLEAR: Block (33) */
#line 33 "btree-1.ceu"
    if (0) {

#line 33 "btree-1.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 33 "btree-1.ceu"
    }
#line 33 "btree-1.ceu"
/* CLEAR: Block (33) */
#line 33 "btree-1.ceu"
    if (0) {

#line 33 "btree-1.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 33 "btree-1.ceu"
    }
#line 33 "btree-1.ceu"
/* CLEAR: Block (33) */
#line 33 "btree-1.ceu"
    if (0) {

#line 33 "btree-1.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 33 "btree-1.ceu"
    {
    tceu_evt evt;
             evt.id = CEU_IN__CLEAR;
    ceu_sys_go_ex(_ceu_app, &evt,
                  _ceu_stk,
                  _ceu_org,
                  &_ceu_org->trls[_ceu_org->n], /* to the end, only free it */
                  NULL);
}

#line 33 "btree-1.ceu"
    return;/* NODE: Dcl_cls 4 */

#line 33 "btree-1.ceu"
case Class_Body_239:;/* NODE: Block 1145 */

#line 33 "btree-1.ceu"
    /*  FINALIZE */
_ceu_org->trls[ 5 ].evt = CEU_IN__CLEAR;
_ceu_org->trls[ 5 ].lbl = Body_239_Block__fin_30;

#line 33 "btree-1.ceu"
    {/* NODE: Stmts 1144 */

#line 33 "btree-1.ceu"
    {/* NODE: Block 541 */

#line 33 "btree-1.ceu"
    {/* NODE: Stmts 540 */

#line 33 "btree-1.ceu"
    {/* NODE: Dcl_var 537 */
/* NODE: SetBlock 539 */
/* NODE: Block 474 */

#line 33 "btree-1.ceu"
    {/* NODE: Stmts 473 */

#line 33 "btree-1.ceu"
    {/* NODE: ParOr 549 */

#line 33 "btree-1.ceu"
/* ParOr: spawn subs */
#line 33 "btree-1.ceu"
    {
    tceu_stk stk_ = { NULL, _ceu_org, 0, 4, {} };
    if (setjmp(stk_.jmp) != 0) {
#ifdef CEU_ORGS
        _ceu_org = _ceu_app->stk_jmp.org;
#endif
        _ceu_trl = _ceu_app->stk_jmp.trl;

#line 33 "btree-1.ceu"
    _ceu_lbl = _ceu_app->stk_jmp.lbl;
goto _CEU_GOTO_;

#line 33 "btree-1.ceu"
        }

    /* SETJMP: starting trails in a par
     * The 1st trail might abort an enclosing par/or, or emit something that 
     * does.
     */

#line 33 "btree-1.ceu"
        _ceu_org->trls[ 0 ].lbl = Body_239_ParOr_sub_1_8;
    _ceu_stk->up = &stk_;
    ceu_app_go(_ceu_app,NULL,_ceu_org,
               &_ceu_org->trls[ 0 ],
               &stk_);
    _ceu_stk->up = NULL;

#line 33 "btree-1.ceu"
        _ceu_trl = &_ceu_org->trls[ 1 ];

#line 33 "btree-1.ceu"
    }
/* NODE: Block 469 */

#line 33 "btree-1.ceu"
    {/* NODE: Stmts 468 */

#line 33 "btree-1.ceu"
    {/* NODE: Block 238 */

#line 34 "btree-1.ceu"
    {/* NODE: Stmts 237 */

#line 34 "btree-1.ceu"
    {/* NODE: ParOr 583 */

#line 34 "btree-1.ceu"
/* ParOr: spawn subs */
#line 34 "btree-1.ceu"
    {
    tceu_stk stk_ = { NULL, _ceu_org, 1, 4, {} };
    if (setjmp(stk_.jmp) != 0) {
#ifdef CEU_ORGS
        _ceu_org = _ceu_app->stk_jmp.org;
#endif
        _ceu_trl = _ceu_app->stk_jmp.trl;

#line 34 "btree-1.ceu"
    _ceu_lbl = _ceu_app->stk_jmp.lbl;
goto _CEU_GOTO_;

#line 34 "btree-1.ceu"
        }

    /* SETJMP: starting trails in a par
     * The 1st trail might abort an enclosing par/or, or emit something that 
     * does.
     */

#line 34 "btree-1.ceu"
        _ceu_org->trls[ 1 ].lbl = Body_239_ParOr_sub_1_12;
    _ceu_stk->up = &stk_;
    ceu_app_go(_ceu_app,NULL,_ceu_org,
               &_ceu_org->trls[ 1 ],
               &stk_);
    _ceu_stk->up = NULL;

#line 34 "btree-1.ceu"
        _ceu_trl = &_ceu_org->trls[ 2 ];

#line 34 "btree-1.ceu"
    }
/* NODE: Block 235 */

#line 35 "btree-1.ceu"
    {/* NODE: Stmts 234 */

#line 35 "btree-1.ceu"
    {/* NODE: If 617 */

#line 35 "btree-1.ceu"
    if ((((((CEU_BTree *)(  ((tceu_pool_adts*) (&((CEU_Body_239*)_ceu_org)->t))->root)))->tag == CEU_BTREE_SEQUENCE) /* XXXX */)) {
/* NODE: Block 185 */

#line 36 "btree-1.ceu"
    {/* NODE: Stmts 184 */

#line 36 "btree-1.ceu"
    {/* NODE: Stmts 624 */

#line 36 "btree-1.ceu"
    {/* NODE: Dcl_var 621 */
/* NODE: Block 668 */

#line 36 "btree-1.ceu"
    {
#line 36 "btree-1.ceu"
    #ifdef CEU_ORGS
_ceu_org->trls[ 2 ].evt = CEU_IN__ORG;
_ceu_org->trls[ 2 ].org = NULL;
#endif

#line 36 "btree-1.ceu"
    (((CEU_Body_239*)_ceu_org)->_body_165_17).tag = CEU__OPTION__BODY_239__PTR_NIL;

#line 36 "btree-1.ceu"
    /*  RESET OPT-ORG TO NULL */
_ceu_org->trls[ 3 ].evt = CEU_IN__ok_killed;
_ceu_org->trls[ 3 ].lbl = Body_239_optorg_reset_17;
_ceu_org->trls[ 3 ].org_or_adt = NULL;

#line 36 "btree-1.ceu"
    _ceu_trl = &_ceu_org->trls[ 4 ];
/* NODE: Stmts 667 */

#line 36 "btree-1.ceu"
    {/* NODE: Dcl_adt 1294 */
/* NODE: Dcl_var 655 */

#line 36 "btree-1.ceu"
/* start org: _s */
#line 36 "btree-1.ceu"
        /* resets org memory and starts org.trail[0]=Class_XXX */
    /* TODO: BUG: _ceu_org is not necessarily the parent for pool allocations */
    ceu_out_org_init(_ceu_app, ((tceu_org*) &(((CEU_Body_239*)_ceu_org)->_s_16)),2,Class_Scope,
                     3,
                     0,
                     _ceu_org,2);
/* TODO: currently idx is always "1" for all interfaces access because pools 
 * are all together there. When we have separate trls for pools, we'll have to 
 * indirectly access the offset in the interface. */

#line 36 "btree-1.ceu"
    {
    tceu_stk stk_ = { NULL, ((tceu_org*) &(((CEU_Body_239*)_ceu_org)->_s_16)), 0, ((tceu_org*) &(((CEU_Body_239*)_ceu_org)->_s_16))->n, {} };
    if (setjmp(stk_.jmp) != 0) {
#ifdef CEU_ORGS
        _ceu_org = _ceu_app->stk_jmp.org;
#endif
        _ceu_trl = _ceu_app->stk_jmp.trl;

#line 36 "btree-1.ceu"
    _ceu_lbl = _ceu_app->stk_jmp.lbl;
goto _CEU_GOTO_;

#line 36 "btree-1.ceu"
        }

    /* SETJMP: spawning a new org
     * The new org might emit a global event that awakes a par/or enclosing the 
     * call point.
     */
    _ceu_stk->up = &stk_;
    ceu_app_go(_ceu_app,NULL,
               ((tceu_org*) &(((CEU_Body_239*)_ceu_org)->_s_16)), &((tceu_org*) &(((CEU_Body_239*)_ceu_org)->_s_16))->trls[0],
               &stk_);
    _ceu_stk->up = NULL;

#line 36 "btree-1.ceu"
    }
/* NODE: Dcl_var 657 */
/* NODE: Set 669 */

#line 36 "btree-1.ceu"
/* SET: _body_165 *//* NODE: Spawn 645 */

#line 36 "btree-1.ceu"
    /*{*/
    tceu_org* __ceu_new_645;

#line 36 "btree-1.ceu"
    #if !defined(CEU_ORGS_NEWS_MALLOC)
    __ceu_new_645 = (tceu_org*) ceu_pool_alloc(&(*((CEU_Body_239*)_ceu_org)->_bodies).pool);
#elif !defined(CEU_ORGS_NEWS_POOL)
    __ceu_new_645 = (tceu_org*) ceu_out_realloc(NULL, sizeof(CEU_Body_239));
#else
    if ((*((CEU_Body_239*)_ceu_org)->_bodies).pool.queue == NULL) {
        __ceu_new_645 = (tceu_org*) ceu_out_realloc(NULL, sizeof(CEU_Body_239));
    } else {
        __ceu_new_645 = (tceu_org*) ceu_pool_alloc(&(*((CEU_Body_239*)_ceu_org)->_bodies).pool);
    }
#endif

#line 36 "btree-1.ceu"
    (((CEU_Body_239*)_ceu_org)->_body_165_17) = (CEU__OPTION__BODY_239__PTR_pack(((CEU_Body_239*)__ceu_new_645)));
#line 36 "btree-1.ceu"
        if (__ceu_new_645 != NULL) {

#line 36 "btree-1.ceu"
    #ifdef CEU_ORGS_NEWS_POOL
        __ceu_new_645->pool = &(*((CEU_Body_239*)_ceu_org)->_bodies);
#endif

#line 36 "btree-1.ceu"
/* start org: dyn */
#line 36 "btree-1.ceu"
        /* resets org memory and starts org.trail[0]=Class_XXX */
    /* TODO: BUG: _ceu_org is not necessarily the parent for pool allocations */
    ceu_out_org_init(_ceu_app, ((tceu_org*) &(*((CEU_Body_239*)__ceu_new_645))),7,Class_Body_239,
                     4,
                     1,
                     (*((CEU_Body_239*)_ceu_org)->_bodies).parent_org,(*((CEU_Body_239*)_ceu_org)->_bodies).parent_trl);
/* TODO: currently idx is always "1" for all interfaces access because pools 
 * are all together there. When we have separate trls for pools, we'll have to 
 * indirectly access the offset in the interface. */

#line 36 "btree-1.ceu"
        ((CEU_Body_239*)((tceu_org*) &(*((CEU_Body_239*)__ceu_new_645))))->_out =
        ((CEU_Body_239*)_ceu_org)->_out;

#line 36 "btree-1.ceu"
        _ceu_constr_644(_ceu_app, ((tceu_org*) &(*((CEU_Body_239*)__ceu_new_645))), _ceu_org);

#line 36 "btree-1.ceu"
    {
    tceu_stk stk_ = { NULL, ((tceu_org*) &(*((CEU_Body_239*)__ceu_new_645))), 0, ((tceu_org*) &(*((CEU_Body_239*)__ceu_new_645)))->n, {} };
    if (setjmp(stk_.jmp) != 0) {
#ifdef CEU_ORGS
        _ceu_org = _ceu_app->stk_jmp.org;
#endif
        _ceu_trl = _ceu_app->stk_jmp.trl;

#line 36 "btree-1.ceu"
    _ceu_lbl = _ceu_app->stk_jmp.lbl;
goto _CEU_GOTO_;

#line 36 "btree-1.ceu"
        }

    /* SETJMP: spawning a new org
     * The new org might emit a global event that awakes a par/or enclosing the 
     * call point.
     */
    _ceu_stk->up = &stk_;
    ceu_app_go(_ceu_app,NULL,
               ((tceu_org*) &(*((CEU_Body_239*)__ceu_new_645))), &((tceu_org*) &(*((CEU_Body_239*)__ceu_new_645)))->trls[0],
               &stk_);
    _ceu_stk->up = NULL;

#line 36 "btree-1.ceu"
        if (!((tceu_org*) &(*((CEU_Body_239*)__ceu_new_645)))->isAlive) {
        (((CEU_Body_239*)_ceu_org)->_body_165_17) = CEU__OPTION__BODY_239__PTR_pack(NULL);
    }

#line 36 "btree-1.ceu"
    }

#line 36 "btree-1.ceu"
        }
/*}*/
/* NODE: If 666 */

#line 36 "btree-1.ceu"
    if (((((CEU_Body_239*)_ceu_org)->_body_165_17).tag != CEU__OPTION__BODY_239__PTR_NIL)) {
/* NODE: Block 663 */

#line 36 "btree-1.ceu"
    {/* NODE: Stmts 662 */

#line 36 "btree-1.ceu"
    {/* NODE: Stmts 723 */

#line 36 "btree-1.ceu"
    {/* NODE: Nothing 677 */
/* NODE: Nothing 1354 */
/* NODE: Nothing 1355 */
/* NODE: Stmts 722 */

#line 36 "btree-1.ceu"
    {/* NODE: If 721 */

#line 36 "btree-1.ceu"
    if ((!(((*((tceu_org*)(((CEU__OPTION__BODY_239__PTR_SOME_assert(_ceu_app, (&((CEU_Body_239*)_ceu_org)->_body_165_17),__FILE__,__LINE__)->SOME.v))))).isAlive)))) {
/* NODE: Block 718 */

#line 36 "btree-1.ceu"
    {/* NODE: Stmts 717 */

#line 36 "btree-1.ceu"
    {/* NODE: Set 697 */

#line 36 "btree-1.ceu"
/* SET: ok *//* NODE: Op1_cast 695 */

#line 36 "btree-1.ceu"
    (((CEU_Body_239*)_ceu_org)->ok_14) = ((int)(((*((tceu_org*)(((CEU__OPTION__BODY_239__PTR_SOME_assert(_ceu_app, (&((CEU_Body_239*)_ceu_org)->_body_165_17),__FILE__,__LINE__)->SOME.v))))).ret)));
#line 36 "btree-1.ceu"
    }
#line 36 "btree-1.ceu"
/* CLEAR: Block (36) */
#line 36 "btree-1.ceu"
    if (0) {

#line 36 "btree-1.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
} else {
/* NODE: Block 720 */

#line 36 "btree-1.ceu"
    {/* NODE: Stmts 719 */

#line 36 "btree-1.ceu"
    {/* NODE: Set 727 */

#line 36 "btree-1.ceu"
/* SET: table: 0xdbe2e0 *//* NODE: Await 682 */

#line 36 "btree-1.ceu"
    _CEU_NO_682_:
if (0) { goto _CEU_NO_682_; /* avoids "not used" warning */ }

#line 36 "btree-1.ceu"
    _ceu_trl->evt = CEU_IN__ok_killed;
_ceu_trl->lbl = Body_239_Awake__ok_killed_16;
_ceu_trl->seqno = _ceu_app->seqno;

#line 36 "btree-1.ceu"
    _ceu_trl->org_or_adt = (void*)(((CEU__OPTION__BODY_239__PTR_SOME_assert(_ceu_app, (&((CEU_Body_239*)_ceu_org)->_body_165_17),__FILE__,__LINE__)->SOME.v)));

#line 36 "btree-1.ceu"
    return;

case Body_239_Awake__ok_killed_16:;

#line 36 "btree-1.ceu"
    #ifdef CEU_DEBUG_TRAILS
#ifndef CEU_OS
printf("\tOK!\n");
#endif
#endif

#line 36 "btree-1.ceu"
    {

#line 36 "btree-1.ceu"
        tceu_kill* __ceu_casted = (tceu_kill*) _ceu_evt->param;

#line 36 "btree-1.ceu"
        (((CEU_Body_239*)_ceu_org)->ok_14) = ((__ceu_casted)->ret);
}

#line 36 "btree-1.ceu"
    }
#line 36 "btree-1.ceu"
/* CLEAR: Block (36) */
#line 36 "btree-1.ceu"
    if (0) {

#line 36 "btree-1.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
}

#line 36 "btree-1.ceu"
    }
#line 36 "btree-1.ceu"
    }
#line 36 "btree-1.ceu"
    }
#line 36 "btree-1.ceu"
/* CLEAR: Block (36) */
#line 36 "btree-1.ceu"
    if (0) {

#line 36 "btree-1.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
} else {
/* NODE: Block 665 */

#line 36 "btree-1.ceu"
    {/* NODE: Stmts 664 */

#line 36 "btree-1.ceu"
    {/* NODE: Set 728 */

#line 36 "btree-1.ceu"
/* SET: ok *//* NODE: RawExp 652 */

#line 36 "btree-1.ceu"
    (((CEU_Body_239*)_ceu_org)->ok_14) = _ceu_app->ret;
#line 36 "btree-1.ceu"
    }
#line 36 "btree-1.ceu"
/* CLEAR: Block (36) */
#line 36 "btree-1.ceu"
    if (0) {

#line 36 "btree-1.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
}

#line 36 "btree-1.ceu"
    }
#line 36 "btree-1.ceu"
/* CLEAR: Block (36) */
#line 36 "btree-1.ceu"
    {
    tceu_evt evt;
             evt.id = CEU_IN__CLEAR;
    ceu_sys_go_ex(_ceu_app, &evt,
                  _ceu_stk,
                  _ceu_org,
                  &_ceu_org->trls[ 2 ],
                  &_ceu_org->trls[ 5 ]);
                                        /* excludes +1 */
}

/* LONGJMP
 * Block termination: we will abort all trails between [t1,t2].
 * Return status=1 to distinguish from longjmp from organism termination.
 * We want to continue from "me.lbl_jmp" below.
 */
#ifdef CEU_ORGS
_ceu_app->stk_jmp.org = _ceu_org;
#endif
_ceu_app->stk_jmp.trl = _ceu_trl;
_ceu_app->stk_jmp.lbl = Body_239_Block_jmp_18;
ceu_longjmp(_ceu_app, _ceu_org,
            2,4);

#line 36 "btree-1.ceu"
case Body_239_Block_jmp_18:;
#line 36 "btree-1.ceu"
    if (0) {

#line 36 "btree-1.ceu"
case Body_239_optorg_reset_17:;
#line 36 "btree-1.ceu"
        {
        tceu_kill* __ceu_casted = (tceu_kill*)_ceu_evt->param;
        if ( ((((CEU_Body_239*)_ceu_org)->_body_165_17).tag != CEU__OPTION__BODY_239__PTR_NIL) &&
             ((((CEU_Body_239*)_ceu_org)->_body_165_17).SOME.v == __ceu_casted->org_or_adt) )
        {
            (((CEU_Body_239*)_ceu_org)->_body_165_17) = CEU__OPTION__BODY_239__PTR_pack(NULL);
        }
    }

#line 36 "btree-1.ceu"
    /*  RESET OPT-ORG TO NULL */
_ceu_org->trls[ 3 ].evt = CEU_IN__ok_killed;
_ceu_org->trls[ 3 ].lbl = Body_239_optorg_reset_17;

#line 36 "btree-1.ceu"
    return;
#line 36 "btree-1.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 36 "btree-1.ceu"
    }/* NODE: If 730 */

#line 37 "btree-1.ceu"
    if (((((CEU_Body_239*)_ceu_org)->ok_14)==0)) {
/* NODE: Block 173 */

#line 38 "btree-1.ceu"
    {/* NODE: Stmts 172 */

#line 38 "btree-1.ceu"
    {/* NODE: Stmts 734 */

#line 38 "btree-1.ceu"
    {/* NODE: Set 732 */

#line 38 "btree-1.ceu"
/* SET: _ret *//* NODE: Var 170 */

#line 38 "btree-1.ceu"
    (((CEU_Body_239*)_ceu_org)->_ret_13) = (((CEU_Body_239*)_ceu_org)->ok_14);
#line 38 "btree-1.ceu"
    #ifdef CEU_ORGS_AWAIT
    _ceu_org->ret = (((CEU_Body_239*)_ceu_org)->_ret_13);
    /* HACK_8: result of immediate spawn termination */
    _ceu_app->ret = _ceu_org->ret;
#endif
/* NODE: Escape 733 */

#line 38 "btree-1.ceu"
    _ceu_lbl = Body_239_Set_out_6;
goto _CEU_GOTO_;

#line 38 "btree-1.ceu"
    }
#line 38 "btree-1.ceu"
    }
#line 38 "btree-1.ceu"
/* CLEAR: Block (38) */
#line 38 "btree-1.ceu"
    if (0) {

#line 38 "btree-1.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
} else {
/* NODE: Nothing 729 */
}
/* NODE: Block 778 */

#line 40 "btree-1.ceu"
    {
#line 40 "btree-1.ceu"
    #ifdef CEU_ORGS
_ceu_org->trls[ 2 ].evt = CEU_IN__ORG;
_ceu_org->trls[ 2 ].org = NULL;
#endif

#line 40 "btree-1.ceu"
    (((CEU_Body_239*)_ceu_org)->_body_180_19).tag = CEU__OPTION__BODY_239__PTR_NIL;

#line 40 "btree-1.ceu"
    /*  RESET OPT-ORG TO NULL */
_ceu_org->trls[ 3 ].evt = CEU_IN__ok_killed;
_ceu_org->trls[ 3 ].lbl = Body_239_optorg_reset_20;
_ceu_org->trls[ 3 ].org_or_adt = NULL;

#line 40 "btree-1.ceu"
    _ceu_trl = &_ceu_org->trls[ 4 ];
/* NODE: Stmts 777 */

#line 40 "btree-1.ceu"
    {/* NODE: Dcl_var 765 */

#line 40 "btree-1.ceu"
/* start org: _s */
#line 40 "btree-1.ceu"
        /* resets org memory and starts org.trail[0]=Class_XXX */
    /* TODO: BUG: _ceu_org is not necessarily the parent for pool allocations */
    ceu_out_org_init(_ceu_app, ((tceu_org*) &(((CEU_Body_239*)_ceu_org)->_s_18)),2,Class_Scope,
                     3,
                     0,
                     _ceu_org,2);
/* TODO: currently idx is always "1" for all interfaces access because pools 
 * are all together there. When we have separate trls for pools, we'll have to 
 * indirectly access the offset in the interface. */

#line 40 "btree-1.ceu"
    {
    tceu_stk stk_ = { NULL, ((tceu_org*) &(((CEU_Body_239*)_ceu_org)->_s_18)), 0, ((tceu_org*) &(((CEU_Body_239*)_ceu_org)->_s_18))->n, {} };
    if (setjmp(stk_.jmp) != 0) {
#ifdef CEU_ORGS
        _ceu_org = _ceu_app->stk_jmp.org;
#endif
        _ceu_trl = _ceu_app->stk_jmp.trl;

#line 40 "btree-1.ceu"
    _ceu_lbl = _ceu_app->stk_jmp.lbl;
goto _CEU_GOTO_;

#line 40 "btree-1.ceu"
        }

    /* SETJMP: spawning a new org
     * The new org might emit a global event that awakes a par/or enclosing the 
     * call point.
     */
    _ceu_stk->up = &stk_;
    ceu_app_go(_ceu_app,NULL,
               ((tceu_org*) &(((CEU_Body_239*)_ceu_org)->_s_18)), &((tceu_org*) &(((CEU_Body_239*)_ceu_org)->_s_18))->trls[0],
               &stk_);
    _ceu_stk->up = NULL;

#line 40 "btree-1.ceu"
    }
/* NODE: Dcl_var 767 */
/* NODE: Set 779 */

#line 40 "btree-1.ceu"
/* SET: _body_180 *//* NODE: Spawn 755 */

#line 40 "btree-1.ceu"
    /*{*/
    tceu_org* __ceu_new_755;

#line 40 "btree-1.ceu"
    #if !defined(CEU_ORGS_NEWS_MALLOC)
    __ceu_new_755 = (tceu_org*) ceu_pool_alloc(&(*((CEU_Body_239*)_ceu_org)->_bodies).pool);
#elif !defined(CEU_ORGS_NEWS_POOL)
    __ceu_new_755 = (tceu_org*) ceu_out_realloc(NULL, sizeof(CEU_Body_239));
#else
    if ((*((CEU_Body_239*)_ceu_org)->_bodies).pool.queue == NULL) {
        __ceu_new_755 = (tceu_org*) ceu_out_realloc(NULL, sizeof(CEU_Body_239));
    } else {
        __ceu_new_755 = (tceu_org*) ceu_pool_alloc(&(*((CEU_Body_239*)_ceu_org)->_bodies).pool);
    }
#endif

#line 40 "btree-1.ceu"
    (((CEU_Body_239*)_ceu_org)->_body_180_19) = (CEU__OPTION__BODY_239__PTR_pack(((CEU_Body_239*)__ceu_new_755)));
#line 40 "btree-1.ceu"
        if (__ceu_new_755 != NULL) {

#line 40 "btree-1.ceu"
    #ifdef CEU_ORGS_NEWS_POOL
        __ceu_new_755->pool = &(*((CEU_Body_239*)_ceu_org)->_bodies);
#endif

#line 40 "btree-1.ceu"
/* start org: dyn */
#line 40 "btree-1.ceu"
        /* resets org memory and starts org.trail[0]=Class_XXX */
    /* TODO: BUG: _ceu_org is not necessarily the parent for pool allocations */
    ceu_out_org_init(_ceu_app, ((tceu_org*) &(*((CEU_Body_239*)__ceu_new_755))),7,Class_Body_239,
                     4,
                     1,
                     (*((CEU_Body_239*)_ceu_org)->_bodies).parent_org,(*((CEU_Body_239*)_ceu_org)->_bodies).parent_trl);
/* TODO: currently idx is always "1" for all interfaces access because pools 
 * are all together there. When we have separate trls for pools, we'll have to 
 * indirectly access the offset in the interface. */

#line 40 "btree-1.ceu"
        ((CEU_Body_239*)((tceu_org*) &(*((CEU_Body_239*)__ceu_new_755))))->_out =
        ((CEU_Body_239*)_ceu_org)->_out;

#line 40 "btree-1.ceu"
        _ceu_constr_754(_ceu_app, ((tceu_org*) &(*((CEU_Body_239*)__ceu_new_755))), _ceu_org);

#line 40 "btree-1.ceu"
    {
    tceu_stk stk_ = { NULL, ((tceu_org*) &(*((CEU_Body_239*)__ceu_new_755))), 0, ((tceu_org*) &(*((CEU_Body_239*)__ceu_new_755)))->n, {} };
    if (setjmp(stk_.jmp) != 0) {
#ifdef CEU_ORGS
        _ceu_org = _ceu_app->stk_jmp.org;
#endif
        _ceu_trl = _ceu_app->stk_jmp.trl;

#line 40 "btree-1.ceu"
    _ceu_lbl = _ceu_app->stk_jmp.lbl;
goto _CEU_GOTO_;

#line 40 "btree-1.ceu"
        }

    /* SETJMP: spawning a new org
     * The new org might emit a global event that awakes a par/or enclosing the 
     * call point.
     */
    _ceu_stk->up = &stk_;
    ceu_app_go(_ceu_app,NULL,
               ((tceu_org*) &(*((CEU_Body_239*)__ceu_new_755))), &((tceu_org*) &(*((CEU_Body_239*)__ceu_new_755)))->trls[0],
               &stk_);
    _ceu_stk->up = NULL;

#line 40 "btree-1.ceu"
        if (!((tceu_org*) &(*((CEU_Body_239*)__ceu_new_755)))->isAlive) {
        (((CEU_Body_239*)_ceu_org)->_body_180_19) = CEU__OPTION__BODY_239__PTR_pack(NULL);
    }

#line 40 "btree-1.ceu"
    }

#line 40 "btree-1.ceu"
        }
/*}*/
/* NODE: If 776 */

#line 40 "btree-1.ceu"
    if (((((CEU_Body_239*)_ceu_org)->_body_180_19).tag != CEU__OPTION__BODY_239__PTR_NIL)) {
/* NODE: Block 773 */

#line 40 "btree-1.ceu"
    {/* NODE: Stmts 772 */

#line 40 "btree-1.ceu"
    {/* NODE: Stmts 833 */

#line 40 "btree-1.ceu"
    {/* NODE: Nothing 787 */
/* NODE: Nothing 1360 */
/* NODE: Nothing 1361 */
/* NODE: Stmts 832 */

#line 40 "btree-1.ceu"
    {/* NODE: If 831 */

#line 40 "btree-1.ceu"
    if ((!(((*((tceu_org*)(((CEU__OPTION__BODY_239__PTR_SOME_assert(_ceu_app, (&((CEU_Body_239*)_ceu_org)->_body_180_19),__FILE__,__LINE__)->SOME.v))))).isAlive)))) {
/* NODE: Block 828 */

#line 40 "btree-1.ceu"
    {/* NODE: Stmts 827 */

#line 40 "btree-1.ceu"
    {/* NODE: Set 807 */

#line 40 "btree-1.ceu"
/* SET: ok *//* NODE: Op1_cast 805 */

#line 40 "btree-1.ceu"
    (((CEU_Body_239*)_ceu_org)->ok_14) = ((int)(((*((tceu_org*)(((CEU__OPTION__BODY_239__PTR_SOME_assert(_ceu_app, (&((CEU_Body_239*)_ceu_org)->_body_180_19),__FILE__,__LINE__)->SOME.v))))).ret)));
#line 40 "btree-1.ceu"
    }
#line 40 "btree-1.ceu"
/* CLEAR: Block (40) */
#line 40 "btree-1.ceu"
    if (0) {

#line 40 "btree-1.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
} else {
/* NODE: Block 830 */

#line 40 "btree-1.ceu"
    {/* NODE: Stmts 829 */

#line 40 "btree-1.ceu"
    {/* NODE: Set 837 */

#line 40 "btree-1.ceu"
/* SET: table: 0xdbb890 *//* NODE: Await 792 */

#line 40 "btree-1.ceu"
    _CEU_NO_792_:
if (0) { goto _CEU_NO_792_; /* avoids "not used" warning */ }

#line 40 "btree-1.ceu"
    _ceu_trl->evt = CEU_IN__ok_killed;
_ceu_trl->lbl = Body_239_Awake__ok_killed_19;
_ceu_trl->seqno = _ceu_app->seqno;

#line 40 "btree-1.ceu"
    _ceu_trl->org_or_adt = (void*)(((CEU__OPTION__BODY_239__PTR_SOME_assert(_ceu_app, (&((CEU_Body_239*)_ceu_org)->_body_180_19),__FILE__,__LINE__)->SOME.v)));

#line 40 "btree-1.ceu"
    return;

case Body_239_Awake__ok_killed_19:;

#line 40 "btree-1.ceu"
    #ifdef CEU_DEBUG_TRAILS
#ifndef CEU_OS
printf("\tOK!\n");
#endif
#endif

#line 40 "btree-1.ceu"
    {

#line 40 "btree-1.ceu"
        tceu_kill* __ceu_casted = (tceu_kill*) _ceu_evt->param;

#line 40 "btree-1.ceu"
        (((CEU_Body_239*)_ceu_org)->ok_14) = ((__ceu_casted)->ret);
}

#line 40 "btree-1.ceu"
    }
#line 40 "btree-1.ceu"
/* CLEAR: Block (40) */
#line 40 "btree-1.ceu"
    if (0) {

#line 40 "btree-1.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
}

#line 40 "btree-1.ceu"
    }
#line 40 "btree-1.ceu"
    }
#line 40 "btree-1.ceu"
    }
#line 40 "btree-1.ceu"
/* CLEAR: Block (40) */
#line 40 "btree-1.ceu"
    if (0) {

#line 40 "btree-1.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
} else {
/* NODE: Block 775 */

#line 40 "btree-1.ceu"
    {/* NODE: Stmts 774 */

#line 40 "btree-1.ceu"
    {/* NODE: Set 838 */

#line 40 "btree-1.ceu"
/* SET: ok *//* NODE: RawExp 762 */

#line 40 "btree-1.ceu"
    (((CEU_Body_239*)_ceu_org)->ok_14) = _ceu_app->ret;
#line 40 "btree-1.ceu"
    }
#line 40 "btree-1.ceu"
/* CLEAR: Block (40) */
#line 40 "btree-1.ceu"
    if (0) {

#line 40 "btree-1.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
}

#line 40 "btree-1.ceu"
    }
#line 40 "btree-1.ceu"
/* CLEAR: Block (40) */
#line 40 "btree-1.ceu"
    {
    tceu_evt evt;
             evt.id = CEU_IN__CLEAR;
    ceu_sys_go_ex(_ceu_app, &evt,
                  _ceu_stk,
                  _ceu_org,
                  &_ceu_org->trls[ 2 ],
                  &_ceu_org->trls[ 5 ]);
                                        /* excludes +1 */
}

/* LONGJMP
 * Block termination: we will abort all trails between [t1,t2].
 * Return status=1 to distinguish from longjmp from organism termination.
 * We want to continue from "me.lbl_jmp" below.
 */
#ifdef CEU_ORGS
_ceu_app->stk_jmp.org = _ceu_org;
#endif
_ceu_app->stk_jmp.trl = _ceu_trl;
_ceu_app->stk_jmp.lbl = Body_239_Block_jmp_21;
ceu_longjmp(_ceu_app, _ceu_org,
            2,4);

#line 40 "btree-1.ceu"
case Body_239_Block_jmp_21:;
#line 40 "btree-1.ceu"
    if (0) {

#line 40 "btree-1.ceu"
case Body_239_optorg_reset_20:;
#line 40 "btree-1.ceu"
        {
        tceu_kill* __ceu_casted = (tceu_kill*)_ceu_evt->param;
        if ( ((((CEU_Body_239*)_ceu_org)->_body_180_19).tag != CEU__OPTION__BODY_239__PTR_NIL) &&
             ((((CEU_Body_239*)_ceu_org)->_body_180_19).SOME.v == __ceu_casted->org_or_adt) )
        {
            (((CEU_Body_239*)_ceu_org)->_body_180_19) = CEU__OPTION__BODY_239__PTR_pack(NULL);
        }
    }

#line 40 "btree-1.ceu"
    /*  RESET OPT-ORG TO NULL */
_ceu_org->trls[ 3 ].evt = CEU_IN__ok_killed;
_ceu_org->trls[ 3 ].lbl = Body_239_optorg_reset_20;

#line 40 "btree-1.ceu"
    return;
#line 40 "btree-1.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
/* NODE: Stmts 842 */

#line 41 "btree-1.ceu"
    {/* NODE: Set 840 */

#line 41 "btree-1.ceu"
/* SET: _ret *//* NODE: Var 182 */

#line 41 "btree-1.ceu"
    (((CEU_Body_239*)_ceu_org)->_ret_13) = (((CEU_Body_239*)_ceu_org)->ok_14);
#line 41 "btree-1.ceu"
    #ifdef CEU_ORGS_AWAIT
    _ceu_org->ret = (((CEU_Body_239*)_ceu_org)->_ret_13);
    /* HACK_8: result of immediate spawn termination */
    _ceu_app->ret = _ceu_org->ret;
#endif
/* NODE: Escape 841 */

#line 41 "btree-1.ceu"
    _ceu_lbl = Body_239_Set_out_6;
goto _CEU_GOTO_;

#line 41 "btree-1.ceu"
    }
#line 36 "btree-1.ceu"
    }
#line 36 "btree-1.ceu"
/* CLEAR: Block (36) */
#line 36 "btree-1.ceu"
    if (0) {

#line 36 "btree-1.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
} else {
/* NODE: If 616 */

#line 42 "btree-1.ceu"
    if ((((((CEU_BTree *)(  ((tceu_pool_adts*) (&((CEU_Body_239*)_ceu_org)->t))->root)))->tag == CEU_BTREE_SELECTOR) /* XXXX */)) {
/* NODE: Block 213 */

#line 43 "btree-1.ceu"
    {/* NODE: Stmts 212 */

#line 43 "btree-1.ceu"
    {/* NODE: Stmts 849 */

#line 43 "btree-1.ceu"
    {/* NODE: Dcl_var 846 */
/* NODE: Block 893 */

#line 43 "btree-1.ceu"
    {
#line 43 "btree-1.ceu"
    #ifdef CEU_ORGS
_ceu_org->trls[ 2 ].evt = CEU_IN__ORG;
_ceu_org->trls[ 2 ].org = NULL;
#endif

#line 43 "btree-1.ceu"
    (((CEU_Body_239*)_ceu_org)->_body_193_22).tag = CEU__OPTION__BODY_239__PTR_NIL;

#line 43 "btree-1.ceu"
    /*  RESET OPT-ORG TO NULL */
_ceu_org->trls[ 3 ].evt = CEU_IN__ok_killed;
_ceu_org->trls[ 3 ].lbl = Body_239_optorg_reset_23;
_ceu_org->trls[ 3 ].org_or_adt = NULL;

#line 43 "btree-1.ceu"
    _ceu_trl = &_ceu_org->trls[ 4 ];
/* NODE: Stmts 892 */

#line 43 "btree-1.ceu"
    {/* NODE: Dcl_var 880 */

#line 43 "btree-1.ceu"
/* start org: _s */
#line 43 "btree-1.ceu"
        /* resets org memory and starts org.trail[0]=Class_XXX */
    /* TODO: BUG: _ceu_org is not necessarily the parent for pool allocations */
    ceu_out_org_init(_ceu_app, ((tceu_org*) &(((CEU_Body_239*)_ceu_org)->_s_21)),2,Class_Scope,
                     3,
                     0,
                     _ceu_org,2);
/* TODO: currently idx is always "1" for all interfaces access because pools 
 * are all together there. When we have separate trls for pools, we'll have to 
 * indirectly access the offset in the interface. */

#line 43 "btree-1.ceu"
    {
    tceu_stk stk_ = { NULL, ((tceu_org*) &(((CEU_Body_239*)_ceu_org)->_s_21)), 0, ((tceu_org*) &(((CEU_Body_239*)_ceu_org)->_s_21))->n, {} };
    if (setjmp(stk_.jmp) != 0) {
#ifdef CEU_ORGS
        _ceu_org = _ceu_app->stk_jmp.org;
#endif
        _ceu_trl = _ceu_app->stk_jmp.trl;

#line 43 "btree-1.ceu"
    _ceu_lbl = _ceu_app->stk_jmp.lbl;
goto _CEU_GOTO_;

#line 43 "btree-1.ceu"
        }

    /* SETJMP: spawning a new org
     * The new org might emit a global event that awakes a par/or enclosing the 
     * call point.
     */
    _ceu_stk->up = &stk_;
    ceu_app_go(_ceu_app,NULL,
               ((tceu_org*) &(((CEU_Body_239*)_ceu_org)->_s_21)), &((tceu_org*) &(((CEU_Body_239*)_ceu_org)->_s_21))->trls[0],
               &stk_);
    _ceu_stk->up = NULL;

#line 43 "btree-1.ceu"
    }
/* NODE: Dcl_var 882 */
/* NODE: Set 894 */

#line 43 "btree-1.ceu"
/* SET: _body_193 *//* NODE: Spawn 870 */

#line 43 "btree-1.ceu"
    /*{*/
    tceu_org* __ceu_new_870;

#line 43 "btree-1.ceu"
    #if !defined(CEU_ORGS_NEWS_MALLOC)
    __ceu_new_870 = (tceu_org*) ceu_pool_alloc(&(*((CEU_Body_239*)_ceu_org)->_bodies).pool);
#elif !defined(CEU_ORGS_NEWS_POOL)
    __ceu_new_870 = (tceu_org*) ceu_out_realloc(NULL, sizeof(CEU_Body_239));
#else
    if ((*((CEU_Body_239*)_ceu_org)->_bodies).pool.queue == NULL) {
        __ceu_new_870 = (tceu_org*) ceu_out_realloc(NULL, sizeof(CEU_Body_239));
    } else {
        __ceu_new_870 = (tceu_org*) ceu_pool_alloc(&(*((CEU_Body_239*)_ceu_org)->_bodies).pool);
    }
#endif

#line 43 "btree-1.ceu"
    (((CEU_Body_239*)_ceu_org)->_body_193_22) = (CEU__OPTION__BODY_239__PTR_pack(((CEU_Body_239*)__ceu_new_870)));
#line 43 "btree-1.ceu"
        if (__ceu_new_870 != NULL) {

#line 43 "btree-1.ceu"
    #ifdef CEU_ORGS_NEWS_POOL
        __ceu_new_870->pool = &(*((CEU_Body_239*)_ceu_org)->_bodies);
#endif

#line 43 "btree-1.ceu"
/* start org: dyn */
#line 43 "btree-1.ceu"
        /* resets org memory and starts org.trail[0]=Class_XXX */
    /* TODO: BUG: _ceu_org is not necessarily the parent for pool allocations */
    ceu_out_org_init(_ceu_app, ((tceu_org*) &(*((CEU_Body_239*)__ceu_new_870))),7,Class_Body_239,
                     4,
                     1,
                     (*((CEU_Body_239*)_ceu_org)->_bodies).parent_org,(*((CEU_Body_239*)_ceu_org)->_bodies).parent_trl);
/* TODO: currently idx is always "1" for all interfaces access because pools 
 * are all together there. When we have separate trls for pools, we'll have to 
 * indirectly access the offset in the interface. */

#line 43 "btree-1.ceu"
        ((CEU_Body_239*)((tceu_org*) &(*((CEU_Body_239*)__ceu_new_870))))->_out =
        ((CEU_Body_239*)_ceu_org)->_out;

#line 43 "btree-1.ceu"
        _ceu_constr_869(_ceu_app, ((tceu_org*) &(*((CEU_Body_239*)__ceu_new_870))), _ceu_org);

#line 43 "btree-1.ceu"
    {
    tceu_stk stk_ = { NULL, ((tceu_org*) &(*((CEU_Body_239*)__ceu_new_870))), 0, ((tceu_org*) &(*((CEU_Body_239*)__ceu_new_870)))->n, {} };
    if (setjmp(stk_.jmp) != 0) {
#ifdef CEU_ORGS
        _ceu_org = _ceu_app->stk_jmp.org;
#endif
        _ceu_trl = _ceu_app->stk_jmp.trl;

#line 43 "btree-1.ceu"
    _ceu_lbl = _ceu_app->stk_jmp.lbl;
goto _CEU_GOTO_;

#line 43 "btree-1.ceu"
        }

    /* SETJMP: spawning a new org
     * The new org might emit a global event that awakes a par/or enclosing the 
     * call point.
     */
    _ceu_stk->up = &stk_;
    ceu_app_go(_ceu_app,NULL,
               ((tceu_org*) &(*((CEU_Body_239*)__ceu_new_870))), &((tceu_org*) &(*((CEU_Body_239*)__ceu_new_870)))->trls[0],
               &stk_);
    _ceu_stk->up = NULL;

#line 43 "btree-1.ceu"
        if (!((tceu_org*) &(*((CEU_Body_239*)__ceu_new_870)))->isAlive) {
        (((CEU_Body_239*)_ceu_org)->_body_193_22) = CEU__OPTION__BODY_239__PTR_pack(NULL);
    }

#line 43 "btree-1.ceu"
    }

#line 43 "btree-1.ceu"
        }
/*}*/
/* NODE: If 891 */

#line 43 "btree-1.ceu"
    if (((((CEU_Body_239*)_ceu_org)->_body_193_22).tag != CEU__OPTION__BODY_239__PTR_NIL)) {
/* NODE: Block 888 */

#line 43 "btree-1.ceu"
    {/* NODE: Stmts 887 */

#line 43 "btree-1.ceu"
    {/* NODE: Stmts 948 */

#line 43 "btree-1.ceu"
    {/* NODE: Nothing 902 */
/* NODE: Nothing 1366 */
/* NODE: Nothing 1367 */
/* NODE: Stmts 947 */

#line 43 "btree-1.ceu"
    {/* NODE: If 946 */

#line 43 "btree-1.ceu"
    if ((!(((*((tceu_org*)(((CEU__OPTION__BODY_239__PTR_SOME_assert(_ceu_app, (&((CEU_Body_239*)_ceu_org)->_body_193_22),__FILE__,__LINE__)->SOME.v))))).isAlive)))) {
/* NODE: Block 943 */

#line 43 "btree-1.ceu"
    {/* NODE: Stmts 942 */

#line 43 "btree-1.ceu"
    {/* NODE: Set 922 */

#line 43 "btree-1.ceu"
/* SET: ok *//* NODE: Op1_cast 920 */

#line 43 "btree-1.ceu"
    (((CEU_Body_239*)_ceu_org)->ok_20) = ((int)(((*((tceu_org*)(((CEU__OPTION__BODY_239__PTR_SOME_assert(_ceu_app, (&((CEU_Body_239*)_ceu_org)->_body_193_22),__FILE__,__LINE__)->SOME.v))))).ret)));
#line 43 "btree-1.ceu"
    }
#line 43 "btree-1.ceu"
/* CLEAR: Block (43) */
#line 43 "btree-1.ceu"
    if (0) {

#line 43 "btree-1.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
} else {
/* NODE: Block 945 */

#line 43 "btree-1.ceu"
    {/* NODE: Stmts 944 */

#line 43 "btree-1.ceu"
    {/* NODE: Set 952 */

#line 43 "btree-1.ceu"
/* SET: table: 0xdd9ea0 *//* NODE: Await 907 */

#line 43 "btree-1.ceu"
    _CEU_NO_907_:
if (0) { goto _CEU_NO_907_; /* avoids "not used" warning */ }

#line 43 "btree-1.ceu"
    _ceu_trl->evt = CEU_IN__ok_killed;
_ceu_trl->lbl = Body_239_Awake__ok_killed_22;
_ceu_trl->seqno = _ceu_app->seqno;

#line 43 "btree-1.ceu"
    _ceu_trl->org_or_adt = (void*)(((CEU__OPTION__BODY_239__PTR_SOME_assert(_ceu_app, (&((CEU_Body_239*)_ceu_org)->_body_193_22),__FILE__,__LINE__)->SOME.v)));

#line 43 "btree-1.ceu"
    return;

case Body_239_Awake__ok_killed_22:;

#line 43 "btree-1.ceu"
    #ifdef CEU_DEBUG_TRAILS
#ifndef CEU_OS
printf("\tOK!\n");
#endif
#endif

#line 43 "btree-1.ceu"
    {

#line 43 "btree-1.ceu"
        tceu_kill* __ceu_casted = (tceu_kill*) _ceu_evt->param;

#line 43 "btree-1.ceu"
        (((CEU_Body_239*)_ceu_org)->ok_20) = ((__ceu_casted)->ret);
}

#line 43 "btree-1.ceu"
    }
#line 43 "btree-1.ceu"
/* CLEAR: Block (43) */
#line 43 "btree-1.ceu"
    if (0) {

#line 43 "btree-1.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
}

#line 43 "btree-1.ceu"
    }
#line 43 "btree-1.ceu"
    }
#line 43 "btree-1.ceu"
    }
#line 43 "btree-1.ceu"
/* CLEAR: Block (43) */
#line 43 "btree-1.ceu"
    if (0) {

#line 43 "btree-1.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
} else {
/* NODE: Block 890 */

#line 43 "btree-1.ceu"
    {/* NODE: Stmts 889 */

#line 43 "btree-1.ceu"
    {/* NODE: Set 953 */

#line 43 "btree-1.ceu"
/* SET: ok *//* NODE: RawExp 877 */

#line 43 "btree-1.ceu"
    (((CEU_Body_239*)_ceu_org)->ok_20) = _ceu_app->ret;
#line 43 "btree-1.ceu"
    }
#line 43 "btree-1.ceu"
/* CLEAR: Block (43) */
#line 43 "btree-1.ceu"
    if (0) {

#line 43 "btree-1.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
}

#line 43 "btree-1.ceu"
    }
#line 43 "btree-1.ceu"
/* CLEAR: Block (43) */
#line 43 "btree-1.ceu"
    {
    tceu_evt evt;
             evt.id = CEU_IN__CLEAR;
    ceu_sys_go_ex(_ceu_app, &evt,
                  _ceu_stk,
                  _ceu_org,
                  &_ceu_org->trls[ 2 ],
                  &_ceu_org->trls[ 5 ]);
                                        /* excludes +1 */
}

/* LONGJMP
 * Block termination: we will abort all trails between [t1,t2].
 * Return status=1 to distinguish from longjmp from organism termination.
 * We want to continue from "me.lbl_jmp" below.
 */
#ifdef CEU_ORGS
_ceu_app->stk_jmp.org = _ceu_org;
#endif
_ceu_app->stk_jmp.trl = _ceu_trl;
_ceu_app->stk_jmp.lbl = Body_239_Block_jmp_24;
ceu_longjmp(_ceu_app, _ceu_org,
            2,4);

#line 43 "btree-1.ceu"
case Body_239_Block_jmp_24:;
#line 43 "btree-1.ceu"
    if (0) {

#line 43 "btree-1.ceu"
case Body_239_optorg_reset_23:;
#line 43 "btree-1.ceu"
        {
        tceu_kill* __ceu_casted = (tceu_kill*)_ceu_evt->param;
        if ( ((((CEU_Body_239*)_ceu_org)->_body_193_22).tag != CEU__OPTION__BODY_239__PTR_NIL) &&
             ((((CEU_Body_239*)_ceu_org)->_body_193_22).SOME.v == __ceu_casted->org_or_adt) )
        {
            (((CEU_Body_239*)_ceu_org)->_body_193_22) = CEU__OPTION__BODY_239__PTR_pack(NULL);
        }
    }

#line 43 "btree-1.ceu"
    /*  RESET OPT-ORG TO NULL */
_ceu_org->trls[ 3 ].evt = CEU_IN__ok_killed;
_ceu_org->trls[ 3 ].lbl = Body_239_optorg_reset_23;

#line 43 "btree-1.ceu"
    return;
#line 43 "btree-1.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 43 "btree-1.ceu"
    }/* NODE: If 955 */

#line 44 "btree-1.ceu"
    if (((((CEU_Body_239*)_ceu_org)->ok_20)!=0)) {
/* NODE: Block 201 */

#line 45 "btree-1.ceu"
    {/* NODE: Stmts 200 */

#line 45 "btree-1.ceu"
    {/* NODE: Stmts 959 */

#line 45 "btree-1.ceu"
    {/* NODE: Set 957 */

#line 45 "btree-1.ceu"
/* SET: _ret *//* NODE: Var 198 */

#line 45 "btree-1.ceu"
    (((CEU_Body_239*)_ceu_org)->_ret_13) = (((CEU_Body_239*)_ceu_org)->ok_20);
#line 45 "btree-1.ceu"
    #ifdef CEU_ORGS_AWAIT
    _ceu_org->ret = (((CEU_Body_239*)_ceu_org)->_ret_13);
    /* HACK_8: result of immediate spawn termination */
    _ceu_app->ret = _ceu_org->ret;
#endif
/* NODE: Escape 958 */

#line 45 "btree-1.ceu"
    _ceu_lbl = Body_239_Set_out_6;
goto _CEU_GOTO_;

#line 45 "btree-1.ceu"
    }
#line 45 "btree-1.ceu"
    }
#line 45 "btree-1.ceu"
/* CLEAR: Block (45) */
#line 45 "btree-1.ceu"
    if (0) {

#line 45 "btree-1.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
} else {
/* NODE: Nothing 954 */
}
/* NODE: Stmts 964 */

#line 47 "btree-1.ceu"
    {/* NODE: Dcl_var 961 */
/* NODE: Block 1008 */

#line 47 "btree-1.ceu"
    {
#line 47 "btree-1.ceu"
    #ifdef CEU_ORGS
_ceu_org->trls[ 2 ].evt = CEU_IN__ORG;
_ceu_org->trls[ 2 ].org = NULL;
#endif

#line 47 "btree-1.ceu"
    (((CEU_Body_239*)_ceu_org)->_body_208_25).tag = CEU__OPTION__BODY_239__PTR_NIL;

#line 47 "btree-1.ceu"
    /*  RESET OPT-ORG TO NULL */
_ceu_org->trls[ 3 ].evt = CEU_IN__ok_killed;
_ceu_org->trls[ 3 ].lbl = Body_239_optorg_reset_26;
_ceu_org->trls[ 3 ].org_or_adt = NULL;

#line 47 "btree-1.ceu"
    _ceu_trl = &_ceu_org->trls[ 4 ];
/* NODE: Stmts 1007 */

#line 47 "btree-1.ceu"
    {/* NODE: Dcl_var 995 */

#line 47 "btree-1.ceu"
/* start org: _s */
#line 47 "btree-1.ceu"
        /* resets org memory and starts org.trail[0]=Class_XXX */
    /* TODO: BUG: _ceu_org is not necessarily the parent for pool allocations */
    ceu_out_org_init(_ceu_app, ((tceu_org*) &(((CEU_Body_239*)_ceu_org)->_s_24)),2,Class_Scope,
                     3,
                     0,
                     _ceu_org,2);
/* TODO: currently idx is always "1" for all interfaces access because pools 
 * are all together there. When we have separate trls for pools, we'll have to 
 * indirectly access the offset in the interface. */

#line 47 "btree-1.ceu"
    {
    tceu_stk stk_ = { NULL, ((tceu_org*) &(((CEU_Body_239*)_ceu_org)->_s_24)), 0, ((tceu_org*) &(((CEU_Body_239*)_ceu_org)->_s_24))->n, {} };
    if (setjmp(stk_.jmp) != 0) {
#ifdef CEU_ORGS
        _ceu_org = _ceu_app->stk_jmp.org;
#endif
        _ceu_trl = _ceu_app->stk_jmp.trl;

#line 47 "btree-1.ceu"
    _ceu_lbl = _ceu_app->stk_jmp.lbl;
goto _CEU_GOTO_;

#line 47 "btree-1.ceu"
        }

    /* SETJMP: spawning a new org
     * The new org might emit a global event that awakes a par/or enclosing the 
     * call point.
     */
    _ceu_stk->up = &stk_;
    ceu_app_go(_ceu_app,NULL,
               ((tceu_org*) &(((CEU_Body_239*)_ceu_org)->_s_24)), &((tceu_org*) &(((CEU_Body_239*)_ceu_org)->_s_24))->trls[0],
               &stk_);
    _ceu_stk->up = NULL;

#line 47 "btree-1.ceu"
    }
/* NODE: Dcl_var 997 */
/* NODE: Set 1009 */

#line 47 "btree-1.ceu"
/* SET: _body_208 *//* NODE: Spawn 985 */

#line 47 "btree-1.ceu"
    /*{*/
    tceu_org* __ceu_new_985;

#line 47 "btree-1.ceu"
    #if !defined(CEU_ORGS_NEWS_MALLOC)
    __ceu_new_985 = (tceu_org*) ceu_pool_alloc(&(*((CEU_Body_239*)_ceu_org)->_bodies).pool);
#elif !defined(CEU_ORGS_NEWS_POOL)
    __ceu_new_985 = (tceu_org*) ceu_out_realloc(NULL, sizeof(CEU_Body_239));
#else
    if ((*((CEU_Body_239*)_ceu_org)->_bodies).pool.queue == NULL) {
        __ceu_new_985 = (tceu_org*) ceu_out_realloc(NULL, sizeof(CEU_Body_239));
    } else {
        __ceu_new_985 = (tceu_org*) ceu_pool_alloc(&(*((CEU_Body_239*)_ceu_org)->_bodies).pool);
    }
#endif

#line 47 "btree-1.ceu"
    (((CEU_Body_239*)_ceu_org)->_body_208_25) = (CEU__OPTION__BODY_239__PTR_pack(((CEU_Body_239*)__ceu_new_985)));
#line 47 "btree-1.ceu"
        if (__ceu_new_985 != NULL) {

#line 47 "btree-1.ceu"
    #ifdef CEU_ORGS_NEWS_POOL
        __ceu_new_985->pool = &(*((CEU_Body_239*)_ceu_org)->_bodies);
#endif

#line 47 "btree-1.ceu"
/* start org: dyn */
#line 47 "btree-1.ceu"
        /* resets org memory and starts org.trail[0]=Class_XXX */
    /* TODO: BUG: _ceu_org is not necessarily the parent for pool allocations */
    ceu_out_org_init(_ceu_app, ((tceu_org*) &(*((CEU_Body_239*)__ceu_new_985))),7,Class_Body_239,
                     4,
                     1,
                     (*((CEU_Body_239*)_ceu_org)->_bodies).parent_org,(*((CEU_Body_239*)_ceu_org)->_bodies).parent_trl);
/* TODO: currently idx is always "1" for all interfaces access because pools 
 * are all together there. When we have separate trls for pools, we'll have to 
 * indirectly access the offset in the interface. */

#line 47 "btree-1.ceu"
        ((CEU_Body_239*)((tceu_org*) &(*((CEU_Body_239*)__ceu_new_985))))->_out =
        ((CEU_Body_239*)_ceu_org)->_out;

#line 47 "btree-1.ceu"
        _ceu_constr_984(_ceu_app, ((tceu_org*) &(*((CEU_Body_239*)__ceu_new_985))), _ceu_org);

#line 47 "btree-1.ceu"
    {
    tceu_stk stk_ = { NULL, ((tceu_org*) &(*((CEU_Body_239*)__ceu_new_985))), 0, ((tceu_org*) &(*((CEU_Body_239*)__ceu_new_985)))->n, {} };
    if (setjmp(stk_.jmp) != 0) {
#ifdef CEU_ORGS
        _ceu_org = _ceu_app->stk_jmp.org;
#endif
        _ceu_trl = _ceu_app->stk_jmp.trl;

#line 47 "btree-1.ceu"
    _ceu_lbl = _ceu_app->stk_jmp.lbl;
goto _CEU_GOTO_;

#line 47 "btree-1.ceu"
        }

    /* SETJMP: spawning a new org
     * The new org might emit a global event that awakes a par/or enclosing the 
     * call point.
     */
    _ceu_stk->up = &stk_;
    ceu_app_go(_ceu_app,NULL,
               ((tceu_org*) &(*((CEU_Body_239*)__ceu_new_985))), &((tceu_org*) &(*((CEU_Body_239*)__ceu_new_985)))->trls[0],
               &stk_);
    _ceu_stk->up = NULL;

#line 47 "btree-1.ceu"
        if (!((tceu_org*) &(*((CEU_Body_239*)__ceu_new_985)))->isAlive) {
        (((CEU_Body_239*)_ceu_org)->_body_208_25) = CEU__OPTION__BODY_239__PTR_pack(NULL);
    }

#line 47 "btree-1.ceu"
    }

#line 47 "btree-1.ceu"
        }
/*}*/
/* NODE: If 1006 */

#line 47 "btree-1.ceu"
    if (((((CEU_Body_239*)_ceu_org)->_body_208_25).tag != CEU__OPTION__BODY_239__PTR_NIL)) {
/* NODE: Block 1003 */

#line 47 "btree-1.ceu"
    {/* NODE: Stmts 1002 */

#line 47 "btree-1.ceu"
    {/* NODE: Stmts 1063 */

#line 47 "btree-1.ceu"
    {/* NODE: Nothing 1017 */
/* NODE: Nothing 1372 */
/* NODE: Nothing 1373 */
/* NODE: Stmts 1062 */

#line 47 "btree-1.ceu"
    {/* NODE: If 1061 */

#line 47 "btree-1.ceu"
    if ((!(((*((tceu_org*)(((CEU__OPTION__BODY_239__PTR_SOME_assert(_ceu_app, (&((CEU_Body_239*)_ceu_org)->_body_208_25),__FILE__,__LINE__)->SOME.v))))).isAlive)))) {
/* NODE: Block 1058 */

#line 47 "btree-1.ceu"
    {/* NODE: Stmts 1057 */

#line 47 "btree-1.ceu"
    {/* NODE: Set 1037 */

#line 47 "btree-1.ceu"
/* SET: ok *//* NODE: Op1_cast 1035 */

#line 47 "btree-1.ceu"
    (((CEU_Body_239*)_ceu_org)->ok_23) = ((int)(((*((tceu_org*)(((CEU__OPTION__BODY_239__PTR_SOME_assert(_ceu_app, (&((CEU_Body_239*)_ceu_org)->_body_208_25),__FILE__,__LINE__)->SOME.v))))).ret)));
#line 47 "btree-1.ceu"
    }
#line 47 "btree-1.ceu"
/* CLEAR: Block (47) */
#line 47 "btree-1.ceu"
    if (0) {

#line 47 "btree-1.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
} else {
/* NODE: Block 1060 */

#line 47 "btree-1.ceu"
    {/* NODE: Stmts 1059 */

#line 47 "btree-1.ceu"
    {/* NODE: Set 1067 */

#line 47 "btree-1.ceu"
/* SET: table: 0xde72e0 *//* NODE: Await 1022 */

#line 47 "btree-1.ceu"
    _CEU_NO_1022_:
if (0) { goto _CEU_NO_1022_; /* avoids "not used" warning */ }

#line 47 "btree-1.ceu"
    _ceu_trl->evt = CEU_IN__ok_killed;
_ceu_trl->lbl = Body_239_Awake__ok_killed_25;
_ceu_trl->seqno = _ceu_app->seqno;

#line 47 "btree-1.ceu"
    _ceu_trl->org_or_adt = (void*)(((CEU__OPTION__BODY_239__PTR_SOME_assert(_ceu_app, (&((CEU_Body_239*)_ceu_org)->_body_208_25),__FILE__,__LINE__)->SOME.v)));

#line 47 "btree-1.ceu"
    return;

case Body_239_Awake__ok_killed_25:;

#line 47 "btree-1.ceu"
    #ifdef CEU_DEBUG_TRAILS
#ifndef CEU_OS
printf("\tOK!\n");
#endif
#endif

#line 47 "btree-1.ceu"
    {

#line 47 "btree-1.ceu"
        tceu_kill* __ceu_casted = (tceu_kill*) _ceu_evt->param;

#line 47 "btree-1.ceu"
        (((CEU_Body_239*)_ceu_org)->ok_23) = ((__ceu_casted)->ret);
}

#line 47 "btree-1.ceu"
    }
#line 47 "btree-1.ceu"
/* CLEAR: Block (47) */
#line 47 "btree-1.ceu"
    if (0) {

#line 47 "btree-1.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
}

#line 47 "btree-1.ceu"
    }
#line 47 "btree-1.ceu"
    }
#line 47 "btree-1.ceu"
    }
#line 47 "btree-1.ceu"
/* CLEAR: Block (47) */
#line 47 "btree-1.ceu"
    if (0) {

#line 47 "btree-1.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
} else {
/* NODE: Block 1005 */

#line 47 "btree-1.ceu"
    {/* NODE: Stmts 1004 */

#line 47 "btree-1.ceu"
    {/* NODE: Set 1068 */

#line 47 "btree-1.ceu"
/* SET: ok *//* NODE: RawExp 992 */

#line 47 "btree-1.ceu"
    (((CEU_Body_239*)_ceu_org)->ok_23) = _ceu_app->ret;
#line 47 "btree-1.ceu"
    }
#line 47 "btree-1.ceu"
/* CLEAR: Block (47) */
#line 47 "btree-1.ceu"
    if (0) {

#line 47 "btree-1.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
}

#line 47 "btree-1.ceu"
    }
#line 47 "btree-1.ceu"
/* CLEAR: Block (47) */
#line 47 "btree-1.ceu"
    {
    tceu_evt evt;
             evt.id = CEU_IN__CLEAR;
    ceu_sys_go_ex(_ceu_app, &evt,
                  _ceu_stk,
                  _ceu_org,
                  &_ceu_org->trls[ 2 ],
                  &_ceu_org->trls[ 5 ]);
                                        /* excludes +1 */
}

/* LONGJMP
 * Block termination: we will abort all trails between [t1,t2].
 * Return status=1 to distinguish from longjmp from organism termination.
 * We want to continue from "me.lbl_jmp" below.
 */
#ifdef CEU_ORGS
_ceu_app->stk_jmp.org = _ceu_org;
#endif
_ceu_app->stk_jmp.trl = _ceu_trl;
_ceu_app->stk_jmp.lbl = Body_239_Block_jmp_27;
ceu_longjmp(_ceu_app, _ceu_org,
            2,4);

#line 47 "btree-1.ceu"
case Body_239_Block_jmp_27:;
#line 47 "btree-1.ceu"
    if (0) {

#line 47 "btree-1.ceu"
case Body_239_optorg_reset_26:;
#line 47 "btree-1.ceu"
        {
        tceu_kill* __ceu_casted = (tceu_kill*)_ceu_evt->param;
        if ( ((((CEU_Body_239*)_ceu_org)->_body_208_25).tag != CEU__OPTION__BODY_239__PTR_NIL) &&
             ((((CEU_Body_239*)_ceu_org)->_body_208_25).SOME.v == __ceu_casted->org_or_adt) )
        {
            (((CEU_Body_239*)_ceu_org)->_body_208_25) = CEU__OPTION__BODY_239__PTR_pack(NULL);
        }
    }

#line 47 "btree-1.ceu"
    /*  RESET OPT-ORG TO NULL */
_ceu_org->trls[ 3 ].evt = CEU_IN__ok_killed;
_ceu_org->trls[ 3 ].lbl = Body_239_optorg_reset_26;

#line 47 "btree-1.ceu"
    return;
#line 47 "btree-1.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 47 "btree-1.ceu"
    }/* NODE: Stmts 1072 */

#line 48 "btree-1.ceu"
    {/* NODE: Set 1070 */

#line 48 "btree-1.ceu"
/* SET: _ret *//* NODE: Var 210 */

#line 48 "btree-1.ceu"
    (((CEU_Body_239*)_ceu_org)->_ret_13) = (((CEU_Body_239*)_ceu_org)->ok_23);
#line 48 "btree-1.ceu"
    #ifdef CEU_ORGS_AWAIT
    _ceu_org->ret = (((CEU_Body_239*)_ceu_org)->_ret_13);
    /* HACK_8: result of immediate spawn termination */
    _ceu_app->ret = _ceu_org->ret;
#endif
/* NODE: Escape 1071 */

#line 48 "btree-1.ceu"
    _ceu_lbl = Body_239_Set_out_6;
goto _CEU_GOTO_;

#line 48 "btree-1.ceu"
    }
#line 43 "btree-1.ceu"
    }
#line 43 "btree-1.ceu"
/* CLEAR: Block (43) */
#line 43 "btree-1.ceu"
    if (0) {

#line 43 "btree-1.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
} else {
/* NODE: If 615 */

#line 49 "btree-1.ceu"
    if ((((((CEU_BTree *)(  ((tceu_pool_adts*) (&((CEU_Body_239*)_ceu_org)->t))->root)))->tag == CEU_BTREE_LEAF) /* XXXX */)) {
/* NODE: Block 232 */

#line 50 "btree-1.ceu"
    {/* NODE: Stmts 231 */

#line 50 "btree-1.ceu"
    {/* NODE: Stmts 1079 */

#line 50 "btree-1.ceu"
    {/* NODE: Dcl_var 1076 */
/* NODE: Do 1087 */
/* NODE: Block 1086 */

#line 51 "btree-1.ceu"
    {
#line 51 "btree-1.ceu"
    #ifdef CEU_ORGS
_ceu_org->trls[ 2 ].evt = CEU_IN__ORG;
_ceu_org->trls[ 2 ].org = NULL;
#endif

#line 51 "btree-1.ceu"
    _ceu_trl = &_ceu_org->trls[ 3 ];
/* NODE: Stmts 1085 */

#line 51 "btree-1.ceu"
    {/* NODE: Dcl_var 1084 */

#line 51 "btree-1.ceu"
/* start org: _org_227 */
#line 51 "btree-1.ceu"
        /* resets org memory and starts org.trail[0]=Class_XXX */
    /* TODO: BUG: _ceu_org is not necessarily the parent for pool allocations */
    ceu_out_org_init(_ceu_app, ((tceu_org*) &(((CEU_Body_239*)_ceu_org)->_org_227_27)),2,Class_LeafHandler,
                     1,
                     0,
                     _ceu_org,2);
/* TODO: currently idx is always "1" for all interfaces access because pools 
 * are all together there. When we have separate trls for pools, we'll have to 
 * indirectly access the offset in the interface. */

#line 51 "btree-1.ceu"
        _ceu_constr_226(_ceu_app, ((tceu_org*) &(((CEU_Body_239*)_ceu_org)->_org_227_27)), _ceu_org);

#line 51 "btree-1.ceu"
    {
    tceu_stk stk_ = { NULL, ((tceu_org*) &(((CEU_Body_239*)_ceu_org)->_org_227_27)), 0, ((tceu_org*) &(((CEU_Body_239*)_ceu_org)->_org_227_27))->n, {} };
    if (setjmp(stk_.jmp) != 0) {
#ifdef CEU_ORGS
        _ceu_org = _ceu_app->stk_jmp.org;
#endif
        _ceu_trl = _ceu_app->stk_jmp.trl;

#line 51 "btree-1.ceu"
    _ceu_lbl = _ceu_app->stk_jmp.lbl;
goto _CEU_GOTO_;

#line 51 "btree-1.ceu"
        }

    /* SETJMP: spawning a new org
     * The new org might emit a global event that awakes a par/or enclosing the 
     * call point.
     */
    _ceu_stk->up = &stk_;
    ceu_app_go(_ceu_app,NULL,
               ((tceu_org*) &(((CEU_Body_239*)_ceu_org)->_org_227_27)), &((tceu_org*) &(((CEU_Body_239*)_ceu_org)->_org_227_27))->trls[0],
               &stk_);
    _ceu_stk->up = NULL;

#line 51 "btree-1.ceu"
    }
/* NODE: Stmts 1131 */

#line 51 "btree-1.ceu"
    {/* NODE: Nothing 1093 */
/* NODE: Nothing 1375 */
/* NODE: Nothing 1376 */
/* NODE: Stmts 1130 */

#line 51 "btree-1.ceu"
    {/* NODE: If 1129 */

#line 51 "btree-1.ceu"
    if ((!(((*((tceu_org*)(&((CEU_Body_239*)_ceu_org)->_org_227_27))).isAlive)))) {
/* NODE: Block 1126 */

#line 51 "btree-1.ceu"
    {/* NODE: Stmts 1125 */

#line 51 "btree-1.ceu"
    {/* NODE: Set 1109 */

#line 51 "btree-1.ceu"
/* SET: ok *//* NODE: Op1_cast 1107 */

#line 51 "btree-1.ceu"
    (((CEU_Body_239*)_ceu_org)->ok_26) = ((int)(((*((tceu_org*)(&((CEU_Body_239*)_ceu_org)->_org_227_27))).ret)));
#line 51 "btree-1.ceu"
    }
#line 51 "btree-1.ceu"
/* CLEAR: Block (51) */
#line 51 "btree-1.ceu"
    if (0) {

#line 51 "btree-1.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
} else {
/* NODE: Block 1128 */

#line 51 "btree-1.ceu"
    {/* NODE: Stmts 1127 */

#line 51 "btree-1.ceu"
    {/* NODE: Set 1135 */

#line 51 "btree-1.ceu"
/* SET: table: 0xdee450 *//* NODE: Await 1096 */

#line 51 "btree-1.ceu"
    _CEU_NO_1096_:
if (0) { goto _CEU_NO_1096_; /* avoids "not used" warning */ }

#line 51 "btree-1.ceu"
    _ceu_trl->evt = CEU_IN__ok_killed;
_ceu_trl->lbl = Body_239_Awake__ok_killed_28;
_ceu_trl->seqno = _ceu_app->seqno;

#line 51 "btree-1.ceu"
    _ceu_trl->org_or_adt = (void*)(&((CEU_Body_239*)_ceu_org)->_org_227_27);

#line 51 "btree-1.ceu"
    return;

case Body_239_Awake__ok_killed_28:;

#line 51 "btree-1.ceu"
    #ifdef CEU_DEBUG_TRAILS
#ifndef CEU_OS
printf("\tOK!\n");
#endif
#endif

#line 51 "btree-1.ceu"
    {

#line 51 "btree-1.ceu"
        tceu_kill* __ceu_casted = (tceu_kill*) _ceu_evt->param;

#line 51 "btree-1.ceu"
        (((CEU_Body_239*)_ceu_org)->ok_26) = ((__ceu_casted)->ret);
}

#line 51 "btree-1.ceu"
    }
#line 51 "btree-1.ceu"
/* CLEAR: Block (51) */
#line 51 "btree-1.ceu"
    if (0) {

#line 51 "btree-1.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
}

#line 51 "btree-1.ceu"
    }
#line 51 "btree-1.ceu"
    }
#line 51 "btree-1.ceu"
    }
#line 51 "btree-1.ceu"
/* CLEAR: Block (51) */
#line 51 "btree-1.ceu"
    {
    tceu_evt evt;
             evt.id = CEU_IN__CLEAR;
    ceu_sys_go_ex(_ceu_app, &evt,
                  _ceu_stk,
                  _ceu_org,
                  &_ceu_org->trls[ 2 ],
                  &_ceu_org->trls[ 4 ]);
                                        /* excludes +1 */
}

/* LONGJMP
 * Block termination: we will abort all trails between [t1,t2].
 * Return status=1 to distinguish from longjmp from organism termination.
 * We want to continue from "me.lbl_jmp" below.
 */
#ifdef CEU_ORGS
_ceu_app->stk_jmp.org = _ceu_org;
#endif
_ceu_app->stk_jmp.trl = _ceu_trl;
_ceu_app->stk_jmp.lbl = Body_239_Block_jmp_29;
ceu_longjmp(_ceu_app, _ceu_org,
            2,3);

#line 51 "btree-1.ceu"
case Body_239_Block_jmp_29:;
#line 51 "btree-1.ceu"
    if (0) {

#line 51 "btree-1.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 50 "btree-1.ceu"
    }/* NODE: Stmts 1139 */

#line 54 "btree-1.ceu"
    {/* NODE: Set 1137 */

#line 54 "btree-1.ceu"
/* SET: _ret *//* NODE: Var 229 */

#line 54 "btree-1.ceu"
    (((CEU_Body_239*)_ceu_org)->_ret_13) = (((CEU_Body_239*)_ceu_org)->ok_26);
#line 54 "btree-1.ceu"
    #ifdef CEU_ORGS_AWAIT
    _ceu_org->ret = (((CEU_Body_239*)_ceu_org)->_ret_13);
    /* HACK_8: result of immediate spawn termination */
    _ceu_app->ret = _ceu_org->ret;
#endif
/* NODE: Escape 1138 */

#line 54 "btree-1.ceu"
    _ceu_lbl = Body_239_Set_out_6;
goto _CEU_GOTO_;

#line 54 "btree-1.ceu"
    }
#line 50 "btree-1.ceu"
    }
#line 50 "btree-1.ceu"
/* CLEAR: Block (50) */
#line 50 "btree-1.ceu"
    if (0) {

#line 50 "btree-1.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
} else {
/* NODE: Nothing 614 */
}
}
}

#line 35 "btree-1.ceu"
    }
#line 35 "btree-1.ceu"
/* CLEAR: Block (35) */
#line 35 "btree-1.ceu"
    if (0) {

#line 35 "btree-1.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 34 "btree-1.ceu"
/* PAROR JOIN */
#line 34 "btree-1.ceu"
    _ceu_lbl = Body_239_ParOr_out_13;
goto _CEU_GOTO_;

#line 34 "btree-1.ceu"
case Body_239_ParOr_sub_1_12:;/* NODE: Block 582 */

#line 34 "btree-1.ceu"
    {/* NODE: Stmts 581 */

#line 34 "btree-1.ceu"
    {/* NODE: Stmts 613 */

#line 34 "btree-1.ceu"
    {/* NODE: Nothing 584 */
/* NODE: Nothing 1345 */
/* NODE: If 598 */

#line 34 "btree-1.ceu"
    if ((((((CEU_BTree *)(  ((tceu_pool_adts*) (&((CEU_Body_239*)_ceu_org)->t))->root)))->tag == CEU_BTREE_NIL) /* XXXX */)) {
/* NODE: Block 595 */

#line 34 "btree-1.ceu"
    {/* NODE: Stmts 594 */

#line 34 "btree-1.ceu"
    {/* NODE: Nothing 593 */

#line 34 "btree-1.ceu"
    }
#line 34 "btree-1.ceu"
/* CLEAR: Block (34) */
#line 34 "btree-1.ceu"
    if (0) {

#line 34 "btree-1.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
} else {
/* NODE: Block 597 */

#line 34 "btree-1.ceu"
    {/* NODE: Stmts 596 */

#line 34 "btree-1.ceu"
    {/* NODE: Await 588 */

#line 34 "btree-1.ceu"
    _CEU_NO_588_:
if (0) { goto _CEU_NO_588_; /* avoids "not used" warning */ }

#line 34 "btree-1.ceu"
    _ceu_trl->evt = CEU_IN__ok_killed;
_ceu_trl->lbl = Body_239_Awake__ok_killed_15;
_ceu_trl->seqno = _ceu_app->seqno;

#line 34 "btree-1.ceu"
    _ceu_trl->org_or_adt = (void*)(((CEU_BTree *)(  ((tceu_pool_adts*) (&((CEU_Body_239*)_ceu_org)->t))->root)));

#line 34 "btree-1.ceu"
    return;

case Body_239_Awake__ok_killed_15:;

#line 34 "btree-1.ceu"
    #ifdef CEU_DEBUG_TRAILS
#ifndef CEU_OS
printf("\tOK!\n");
#endif
#endif

#line 34 "btree-1.ceu"
    }
#line 34 "btree-1.ceu"
/* CLEAR: Block (34) */
#line 34 "btree-1.ceu"
    if (0) {

#line 34 "btree-1.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
}
/* NODE: Nothing 1346 */

#line 34 "btree-1.ceu"
    }
#line 34 "btree-1.ceu"
    }
#line 34 "btree-1.ceu"
/* CLEAR: Block (34) */
#line 34 "btree-1.ceu"
    if (0) {

#line 34 "btree-1.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 34 "btree-1.ceu"
/* PAROR JOIN */
#line 34 "btree-1.ceu"
    _ceu_lbl = Body_239_ParOr_out_13;
goto _CEU_GOTO_;

#line 34 "btree-1.ceu"
case Body_239_ParOr_out_13:;
#line 34 "btree-1.ceu"
/* CLEAR: ParOr (34) */
#line 34 "btree-1.ceu"
    {
    tceu_evt evt;
             evt.id = CEU_IN__CLEAR;
    ceu_sys_go_ex(_ceu_app, &evt,
                  _ceu_stk,
                  _ceu_org,
                  &_ceu_org->trls[ 1 ],
                  &_ceu_org->trls[ 5 ]);
                                        /* excludes +1 */
}

/* LONGJMP
 * Block termination: we will abort all trails between [t1,t2].
 * Return status=1 to distinguish from longjmp from organism termination.
 * We want to continue from "me.lbl_jmp" below.
 */
#ifdef CEU_ORGS
_ceu_app->stk_jmp.org = _ceu_org;
#endif
_ceu_app->stk_jmp.trl = _ceu_trl;
_ceu_app->stk_jmp.lbl = Body_239_ParOr_jmp_14;
ceu_longjmp(_ceu_app, _ceu_org,
            1,4);

#line 34 "btree-1.ceu"
case Body_239_ParOr_jmp_14:;
#line 34 "btree-1.ceu"
    }
#line 34 "btree-1.ceu"
/* CLEAR: Block (34) */
#line 34 "btree-1.ceu"
    if (0) {

#line 34 "btree-1.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 33 "btree-1.ceu"
    }
#line 33 "btree-1.ceu"
/* CLEAR: Block (33) */
#line 33 "btree-1.ceu"
    if (0) {

#line 33 "btree-1.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 33 "btree-1.ceu"
/* PAROR JOIN */
#line 33 "btree-1.ceu"
    _ceu_lbl = Body_239_ParOr_out_9;
goto _CEU_GOTO_;

#line 33 "btree-1.ceu"
case Body_239_ParOr_sub_1_8:;/* NODE: Block 548 */

#line 33 "btree-1.ceu"
    {/* NODE: Stmts 547 */

#line 33 "btree-1.ceu"
    {/* NODE: Stmts 579 */

#line 33 "btree-1.ceu"
    {/* NODE: Nothing 550 */
/* NODE: Nothing 1343 */
/* NODE: Nothing 1344 */
/* NODE: Stmts 578 */

#line 33 "btree-1.ceu"
    {/* NODE: If 577 */

#line 33 "btree-1.ceu"
    if ((!(((*((tceu_org*)((((CEU_Body_239*)_ceu_org)->_parent)))).isAlive)))) {
/* NODE: Block 574 */

#line 33 "btree-1.ceu"
    {/* NODE: Stmts 573 */

#line 33 "btree-1.ceu"
    {/* NODE: Nothing 555 */

#line 33 "btree-1.ceu"
    }
#line 33 "btree-1.ceu"
/* CLEAR: Block (33) */
#line 33 "btree-1.ceu"
    if (0) {

#line 33 "btree-1.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
} else {
/* NODE: Block 576 */

#line 33 "btree-1.ceu"
    {/* NODE: Stmts 575 */

#line 33 "btree-1.ceu"
    {/* NODE: Await 554 */

#line 33 "btree-1.ceu"
    _CEU_NO_554_:
if (0) { goto _CEU_NO_554_; /* avoids "not used" warning */ }

#line 33 "btree-1.ceu"
    _ceu_trl->evt = CEU_IN__ok_killed;
_ceu_trl->lbl = Body_239_Awake__ok_killed_11;
_ceu_trl->seqno = _ceu_app->seqno;

#line 33 "btree-1.ceu"
    _ceu_trl->org_or_adt = (void*)((((CEU_Body_239*)_ceu_org)->_parent));

#line 33 "btree-1.ceu"
    return;

case Body_239_Awake__ok_killed_11:;

#line 33 "btree-1.ceu"
    #ifdef CEU_DEBUG_TRAILS
#ifndef CEU_OS
printf("\tOK!\n");
#endif
#endif

#line 33 "btree-1.ceu"
    }
#line 33 "btree-1.ceu"
/* CLEAR: Block (33) */
#line 33 "btree-1.ceu"
    if (0) {

#line 33 "btree-1.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
}

#line 33 "btree-1.ceu"
    }
#line 33 "btree-1.ceu"
    }
#line 33 "btree-1.ceu"
    }
#line 33 "btree-1.ceu"
/* CLEAR: Block (33) */
#line 33 "btree-1.ceu"
    if (0) {

#line 33 "btree-1.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 33 "btree-1.ceu"
/* PAROR JOIN */
#line 33 "btree-1.ceu"
    _ceu_lbl = Body_239_ParOr_out_9;
goto _CEU_GOTO_;

#line 33 "btree-1.ceu"
case Body_239_ParOr_out_9:;
#line 33 "btree-1.ceu"
/* CLEAR: ParOr (33) */
#line 33 "btree-1.ceu"
    {
    tceu_evt evt;
             evt.id = CEU_IN__CLEAR;
    ceu_sys_go_ex(_ceu_app, &evt,
                  _ceu_stk,
                  _ceu_org,
                  &_ceu_org->trls[ 0 ],
                  &_ceu_org->trls[ 5 ]);
                                        /* excludes +1 */
}

/* LONGJMP
 * Block termination: we will abort all trails between [t1,t2].
 * Return status=1 to distinguish from longjmp from organism termination.
 * We want to continue from "me.lbl_jmp" below.
 */
#ifdef CEU_ORGS
_ceu_app->stk_jmp.org = _ceu_org;
#endif
_ceu_app->stk_jmp.trl = _ceu_trl;
_ceu_app->stk_jmp.lbl = Body_239_ParOr_jmp_10;
ceu_longjmp(_ceu_app, _ceu_org,
            0,4);

#line 33 "btree-1.ceu"
case Body_239_ParOr_jmp_10:;/* NODE: Stmts 1143 */

#line 33 "btree-1.ceu"
    {/* NODE: Set 1141 */

#line 33 "btree-1.ceu"
/* SET: _ret *//* NODE: NUMBER 471 */

#line 33 "btree-1.ceu"
    (((CEU_Body_239*)_ceu_org)->_ret_13) = 0;
#line 33 "btree-1.ceu"
    #ifdef CEU_ORGS_AWAIT
    _ceu_org->ret = (((CEU_Body_239*)_ceu_org)->_ret_13);
    /* HACK_8: result of immediate spawn termination */
    _ceu_app->ret = _ceu_org->ret;
#endif
/* NODE: Escape 1142 */

#line 33 "btree-1.ceu"
    _ceu_lbl = Body_239_Set_out_6;
goto _CEU_GOTO_;

#line 33 "btree-1.ceu"
    }
#line 33 "btree-1.ceu"
    }
#line 33 "btree-1.ceu"
/* CLEAR: Block (33) */
#line 33 "btree-1.ceu"
    if (0) {

#line 33 "btree-1.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 33 "btree-1.ceu"
    return;
#line 33 "btree-1.ceu"
case Body_239_Set_out_6:;
#line 33 "btree-1.ceu"
/* CLEAR: SetBlock (33) */
#line 33 "btree-1.ceu"
    {
    tceu_evt evt;
             evt.id = CEU_IN__CLEAR;
    ceu_sys_go_ex(_ceu_app, &evt,
                  _ceu_stk,
                  _ceu_org,
                  &_ceu_org->trls[ 0 ],
                  &_ceu_org->trls[ 5 ]);
                                        /* excludes +1 */
}

/* LONGJMP
 * Block termination: we will abort all trails between [t1,t2].
 * Return status=1 to distinguish from longjmp from organism termination.
 * We want to continue from "me.lbl_jmp" below.
 */
#ifdef CEU_ORGS
_ceu_app->stk_jmp.org = _ceu_org;
#endif
_ceu_app->stk_jmp.trl = _ceu_trl;
_ceu_app->stk_jmp.lbl = Body_239_Set_jmp_7;
ceu_longjmp(_ceu_app, _ceu_org,
            0,4);

#line 33 "btree-1.ceu"
case Body_239_Set_jmp_7:;
#line 33 "btree-1.ceu"
    }
#line 33 "btree-1.ceu"
/* CLEAR: Block (33) */
#line 33 "btree-1.ceu"
    if (0) {

#line 33 "btree-1.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 33 "btree-1.ceu"
    }
#line 33 "btree-1.ceu"
/* CLEAR: Block (33) */
#line 33 "btree-1.ceu"
    {
    tceu_evt evt;
             evt.id = CEU_IN__CLEAR;
    ceu_sys_go_ex(_ceu_app, &evt,
                  _ceu_stk,
                  _ceu_org,
                  &_ceu_org->trls[ 0 ],
                  &_ceu_org->trls[ 7 ]);
                                        /* excludes +1 */
}

/* LONGJMP
 * Block termination: we will abort all trails between [t1,t2].
 * Return status=1 to distinguish from longjmp from organism termination.
 * We want to continue from "me.lbl_jmp" below.
 */
#ifdef CEU_ORGS
_ceu_app->stk_jmp.org = _ceu_org;
#endif
_ceu_app->stk_jmp.trl = _ceu_trl;
_ceu_app->stk_jmp.lbl = Body_239_Block_jmp_31;
ceu_longjmp(_ceu_app, _ceu_org,
            0,6);

#line 33 "btree-1.ceu"
case Body_239_Block_jmp_31:;
#line 33 "btree-1.ceu"
    if (0) {

#line 33 "btree-1.ceu"
case Body_239_Block__fin_30:;
#line 33 "btree-1.ceu"
    return;
#line 33 "btree-1.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 33 "btree-1.ceu"
    {
    tceu_evt evt;
             evt.id = CEU_IN__CLEAR;
    ceu_sys_go_ex(_ceu_app, &evt,
                  _ceu_stk,
                  _ceu_org,
                  &_ceu_org->trls[_ceu_org->n], /* to the end, only free it */
                  NULL);
}

#line 33 "btree-1.ceu"
    return;
    }
#ifdef CEU_DEBUG
    ceu_out_assert_msg(0, "no return");
#endif
}

#ifdef CEU_OS_APP
static __attribute__((noinline))  __attribute__((noclone))
#endif
void
ceu_app_init (tceu_app* app)
{
    app->seqno = 0;
#if defined(CEU_RET) || defined(CEU_OS_APP)
    app->isAlive = 1;
#endif
#ifdef CEU_ASYNCS
    app->pendingAsyncs = 1;
#endif
#if defined(CEU_ORGS_NEWS_MALLOC) && defined(CEU_ORGS_AWAIT)
    app->dont_emit_kill = 0;
#endif
#ifdef CEU_REENTRANT
    app->stki = 0;
#endif
#ifdef CEU_RET
    app->ret = 0;
#endif
#ifdef CEU_ORGS_NEWS_MALLOC
    app->tofree = NULL;
#endif
#ifdef CEU_WCLOCKS
    app->wclk_late = 0;
    app->wclk_min_set = CEU_WCLOCK_INACTIVE;
    app->wclk_min_cmp = CEU_WCLOCK_INACTIVE;
#ifdef CEU_TIMEMACHINE
    app->wclk_late_ = 0;
    app->wclk_min_set_ = CEU_WCLOCK_INACTIVE;
    app->wclk_min_cmp_ = CEU_WCLOCK_INACTIVE;
#endif
#endif
#ifdef CEU_THREADS
    pthread_mutex_init(&app->threads_mutex, NULL);
    /*PTHREAD_COND_INITIALIZER,*/
    app->threads_n = 0;

    /* All code run atomically:
     * - the program is always locked as a whole
     * -    thread spawns will unlock => re-lock
     * - but program will still run to completion
     */
    CEU_THREADS_MUTEX_LOCK(&app->threads_mutex);
#endif

    CEU_BTREE_BASE.tag = CEU_BTREE_NIL;


#ifdef CEU_OS_APP

#ifdef __AVR
    app->code  = (__typeof__(ceu_app_go)*)    (((word)app->addr>>1) + &ceu_app_go);
    app->calls = (__typeof__(ceu_app_calls)*) (((word)app->addr>>1) + &ceu_app_calls);
#else
    app->code  = (__typeof__(ceu_app_go)*)    (&ceu_app_go);
    app->calls = (__typeof__(ceu_app_calls)*) (&ceu_app_calls);
#endif

#else   /* !CEU_OS_APP */

    app->code  = (__typeof__(ceu_app_go)*)    (&ceu_app_go);

#endif  /* CEU_OS_APP */

#ifndef CEU_OS_APP
#ifdef CEU_DEBUG
    CEU_APP_SIG = app;
    signal(SIGSEGV, ceu_segfault);
#endif
#endif

    ceu_out_org_init(app, app->data, CEU_NTRAILS, Class_Main,
                     0, 0,
                     NULL, 0);

#ifdef CEU_LUA
    ceu_luaL_newstate(app->lua);
    ceu_out_assert(app->lua != NULL);
    ceu_luaL_openlibs(app->lua);
    ceu_lua_atpanic(app->lua, ceu_lua_atpanic_f);    /* TODO: CEU_OS */
#endif

    app->data->trls[0].evt = CEU_IN__INIT;
    app->data->trls[0].seqno = 0;
    ceu_sys_go(app, CEU_IN__INIT, NULL);
}

/* EXPORTED ENTRY POINT
 * CEU_EXPORT is put in a separate section ".export".
 * "gcc-ld" should place it at 0x00, before ".text".
 */

#ifdef CEU_OS_APP
__attribute__ ((section (".export")))
void CEU_EXPORT (uint* size, tceu_init** init
#ifdef CEU_OS_LUAIFC
                , char** luaifc
#endif
) {
    *size = sizeof(CEU_Main);
    *init = (tceu_init*) &ceu_app_init;
#ifdef CEU_OS_LUAIFC
    *luaifc = (=== APP_LUAIFC ===);
#endif
}
#endif
