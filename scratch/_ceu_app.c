/*
 * This file is automatically generated.
 * Check the github repository for a readable version:
 * http://github.com/fsantanna/ceu
 *
 * CÃ©u is distributed under the MIT License:
 *

Copyright (C) 2012 Francisco Sant'Anna

Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the "Software"), to deal in
the Software without restriction, including without limitation the rights to
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
of the Software, and to permit persons to whom the Software is furnished to do
so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/
#line 1 "chaser.ceu"

#ifndef _CEU_APP_H
#define _CEU_APP_H

#include "ceu_types.h"

#define CEU_EXTS
#define CEU_ORGS_AWAIT
#define CEU_ORGS_NEWS_MALLOC
#define CEU_ADTS_NEWS
#define CEU_CLEAR
#define CEU_ORGS
#define CEU_ORGS_NEWS
#define CEU_GOTO
#define CEU_RET
#define CEU_ADTS_NEWS_MALLOC
#define CEU_ADTS_AWAIT
#define CEU_ADTS_AWAIT_BTree
     /* CEU_EXTS, CEU_WCLOCKS, CEU_INTS, ... */

/* TODO: lbl => unsigned */
#ifndef CEU_OS
typedef s8 tceu_nlbl;
#endif

#ifdef CEU_IFCS
/* (x) number of different classes */
typedef s16 tceu_ncls;
#endif

/* TODO: remove */
#define CEU_NTRAILS 11

#ifndef _CEU_OS_H
#define _CEU_OS_H

#include <stddef.h>
#include "ceu_types.h"

#ifdef CEU_DEBUG
#include <assert.h>
#endif

#if defined(CEU_OS) && defined(__AVR)
#error Understand this again!
#include "Arduino.h"
#define CEU_ISR
#define CEU_ISR_ON()  interrupts()
#define CEU_ISR_OFF() noInterrupts()
#else
#define CEU_ISR_ON()
#define CEU_ISR_OFF()
#endif

/*
#if defined(CEU_CLEAR) || defined(CEU_INTS) || defined(CEU_ORGS) || defined(CEU_REENTRANT)
*/
#if 1
#include <setjmp.h>
#define CEU_STACK
#endif

#if defined(CEU_OS_KERNEL) || defined(CEU_OS_APP)
#define CEU_OS
#endif

#if defined(CEU_ORGS_NEWS) || defined(CEU_ADTS_NEWS)
#define CEU_NEWS
#endif
#if defined(CEU_ORGS_NEWS_POOL) || defined(CEU_ADTS_NEWS_POOL)
#define CEU_NEWS_POOL
#endif
#if defined(CEU_ORGS_AWAIT) || defined(CEU_ADTS_AWAIT)
#define CEU_ORGS_OR_ADTS_AWAIT
#endif

#ifdef CEU_OS

    /* TODO: all should be configurable */
    #define CEU_EXTS
    #define CEU_WCLOCKS
    #define CEU_ASYNCS
    #define CEU_RET
    #define CEU_CLEAR
    #define CEU_STACK
#ifndef __AVR
#endif
    #define CEU_INTS
    #define CEU_ORGS
    /*#define CEU_PSES*/ /* TODO: never tried */
    #define CEU_NEWS
    #define CEU_NEWS_POOL
    #define CEU_ORGS_NEWS
    #define CEU_ORGS_NEWS_MALLOC
    #define CEU_ORGS_NEWS_POOL
    #define CEU_ADTS_NEWS
    #define CEU_ADTS_NEWS_MALLOC
    #define CEU_ADTS_NEWS_POOL
    #define CEU_ORGS_AWAIT
    #define CEU_ADTS_AWAIT
    #define CEU_ORGS_OR_ADTS_AWAIT
/*
    #define CEU_THREADS
*/

#ifdef __AVR
    #define CEU_QUEUE_MAX 256
#else
    #define CEU_QUEUE_MAX 65536
#endif

    #define CEU_IN__NONE          0
    #define CEU_IN__ORG         255
    #define CEU_IN__ORG_PSED    254
    #define CEU_IN__CLEAR       253
    #define CEU_IN__ok_killed   252
    #define CEU_IN__INIT        251     /* HIGHER EXTERNAL */
    #define CEU_IN__ASYNC       250
    #define CEU_IN__THREAD      249
    #define CEU_IN__WCLOCK      248
    #define CEU_IN_OS_START     247
    #define CEU_IN_OS_STOP      246
    #define CEU_IN_OS_DT        245
    #define CEU_IN_OS_INTERRUPT 244
#ifdef CEU_TIMEMACHINE
    #define CEU_IN__WCLOCK_     243
    #define CEU_IN              243
#else
    #define CEU_IN              242
#endif

    #define CEU_IN_higher       CEU_IN__INIT  /* _INIT = HIGHER EXTERNAL */
    #define CEU_IN_lower        128     /* TODO: not checked from up and down */

    typedef s8 tceu_nlbl;   /* TODO: to small!! */

#endif /* CEU_OS */

#ifdef CEU_OS_APP

    #define ceu_out_log(mode,str) \
        ((__typeof__(ceu_sys_log)*)((_ceu_app)->sys_vec[CEU_SYS_LOG]))(mode,str)

    #define ceu_out_assert(v) \
        ((__typeof__(ceu_sys_assert)*)((_ceu_app)->sys_vec[CEU_SYS_ASSERT]))(v)

    #define ceu_out_assert_msg_ex(v,msg,file,line)       \
        {                                                \
            int __ceu_v = v;                             \
            if ((!(__ceu_v)) && ((msg)!=NULL)) {         \
                ceu_out_log(0, (long)"[");               \
                ceu_out_log(0, (long)(file));            \
                ceu_out_log(0, (long)":");               \
                ceu_out_log(2, (line));                  \
                ceu_out_log(0, (long)"] ");              \
                ceu_out_log(0, (long)"runtime error: "); \
                ceu_out_log(0, (long)(msg));             \
                ceu_out_log(0, (long)"\n");              \
            }                                            \
            ((__typeof__(ceu_sys_assert)*)((_ceu_app)->sys_vec[CEU_SYS_ASSERT]))(__ceu_v); \
        }
    #define ceu_out_assert_msg(v,msg) ceu_out_assert_msg_ex((v),(msg),__FILE__,__LINE__)

    #define ceu_out_realloc(ptr, size) \
        ((__typeof__(ceu_sys_realloc)*)((_ceu_app)->sys_vec[CEU_SYS_REALLOC]))(ptr,size)

    #define ceu_out_req() \
        ((__typeof__(ceu_sys_req)*)((_ceu_app)->sys_vec[CEU_SYS_REQ]))()

    #define ceu_out_load(addr) \
        ((__typeof__(ceu_sys_load)*)((_ceu_app)->sys_vec[CEU_SYS_LOAD]))(addr)

#ifdef CEU_ISR
    #define ceu_out_isr(n,f) \
        ((__typeof__(ceu_sys_isr)*)((_ceu_app)->sys_vec[CEU_SYS_ISR]))(n,f,_ceu_app)
#endif

    #define ceu_out_org_init(app,org,n,lbl,cls,isDyn,parent_org,parent_trl) \
        ((__typeof__(ceu_sys_org_init)*)((app)->sys_vec[CEU_SYS_ORG]))(org,n,lbl,cls,isDyn,parent_org,parent_trl)
    #define ceu_out_start(app) \
        ((__typeof__(ceu_sys_start)*)((_ceu_app)->sys_vec[CEU_SYS_START]))(app)
    #define ceu_out_link(app1,evt1 , app2,evt2) \
        ((__typeof__(ceu_sys_link)*)((_ceu_app)->sys_vec[CEU_SYS_LINK]))(app1,evt1,app2,evt2)

    #define ceu_out_emit(app,id,sz,buf) \
        ((__typeof__(ceu_sys_emit)*)((app)->sys_vec[CEU_SYS_EMIT]))(app,id,sz,buf)

    #define ceu_out_call(app,id,param) \
        ((__typeof__(ceu_sys_call)*)((app)->sys_vec[CEU_SYS_CALL]))(app,id,param)

#ifdef CEU_WCLOCKS
    #define ceu_out_wclock(app,dt,set,get) \
        ((__typeof__(ceu_sys_wclock)*)((app)->sys_vec[CEU_SYS_WCLOCK]))(app,dt,set,get)
#ifdef CEU_TIMEMACHINE
    #error TIMEMACHINE
#endif
#endif

    #define ceu_out_go(app,evt,evtp) \
        ((__typeof__(ceu_sys_go)*)((app)->sys_vec[CEU_SYS_GO]))(app,evt,evtp)

#else /* ! CEU_OS_APP (!CEU_OS||CEU_OS_KERNEL) */

    #ifndef ceu_out_assert
        #error "Missing definition for macro \"ceu_out_assert\"."
    #endif

    #ifndef ceu_out_log
        #error "Missing definition for macro \"ceu_out_log\"."
    #endif

    #define ceu_out_assert_msg_ex(v,msg,file,line)          \
        {                                                   \
            int __ceu_v = v;                                \
            if ((!(__ceu_v)) && ((msg)!=NULL)) {            \
                ceu_out_log(0, (long)"[");                  \
                ceu_out_log(0, (long)(file));               \
                ceu_out_log(0, (long)":");                  \
                ceu_out_log(2, line);                       \
                ceu_out_log(0, (long)"] ");                 \
                ceu_out_log(0, (long)"runtime error: ");    \
                ceu_out_log(0, (long)(msg));                \
                ceu_out_log(0, (long)"\n");                 \
            }                                               \
            ceu_out_assert(__ceu_v);                        \
        }
    #define ceu_out_assert_msg(v,msg) ceu_out_assert_msg_ex((v),(msg),__FILE__,__LINE__)

    #define ceu_out_realloc(ptr,size) \
            ceu_sys_realloc(ptr,size)
    #define ceu_out_req() \
            ceu_sys_req()
    #define ceu_out_org_init(app,org,n,lbl,cls,isDyn,parent_org,parent_trl) \
            ceu_sys_org_init(org,n,lbl,cls,isDyn,parent_org,parent_trl)

#ifdef CEU_WCLOCKS
    #define ceu_out_wclock(app,dt,set,get) \
            ceu_sys_wclock(app,dt,set,get)
#ifdef CEU_TIMEMACHINE
    #define ceu_out_wclock_(app,dt,set,get) \
            ceu_sys_wclock_(app,dt,set,get)
#endif
#endif
    #define ceu_out_go(app,evt,evtp) \
            ceu_sys_go(app,evt,evtp)
    #define ceu_out_go_stk(app,evt,evtp,stk) \
            ceu_sys_go_stk(app,evt,evtp,stk)

#endif /* ! CEU_OS_APP (!CEU_OS||CEU_OS_KERNEL) */

#define ceu_in_emit(app,id,n,buf) \
    ceu_out_go_stk(app,id,buf,&stk_)

#ifdef CEU_THREADS
/* TODO: app */
#ifndef _CEU_THREADS_H
#define _CEU_THREADS_H

#include <pthread.h>
#define CEU_THREADS_T               pthread_t
#define CEU_THREADS_MUTEX_T         pthread_mutex_t
#define CEU_THREADS_COND_T          pthread_cond_t
#define CEU_THREADS_SELF()          pthread_self()
#define CEU_THREADS_CREATE(t,f,p)   pthread_create(t,NULL,f,p)
#define CEU_THREADS_DETACH(t)       pthread_detach(t)
/*
#define CEU_THREADS_MUTEX_LOCK(m)   pthread_mutex_lock(m); printf("L[%d]\n",__LINE__)
#define CEU_THREADS_MUTEX_UNLOCK(m) pthread_mutex_unlock(m); printf("U[%d]\n",__LINE__)
*/
#define CEU_THREADS_MUTEX_LOCK(m)   pthread_mutex_lock(m)
#define CEU_THREADS_MUTEX_UNLOCK(m) pthread_mutex_unlock(m);
/*
#define CEU_THREADS_COND_WAIT(c,m)  pthread_cond_wait(c,m)
#define CEU_THREADS_COND_SIGNAL(c)  pthread_cond_signal(c)
*/

#endif

#endif

#ifdef CEU_LUA
#include <stdio.h>      /* BUFSIZ */
#include <string.h>     /* strcpy */
#if defined(__ANDROID__) || defined(CEU_OS)
    #include "lua.h"
    #include "lauxlib.h"
    #include "lualib.h"
#else
    #include <lua5.1/lua.h>
    #include <lua5.1/lauxlib.h>
    #include <lua5.1/lualib.h>
#endif

#ifdef CEU_OS_APP
    #define ceu_luaL_newstate(set) { \
        set = ceu_out_call(_ceu_app, CEU_OUT_LUA_NEW, NULL); \
    }

    #define ceu_luaL_openlibs(l) { \
        lua_State* p = l;          \
        ceu_out_call(_ceu_app, CEU_OUT_LUAL_OPENLIBS, &p); \
    }

    #define ceu_lua_atpanic(l, f) {     \
    }

    #define ceu_luaL_loadstring(set, l, str) {  \
        tceu__lua_State___char_ p = { l, str }; \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUAL_LOADSTRING, &p); \
    }

    #define ceu_lua_pushnumber(l, v) {      \
        tceu__lua_State___int p = { l, v }; \
        ceu_out_call(_ceu_app, CEU_OUT_LUA_PUSHNUMBER, &p); \
    }

    #define ceu_lua_pushstring(l, v) {      \
        tceu__lua_State___char_ p = { l, v }; \
        ceu_out_call(_ceu_app, CEU_OUT_LUA_PUSHSTRING, &p); \
    }

    #define ceu_lua_pushlightuserdata(l, v) {   \
        tceu__lua_State___void_ p = { l, v };     \
        ceu_out_call(_ceu_app, CEU_OUT_LUA_PUSHLIGHTUSERDATA, &p); \
    }

    #define ceu_lua_pcall(set,l,nargs,nrets,err) {                  \
        tceu__lua_State___int__int__int p = { l, nargs, nrets, err }; \
        ceu_out_call(_ceu_app, CEU_OUT_LUA_PCALL, &p); \
    }

    #define ceu_lua_isnumber(set, l, idx) {     \
        tceu__lua_State___int p = { l, idx };   \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUA_ISNUMBER, &p); \
    }

    #define ceu_lua_tonumber(set, l, idx) {     \
        tceu__lua_State___int p = { l, idx };   \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUA_TONUMBER, &p); \
    }

    #define ceu_lua_isboolean(set, l, idx) {    \
        tceu__lua_State___int p = { l, idx };   \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUA_ISBOOLEAN, &p); \
    }

    #define ceu_lua_toboolean(set, l, idx) {    \
        tceu__lua_State___int p = { l, idx };   \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUA_TOBOOLEAN, &p); \
    }

    #define ceu_lua_pop(l, n) {             \
        tceu__lua_State___int p = { l, n }; \
        ceu_out_call(_ceu_app, CEU_OUT_LUA_POP, &p); \
    }

    #define ceu_lua_isstring(set, l, idx) {     \
        tceu__lua_State___int p = { l, idx };   \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUA_ISSTRING, &p); \
    }

    #define ceu_lua_tostring(set, l, idx) {     \
        tceu__lua_State___int p = { l, idx };   \
        set = ceu_out_call(_ceu_app, CEU_OUT_LUA_TOSTRING, &p); \
    }

    #define ceu_lua_islightuserdata(set, l, idx) {  \
        tceu__lua_State___int p = { l, idx };       \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUA_ISLIGHTUSERDATA, &p); \
    }

    #define ceu_lua_touserdata(set, l, idx) {   \
        tceu__lua_State___int p = { l, idx };   \
        set = ceu_out_call(_ceu_app, CEU_OUT_LUA_TOUSERDATA, &p); \
    }

    #define ceu_lua_error(l) {                          \
        lua_State** p = &l;                             \
        ceu_out_call(_ceu_app, CEU_OUT_LUA_ERROR, &p);  \
    }

    #define ceu_lua_objlen(set, l, idx) {                       \
        tceu__lua_State___int p = { l, idx };                   \
        set = ceu_out_call(_ceu_app, CEU_OUT_LUA_OBJLEN, &p);   \
    }

#else
    #define ceu_luaL_newstate(set)               set = luaL_newstate()
    #define ceu_luaL_openlibs(l)                 luaL_openlibs(l)
    #define ceu_lua_atpanic(l,f)                 lua_atpanic(l,f)
    #define ceu_luaL_loadstring(set,l,str)       set = luaL_loadstring(l,str)
    #define ceu_lua_pushnumber(l,v)              lua_pushnumber(l,v)
    #define ceu_lua_pushstring(l,v)              lua_pushstring(l,v)
    #define ceu_lua_pushlightuserdata(l,v)       lua_pushlightuserdata(l,v)
    #define ceu_lua_pcall(set,l,nargs,nrets,err) set = lua_pcall(l,nargs,nrets,err)
    #define ceu_lua_isnumber(set,l,idx)          set = lua_isnumber(l,idx)
    #define ceu_lua_tonumber(set,l,idx)          set = lua_tonumber(l,idx)
    #define ceu_lua_isboolean(set,l,idx)         set = lua_isboolean(l,idx)
    #define ceu_lua_toboolean(set,l,idx)         set = lua_toboolean(l,idx)
    #define ceu_lua_pop(l,n)                     lua_pop(l,n)
    #define ceu_lua_isstring(set,l,idx)          set = lua_isstring(l,idx)
    #define ceu_lua_tostring(set,l,idx)          set = lua_tostring(l,idx)
    #define ceu_lua_islightuserdata(set,l,idx)   set = lua_islightuserdata(l,idx)
    #define ceu_lua_touserdata(set,l,idx)        set = lua_touserdata(l,idx)
    #define ceu_lua_error(l)                     lua_error(l)
    #define ceu_lua_objlen(set,l,idx)            set = lua_objlen(l,idx)
#endif
#endif

typedef u8 tceu_nevt;   /* max number of events */
                        /* TODO: should "u8" be fixed? */

typedef u8 tceu_ntrl;   /* max number of trails per class */
                        /* TODO: should "u8" be fixed? */

#ifdef CEU_STACK
typedef u16 tceu_nstk;  /* max size of internal stack in bytes */
                        /* TODO: should "u16" be fixed? */
#endif

#ifdef __cplusplus
#define CEU_WCLOCK_INACTIVE 0x7fffffffL     /* TODO */
#else
#define CEU_WCLOCK_INACTIVE INT32_MAX
#endif
#define CEU_WCLOCK_EXPIRED (CEU_WCLOCK_INACTIVE-1)

/* TCEU_TRL */

struct tceu_org;
typedef union tceu_trl {
    tceu_nevt evt;

    /* normal await // IN__CLEAR */
    struct {                    /* TODO(ram): bitfields */
        tceu_nevt evt1;
        tceu_nlbl lbl;
        u8        seqno;        /* TODO(ram): 2 bits is enough */
#ifdef CEU_INTS                 /* R-9: size of trails for internal events */
#ifdef CEU_ORGS
        void*     evto;
#endif
#endif
    };

    /* IN__ORG */
#ifdef CEU_ORGS
    struct {                    /* TODO(ram): bad for alignment */
        tceu_nevt evt3;
        struct tceu_org* org;
    };
#endif

    /* _ok_killed */
#ifdef CEU_ORGS_OR_ADTS_AWAIT
    struct {
        tceu_nevt evt4;
        tceu_nlbl lbl4;
        void*     org_or_adt;
    };
#endif
} tceu_trl;

/* TCEU_EVT */

typedef struct tceu_evt {
    tceu_nevt id;
    void*     param;
#if defined(CEU_ORGS) && defined(CEU_INTS)
    void*     org;      /* emitting org */
#endif
} tceu_evt;

/* TCEU_ORG */

struct tceu_pool_orgs;
typedef struct tceu_org
{
#ifdef CEU_ORGS
    struct tceu_org* nxt; /* first field because of free list for orgs/adts */
    struct tceu_org* prv;
    struct tceu_org* parent_org;
    tceu_ntrl parent_trl;
#endif

#if defined(CEU_ORGS) || defined(CEU_OS)
    tceu_ntrl n;            /* number of trails (TODO(ram): opt, metadata) */
#endif

#ifdef CEU_ORGS

#ifdef CEU_IFCS
    tceu_ncls cls;          /* class id */
#endif
    u8 isAlive: 1;          /* Three purposes:
                             * - avoids double free
                             * - required by "watching o" to avoid awaiting a
                             *      dead org
                             * - required by "Do T" to avoid awaiting a dead 
                             *      org
                             */
#if defined(CEU_ORGS_NEWS) || defined(CEU_ORGS_AWAIT)
#endif
#ifdef CEU_ORGS_NEWS
    u8 isDyn: 1;            /* created w/ new or spawn? */
#endif
#ifdef CEU_ORGS_NEWS_POOL
    struct tceu_pool_orgs* pool;
#endif

#ifdef CEU_ORGS_AWAIT
    int ret;
#endif

#endif  /* CEU_ORGS */

    tceu_trl trls[0];       /* first trail */

} tceu_org;

/* TCEU_POOL_ORGS , TCEU_POOL_ADTS */

#if defined(CEU_ORGS_NEWS_POOL) || defined(CEU_ADTS_NEWS_POOL)
#ifndef _CEU_POOL_H
#define _CEU_POOL_H

#include "ceu_types.h"

/* TODO: all "int" here, should evaluate the correct unsigned type */

typedef struct {
    byte**  queue;
                    /* queue is in the next offset to distinguish dynamic(NULL)
                       from static pools(any-address) */
    int     size;
    int     free;
    int     index;
    int     unit;
    byte*   mem;
} tceu_pool;

#define CEU_POOL_DCL(name, type, size) \
    type*     name##_queue[size];      \
    type      name##_mem[size];        \
    tceu_pool name;

void ceu_pool_init (tceu_pool* pool, int size, int unit, byte** queue, byte* mem);
byte* ceu_pool_alloc (tceu_pool* pool);
void ceu_pool_free (tceu_pool* pool, byte* val);

#endif

#endif

#ifdef CEU_ORGS_NEWS
typedef struct tceu_pool_orgs {
    tceu_org* parent_org;
    tceu_ntrl parent_trl;
#ifdef CEU_ORGS_NEWS_POOL
    tceu_pool pool;
#endif
} tceu_pool_orgs;
#endif

#ifdef CEU_ADTS_NEWS
typedef struct {
    void* root;
#ifdef CEU_ADTS_NEWS_POOL
    void* pool;
#endif
} tceu_pool_adts;
#endif

/* TCEU_KILL */

#ifdef CEU_ORGS_OR_ADTS_AWAIT
typedef struct tceu_kill {
    void*     org_or_adt;
    int       ret;
} tceu_kill;
#endif

/* TCEU_LST */

#ifdef CEU_DEBUG
typedef struct tceu_lst {
#ifdef CEU_ORGS
    void*     org;
#endif
    tceu_trl* trl;
    tceu_nlbl lbl;
} tceu_lst;

#endif

/* TCEU_STK */

typedef struct tceu_stk {
    struct tceu_stk* up;
    tceu_org* org;
    tceu_ntrl trl1;
    tceu_ntrl trl2;
    jmp_buf   jmp;
} tceu_stk;

/* TCEU_JMP */

#ifdef CEU_STACK
typedef struct tceu_jmp {
#ifdef CEU_ORGS
    tceu_org* org;
#endif
    tceu_trl* trl;
    tceu_nlbl lbl;
} tceu_jmp;
#endif

/* TCEU_APP */

typedef struct tceu_app {
    /* global seqno: incremented on every reaction
     * awaiting trails matches only if trl->seqno < seqno,
     * i.e., previously awaiting the event
     */
    u8 seqno:          2;
#if defined(CEU_RET) || defined(CEU_OS)
    u8 isAlive:        1;
#endif
#ifdef CEU_ASYNCS
    u8 pendingAsyncs:  1;
#endif
#if defined(CEU_ORGS_NEWS_MALLOC) && defined(CEU_ORGS_AWAIT)
    u8 dont_emit_kill: 1;
#endif

#ifdef CEU_OS
    struct tceu_app* nxt;
#endif

#ifdef CEU_REENTRANT
    tceu_nstk stki;
#endif

#ifdef CEU_STACK
    tceu_stk* stk_bottom;
    tceu_jmp  stk_jmp;
#endif

#if defined(CEU_RET) || defined(CEU_ORGS_AWAIT)
    int ret;
#endif

#ifdef CEU_ORGS_NEWS_MALLOC
    tceu_org* tofree;
#endif

#ifdef CEU_WCLOCKS
    s32         wclk_late;
    s32         wclk_min_set;   /* used to set */
    s32         wclk_min_cmp;   /* used to compare */
                                /* cmp<-set every reaction */
#ifdef CEU_TIMEMACHINE
    s32         wclk_late_;
    s32         wclk_min_set_;
    s32         wclk_min_cmp_;
#endif
#endif

#ifndef CEU_OS
#ifdef CEU_DEBUG
    tceu_lst    lst; /* segfault printf */
#endif
#endif

#ifdef CEU_THREADS
    CEU_THREADS_MUTEX_T threads_mutex;
    /*CEU_THREADS_COND_T  threads_cond;*/
    u8                  threads_n;          /* number of running threads */
        /* TODO: u8? */
#endif
#if defined(CEU_LUA) || defined(CEU_OS)
#ifdef CEU_LUA
    lua_State*  lua;    /* TODO: move to data? */
#else
    void*       lua;
#endif
#endif

    void        (*code)  (struct tceu_app*,tceu_evt*,tceu_org*,tceu_trl*,tceu_stk*);
    void        (*init)  (struct tceu_app*);
#ifdef CEU_OS
    void*       (*calls) (struct tceu_app*,tceu_nevt,void*);
    void**      sys_vec;
    void*       addr;
#ifdef CEU_OS_LUAIFC
    char*       luaifc;
#endif
#endif
    tceu_org*   data;
} tceu_app;

#ifdef CEU_OS
typedef void (*tceu_init)   (tceu_app* app);
typedef void (*tceu_export) (uint* size, tceu_init** init
#ifdef CEU_OS_LUAIFC
                            , char** luaifc
#endif
);
#endif

/* TCEU_THREADS_P */

#ifdef CEU_THREADS
typedef struct {
    tceu_app* app;
    tceu_org* org;
    s8*       st; /* thread state:
                   * 0=ini (sync  spawns)
                   * 1=cpy (async copies)
                   * 2=lck (sync  locks)
                   * 3=end (sync/async terminates)
                   */
} tceu_threads_p;
#endif

#ifdef CEU_PSES
void ceu_pause (tceu_trl* trl, tceu_trl* trlF, int psed);
#endif

int  ceu_go_all    (tceu_app* app);

#ifdef CEU_WCLOCKS
int       ceu_sys_wclock (tceu_app* app, s32 dt, s32* set, s32* get);
#endif
void      ceu_sys_go     (tceu_app* app, int evt, void* evtp);

#ifdef CEU_OS

/* TCEU_LINK */

typedef struct tceu_lnk {
    tceu_app* src_app;
    tceu_nevt src_evt;
    tceu_app* dst_app;
    tceu_nevt dst_evt;
    struct tceu_lnk* nxt;
} tceu_lnk;

/* TCEU_QUEUE */

typedef struct {
    tceu_app* app;
    tceu_nevt evt;
#if CEU_QUEUE_MAX == 256
    s8        sz;
#else
    s16       sz;   /* signed because of fill */
#endif
    byte      buf[0];
} tceu_queue;

#ifdef CEU_ISR
typedef void(*tceu_isr_f)(tceu_app* app, tceu_org* org);
#endif

void ceu_os_init      (void);
int  ceu_os_scheduler (int(*dt)());
tceu_queue* ceu_sys_queue_nxt (void);
void        ceu_sys_queue_rem (void);

void      ceu_sys_assert    (int v);
void      ceu_sys_log       (int mode, long str);
void*     ceu_sys_realloc   (void* ptr, size_t size);
int       ceu_sys_req       (void);
tceu_app* ceu_sys_load      (void* addr);
#ifdef CEU_ISR
int       ceu_sys_isr       (int n, tceu_isr_f f, tceu_app* app);
#endif
void      ceu_sys_org_init  (tceu_org* org, int n, int lbl, int cls, int isDyn,
                             tceu_org* parent_org, tceu_ntrl parent_trl);
void      ceu_sys_start     (tceu_app* app);
int       ceu_sys_link      (tceu_app* src_app, tceu_nevt src_evt, tceu_app* dst_app, tceu_nevt dst_evt);
int       ceu_sys_unlink    (tceu_app* src_app, tceu_nevt src_evt, tceu_app* dst_app, tceu_nevt dst_evt);
int       ceu_sys_emit      (tceu_app* app, tceu_nevt evt, int sz, void* param);
void*     ceu_sys_call      (tceu_app* app, tceu_nevt evt, void* param);

enum {
    CEU_SYS_ASSERT = 0,
    CEU_SYS_LOG,
    CEU_SYS_REALLOC,
    CEU_SYS_REQ,
    CEU_SYS_LOAD,
#ifdef CEU_ISR
    CEU_SYS_ISR,
#endif
#ifdef CEU_CLEAR
    CEU_SYS_CLEAR,
#endif
    CEU_SYS_STACK_PUSH,
#ifdef CEU_ORGS
    CEU_SYS_STACK_CLEAR_ORG,
#endif
    CEU_SYS_ORG,
#ifdef CEU_ORGS
    CEU_SYS_ORG_TRAIL,
    CEU_SYS_ORG_SPAWN,
#endif
    CEU_SYS_START,
    CEU_SYS_LINK,
    CEU_SYS_UNLINK,
    CEU_SYS_EMIT,
    CEU_SYS_CALL,
#ifdef CEU_WCLOCKS
    CEU_SYS_WCLOCK,
#endif
    CEU_SYS_GO,
    CEU_SYS_MAX
};

/* SYS_VECTOR
 */
extern void* CEU_SYS_VEC[CEU_SYS_MAX];

#endif  /* CEU_OS */

#endif  /* _CEU_OS_H */


#ifdef CEU_NEWS_POOL
#ifndef _CEU_POOL_H
#define _CEU_POOL_H

#include "ceu_types.h"

/* TODO: all "int" here, should evaluate the correct unsigned type */

typedef struct {
    byte**  queue;
                    /* queue is in the next offset to distinguish dynamic(NULL)
                       from static pools(any-address) */
    int     size;
    int     free;
    int     index;
    int     unit;
    byte*   mem;
} tceu_pool;

#define CEU_POOL_DCL(name, type, size) \
    type*     name##_queue[size];      \
    type      name##_mem[size];        \
    tceu_pool name;

void ceu_pool_init (tceu_pool* pool, int size, int unit, byte** queue, byte* mem);
byte* ceu_pool_alloc (tceu_pool* pool);
void ceu_pool_free (tceu_pool* pool, byte* val);

#endif

#endif

#ifdef CEU_VECTOR
#ifndef _CEU_VECTOR_H
#define _CEU_VECTOR_H

#ifndef _CEU_OS_H
#define _CEU_OS_H

#include <stddef.h>
#include "ceu_types.h"

#ifdef CEU_DEBUG
#include <assert.h>
#endif

#if defined(CEU_OS) && defined(__AVR)
#error Understand this again!
#include "Arduino.h"
#define CEU_ISR
#define CEU_ISR_ON()  interrupts()
#define CEU_ISR_OFF() noInterrupts()
#else
#define CEU_ISR_ON()
#define CEU_ISR_OFF()
#endif

/*
#if defined(CEU_CLEAR) || defined(CEU_INTS) || defined(CEU_ORGS) || defined(CEU_REENTRANT)
*/
#if 1
#include <setjmp.h>
#define CEU_STACK
#endif

#if defined(CEU_OS_KERNEL) || defined(CEU_OS_APP)
#define CEU_OS
#endif

#if defined(CEU_ORGS_NEWS) || defined(CEU_ADTS_NEWS)
#define CEU_NEWS
#endif
#if defined(CEU_ORGS_NEWS_POOL) || defined(CEU_ADTS_NEWS_POOL)
#define CEU_NEWS_POOL
#endif
#if defined(CEU_ORGS_AWAIT) || defined(CEU_ADTS_AWAIT)
#define CEU_ORGS_OR_ADTS_AWAIT
#endif

#ifdef CEU_OS

    /* TODO: all should be configurable */
    #define CEU_EXTS
    #define CEU_WCLOCKS
    #define CEU_ASYNCS
    #define CEU_RET
    #define CEU_CLEAR
    #define CEU_STACK
#ifndef __AVR
#endif
    #define CEU_INTS
    #define CEU_ORGS
    /*#define CEU_PSES*/ /* TODO: never tried */
    #define CEU_NEWS
    #define CEU_NEWS_POOL
    #define CEU_ORGS_NEWS
    #define CEU_ORGS_NEWS_MALLOC
    #define CEU_ORGS_NEWS_POOL
    #define CEU_ADTS_NEWS
    #define CEU_ADTS_NEWS_MALLOC
    #define CEU_ADTS_NEWS_POOL
    #define CEU_ORGS_AWAIT
    #define CEU_ADTS_AWAIT
    #define CEU_ORGS_OR_ADTS_AWAIT
/*
    #define CEU_THREADS
*/

#ifdef __AVR
    #define CEU_QUEUE_MAX 256
#else
    #define CEU_QUEUE_MAX 65536
#endif

    #define CEU_IN__NONE          0
    #define CEU_IN__ORG         255
    #define CEU_IN__ORG_PSED    254
    #define CEU_IN__CLEAR       253
    #define CEU_IN__ok_killed   252
    #define CEU_IN__INIT        251     /* HIGHER EXTERNAL */
    #define CEU_IN__ASYNC       250
    #define CEU_IN__THREAD      249
    #define CEU_IN__WCLOCK      248
    #define CEU_IN_OS_START     247
    #define CEU_IN_OS_STOP      246
    #define CEU_IN_OS_DT        245
    #define CEU_IN_OS_INTERRUPT 244
#ifdef CEU_TIMEMACHINE
    #define CEU_IN__WCLOCK_     243
    #define CEU_IN              243
#else
    #define CEU_IN              242
#endif

    #define CEU_IN_higher       CEU_IN__INIT  /* _INIT = HIGHER EXTERNAL */
    #define CEU_IN_lower        128     /* TODO: not checked from up and down */

    typedef s8 tceu_nlbl;   /* TODO: to small!! */

#endif /* CEU_OS */

#ifdef CEU_OS_APP

    #define ceu_out_log(mode,str) \
        ((__typeof__(ceu_sys_log)*)((_ceu_app)->sys_vec[CEU_SYS_LOG]))(mode,str)

    #define ceu_out_assert(v) \
        ((__typeof__(ceu_sys_assert)*)((_ceu_app)->sys_vec[CEU_SYS_ASSERT]))(v)

    #define ceu_out_assert_msg_ex(v,msg,file,line)       \
        {                                                \
            int __ceu_v = v;                             \
            if ((!(__ceu_v)) && ((msg)!=NULL)) {         \
                ceu_out_log(0, (long)"[");               \
                ceu_out_log(0, (long)(file));            \
                ceu_out_log(0, (long)":");               \
                ceu_out_log(2, (line));                  \
                ceu_out_log(0, (long)"] ");              \
                ceu_out_log(0, (long)"runtime error: "); \
                ceu_out_log(0, (long)(msg));             \
                ceu_out_log(0, (long)"\n");              \
            }                                            \
            ((__typeof__(ceu_sys_assert)*)((_ceu_app)->sys_vec[CEU_SYS_ASSERT]))(__ceu_v); \
        }
    #define ceu_out_assert_msg(v,msg) ceu_out_assert_msg_ex((v),(msg),__FILE__,__LINE__)

    #define ceu_out_realloc(ptr, size) \
        ((__typeof__(ceu_sys_realloc)*)((_ceu_app)->sys_vec[CEU_SYS_REALLOC]))(ptr,size)

    #define ceu_out_req() \
        ((__typeof__(ceu_sys_req)*)((_ceu_app)->sys_vec[CEU_SYS_REQ]))()

    #define ceu_out_load(addr) \
        ((__typeof__(ceu_sys_load)*)((_ceu_app)->sys_vec[CEU_SYS_LOAD]))(addr)

#ifdef CEU_ISR
    #define ceu_out_isr(n,f) \
        ((__typeof__(ceu_sys_isr)*)((_ceu_app)->sys_vec[CEU_SYS_ISR]))(n,f,_ceu_app)
#endif

    #define ceu_out_org_init(app,org,n,lbl,cls,isDyn,parent_org,parent_trl) \
        ((__typeof__(ceu_sys_org_init)*)((app)->sys_vec[CEU_SYS_ORG]))(org,n,lbl,cls,isDyn,parent_org,parent_trl)
    #define ceu_out_start(app) \
        ((__typeof__(ceu_sys_start)*)((_ceu_app)->sys_vec[CEU_SYS_START]))(app)
    #define ceu_out_link(app1,evt1 , app2,evt2) \
        ((__typeof__(ceu_sys_link)*)((_ceu_app)->sys_vec[CEU_SYS_LINK]))(app1,evt1,app2,evt2)

    #define ceu_out_emit(app,id,sz,buf) \
        ((__typeof__(ceu_sys_emit)*)((app)->sys_vec[CEU_SYS_EMIT]))(app,id,sz,buf)

    #define ceu_out_call(app,id,param) \
        ((__typeof__(ceu_sys_call)*)((app)->sys_vec[CEU_SYS_CALL]))(app,id,param)

#ifdef CEU_WCLOCKS
    #define ceu_out_wclock(app,dt,set,get) \
        ((__typeof__(ceu_sys_wclock)*)((app)->sys_vec[CEU_SYS_WCLOCK]))(app,dt,set,get)
#ifdef CEU_TIMEMACHINE
    #error TIMEMACHINE
#endif
#endif

    #define ceu_out_go(app,evt,evtp) \
        ((__typeof__(ceu_sys_go)*)((app)->sys_vec[CEU_SYS_GO]))(app,evt,evtp)

#else /* ! CEU_OS_APP (!CEU_OS||CEU_OS_KERNEL) */

    #ifndef ceu_out_assert
        #error "Missing definition for macro \"ceu_out_assert\"."
    #endif

    #ifndef ceu_out_log
        #error "Missing definition for macro \"ceu_out_log\"."
    #endif

    #define ceu_out_assert_msg_ex(v,msg,file,line)          \
        {                                                   \
            int __ceu_v = v;                                \
            if ((!(__ceu_v)) && ((msg)!=NULL)) {            \
                ceu_out_log(0, (long)"[");                  \
                ceu_out_log(0, (long)(file));               \
                ceu_out_log(0, (long)":");                  \
                ceu_out_log(2, line);                       \
                ceu_out_log(0, (long)"] ");                 \
                ceu_out_log(0, (long)"runtime error: ");    \
                ceu_out_log(0, (long)(msg));                \
                ceu_out_log(0, (long)"\n");                 \
            }                                               \
            ceu_out_assert(__ceu_v);                        \
        }
    #define ceu_out_assert_msg(v,msg) ceu_out_assert_msg_ex((v),(msg),__FILE__,__LINE__)

    #define ceu_out_realloc(ptr,size) \
            ceu_sys_realloc(ptr,size)
    #define ceu_out_req() \
            ceu_sys_req()
    #define ceu_out_org_init(app,org,n,lbl,cls,isDyn,parent_org,parent_trl) \
            ceu_sys_org_init(org,n,lbl,cls,isDyn,parent_org,parent_trl)

#ifdef CEU_WCLOCKS
    #define ceu_out_wclock(app,dt,set,get) \
            ceu_sys_wclock(app,dt,set,get)
#ifdef CEU_TIMEMACHINE
    #define ceu_out_wclock_(app,dt,set,get) \
            ceu_sys_wclock_(app,dt,set,get)
#endif
#endif
    #define ceu_out_go(app,evt,evtp) \
            ceu_sys_go(app,evt,evtp)
    #define ceu_out_go_stk(app,evt,evtp,stk) \
            ceu_sys_go_stk(app,evt,evtp,stk)

#endif /* ! CEU_OS_APP (!CEU_OS||CEU_OS_KERNEL) */

#define ceu_in_emit(app,id,n,buf) \
    ceu_out_go_stk(app,id,buf,&stk_)

#ifdef CEU_THREADS
/* TODO: app */
#include "ceu_threads.h"
#endif

#ifdef CEU_LUA
#include <stdio.h>      /* BUFSIZ */
#include <string.h>     /* strcpy */
#if defined(__ANDROID__) || defined(CEU_OS)
    #include "lua.h"
    #include "lauxlib.h"
    #include "lualib.h"
#else
    #include <lua5.1/lua.h>
    #include <lua5.1/lauxlib.h>
    #include <lua5.1/lualib.h>
#endif

#ifdef CEU_OS_APP
    #define ceu_luaL_newstate(set) { \
        set = ceu_out_call(_ceu_app, CEU_OUT_LUA_NEW, NULL); \
    }

    #define ceu_luaL_openlibs(l) { \
        lua_State* p = l;          \
        ceu_out_call(_ceu_app, CEU_OUT_LUAL_OPENLIBS, &p); \
    }

    #define ceu_lua_atpanic(l, f) {     \
    }

    #define ceu_luaL_loadstring(set, l, str) {  \
        tceu__lua_State___char_ p = { l, str }; \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUAL_LOADSTRING, &p); \
    }

    #define ceu_lua_pushnumber(l, v) {      \
        tceu__lua_State___int p = { l, v }; \
        ceu_out_call(_ceu_app, CEU_OUT_LUA_PUSHNUMBER, &p); \
    }

    #define ceu_lua_pushstring(l, v) {      \
        tceu__lua_State___char_ p = { l, v }; \
        ceu_out_call(_ceu_app, CEU_OUT_LUA_PUSHSTRING, &p); \
    }

    #define ceu_lua_pushlightuserdata(l, v) {   \
        tceu__lua_State___void_ p = { l, v };     \
        ceu_out_call(_ceu_app, CEU_OUT_LUA_PUSHLIGHTUSERDATA, &p); \
    }

    #define ceu_lua_pcall(set,l,nargs,nrets,err) {                  \
        tceu__lua_State___int__int__int p = { l, nargs, nrets, err }; \
        ceu_out_call(_ceu_app, CEU_OUT_LUA_PCALL, &p); \
    }

    #define ceu_lua_isnumber(set, l, idx) {     \
        tceu__lua_State___int p = { l, idx };   \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUA_ISNUMBER, &p); \
    }

    #define ceu_lua_tonumber(set, l, idx) {     \
        tceu__lua_State___int p = { l, idx };   \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUA_TONUMBER, &p); \
    }

    #define ceu_lua_isboolean(set, l, idx) {    \
        tceu__lua_State___int p = { l, idx };   \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUA_ISBOOLEAN, &p); \
    }

    #define ceu_lua_toboolean(set, l, idx) {    \
        tceu__lua_State___int p = { l, idx };   \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUA_TOBOOLEAN, &p); \
    }

    #define ceu_lua_pop(l, n) {             \
        tceu__lua_State___int p = { l, n }; \
        ceu_out_call(_ceu_app, CEU_OUT_LUA_POP, &p); \
    }

    #define ceu_lua_isstring(set, l, idx) {     \
        tceu__lua_State___int p = { l, idx };   \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUA_ISSTRING, &p); \
    }

    #define ceu_lua_tostring(set, l, idx) {     \
        tceu__lua_State___int p = { l, idx };   \
        set = ceu_out_call(_ceu_app, CEU_OUT_LUA_TOSTRING, &p); \
    }

    #define ceu_lua_islightuserdata(set, l, idx) {  \
        tceu__lua_State___int p = { l, idx };       \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUA_ISLIGHTUSERDATA, &p); \
    }

    #define ceu_lua_touserdata(set, l, idx) {   \
        tceu__lua_State___int p = { l, idx };   \
        set = ceu_out_call(_ceu_app, CEU_OUT_LUA_TOUSERDATA, &p); \
    }

    #define ceu_lua_error(l) {                          \
        lua_State** p = &l;                             \
        ceu_out_call(_ceu_app, CEU_OUT_LUA_ERROR, &p);  \
    }

    #define ceu_lua_objlen(set, l, idx) {                       \
        tceu__lua_State___int p = { l, idx };                   \
        set = ceu_out_call(_ceu_app, CEU_OUT_LUA_OBJLEN, &p);   \
    }

#else
    #define ceu_luaL_newstate(set)               set = luaL_newstate()
    #define ceu_luaL_openlibs(l)                 luaL_openlibs(l)
    #define ceu_lua_atpanic(l,f)                 lua_atpanic(l,f)
    #define ceu_luaL_loadstring(set,l,str)       set = luaL_loadstring(l,str)
    #define ceu_lua_pushnumber(l,v)              lua_pushnumber(l,v)
    #define ceu_lua_pushstring(l,v)              lua_pushstring(l,v)
    #define ceu_lua_pushlightuserdata(l,v)       lua_pushlightuserdata(l,v)
    #define ceu_lua_pcall(set,l,nargs,nrets,err) set = lua_pcall(l,nargs,nrets,err)
    #define ceu_lua_isnumber(set,l,idx)          set = lua_isnumber(l,idx)
    #define ceu_lua_tonumber(set,l,idx)          set = lua_tonumber(l,idx)
    #define ceu_lua_isboolean(set,l,idx)         set = lua_isboolean(l,idx)
    #define ceu_lua_toboolean(set,l,idx)         set = lua_toboolean(l,idx)
    #define ceu_lua_pop(l,n)                     lua_pop(l,n)
    #define ceu_lua_isstring(set,l,idx)          set = lua_isstring(l,idx)
    #define ceu_lua_tostring(set,l,idx)          set = lua_tostring(l,idx)
    #define ceu_lua_islightuserdata(set,l,idx)   set = lua_islightuserdata(l,idx)
    #define ceu_lua_touserdata(set,l,idx)        set = lua_touserdata(l,idx)
    #define ceu_lua_error(l)                     lua_error(l)
    #define ceu_lua_objlen(set,l,idx)            set = lua_objlen(l,idx)
#endif
#endif

typedef u8 tceu_nevt;   /* max number of events */
                        /* TODO: should "u8" be fixed? */

typedef u8 tceu_ntrl;   /* max number of trails per class */
                        /* TODO: should "u8" be fixed? */

#ifdef CEU_STACK
typedef u16 tceu_nstk;  /* max size of internal stack in bytes */
                        /* TODO: should "u16" be fixed? */
#endif

#ifdef __cplusplus
#define CEU_WCLOCK_INACTIVE 0x7fffffffL     /* TODO */
#else
#define CEU_WCLOCK_INACTIVE INT32_MAX
#endif
#define CEU_WCLOCK_EXPIRED (CEU_WCLOCK_INACTIVE-1)

/* TCEU_TRL */

struct tceu_org;
typedef union tceu_trl {
    tceu_nevt evt;

    /* normal await // IN__CLEAR */
    struct {                    /* TODO(ram): bitfields */
        tceu_nevt evt1;
        tceu_nlbl lbl;
        u8        seqno;        /* TODO(ram): 2 bits is enough */
#ifdef CEU_INTS                 /* R-9: size of trails for internal events */
#ifdef CEU_ORGS
        void*     evto;
#endif
#endif
    };

    /* IN__ORG */
#ifdef CEU_ORGS
    struct {                    /* TODO(ram): bad for alignment */
        tceu_nevt evt3;
        struct tceu_org* org;
    };
#endif

    /* _ok_killed */
#ifdef CEU_ORGS_OR_ADTS_AWAIT
    struct {
        tceu_nevt evt4;
        tceu_nlbl lbl4;
        void*     org_or_adt;
    };
#endif
} tceu_trl;

/* TCEU_EVT */

typedef struct tceu_evt {
    tceu_nevt id;
    void*     param;
#if defined(CEU_ORGS) && defined(CEU_INTS)
    void*     org;      /* emitting org */
#endif
} tceu_evt;

/* TCEU_ORG */

struct tceu_pool_orgs;
typedef struct tceu_org
{
#ifdef CEU_ORGS
    struct tceu_org* nxt; /* first field because of free list for orgs/adts */
    struct tceu_org* prv;
    struct tceu_org* parent_org;
    tceu_ntrl parent_trl;
#endif

#if defined(CEU_ORGS) || defined(CEU_OS)
    tceu_ntrl n;            /* number of trails (TODO(ram): opt, metadata) */
#endif

#ifdef CEU_ORGS

#ifdef CEU_IFCS
    tceu_ncls cls;          /* class id */
#endif
    u8 isAlive: 1;          /* Three purposes:
                             * - avoids double free
                             * - required by "watching o" to avoid awaiting a
                             *      dead org
                             * - required by "Do T" to avoid awaiting a dead 
                             *      org
                             */
#if defined(CEU_ORGS_NEWS) || defined(CEU_ORGS_AWAIT)
#endif
#ifdef CEU_ORGS_NEWS
    u8 isDyn: 1;            /* created w/ new or spawn? */
#endif
#ifdef CEU_ORGS_NEWS_POOL
    struct tceu_pool_orgs* pool;
#endif

#ifdef CEU_ORGS_AWAIT
    int ret;
#endif

#endif  /* CEU_ORGS */

    tceu_trl trls[0];       /* first trail */

} tceu_org;

/* TCEU_POOL_ORGS , TCEU_POOL_ADTS */

#if defined(CEU_ORGS_NEWS_POOL) || defined(CEU_ADTS_NEWS_POOL)
#include "ceu_pool.h"
#endif

#ifdef CEU_ORGS_NEWS
typedef struct tceu_pool_orgs {
    tceu_org* parent_org;
    tceu_ntrl parent_trl;
#ifdef CEU_ORGS_NEWS_POOL
    tceu_pool pool;
#endif
} tceu_pool_orgs;
#endif

#ifdef CEU_ADTS_NEWS
typedef struct {
    void* root;
#ifdef CEU_ADTS_NEWS_POOL
    void* pool;
#endif
} tceu_pool_adts;
#endif

/* TCEU_KILL */

#ifdef CEU_ORGS_OR_ADTS_AWAIT
typedef struct tceu_kill {
    void*     org_or_adt;
    int       ret;
} tceu_kill;
#endif

/* TCEU_LST */

#ifdef CEU_DEBUG
typedef struct tceu_lst {
#ifdef CEU_ORGS
    void*     org;
#endif
    tceu_trl* trl;
    tceu_nlbl lbl;
} tceu_lst;

#endif

/* TCEU_STK */

typedef struct tceu_stk {
    struct tceu_stk* up;
    tceu_org* org;
    tceu_ntrl trl1;
    tceu_ntrl trl2;
    jmp_buf   jmp;
} tceu_stk;

/* TCEU_JMP */

#ifdef CEU_STACK
typedef struct tceu_jmp {
#ifdef CEU_ORGS
    tceu_org* org;
#endif
    tceu_trl* trl;
    tceu_nlbl lbl;
} tceu_jmp;
#endif

/* TCEU_APP */

typedef struct tceu_app {
    /* global seqno: incremented on every reaction
     * awaiting trails matches only if trl->seqno < seqno,
     * i.e., previously awaiting the event
     */
    u8 seqno:          2;
#if defined(CEU_RET) || defined(CEU_OS)
    u8 isAlive:        1;
#endif
#ifdef CEU_ASYNCS
    u8 pendingAsyncs:  1;
#endif
#if defined(CEU_ORGS_NEWS_MALLOC) && defined(CEU_ORGS_AWAIT)
    u8 dont_emit_kill: 1;
#endif

#ifdef CEU_OS
    struct tceu_app* nxt;
#endif

#ifdef CEU_REENTRANT
    tceu_nstk stki;
#endif

#ifdef CEU_STACK
    tceu_stk* stk_bottom;
    tceu_jmp  stk_jmp;
#endif

#if defined(CEU_RET) || defined(CEU_ORGS_AWAIT)
    int ret;
#endif

#ifdef CEU_ORGS_NEWS_MALLOC
    tceu_org* tofree;
#endif

#ifdef CEU_WCLOCKS
    s32         wclk_late;
    s32         wclk_min_set;   /* used to set */
    s32         wclk_min_cmp;   /* used to compare */
                                /* cmp<-set every reaction */
#ifdef CEU_TIMEMACHINE
    s32         wclk_late_;
    s32         wclk_min_set_;
    s32         wclk_min_cmp_;
#endif
#endif

#ifndef CEU_OS
#ifdef CEU_DEBUG
    tceu_lst    lst; /* segfault printf */
#endif
#endif

#ifdef CEU_THREADS
    CEU_THREADS_MUTEX_T threads_mutex;
    /*CEU_THREADS_COND_T  threads_cond;*/
    u8                  threads_n;          /* number of running threads */
        /* TODO: u8? */
#endif
#if defined(CEU_LUA) || defined(CEU_OS)
#ifdef CEU_LUA
    lua_State*  lua;    /* TODO: move to data? */
#else
    void*       lua;
#endif
#endif

    void        (*code)  (struct tceu_app*,tceu_evt*,tceu_org*,tceu_trl*,tceu_stk*);
    void        (*init)  (struct tceu_app*);
#ifdef CEU_OS
    void*       (*calls) (struct tceu_app*,tceu_nevt,void*);
    void**      sys_vec;
    void*       addr;
#ifdef CEU_OS_LUAIFC
    char*       luaifc;
#endif
#endif
    tceu_org*   data;
} tceu_app;

#ifdef CEU_OS
typedef void (*tceu_init)   (tceu_app* app);
typedef void (*tceu_export) (uint* size, tceu_init** init
#ifdef CEU_OS_LUAIFC
                            , char** luaifc
#endif
);
#endif

/* TCEU_THREADS_P */

#ifdef CEU_THREADS
typedef struct {
    tceu_app* app;
    tceu_org* org;
    s8*       st; /* thread state:
                   * 0=ini (sync  spawns)
                   * 1=cpy (async copies)
                   * 2=lck (sync  locks)
                   * 3=end (sync/async terminates)
                   */
} tceu_threads_p;
#endif

#ifdef CEU_PSES
void ceu_pause (tceu_trl* trl, tceu_trl* trlF, int psed);
#endif

int  ceu_go_all    (tceu_app* app);

#ifdef CEU_WCLOCKS
int       ceu_sys_wclock (tceu_app* app, s32 dt, s32* set, s32* get);
#endif
void      ceu_sys_go     (tceu_app* app, int evt, void* evtp);

#ifdef CEU_OS

/* TCEU_LINK */

typedef struct tceu_lnk {
    tceu_app* src_app;
    tceu_nevt src_evt;
    tceu_app* dst_app;
    tceu_nevt dst_evt;
    struct tceu_lnk* nxt;
} tceu_lnk;

/* TCEU_QUEUE */

typedef struct {
    tceu_app* app;
    tceu_nevt evt;
#if CEU_QUEUE_MAX == 256
    s8        sz;
#else
    s16       sz;   /* signed because of fill */
#endif
    byte      buf[0];
} tceu_queue;

#ifdef CEU_ISR
typedef void(*tceu_isr_f)(tceu_app* app, tceu_org* org);
#endif

void ceu_os_init      (void);
int  ceu_os_scheduler (int(*dt)());
tceu_queue* ceu_sys_queue_nxt (void);
void        ceu_sys_queue_rem (void);

void      ceu_sys_assert    (int v);
void      ceu_sys_log       (int mode, long str);
void*     ceu_sys_realloc   (void* ptr, size_t size);
int       ceu_sys_req       (void);
tceu_app* ceu_sys_load      (void* addr);
#ifdef CEU_ISR
int       ceu_sys_isr       (int n, tceu_isr_f f, tceu_app* app);
#endif
void      ceu_sys_org_init  (tceu_org* org, int n, int lbl, int cls, int isDyn,
                             tceu_org* parent_org, tceu_ntrl parent_trl);
void      ceu_sys_start     (tceu_app* app);
int       ceu_sys_link      (tceu_app* src_app, tceu_nevt src_evt, tceu_app* dst_app, tceu_nevt dst_evt);
int       ceu_sys_unlink    (tceu_app* src_app, tceu_nevt src_evt, tceu_app* dst_app, tceu_nevt dst_evt);
int       ceu_sys_emit      (tceu_app* app, tceu_nevt evt, int sz, void* param);
void*     ceu_sys_call      (tceu_app* app, tceu_nevt evt, void* param);

enum {
    CEU_SYS_ASSERT = 0,
    CEU_SYS_LOG,
    CEU_SYS_REALLOC,
    CEU_SYS_REQ,
    CEU_SYS_LOAD,
#ifdef CEU_ISR
    CEU_SYS_ISR,
#endif
#ifdef CEU_CLEAR
    CEU_SYS_CLEAR,
#endif
    CEU_SYS_STACK_PUSH,
#ifdef CEU_ORGS
    CEU_SYS_STACK_CLEAR_ORG,
#endif
    CEU_SYS_ORG,
#ifdef CEU_ORGS
    CEU_SYS_ORG_TRAIL,
    CEU_SYS_ORG_SPAWN,
#endif
    CEU_SYS_START,
    CEU_SYS_LINK,
    CEU_SYS_UNLINK,
    CEU_SYS_EMIT,
    CEU_SYS_CALL,
#ifdef CEU_WCLOCKS
    CEU_SYS_WCLOCK,
#endif
    CEU_SYS_GO,
    CEU_SYS_MAX
};

/* SYS_VECTOR
 */
extern void* CEU_SYS_VEC[CEU_SYS_MAX];

#endif  /* CEU_OS */

#endif  /* _CEU_OS_H */


typedef struct {
    int   max;
    int   nxt;
    int   unit;
    byte* mem;
} tceu_vector;

#define CEU_VECTOR_DCL(name, type, max)  \
    type        name##_mem[max+1];       \
    tceu_vector name;
                /* [STRING] max+1: extra space for '\0' */

#define ceu_vector_getlen(vec) ((vec)->nxt)
#define ceu_vector_getmax(vec) ((vec)->max > 0 ? (vec)->max : 0)

void  ceu_vector_init   (tceu_vector* vector, int max, int unit, byte* mem);
int   ceu_vector_setlen (tceu_vector* vector, int len);
byte* ceu_vector_geti   (tceu_vector* vector, int idx);
int   ceu_vector_seti   (tceu_vector* vector, int idx, byte* v);
int   ceu_vector_push   (tceu_vector* vector, byte* v);
int   ceu_vector_concat (tceu_vector* to, tceu_vector* fr);
int   ceu_vector_concat_buffer (tceu_vector* to, const char* fr, int n);
char* ceu_vector_tochar (tceu_vector* vector);

#if 0
byte* ceu_pool_alloc (tceu_pool* pool);
void ceu_pool_free (tceu_pool* pool, byte* val);
#endif
#endif

#endif


#define CEU_IN__NONE 0
#define CEU_IN__ORG 255
#define CEU_IN__ORG_PSED 254
#define CEU_IN__CLEAR 253
#define CEU_IN__ok_killed 252
#define CEU_IN__INIT 251
#define CEU_IN__ASYNC 250
#define CEU_IN__THREAD 249
#define CEU_IN__WCLOCK 248
#define CEU_IN_TICK 247
#define CEU_IN_higher CEU_IN__INIT
#define CEU_IN_lower 247
#define CEU_OUT_n 0
      /* CEU_IN_, CEU_OUT_ */
#define CEU_FUN_assert
   /* CEU_FUN_ */
typedef struct {
	int _1;
} tceu__int;
typedef struct {
	s32 _1;
} tceu__s32;


/* class/adts definitions */
/* may use types defined above in "NATIVE" */
/* each class may define new native code that appear after its struct declaration */

enum {
CEU_NONE11,
CEU_LEAF_SENSERIGHT,
CEU_LEAF_SENSELEFT,
CEU_LEAF_SENSEUP,
CEU_LEAF_SENSEDOWN,
CEU_LEAF_GORIGHT,
CEU_LEAF_GOLEFT,
CEU_LEAF_GOUP,
CEU_LEAF_GODOWN,
CEU_LEAF_SKIP
};

typedef struct CEU_Leaf {
    u8 tag;
    union {
                            struct { /* BLOCK ln=3 */
                            } SENSERIGHT;
                            struct { /* BLOCK ln=3 */
                            } SENSELEFT;
                            struct { /* BLOCK ln=3 */
                            } SENSEUP;
                            struct { /* BLOCK ln=3 */
                            } SENSEDOWN;
                            struct { /* BLOCK ln=3 */
                            } GORIGHT;
                            struct { /* BLOCK ln=3 */
                            } GOLEFT;
                            struct { /* BLOCK ln=3 */
                            } GOUP;
                            struct { /* BLOCK ln=3 */
                            } GODOWN;
                            struct { /* BLOCK ln=3 */
                            } SKIP;
    };
}
 CEU_Leaf;

typedef struct CEU_LeafHandler {
#ifdef CEU_ORGS
  struct tceu_org org;
#endif
  tceu_trl trls_[ 2 ];
                            struct { /* BLOCK ln=23 */
                              CEU_Leaf* leaf;
                              union {
                                  union {
                                  };
                                struct { /* BLOCK ln=23 */
                                  union {
                                      struct { /* BLOCK ln=26 */
                                        int answer;
                                        union {
                                          union {
                                          };
                                            struct { /* BLOCK ln=28 */
                                              union {
                                              };
                                            } ;
                                              struct { /* BLOCK ln=30 */
                                                union {
                                                };
                                              } ;
                                                struct { /* BLOCK ln=32 */
                                                  union {
                                                  };
                                                } ;
                                                  struct { /* BLOCK ln=34 */
                                                    union {
                                                    };
                                                  } ;
                                                    struct { /* BLOCK ln=36 */
                                                      union {
                                                      };
                                                    } ;
                                                      struct { /* BLOCK ln=39 */
                                                        union {
                                                        };
                                                      } ;
                                                        struct { /* BLOCK ln=42 */
                                                          union {
                                                          };
                                                        } ;
                                                          struct { /* BLOCK ln=45 */
                                                            union {
                                                            };
                                                          } ;
                                                            struct { /* BLOCK ln=48 */
                                                              union {
                                                              };
                                                            } ;
                                                            struct { /* BLOCK ln=50 */
                                                              union {
                                                              };
                                                            } ;
                                          union {
                                          };
                                        };
                                      } ;
                                  };
                                } ;
                              };
                            } ;

} CEU_LeafHandler;





enum {
CEU_NONE134,
CEU_BTREE_NIL,
CEU_BTREE_SEQUENCE,
CEU_BTREE_SELECTOR,
CEU_BTREE_LEAF
};

typedef struct CEU_BTree {
    u8 tag;
    union {
                            struct { /* BLOCK ln=11 */
                            } NIL;
                            struct { /* BLOCK ln=11 */
                              struct CEU_BTree* first;
                              struct CEU_BTree* second;
                            } SEQUENCE;
                            struct { /* BLOCK ln=11 */
                              struct CEU_BTree* first;
                              struct CEU_BTree* second;
                            } SELECTOR;
                            struct { /* BLOCK ln=11 */
                              CEU_Leaf leaf;
                            } LEAF;
    };
}
 CEU_BTree;

typedef struct CEU_Scope {
#ifdef CEU_ORGS
  struct tceu_org org;
#endif
  tceu_trl trls_[ 2 ];
                                                  struct { /* BLOCK ln=33 */
                                                    union {
                                                        union {
                                                        };
                                                      struct { /* BLOCK ln=33 */
                                                        union {
                                                          struct { /* BLOCK ln=33 */
                                                            union {
                                                            };
                                                          } ;
                                                        };
                                                      } ;
                                                    };
                                                  } ;

} CEU_Scope;





enum {
CEU_NONE1380,
CEU__OPTION__BODY_225__PTR_NIL,
CEU__OPTION__BODY_225__PTR_SOME
};

typedef struct CEU__Option__Body_225__ptr {
    u8 tag;
    union {
                                                                                                struct { /* BLOCK ln=36 */
                                                                                                } NIL;
                                                                                                struct { /* BLOCK ln=36 */
                                                                                                  struct CEU_Body_225* v;
                                                                                                } SOME;
    };
}
 CEU__Option__Body_225__ptr;

typedef struct CEU_Body_225 {
#ifdef CEU_ORGS
  struct tceu_org org;
#endif
  tceu_trl trls_[ 7 ];
                                                  struct { /* BLOCK ln=33 */
                                                    tceu_pool_orgs* _bodies;
;
                                                    struct CEU_Scope* _parent;
                                                    /*
 * REF:
 * tceu_pool_adts* x;  // root/pool always the same as the parent
 * PTR:
 * tceu_pool_adts x;   // pool: the same // root: may point to the middle
 */
tceu_pool_adts t;
;
                                                    struct CEU_BTreeTraverse* _out;
                                                    union {
                                                        union {
                                                        };
                                                      struct { /* BLOCK ln=33 */
                                                        int _ret_13;
                                                        union {
                                                            struct { /* BLOCK ln=33 */
                                                              union {
                                                                struct {
                                                                  struct { /* BLOCK ln=33 */
                                                                    union {
                                                                      union {
                                                                        union {
                                                                            struct { /* BLOCK ln=33 */
                                                                              union {
                                                                              };
                                                                            } ;
                                                                            struct { /* BLOCK ln=33 */
                                                                              union {
                                                                              };
                                                                            } ;
                                                                        };
                                                                      };
                                                                    };
                                                                  } ;
                                                                  struct { /* BLOCK ln=33 */
                                                                    union {
                                                                      struct { /* BLOCK ln=34 */
                                                                        union {
                                                                          struct {
                                                                            struct { /* BLOCK ln=34 */
                                                                              union {
                                                                                union {
                                                                                    struct { /* BLOCK ln=34 */
                                                                                      union {
                                                                                      };
                                                                                    } ;
                                                                                    struct { /* BLOCK ln=34 */
                                                                                      union {
                                                                                      };
                                                                                    } ;
                                                                                };
                                                                              };
                                                                            } ;
                                                                            struct { /* BLOCK ln=35 */
                                                                              union {
                                                                                  struct { /* BLOCK ln=36 */
                                                                                    int ok_14;
                                                                                    union {
                                                                                      union {
                                                                                        struct { /* BLOCK ln=36 */
                                                                                          struct CEU_Scope _s_16;
                                                                                          struct CEU__Option__Body_225__ptr _body_151_17;
                                                                                          union {
                                                                                                  union {
                                                                                                  };
                                                                                                  union {
                                                                                                  };
                                                                                                  struct { /* BLOCK ln=36 */
                                                                                                    union {
                                                                                                    };
                                                                                                  } ;
                                                                                              struct { /* BLOCK ln=36 */
                                                                                                union {
                                                                                                  union {
                                                                                                    union {
                                                                                                        struct { /* BLOCK ln=36 */
                                                                                                          union {
                                                                                                          };
                                                                                                        } ;
                                                                                                        struct { /* BLOCK ln=36 */
                                                                                                          union {
                                                                                                          };
                                                                                                        } ;
                                                                                                    };
                                                                                                  };
                                                                                                };
                                                                                              } ;
                                                                                              struct { /* BLOCK ln=36 */
                                                                                                union {
                                                                                                };
                                                                                              } ;
                                                                                          };
                                                                                        } ;
                                                                                      };
                                                                                        struct { /* BLOCK ln=38 */
                                                                                          union {
                                                                                            union {
                                                                                            };
                                                                                          };
                                                                                        } ;
                                                                                      struct { /* BLOCK ln=40 */
                                                                                        struct CEU_Scope _s_18;
                                                                                        struct CEU__Option__Body_225__ptr _body_166_19;
                                                                                        union {
                                                                                                struct { /* BLOCK ln=40 */
                                                                                                  union {
                                                                                                  };
                                                                                                } ;
                                                                                            struct { /* BLOCK ln=40 */
                                                                                              union {
                                                                                                union {
                                                                                                  union {
                                                                                                      struct { /* BLOCK ln=40 */
                                                                                                        union {
                                                                                                        };
                                                                                                      } ;
                                                                                                      struct { /* BLOCK ln=40 */
                                                                                                        union {
                                                                                                        };
                                                                                                      } ;
                                                                                                  };
                                                                                                };
                                                                                              };
                                                                                            } ;
                                                                                            struct { /* BLOCK ln=40 */
                                                                                              union {
                                                                                              };
                                                                                            } ;
                                                                                        };
                                                                                      } ;
                                                                                      union {
                                                                                      };
                                                                                    };
                                                                                  } ;
                                                                                    struct { /* BLOCK ln=43 */
                                                                                      int ok_20;
                                                                                      int ok_23;
                                                                                      union {
                                                                                        union {
                                                                                          struct { /* BLOCK ln=43 */
                                                                                            struct CEU_Scope _s_21;
                                                                                            struct CEU__Option__Body_225__ptr _body_179_22;
                                                                                            union {
                                                                                                    struct { /* BLOCK ln=43 */
                                                                                                      union {
                                                                                                      };
                                                                                                    } ;
                                                                                                struct { /* BLOCK ln=43 */
                                                                                                  union {
                                                                                                    union {
                                                                                                      union {
                                                                                                          struct { /* BLOCK ln=43 */
                                                                                                            union {
                                                                                                            };
                                                                                                          } ;
                                                                                                          struct { /* BLOCK ln=43 */
                                                                                                            union {
                                                                                                            };
                                                                                                          } ;
                                                                                                      };
                                                                                                    };
                                                                                                  };
                                                                                                } ;
                                                                                                struct { /* BLOCK ln=43 */
                                                                                                  union {
                                                                                                  };
                                                                                                } ;
                                                                                            };
                                                                                          } ;
                                                                                        };
                                                                                          struct { /* BLOCK ln=45 */
                                                                                            union {
                                                                                              union {
                                                                                              };
                                                                                            };
                                                                                          } ;
                                                                                        union {
                                                                                          struct { /* BLOCK ln=47 */
                                                                                            struct CEU_Scope _s_24;
                                                                                            struct CEU__Option__Body_225__ptr _body_194_25;
                                                                                            union {
                                                                                                    struct { /* BLOCK ln=47 */
                                                                                                      union {
                                                                                                      };
                                                                                                    } ;
                                                                                                struct { /* BLOCK ln=47 */
                                                                                                  union {
                                                                                                    union {
                                                                                                      union {
                                                                                                          struct { /* BLOCK ln=47 */
                                                                                                            union {
                                                                                                            };
                                                                                                          } ;
                                                                                                          struct { /* BLOCK ln=47 */
                                                                                                            union {
                                                                                                            };
                                                                                                          } ;
                                                                                                      };
                                                                                                    };
                                                                                                  };
                                                                                                } ;
                                                                                                struct { /* BLOCK ln=47 */
                                                                                                  union {
                                                                                                  };
                                                                                                } ;
                                                                                            };
                                                                                          } ;
                                                                                        };
                                                                                        union {
                                                                                        };
                                                                                      };
                                                                                    } ;
                                                                                      struct { /* BLOCK ln=50 */
                                                                                        int ok_26;
                                                                                        union {
                                                                                          union {
                                                                                              struct { /* BLOCK ln=51 */
                                                                                                struct CEU_LeafHandler _org_213_27;
                                                                                                union {
                                                                                                      struct { /* BLOCK ln=52 */
                                                                                                        union {
                                                                                                        };
                                                                                                      } ;
                                                                                                  union {
                                                                                                    union {
                                                                                                        struct { /* BLOCK ln=51 */
                                                                                                          union {
                                                                                                          };
                                                                                                        } ;
                                                                                                        struct { /* BLOCK ln=51 */
                                                                                                          union {
                                                                                                          };
                                                                                                        } ;
                                                                                                    };
                                                                                                  };
                                                                                                };
                                                                                              } ;
                                                                                          };
                                                                                          union {
                                                                                          };
                                                                                        };
                                                                                      } ;
                                                                              };
                                                                            } ;
                                                                          };
                                                                        };
                                                                      } ;
                                                                    };
                                                                  } ;
                                                                };
                                                                union {
                                                                };
                                                              };
                                                            } ;
                                                        };
                                                      } ;
                                                    };
                                                  } ;

} CEU_Body_225;





typedef struct CEU_BTreeTraverse {
#ifdef CEU_ORGS
  struct tceu_org org;
#endif
  tceu_trl trls_[ 11 ];
                            struct { /* BLOCK ln=29 */
                              /*
 * REF:
 * tceu_pool_adts* x;  // root/pool always the same as the parent
 * PTR:
 * tceu_pool_adts x;   // pool: the same // root: may point to the middle
 */
tceu_pool_adts* btree;
;
                              union {
                                  union {
                                  };
                                struct { /* BLOCK ln=29 */
                                  int _ret_7;
                                  union {
                                      struct { /* BLOCK ln=32 */
                                        tceu_pool_orgs _pool_225;
;
                                        int ok;
                                        union {
                                          union {
                                            union {
                                              union {
                                              };
                                              union {
                                              };
                                              struct { /* BLOCK ln=33 */
                                                struct CEU_Scope _s_10;
                                                struct CEU__Option__Body_225__ptr _body_225_11;
                                                union {
                                                        struct { /* BLOCK ln=33 */
                                                          union {
                                                          };
                                                        } ;
                                                    struct { /* BLOCK ln=33 */
                                                      union {
                                                        union {
                                                          union {
                                                              struct { /* BLOCK ln=33 */
                                                                union {
                                                                };
                                                              } ;
                                                              struct { /* BLOCK ln=33 */
                                                                union {
                                                                };
                                                              } ;
                                                          };
                                                        };
                                                      };
                                                    } ;
                                                    struct { /* BLOCK ln=33 */
                                                      union {
                                                      };
                                                    } ;
                                                };
                                              } ;
                                            };
                                          };
                                          union {
                                          };
                                        };
                                      } ;
                                  };
                                } ;
                              };
                            } ;

} CEU_BTreeTraverse;




typedef struct CEU_Main {
#ifdef CEU_ORGS
  struct tceu_org org;
#endif
  tceu_trl trls_[ 11 ];
    struct { /* BLOCK ln=1 */
      union {
          union {
          };
        struct { /* BLOCK ln=1 */
          union {
              struct { /* BLOCK ln=1 */
                union {
                  union {
                    struct { /* BLOCK ln=1 */
                      union {
                        union {
                        };
                              union {
                              };
                              union {
                              };
                              union {
                              };
                              union {
                              };
                              union {
                              };
                              union {
                              };
                              union {
                              };
                              union {
                              };
                              union {
                              };
                        union {
                        };
                              union {
                              };
                              union {
                              };
                              union {
                              };
                              union {
                              };
                              union {
                              };
                              union {
                              };
                        union {
                        };
                        struct {
                          struct { /* BLOCK ln=59 */
                            /*
 * REF:
 * tceu_pool_adts* x;  // root/pool always the same as the parent
 * PTR:
 * tceu_pool_adts x;   // pool: the same // root: may point to the middle
 */
tceu_pool_adts x_behavior_6;
;
                            union {
                              union {
                              };
                              struct { /* BLOCK ln=66 */
                                union {
                                  union {
                                  };
                                    struct { /* BLOCK ln=67 */
                                      union {
                                        union {
                                        };
                                          struct { /* BLOCK ln=67 */
                                            struct CEU_BTreeTraverse _org_286_7;
                                            union {
                                                  struct { /* BLOCK ln=68 */
                                                    union {
                                                    };
                                                  } ;
                                              union {
                                                union {
                                                    struct { /* BLOCK ln=67 */
                                                      union {
                                                      };
                                                    } ;
                                                    struct { /* BLOCK ln=67 */
                                                      union {
                                                      };
                                                    } ;
                                                };
                                              };
                                            };
                                          } ;
                                      };
                                    } ;
                                };
                              } ;
                            };
                          } ;
                          struct { /* BLOCK ln=72 */
                            /*
 * REF:
 * tceu_pool_adts* x;  // root/pool always the same as the parent
 * PTR:
 * tceu_pool_adts x;   // pool: the same // root: may point to the middle
 */
tceu_pool_adts y_behavior_8;
;
                            union {
                              union {
                              };
                              struct { /* BLOCK ln=79 */
                                union {
                                  union {
                                  };
                                    struct { /* BLOCK ln=80 */
                                      union {
                                        union {
                                        };
                                          struct { /* BLOCK ln=80 */
                                            struct CEU_BTreeTraverse _org_346_9;
                                            union {
                                                  struct { /* BLOCK ln=81 */
                                                    union {
                                                    };
                                                  } ;
                                              union {
                                                union {
                                                    struct { /* BLOCK ln=80 */
                                                      union {
                                                      };
                                                    } ;
                                                    struct { /* BLOCK ln=80 */
                                                      union {
                                                      };
                                                    } ;
                                                };
                                              };
                                            };
                                          } ;
                                      };
                                    } ;
                                };
                              } ;
                            };
                          } ;
                        };
                      };
                    } ;
                  };
                };
              } ;
          };
        } ;
      };
    } ;

} CEU_Main;






#endif

#ifndef _CEU_OS_H
#define _CEU_OS_H

#include <stddef.h>
#include "ceu_types.h"

#ifdef CEU_DEBUG
#include <assert.h>
#endif

#if defined(CEU_OS) && defined(__AVR)
#error Understand this again!
#include "Arduino.h"
#define CEU_ISR
#define CEU_ISR_ON()  interrupts()
#define CEU_ISR_OFF() noInterrupts()
#else
#define CEU_ISR_ON()
#define CEU_ISR_OFF()
#endif

/*
#if defined(CEU_CLEAR) || defined(CEU_INTS) || defined(CEU_ORGS) || defined(CEU_REENTRANT)
*/
#if 1
#include <setjmp.h>
#define CEU_STACK
#endif

#if defined(CEU_OS_KERNEL) || defined(CEU_OS_APP)
#define CEU_OS
#endif

#if defined(CEU_ORGS_NEWS) || defined(CEU_ADTS_NEWS)
#define CEU_NEWS
#endif
#if defined(CEU_ORGS_NEWS_POOL) || defined(CEU_ADTS_NEWS_POOL)
#define CEU_NEWS_POOL
#endif
#if defined(CEU_ORGS_AWAIT) || defined(CEU_ADTS_AWAIT)
#define CEU_ORGS_OR_ADTS_AWAIT
#endif

#ifdef CEU_OS

    /* TODO: all should be configurable */
    #define CEU_EXTS
    #define CEU_WCLOCKS
    #define CEU_ASYNCS
    #define CEU_RET
    #define CEU_CLEAR
    #define CEU_STACK
#ifndef __AVR
#endif
    #define CEU_INTS
    #define CEU_ORGS
    /*#define CEU_PSES*/ /* TODO: never tried */
    #define CEU_NEWS
    #define CEU_NEWS_POOL
    #define CEU_ORGS_NEWS
    #define CEU_ORGS_NEWS_MALLOC
    #define CEU_ORGS_NEWS_POOL
    #define CEU_ADTS_NEWS
    #define CEU_ADTS_NEWS_MALLOC
    #define CEU_ADTS_NEWS_POOL
    #define CEU_ORGS_AWAIT
    #define CEU_ADTS_AWAIT
    #define CEU_ORGS_OR_ADTS_AWAIT
/*
    #define CEU_THREADS
*/

#ifdef __AVR
    #define CEU_QUEUE_MAX 256
#else
    #define CEU_QUEUE_MAX 65536
#endif

    #define CEU_IN__NONE          0
    #define CEU_IN__ORG         255
    #define CEU_IN__ORG_PSED    254
    #define CEU_IN__CLEAR       253
    #define CEU_IN__ok_killed   252
    #define CEU_IN__INIT        251     /* HIGHER EXTERNAL */
    #define CEU_IN__ASYNC       250
    #define CEU_IN__THREAD      249
    #define CEU_IN__WCLOCK      248
    #define CEU_IN_OS_START     247
    #define CEU_IN_OS_STOP      246
    #define CEU_IN_OS_DT        245
    #define CEU_IN_OS_INTERRUPT 244
#ifdef CEU_TIMEMACHINE
    #define CEU_IN__WCLOCK_     243
    #define CEU_IN              243
#else
    #define CEU_IN              242
#endif

    #define CEU_IN_higher       CEU_IN__INIT  /* _INIT = HIGHER EXTERNAL */
    #define CEU_IN_lower        128     /* TODO: not checked from up and down */

    typedef s8 tceu_nlbl;   /* TODO: to small!! */

#endif /* CEU_OS */

#ifdef CEU_OS_APP

    #define ceu_out_log(mode,str) \
        ((__typeof__(ceu_sys_log)*)((_ceu_app)->sys_vec[CEU_SYS_LOG]))(mode,str)

    #define ceu_out_assert(v) \
        ((__typeof__(ceu_sys_assert)*)((_ceu_app)->sys_vec[CEU_SYS_ASSERT]))(v)

    #define ceu_out_assert_msg_ex(v,msg,file,line)       \
        {                                                \
            int __ceu_v = v;                             \
            if ((!(__ceu_v)) && ((msg)!=NULL)) {         \
                ceu_out_log(0, (long)"[");               \
                ceu_out_log(0, (long)(file));            \
                ceu_out_log(0, (long)":");               \
                ceu_out_log(2, (line));                  \
                ceu_out_log(0, (long)"] ");              \
                ceu_out_log(0, (long)"runtime error: "); \
                ceu_out_log(0, (long)(msg));             \
                ceu_out_log(0, (long)"\n");              \
            }                                            \
            ((__typeof__(ceu_sys_assert)*)((_ceu_app)->sys_vec[CEU_SYS_ASSERT]))(__ceu_v); \
        }
    #define ceu_out_assert_msg(v,msg) ceu_out_assert_msg_ex((v),(msg),__FILE__,__LINE__)

    #define ceu_out_realloc(ptr, size) \
        ((__typeof__(ceu_sys_realloc)*)((_ceu_app)->sys_vec[CEU_SYS_REALLOC]))(ptr,size)

    #define ceu_out_req() \
        ((__typeof__(ceu_sys_req)*)((_ceu_app)->sys_vec[CEU_SYS_REQ]))()

    #define ceu_out_load(addr) \
        ((__typeof__(ceu_sys_load)*)((_ceu_app)->sys_vec[CEU_SYS_LOAD]))(addr)

#ifdef CEU_ISR
    #define ceu_out_isr(n,f) \
        ((__typeof__(ceu_sys_isr)*)((_ceu_app)->sys_vec[CEU_SYS_ISR]))(n,f,_ceu_app)
#endif

    #define ceu_out_org_init(app,org,n,lbl,cls,isDyn,parent_org,parent_trl) \
        ((__typeof__(ceu_sys_org_init)*)((app)->sys_vec[CEU_SYS_ORG]))(org,n,lbl,cls,isDyn,parent_org,parent_trl)
    #define ceu_out_start(app) \
        ((__typeof__(ceu_sys_start)*)((_ceu_app)->sys_vec[CEU_SYS_START]))(app)
    #define ceu_out_link(app1,evt1 , app2,evt2) \
        ((__typeof__(ceu_sys_link)*)((_ceu_app)->sys_vec[CEU_SYS_LINK]))(app1,evt1,app2,evt2)

    #define ceu_out_emit(app,id,sz,buf) \
        ((__typeof__(ceu_sys_emit)*)((app)->sys_vec[CEU_SYS_EMIT]))(app,id,sz,buf)

    #define ceu_out_call(app,id,param) \
        ((__typeof__(ceu_sys_call)*)((app)->sys_vec[CEU_SYS_CALL]))(app,id,param)

#ifdef CEU_WCLOCKS
    #define ceu_out_wclock(app,dt,set,get) \
        ((__typeof__(ceu_sys_wclock)*)((app)->sys_vec[CEU_SYS_WCLOCK]))(app,dt,set,get)
#ifdef CEU_TIMEMACHINE
    #error TIMEMACHINE
#endif
#endif

    #define ceu_out_go(app,evt,evtp) \
        ((__typeof__(ceu_sys_go)*)((app)->sys_vec[CEU_SYS_GO]))(app,evt,evtp)

#else /* ! CEU_OS_APP (!CEU_OS||CEU_OS_KERNEL) */

    #ifndef ceu_out_assert
        #error "Missing definition for macro \"ceu_out_assert\"."
    #endif

    #ifndef ceu_out_log
        #error "Missing definition for macro \"ceu_out_log\"."
    #endif

    #define ceu_out_assert_msg_ex(v,msg,file,line)          \
        {                                                   \
            int __ceu_v = v;                                \
            if ((!(__ceu_v)) && ((msg)!=NULL)) {            \
                ceu_out_log(0, (long)"[");                  \
                ceu_out_log(0, (long)(file));               \
                ceu_out_log(0, (long)":");                  \
                ceu_out_log(2, line);                       \
                ceu_out_log(0, (long)"] ");                 \
                ceu_out_log(0, (long)"runtime error: ");    \
                ceu_out_log(0, (long)(msg));                \
                ceu_out_log(0, (long)"\n");                 \
            }                                               \
            ceu_out_assert(__ceu_v);                        \
        }
    #define ceu_out_assert_msg(v,msg) ceu_out_assert_msg_ex((v),(msg),__FILE__,__LINE__)

    #define ceu_out_realloc(ptr,size) \
            ceu_sys_realloc(ptr,size)
    #define ceu_out_req() \
            ceu_sys_req()
    #define ceu_out_org_init(app,org,n,lbl,cls,isDyn,parent_org,parent_trl) \
            ceu_sys_org_init(org,n,lbl,cls,isDyn,parent_org,parent_trl)

#ifdef CEU_WCLOCKS
    #define ceu_out_wclock(app,dt,set,get) \
            ceu_sys_wclock(app,dt,set,get)
#ifdef CEU_TIMEMACHINE
    #define ceu_out_wclock_(app,dt,set,get) \
            ceu_sys_wclock_(app,dt,set,get)
#endif
#endif
    #define ceu_out_go(app,evt,evtp) \
            ceu_sys_go(app,evt,evtp)
    #define ceu_out_go_stk(app,evt,evtp,stk) \
            ceu_sys_go_stk(app,evt,evtp,stk)

#endif /* ! CEU_OS_APP (!CEU_OS||CEU_OS_KERNEL) */

#define ceu_in_emit(app,id,n,buf) \
    ceu_out_go_stk(app,id,buf,&stk_)

#ifdef CEU_THREADS
/* TODO: app */
#include "ceu_threads.h"
#endif

#ifdef CEU_LUA
#include <stdio.h>      /* BUFSIZ */
#include <string.h>     /* strcpy */
#if defined(__ANDROID__) || defined(CEU_OS)
    #include "lua.h"
    #include "lauxlib.h"
    #include "lualib.h"
#else
    #include <lua5.1/lua.h>
    #include <lua5.1/lauxlib.h>
    #include <lua5.1/lualib.h>
#endif

#ifdef CEU_OS_APP
    #define ceu_luaL_newstate(set) { \
        set = ceu_out_call(_ceu_app, CEU_OUT_LUA_NEW, NULL); \
    }

    #define ceu_luaL_openlibs(l) { \
        lua_State* p = l;          \
        ceu_out_call(_ceu_app, CEU_OUT_LUAL_OPENLIBS, &p); \
    }

    #define ceu_lua_atpanic(l, f) {     \
    }

    #define ceu_luaL_loadstring(set, l, str) {  \
        tceu__lua_State___char_ p = { l, str }; \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUAL_LOADSTRING, &p); \
    }

    #define ceu_lua_pushnumber(l, v) {      \
        tceu__lua_State___int p = { l, v }; \
        ceu_out_call(_ceu_app, CEU_OUT_LUA_PUSHNUMBER, &p); \
    }

    #define ceu_lua_pushstring(l, v) {      \
        tceu__lua_State___char_ p = { l, v }; \
        ceu_out_call(_ceu_app, CEU_OUT_LUA_PUSHSTRING, &p); \
    }

    #define ceu_lua_pushlightuserdata(l, v) {   \
        tceu__lua_State___void_ p = { l, v };     \
        ceu_out_call(_ceu_app, CEU_OUT_LUA_PUSHLIGHTUSERDATA, &p); \
    }

    #define ceu_lua_pcall(set,l,nargs,nrets,err) {                  \
        tceu__lua_State___int__int__int p = { l, nargs, nrets, err }; \
        ceu_out_call(_ceu_app, CEU_OUT_LUA_PCALL, &p); \
    }

    #define ceu_lua_isnumber(set, l, idx) {     \
        tceu__lua_State___int p = { l, idx };   \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUA_ISNUMBER, &p); \
    }

    #define ceu_lua_tonumber(set, l, idx) {     \
        tceu__lua_State___int p = { l, idx };   \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUA_TONUMBER, &p); \
    }

    #define ceu_lua_isboolean(set, l, idx) {    \
        tceu__lua_State___int p = { l, idx };   \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUA_ISBOOLEAN, &p); \
    }

    #define ceu_lua_toboolean(set, l, idx) {    \
        tceu__lua_State___int p = { l, idx };   \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUA_TOBOOLEAN, &p); \
    }

    #define ceu_lua_pop(l, n) {             \
        tceu__lua_State___int p = { l, n }; \
        ceu_out_call(_ceu_app, CEU_OUT_LUA_POP, &p); \
    }

    #define ceu_lua_isstring(set, l, idx) {     \
        tceu__lua_State___int p = { l, idx };   \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUA_ISSTRING, &p); \
    }

    #define ceu_lua_tostring(set, l, idx) {     \
        tceu__lua_State___int p = { l, idx };   \
        set = ceu_out_call(_ceu_app, CEU_OUT_LUA_TOSTRING, &p); \
    }

    #define ceu_lua_islightuserdata(set, l, idx) {  \
        tceu__lua_State___int p = { l, idx };       \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUA_ISLIGHTUSERDATA, &p); \
    }

    #define ceu_lua_touserdata(set, l, idx) {   \
        tceu__lua_State___int p = { l, idx };   \
        set = ceu_out_call(_ceu_app, CEU_OUT_LUA_TOUSERDATA, &p); \
    }

    #define ceu_lua_error(l) {                          \
        lua_State** p = &l;                             \
        ceu_out_call(_ceu_app, CEU_OUT_LUA_ERROR, &p);  \
    }

    #define ceu_lua_objlen(set, l, idx) {                       \
        tceu__lua_State___int p = { l, idx };                   \
        set = ceu_out_call(_ceu_app, CEU_OUT_LUA_OBJLEN, &p);   \
    }

#else
    #define ceu_luaL_newstate(set)               set = luaL_newstate()
    #define ceu_luaL_openlibs(l)                 luaL_openlibs(l)
    #define ceu_lua_atpanic(l,f)                 lua_atpanic(l,f)
    #define ceu_luaL_loadstring(set,l,str)       set = luaL_loadstring(l,str)
    #define ceu_lua_pushnumber(l,v)              lua_pushnumber(l,v)
    #define ceu_lua_pushstring(l,v)              lua_pushstring(l,v)
    #define ceu_lua_pushlightuserdata(l,v)       lua_pushlightuserdata(l,v)
    #define ceu_lua_pcall(set,l,nargs,nrets,err) set = lua_pcall(l,nargs,nrets,err)
    #define ceu_lua_isnumber(set,l,idx)          set = lua_isnumber(l,idx)
    #define ceu_lua_tonumber(set,l,idx)          set = lua_tonumber(l,idx)
    #define ceu_lua_isboolean(set,l,idx)         set = lua_isboolean(l,idx)
    #define ceu_lua_toboolean(set,l,idx)         set = lua_toboolean(l,idx)
    #define ceu_lua_pop(l,n)                     lua_pop(l,n)
    #define ceu_lua_isstring(set,l,idx)          set = lua_isstring(l,idx)
    #define ceu_lua_tostring(set,l,idx)          set = lua_tostring(l,idx)
    #define ceu_lua_islightuserdata(set,l,idx)   set = lua_islightuserdata(l,idx)
    #define ceu_lua_touserdata(set,l,idx)        set = lua_touserdata(l,idx)
    #define ceu_lua_error(l)                     lua_error(l)
    #define ceu_lua_objlen(set,l,idx)            set = lua_objlen(l,idx)
#endif
#endif

typedef u8 tceu_nevt;   /* max number of events */
                        /* TODO: should "u8" be fixed? */

typedef u8 tceu_ntrl;   /* max number of trails per class */
                        /* TODO: should "u8" be fixed? */

#ifdef CEU_STACK
typedef u16 tceu_nstk;  /* max size of internal stack in bytes */
                        /* TODO: should "u16" be fixed? */
#endif

#ifdef __cplusplus
#define CEU_WCLOCK_INACTIVE 0x7fffffffL     /* TODO */
#else
#define CEU_WCLOCK_INACTIVE INT32_MAX
#endif
#define CEU_WCLOCK_EXPIRED (CEU_WCLOCK_INACTIVE-1)

/* TCEU_TRL */

struct tceu_org;
typedef union tceu_trl {
    tceu_nevt evt;

    /* normal await // IN__CLEAR */
    struct {                    /* TODO(ram): bitfields */
        tceu_nevt evt1;
        tceu_nlbl lbl;
        u8        seqno;        /* TODO(ram): 2 bits is enough */
#ifdef CEU_INTS                 /* R-9: size of trails for internal events */
#ifdef CEU_ORGS
        void*     evto;
#endif
#endif
    };

    /* IN__ORG */
#ifdef CEU_ORGS
    struct {                    /* TODO(ram): bad for alignment */
        tceu_nevt evt3;
        struct tceu_org* org;
    };
#endif

    /* _ok_killed */
#ifdef CEU_ORGS_OR_ADTS_AWAIT
    struct {
        tceu_nevt evt4;
        tceu_nlbl lbl4;
        void*     org_or_adt;
    };
#endif
} tceu_trl;

/* TCEU_EVT */

typedef struct tceu_evt {
    tceu_nevt id;
    void*     param;
#if defined(CEU_ORGS) && defined(CEU_INTS)
    void*     org;      /* emitting org */
#endif
} tceu_evt;

/* TCEU_ORG */

struct tceu_pool_orgs;
typedef struct tceu_org
{
#ifdef CEU_ORGS
    struct tceu_org* nxt; /* first field because of free list for orgs/adts */
    struct tceu_org* prv;
    struct tceu_org* parent_org;
    tceu_ntrl parent_trl;
#endif

#if defined(CEU_ORGS) || defined(CEU_OS)
    tceu_ntrl n;            /* number of trails (TODO(ram): opt, metadata) */
#endif

#ifdef CEU_ORGS

#ifdef CEU_IFCS
    tceu_ncls cls;          /* class id */
#endif
    u8 isAlive: 1;          /* Three purposes:
                             * - avoids double free
                             * - required by "watching o" to avoid awaiting a
                             *      dead org
                             * - required by "Do T" to avoid awaiting a dead 
                             *      org
                             */
#if defined(CEU_ORGS_NEWS) || defined(CEU_ORGS_AWAIT)
#endif
#ifdef CEU_ORGS_NEWS
    u8 isDyn: 1;            /* created w/ new or spawn? */
#endif
#ifdef CEU_ORGS_NEWS_POOL
    struct tceu_pool_orgs* pool;
#endif

#ifdef CEU_ORGS_AWAIT
    int ret;
#endif

#endif  /* CEU_ORGS */

    tceu_trl trls[0];       /* first trail */

} tceu_org;

/* TCEU_POOL_ORGS , TCEU_POOL_ADTS */

#if defined(CEU_ORGS_NEWS_POOL) || defined(CEU_ADTS_NEWS_POOL)
#ifndef _CEU_POOL_H
#define _CEU_POOL_H

#include "ceu_types.h"

/* TODO: all "int" here, should evaluate the correct unsigned type */

typedef struct {
    byte**  queue;
                    /* queue is in the next offset to distinguish dynamic(NULL)
                       from static pools(any-address) */
    int     size;
    int     free;
    int     index;
    int     unit;
    byte*   mem;
} tceu_pool;

#define CEU_POOL_DCL(name, type, size) \
    type*     name##_queue[size];      \
    type      name##_mem[size];        \
    tceu_pool name;

void ceu_pool_init (tceu_pool* pool, int size, int unit, byte** queue, byte* mem);
byte* ceu_pool_alloc (tceu_pool* pool);
void ceu_pool_free (tceu_pool* pool, byte* val);

#endif

/*
 * Ceu pool.c is based on Contiki and TinyOS pools:
 * https://github.com/contiki-os/contiki/blob/master/core/lib/memb.c
 * https://github.com/tinyos/tinyos-main/blob/master/tos/system/PoolP.nc
 */
#ifndef _CEU_POOL_C
#define _CEU_POOL_C

#include <stdlib.h>


void ceu_pool_init (tceu_pool* pool, int size, int unit, byte** queue, byte* mem)
{
    int i;
    pool->size  = size;
    pool->free  = size;
    pool->index = 0;
    pool->unit  = unit;
    pool->queue = queue;
    pool->mem   = mem;
    for (i=0; i<size; i++) {
        queue[i] = &mem[i*unit];
    }
}

byte* ceu_pool_alloc (tceu_pool* pool) {
    byte* ret;

    if (pool->free == 0) {
        return NULL;
    }

    pool->free--;
    ret = pool->queue[pool->index];
    pool->queue[pool->index++] = NULL;
    if (pool->index == pool->size) {
        pool->index = 0;
    }
    return ret;
}

void ceu_pool_free (tceu_pool* pool, byte* val) {
    int empty = pool->index + pool->free;
    if (empty >= pool->size) {
        empty -= pool->size;
    }
    pool->queue[empty] = val;
    pool->free++;
}

/*
int ceu_pool_inside (tceu_pool* pool, byte* val) {
    return ((byte*)val >= pool->mem)
        && ((byte*)val < pool->mem+(pool->size*pool->unit));
}
*/

#endif

#endif

#ifdef CEU_ORGS_NEWS
typedef struct tceu_pool_orgs {
    tceu_org* parent_org;
    tceu_ntrl parent_trl;
#ifdef CEU_ORGS_NEWS_POOL
    tceu_pool pool;
#endif
} tceu_pool_orgs;
#endif

#ifdef CEU_ADTS_NEWS
typedef struct {
    void* root;
#ifdef CEU_ADTS_NEWS_POOL
    void* pool;
#endif
} tceu_pool_adts;
#endif

/* TCEU_KILL */

#ifdef CEU_ORGS_OR_ADTS_AWAIT
typedef struct tceu_kill {
    void*     org_or_adt;
    int       ret;
} tceu_kill;
#endif

/* TCEU_LST */

#ifdef CEU_DEBUG
typedef struct tceu_lst {
#ifdef CEU_ORGS
    void*     org;
#endif
    tceu_trl* trl;
    tceu_nlbl lbl;
} tceu_lst;

#endif

/* TCEU_STK */

typedef struct tceu_stk {
    struct tceu_stk* up;
    tceu_org* org;
    tceu_ntrl trl1;
    tceu_ntrl trl2;
    jmp_buf   jmp;
} tceu_stk;

/* TCEU_JMP */

#ifdef CEU_STACK
typedef struct tceu_jmp {
#ifdef CEU_ORGS
    tceu_org* org;
#endif
    tceu_trl* trl;
    tceu_nlbl lbl;
} tceu_jmp;
#endif

/* TCEU_APP */

typedef struct tceu_app {
    /* global seqno: incremented on every reaction
     * awaiting trails matches only if trl->seqno < seqno,
     * i.e., previously awaiting the event
     */
    u8 seqno:          2;
#if defined(CEU_RET) || defined(CEU_OS)
    u8 isAlive:        1;
#endif
#ifdef CEU_ASYNCS
    u8 pendingAsyncs:  1;
#endif
#if defined(CEU_ORGS_NEWS_MALLOC) && defined(CEU_ORGS_AWAIT)
    u8 dont_emit_kill: 1;
#endif

#ifdef CEU_OS
    struct tceu_app* nxt;
#endif

#ifdef CEU_REENTRANT
    tceu_nstk stki;
#endif

#ifdef CEU_STACK
    tceu_stk* stk_bottom;
    tceu_jmp  stk_jmp;
#endif

#if defined(CEU_RET) || defined(CEU_ORGS_AWAIT)
    int ret;
#endif

#ifdef CEU_ORGS_NEWS_MALLOC
    tceu_org* tofree;
#endif

#ifdef CEU_WCLOCKS
    s32         wclk_late;
    s32         wclk_min_set;   /* used to set */
    s32         wclk_min_cmp;   /* used to compare */
                                /* cmp<-set every reaction */
#ifdef CEU_TIMEMACHINE
    s32         wclk_late_;
    s32         wclk_min_set_;
    s32         wclk_min_cmp_;
#endif
#endif

#ifndef CEU_OS
#ifdef CEU_DEBUG
    tceu_lst    lst; /* segfault printf */
#endif
#endif

#ifdef CEU_THREADS
    CEU_THREADS_MUTEX_T threads_mutex;
    /*CEU_THREADS_COND_T  threads_cond;*/
    u8                  threads_n;          /* number of running threads */
        /* TODO: u8? */
#endif
#if defined(CEU_LUA) || defined(CEU_OS)
#ifdef CEU_LUA
    lua_State*  lua;    /* TODO: move to data? */
#else
    void*       lua;
#endif
#endif

    void        (*code)  (struct tceu_app*,tceu_evt*,tceu_org*,tceu_trl*,tceu_stk*);
    void        (*init)  (struct tceu_app*);
#ifdef CEU_OS
    void*       (*calls) (struct tceu_app*,tceu_nevt,void*);
    void**      sys_vec;
    void*       addr;
#ifdef CEU_OS_LUAIFC
    char*       luaifc;
#endif
#endif
    tceu_org*   data;
} tceu_app;

#ifdef CEU_OS
typedef void (*tceu_init)   (tceu_app* app);
typedef void (*tceu_export) (uint* size, tceu_init** init
#ifdef CEU_OS_LUAIFC
                            , char** luaifc
#endif
);
#endif

/* TCEU_THREADS_P */

#ifdef CEU_THREADS
typedef struct {
    tceu_app* app;
    tceu_org* org;
    s8*       st; /* thread state:
                   * 0=ini (sync  spawns)
                   * 1=cpy (async copies)
                   * 2=lck (sync  locks)
                   * 3=end (sync/async terminates)
                   */
} tceu_threads_p;
#endif

#ifdef CEU_PSES
void ceu_pause (tceu_trl* trl, tceu_trl* trlF, int psed);
#endif

int  ceu_go_all    (tceu_app* app);

#ifdef CEU_WCLOCKS
int       ceu_sys_wclock (tceu_app* app, s32 dt, s32* set, s32* get);
#endif
void      ceu_sys_go     (tceu_app* app, int evt, void* evtp);

#ifdef CEU_OS

/* TCEU_LINK */

typedef struct tceu_lnk {
    tceu_app* src_app;
    tceu_nevt src_evt;
    tceu_app* dst_app;
    tceu_nevt dst_evt;
    struct tceu_lnk* nxt;
} tceu_lnk;

/* TCEU_QUEUE */

typedef struct {
    tceu_app* app;
    tceu_nevt evt;
#if CEU_QUEUE_MAX == 256
    s8        sz;
#else
    s16       sz;   /* signed because of fill */
#endif
    byte      buf[0];
} tceu_queue;

#ifdef CEU_ISR
typedef void(*tceu_isr_f)(tceu_app* app, tceu_org* org);
#endif

void ceu_os_init      (void);
int  ceu_os_scheduler (int(*dt)());
tceu_queue* ceu_sys_queue_nxt (void);
void        ceu_sys_queue_rem (void);

void      ceu_sys_assert    (int v);
void      ceu_sys_log       (int mode, long str);
void*     ceu_sys_realloc   (void* ptr, size_t size);
int       ceu_sys_req       (void);
tceu_app* ceu_sys_load      (void* addr);
#ifdef CEU_ISR
int       ceu_sys_isr       (int n, tceu_isr_f f, tceu_app* app);
#endif
void      ceu_sys_org_init  (tceu_org* org, int n, int lbl, int cls, int isDyn,
                             tceu_org* parent_org, tceu_ntrl parent_trl);
void      ceu_sys_start     (tceu_app* app);
int       ceu_sys_link      (tceu_app* src_app, tceu_nevt src_evt, tceu_app* dst_app, tceu_nevt dst_evt);
int       ceu_sys_unlink    (tceu_app* src_app, tceu_nevt src_evt, tceu_app* dst_app, tceu_nevt dst_evt);
int       ceu_sys_emit      (tceu_app* app, tceu_nevt evt, int sz, void* param);
void*     ceu_sys_call      (tceu_app* app, tceu_nevt evt, void* param);

enum {
    CEU_SYS_ASSERT = 0,
    CEU_SYS_LOG,
    CEU_SYS_REALLOC,
    CEU_SYS_REQ,
    CEU_SYS_LOAD,
#ifdef CEU_ISR
    CEU_SYS_ISR,
#endif
#ifdef CEU_CLEAR
    CEU_SYS_CLEAR,
#endif
    CEU_SYS_STACK_PUSH,
#ifdef CEU_ORGS
    CEU_SYS_STACK_CLEAR_ORG,
#endif
    CEU_SYS_ORG,
#ifdef CEU_ORGS
    CEU_SYS_ORG_TRAIL,
    CEU_SYS_ORG_SPAWN,
#endif
    CEU_SYS_START,
    CEU_SYS_LINK,
    CEU_SYS_UNLINK,
    CEU_SYS_EMIT,
    CEU_SYS_CALL,
#ifdef CEU_WCLOCKS
    CEU_SYS_WCLOCK,
#endif
    CEU_SYS_GO,
    CEU_SYS_MAX
};

/* SYS_VECTOR
 */
extern void* CEU_SYS_VEC[CEU_SYS_MAX];

#endif  /* CEU_OS */

#endif  /* _CEU_OS_H */

#ifndef _CEU_OS_H
#define _CEU_OS_H

#include <stddef.h>
#include "ceu_types.h"

#ifdef CEU_DEBUG
#include <assert.h>
#endif

#if defined(CEU_OS) && defined(__AVR)
#error Understand this again!
#include "Arduino.h"
#define CEU_ISR
#define CEU_ISR_ON()  interrupts()
#define CEU_ISR_OFF() noInterrupts()
#else
#define CEU_ISR_ON()
#define CEU_ISR_OFF()
#endif

/*
#if defined(CEU_CLEAR) || defined(CEU_INTS) || defined(CEU_ORGS) || defined(CEU_REENTRANT)
*/
#if 1
#include <setjmp.h>
#define CEU_STACK
#endif

#if defined(CEU_OS_KERNEL) || defined(CEU_OS_APP)
#define CEU_OS
#endif

#if defined(CEU_ORGS_NEWS) || defined(CEU_ADTS_NEWS)
#define CEU_NEWS
#endif
#if defined(CEU_ORGS_NEWS_POOL) || defined(CEU_ADTS_NEWS_POOL)
#define CEU_NEWS_POOL
#endif
#if defined(CEU_ORGS_AWAIT) || defined(CEU_ADTS_AWAIT)
#define CEU_ORGS_OR_ADTS_AWAIT
#endif

#ifdef CEU_OS

    /* TODO: all should be configurable */
    #define CEU_EXTS
    #define CEU_WCLOCKS
    #define CEU_ASYNCS
    #define CEU_RET
    #define CEU_CLEAR
    #define CEU_STACK
#ifndef __AVR
#endif
    #define CEU_INTS
    #define CEU_ORGS
    /*#define CEU_PSES*/ /* TODO: never tried */
    #define CEU_NEWS
    #define CEU_NEWS_POOL
    #define CEU_ORGS_NEWS
    #define CEU_ORGS_NEWS_MALLOC
    #define CEU_ORGS_NEWS_POOL
    #define CEU_ADTS_NEWS
    #define CEU_ADTS_NEWS_MALLOC
    #define CEU_ADTS_NEWS_POOL
    #define CEU_ORGS_AWAIT
    #define CEU_ADTS_AWAIT
    #define CEU_ORGS_OR_ADTS_AWAIT
/*
    #define CEU_THREADS
*/

#ifdef __AVR
    #define CEU_QUEUE_MAX 256
#else
    #define CEU_QUEUE_MAX 65536
#endif

    #define CEU_IN__NONE          0
    #define CEU_IN__ORG         255
    #define CEU_IN__ORG_PSED    254
    #define CEU_IN__CLEAR       253
    #define CEU_IN__ok_killed   252
    #define CEU_IN__INIT        251     /* HIGHER EXTERNAL */
    #define CEU_IN__ASYNC       250
    #define CEU_IN__THREAD      249
    #define CEU_IN__WCLOCK      248
    #define CEU_IN_OS_START     247
    #define CEU_IN_OS_STOP      246
    #define CEU_IN_OS_DT        245
    #define CEU_IN_OS_INTERRUPT 244
#ifdef CEU_TIMEMACHINE
    #define CEU_IN__WCLOCK_     243
    #define CEU_IN              243
#else
    #define CEU_IN              242
#endif

    #define CEU_IN_higher       CEU_IN__INIT  /* _INIT = HIGHER EXTERNAL */
    #define CEU_IN_lower        128     /* TODO: not checked from up and down */

    typedef s8 tceu_nlbl;   /* TODO: to small!! */

#endif /* CEU_OS */

#ifdef CEU_OS_APP

    #define ceu_out_log(mode,str) \
        ((__typeof__(ceu_sys_log)*)((_ceu_app)->sys_vec[CEU_SYS_LOG]))(mode,str)

    #define ceu_out_assert(v) \
        ((__typeof__(ceu_sys_assert)*)((_ceu_app)->sys_vec[CEU_SYS_ASSERT]))(v)

    #define ceu_out_assert_msg_ex(v,msg,file,line)       \
        {                                                \
            int __ceu_v = v;                             \
            if ((!(__ceu_v)) && ((msg)!=NULL)) {         \
                ceu_out_log(0, (long)"[");               \
                ceu_out_log(0, (long)(file));            \
                ceu_out_log(0, (long)":");               \
                ceu_out_log(2, (line));                  \
                ceu_out_log(0, (long)"] ");              \
                ceu_out_log(0, (long)"runtime error: "); \
                ceu_out_log(0, (long)(msg));             \
                ceu_out_log(0, (long)"\n");              \
            }                                            \
            ((__typeof__(ceu_sys_assert)*)((_ceu_app)->sys_vec[CEU_SYS_ASSERT]))(__ceu_v); \
        }
    #define ceu_out_assert_msg(v,msg) ceu_out_assert_msg_ex((v),(msg),__FILE__,__LINE__)

    #define ceu_out_realloc(ptr, size) \
        ((__typeof__(ceu_sys_realloc)*)((_ceu_app)->sys_vec[CEU_SYS_REALLOC]))(ptr,size)

    #define ceu_out_req() \
        ((__typeof__(ceu_sys_req)*)((_ceu_app)->sys_vec[CEU_SYS_REQ]))()

    #define ceu_out_load(addr) \
        ((__typeof__(ceu_sys_load)*)((_ceu_app)->sys_vec[CEU_SYS_LOAD]))(addr)

#ifdef CEU_ISR
    #define ceu_out_isr(n,f) \
        ((__typeof__(ceu_sys_isr)*)((_ceu_app)->sys_vec[CEU_SYS_ISR]))(n,f,_ceu_app)
#endif

    #define ceu_out_org_init(app,org,n,lbl,cls,isDyn,parent_org,parent_trl) \
        ((__typeof__(ceu_sys_org_init)*)((app)->sys_vec[CEU_SYS_ORG]))(org,n,lbl,cls,isDyn,parent_org,parent_trl)
    #define ceu_out_start(app) \
        ((__typeof__(ceu_sys_start)*)((_ceu_app)->sys_vec[CEU_SYS_START]))(app)
    #define ceu_out_link(app1,evt1 , app2,evt2) \
        ((__typeof__(ceu_sys_link)*)((_ceu_app)->sys_vec[CEU_SYS_LINK]))(app1,evt1,app2,evt2)

    #define ceu_out_emit(app,id,sz,buf) \
        ((__typeof__(ceu_sys_emit)*)((app)->sys_vec[CEU_SYS_EMIT]))(app,id,sz,buf)

    #define ceu_out_call(app,id,param) \
        ((__typeof__(ceu_sys_call)*)((app)->sys_vec[CEU_SYS_CALL]))(app,id,param)

#ifdef CEU_WCLOCKS
    #define ceu_out_wclock(app,dt,set,get) \
        ((__typeof__(ceu_sys_wclock)*)((app)->sys_vec[CEU_SYS_WCLOCK]))(app,dt,set,get)
#ifdef CEU_TIMEMACHINE
    #error TIMEMACHINE
#endif
#endif

    #define ceu_out_go(app,evt,evtp) \
        ((__typeof__(ceu_sys_go)*)((app)->sys_vec[CEU_SYS_GO]))(app,evt,evtp)

#else /* ! CEU_OS_APP (!CEU_OS||CEU_OS_KERNEL) */

    #ifndef ceu_out_assert
        #error "Missing definition for macro \"ceu_out_assert\"."
    #endif

    #ifndef ceu_out_log
        #error "Missing definition for macro \"ceu_out_log\"."
    #endif

    #define ceu_out_assert_msg_ex(v,msg,file,line)          \
        {                                                   \
            int __ceu_v = v;                                \
            if ((!(__ceu_v)) && ((msg)!=NULL)) {            \
                ceu_out_log(0, (long)"[");                  \
                ceu_out_log(0, (long)(file));               \
                ceu_out_log(0, (long)":");                  \
                ceu_out_log(2, line);                       \
                ceu_out_log(0, (long)"] ");                 \
                ceu_out_log(0, (long)"runtime error: ");    \
                ceu_out_log(0, (long)(msg));                \
                ceu_out_log(0, (long)"\n");                 \
            }                                               \
            ceu_out_assert(__ceu_v);                        \
        }
    #define ceu_out_assert_msg(v,msg) ceu_out_assert_msg_ex((v),(msg),__FILE__,__LINE__)

    #define ceu_out_realloc(ptr,size) \
            ceu_sys_realloc(ptr,size)
    #define ceu_out_req() \
            ceu_sys_req()
    #define ceu_out_org_init(app,org,n,lbl,cls,isDyn,parent_org,parent_trl) \
            ceu_sys_org_init(org,n,lbl,cls,isDyn,parent_org,parent_trl)

#ifdef CEU_WCLOCKS
    #define ceu_out_wclock(app,dt,set,get) \
            ceu_sys_wclock(app,dt,set,get)
#ifdef CEU_TIMEMACHINE
    #define ceu_out_wclock_(app,dt,set,get) \
            ceu_sys_wclock_(app,dt,set,get)
#endif
#endif
    #define ceu_out_go(app,evt,evtp) \
            ceu_sys_go(app,evt,evtp)
    #define ceu_out_go_stk(app,evt,evtp,stk) \
            ceu_sys_go_stk(app,evt,evtp,stk)

#endif /* ! CEU_OS_APP (!CEU_OS||CEU_OS_KERNEL) */

#define ceu_in_emit(app,id,n,buf) \
    ceu_out_go_stk(app,id,buf,&stk_)

#ifdef CEU_THREADS
/* TODO: app */
#include "ceu_threads.h"
#endif

#ifdef CEU_LUA
#include <stdio.h>      /* BUFSIZ */
#include <string.h>     /* strcpy */
#if defined(__ANDROID__) || defined(CEU_OS)
    #include "lua.h"
    #include "lauxlib.h"
    #include "lualib.h"
#else
    #include <lua5.1/lua.h>
    #include <lua5.1/lauxlib.h>
    #include <lua5.1/lualib.h>
#endif

#ifdef CEU_OS_APP
    #define ceu_luaL_newstate(set) { \
        set = ceu_out_call(_ceu_app, CEU_OUT_LUA_NEW, NULL); \
    }

    #define ceu_luaL_openlibs(l) { \
        lua_State* p = l;          \
        ceu_out_call(_ceu_app, CEU_OUT_LUAL_OPENLIBS, &p); \
    }

    #define ceu_lua_atpanic(l, f) {     \
    }

    #define ceu_luaL_loadstring(set, l, str) {  \
        tceu__lua_State___char_ p = { l, str }; \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUAL_LOADSTRING, &p); \
    }

    #define ceu_lua_pushnumber(l, v) {      \
        tceu__lua_State___int p = { l, v }; \
        ceu_out_call(_ceu_app, CEU_OUT_LUA_PUSHNUMBER, &p); \
    }

    #define ceu_lua_pushstring(l, v) {      \
        tceu__lua_State___char_ p = { l, v }; \
        ceu_out_call(_ceu_app, CEU_OUT_LUA_PUSHSTRING, &p); \
    }

    #define ceu_lua_pushlightuserdata(l, v) {   \
        tceu__lua_State___void_ p = { l, v };     \
        ceu_out_call(_ceu_app, CEU_OUT_LUA_PUSHLIGHTUSERDATA, &p); \
    }

    #define ceu_lua_pcall(set,l,nargs,nrets,err) {                  \
        tceu__lua_State___int__int__int p = { l, nargs, nrets, err }; \
        ceu_out_call(_ceu_app, CEU_OUT_LUA_PCALL, &p); \
    }

    #define ceu_lua_isnumber(set, l, idx) {     \
        tceu__lua_State___int p = { l, idx };   \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUA_ISNUMBER, &p); \
    }

    #define ceu_lua_tonumber(set, l, idx) {     \
        tceu__lua_State___int p = { l, idx };   \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUA_TONUMBER, &p); \
    }

    #define ceu_lua_isboolean(set, l, idx) {    \
        tceu__lua_State___int p = { l, idx };   \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUA_ISBOOLEAN, &p); \
    }

    #define ceu_lua_toboolean(set, l, idx) {    \
        tceu__lua_State___int p = { l, idx };   \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUA_TOBOOLEAN, &p); \
    }

    #define ceu_lua_pop(l, n) {             \
        tceu__lua_State___int p = { l, n }; \
        ceu_out_call(_ceu_app, CEU_OUT_LUA_POP, &p); \
    }

    #define ceu_lua_isstring(set, l, idx) {     \
        tceu__lua_State___int p = { l, idx };   \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUA_ISSTRING, &p); \
    }

    #define ceu_lua_tostring(set, l, idx) {     \
        tceu__lua_State___int p = { l, idx };   \
        set = ceu_out_call(_ceu_app, CEU_OUT_LUA_TOSTRING, &p); \
    }

    #define ceu_lua_islightuserdata(set, l, idx) {  \
        tceu__lua_State___int p = { l, idx };       \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUA_ISLIGHTUSERDATA, &p); \
    }

    #define ceu_lua_touserdata(set, l, idx) {   \
        tceu__lua_State___int p = { l, idx };   \
        set = ceu_out_call(_ceu_app, CEU_OUT_LUA_TOUSERDATA, &p); \
    }

    #define ceu_lua_error(l) {                          \
        lua_State** p = &l;                             \
        ceu_out_call(_ceu_app, CEU_OUT_LUA_ERROR, &p);  \
    }

    #define ceu_lua_objlen(set, l, idx) {                       \
        tceu__lua_State___int p = { l, idx };                   \
        set = ceu_out_call(_ceu_app, CEU_OUT_LUA_OBJLEN, &p);   \
    }

#else
    #define ceu_luaL_newstate(set)               set = luaL_newstate()
    #define ceu_luaL_openlibs(l)                 luaL_openlibs(l)
    #define ceu_lua_atpanic(l,f)                 lua_atpanic(l,f)
    #define ceu_luaL_loadstring(set,l,str)       set = luaL_loadstring(l,str)
    #define ceu_lua_pushnumber(l,v)              lua_pushnumber(l,v)
    #define ceu_lua_pushstring(l,v)              lua_pushstring(l,v)
    #define ceu_lua_pushlightuserdata(l,v)       lua_pushlightuserdata(l,v)
    #define ceu_lua_pcall(set,l,nargs,nrets,err) set = lua_pcall(l,nargs,nrets,err)
    #define ceu_lua_isnumber(set,l,idx)          set = lua_isnumber(l,idx)
    #define ceu_lua_tonumber(set,l,idx)          set = lua_tonumber(l,idx)
    #define ceu_lua_isboolean(set,l,idx)         set = lua_isboolean(l,idx)
    #define ceu_lua_toboolean(set,l,idx)         set = lua_toboolean(l,idx)
    #define ceu_lua_pop(l,n)                     lua_pop(l,n)
    #define ceu_lua_isstring(set,l,idx)          set = lua_isstring(l,idx)
    #define ceu_lua_tostring(set,l,idx)          set = lua_tostring(l,idx)
    #define ceu_lua_islightuserdata(set,l,idx)   set = lua_islightuserdata(l,idx)
    #define ceu_lua_touserdata(set,l,idx)        set = lua_touserdata(l,idx)
    #define ceu_lua_error(l)                     lua_error(l)
    #define ceu_lua_objlen(set,l,idx)            set = lua_objlen(l,idx)
#endif
#endif

typedef u8 tceu_nevt;   /* max number of events */
                        /* TODO: should "u8" be fixed? */

typedef u8 tceu_ntrl;   /* max number of trails per class */
                        /* TODO: should "u8" be fixed? */

#ifdef CEU_STACK
typedef u16 tceu_nstk;  /* max size of internal stack in bytes */
                        /* TODO: should "u16" be fixed? */
#endif

#ifdef __cplusplus
#define CEU_WCLOCK_INACTIVE 0x7fffffffL     /* TODO */
#else
#define CEU_WCLOCK_INACTIVE INT32_MAX
#endif
#define CEU_WCLOCK_EXPIRED (CEU_WCLOCK_INACTIVE-1)

/* TCEU_TRL */

struct tceu_org;
typedef union tceu_trl {
    tceu_nevt evt;

    /* normal await // IN__CLEAR */
    struct {                    /* TODO(ram): bitfields */
        tceu_nevt evt1;
        tceu_nlbl lbl;
        u8        seqno;        /* TODO(ram): 2 bits is enough */
#ifdef CEU_INTS                 /* R-9: size of trails for internal events */
#ifdef CEU_ORGS
        void*     evto;
#endif
#endif
    };

    /* IN__ORG */
#ifdef CEU_ORGS
    struct {                    /* TODO(ram): bad for alignment */
        tceu_nevt evt3;
        struct tceu_org* org;
    };
#endif

    /* _ok_killed */
#ifdef CEU_ORGS_OR_ADTS_AWAIT
    struct {
        tceu_nevt evt4;
        tceu_nlbl lbl4;
        void*     org_or_adt;
    };
#endif
} tceu_trl;

/* TCEU_EVT */

typedef struct tceu_evt {
    tceu_nevt id;
    void*     param;
#if defined(CEU_ORGS) && defined(CEU_INTS)
    void*     org;      /* emitting org */
#endif
} tceu_evt;

/* TCEU_ORG */

struct tceu_pool_orgs;
typedef struct tceu_org
{
#ifdef CEU_ORGS
    struct tceu_org* nxt; /* first field because of free list for orgs/adts */
    struct tceu_org* prv;
    struct tceu_org* parent_org;
    tceu_ntrl parent_trl;
#endif

#if defined(CEU_ORGS) || defined(CEU_OS)
    tceu_ntrl n;            /* number of trails (TODO(ram): opt, metadata) */
#endif

#ifdef CEU_ORGS

#ifdef CEU_IFCS
    tceu_ncls cls;          /* class id */
#endif
    u8 isAlive: 1;          /* Three purposes:
                             * - avoids double free
                             * - required by "watching o" to avoid awaiting a
                             *      dead org
                             * - required by "Do T" to avoid awaiting a dead 
                             *      org
                             */
#if defined(CEU_ORGS_NEWS) || defined(CEU_ORGS_AWAIT)
#endif
#ifdef CEU_ORGS_NEWS
    u8 isDyn: 1;            /* created w/ new or spawn? */
#endif
#ifdef CEU_ORGS_NEWS_POOL
    struct tceu_pool_orgs* pool;
#endif

#ifdef CEU_ORGS_AWAIT
    int ret;
#endif

#endif  /* CEU_ORGS */

    tceu_trl trls[0];       /* first trail */

} tceu_org;

/* TCEU_POOL_ORGS , TCEU_POOL_ADTS */

#if defined(CEU_ORGS_NEWS_POOL) || defined(CEU_ADTS_NEWS_POOL)
#ifndef _CEU_POOL_H
#define _CEU_POOL_H

#include "ceu_types.h"

/* TODO: all "int" here, should evaluate the correct unsigned type */

typedef struct {
    byte**  queue;
                    /* queue is in the next offset to distinguish dynamic(NULL)
                       from static pools(any-address) */
    int     size;
    int     free;
    int     index;
    int     unit;
    byte*   mem;
} tceu_pool;

#define CEU_POOL_DCL(name, type, size) \
    type*     name##_queue[size];      \
    type      name##_mem[size];        \
    tceu_pool name;

void ceu_pool_init (tceu_pool* pool, int size, int unit, byte** queue, byte* mem);
byte* ceu_pool_alloc (tceu_pool* pool);
void ceu_pool_free (tceu_pool* pool, byte* val);

#endif

/*
 * Ceu pool.c is based on Contiki and TinyOS pools:
 * https://github.com/contiki-os/contiki/blob/master/core/lib/memb.c
 * https://github.com/tinyos/tinyos-main/blob/master/tos/system/PoolP.nc
 */
#ifndef _CEU_POOL_C
#define _CEU_POOL_C

#include <stdlib.h>


void ceu_pool_init (tceu_pool* pool, int size, int unit, byte** queue, byte* mem)
{
    int i;
    pool->size  = size;
    pool->free  = size;
    pool->index = 0;
    pool->unit  = unit;
    pool->queue = queue;
    pool->mem   = mem;
    for (i=0; i<size; i++) {
        queue[i] = &mem[i*unit];
    }
}

byte* ceu_pool_alloc (tceu_pool* pool) {
    byte* ret;

    if (pool->free == 0) {
        return NULL;
    }

    pool->free--;
    ret = pool->queue[pool->index];
    pool->queue[pool->index++] = NULL;
    if (pool->index == pool->size) {
        pool->index = 0;
    }
    return ret;
}

void ceu_pool_free (tceu_pool* pool, byte* val) {
    int empty = pool->index + pool->free;
    if (empty >= pool->size) {
        empty -= pool->size;
    }
    pool->queue[empty] = val;
    pool->free++;
}

/*
int ceu_pool_inside (tceu_pool* pool, byte* val) {
    return ((byte*)val >= pool->mem)
        && ((byte*)val < pool->mem+(pool->size*pool->unit));
}
*/

#endif

#endif

#ifdef CEU_ORGS_NEWS
typedef struct tceu_pool_orgs {
    tceu_org* parent_org;
    tceu_ntrl parent_trl;
#ifdef CEU_ORGS_NEWS_POOL
    tceu_pool pool;
#endif
} tceu_pool_orgs;
#endif

#ifdef CEU_ADTS_NEWS
typedef struct {
    void* root;
#ifdef CEU_ADTS_NEWS_POOL
    void* pool;
#endif
} tceu_pool_adts;
#endif

/* TCEU_KILL */

#ifdef CEU_ORGS_OR_ADTS_AWAIT
typedef struct tceu_kill {
    void*     org_or_adt;
    int       ret;
} tceu_kill;
#endif

/* TCEU_LST */

#ifdef CEU_DEBUG
typedef struct tceu_lst {
#ifdef CEU_ORGS
    void*     org;
#endif
    tceu_trl* trl;
    tceu_nlbl lbl;
} tceu_lst;

#endif

/* TCEU_STK */

typedef struct tceu_stk {
    struct tceu_stk* up;
    tceu_org* org;
    tceu_ntrl trl1;
    tceu_ntrl trl2;
    jmp_buf   jmp;
} tceu_stk;

/* TCEU_JMP */

#ifdef CEU_STACK
typedef struct tceu_jmp {
#ifdef CEU_ORGS
    tceu_org* org;
#endif
    tceu_trl* trl;
    tceu_nlbl lbl;
} tceu_jmp;
#endif

/* TCEU_APP */

typedef struct tceu_app {
    /* global seqno: incremented on every reaction
     * awaiting trails matches only if trl->seqno < seqno,
     * i.e., previously awaiting the event
     */
    u8 seqno:          2;
#if defined(CEU_RET) || defined(CEU_OS)
    u8 isAlive:        1;
#endif
#ifdef CEU_ASYNCS
    u8 pendingAsyncs:  1;
#endif
#if defined(CEU_ORGS_NEWS_MALLOC) && defined(CEU_ORGS_AWAIT)
    u8 dont_emit_kill: 1;
#endif

#ifdef CEU_OS
    struct tceu_app* nxt;
#endif

#ifdef CEU_REENTRANT
    tceu_nstk stki;
#endif

#ifdef CEU_STACK
    tceu_stk* stk_bottom;
    tceu_jmp  stk_jmp;
#endif

#if defined(CEU_RET) || defined(CEU_ORGS_AWAIT)
    int ret;
#endif

#ifdef CEU_ORGS_NEWS_MALLOC
    tceu_org* tofree;
#endif

#ifdef CEU_WCLOCKS
    s32         wclk_late;
    s32         wclk_min_set;   /* used to set */
    s32         wclk_min_cmp;   /* used to compare */
                                /* cmp<-set every reaction */
#ifdef CEU_TIMEMACHINE
    s32         wclk_late_;
    s32         wclk_min_set_;
    s32         wclk_min_cmp_;
#endif
#endif

#ifndef CEU_OS
#ifdef CEU_DEBUG
    tceu_lst    lst; /* segfault printf */
#endif
#endif

#ifdef CEU_THREADS
    CEU_THREADS_MUTEX_T threads_mutex;
    /*CEU_THREADS_COND_T  threads_cond;*/
    u8                  threads_n;          /* number of running threads */
        /* TODO: u8? */
#endif
#if defined(CEU_LUA) || defined(CEU_OS)
#ifdef CEU_LUA
    lua_State*  lua;    /* TODO: move to data? */
#else
    void*       lua;
#endif
#endif

    void        (*code)  (struct tceu_app*,tceu_evt*,tceu_org*,tceu_trl*,tceu_stk*);
    void        (*init)  (struct tceu_app*);
#ifdef CEU_OS
    void*       (*calls) (struct tceu_app*,tceu_nevt,void*);
    void**      sys_vec;
    void*       addr;
#ifdef CEU_OS_LUAIFC
    char*       luaifc;
#endif
#endif
    tceu_org*   data;
} tceu_app;

#ifdef CEU_OS
typedef void (*tceu_init)   (tceu_app* app);
typedef void (*tceu_export) (uint* size, tceu_init** init
#ifdef CEU_OS_LUAIFC
                            , char** luaifc
#endif
);
#endif

/* TCEU_THREADS_P */

#ifdef CEU_THREADS
typedef struct {
    tceu_app* app;
    tceu_org* org;
    s8*       st; /* thread state:
                   * 0=ini (sync  spawns)
                   * 1=cpy (async copies)
                   * 2=lck (sync  locks)
                   * 3=end (sync/async terminates)
                   */
} tceu_threads_p;
#endif

#ifdef CEU_PSES
void ceu_pause (tceu_trl* trl, tceu_trl* trlF, int psed);
#endif

int  ceu_go_all    (tceu_app* app);

#ifdef CEU_WCLOCKS
int       ceu_sys_wclock (tceu_app* app, s32 dt, s32* set, s32* get);
#endif
void      ceu_sys_go     (tceu_app* app, int evt, void* evtp);

#ifdef CEU_OS

/* TCEU_LINK */

typedef struct tceu_lnk {
    tceu_app* src_app;
    tceu_nevt src_evt;
    tceu_app* dst_app;
    tceu_nevt dst_evt;
    struct tceu_lnk* nxt;
} tceu_lnk;

/* TCEU_QUEUE */

typedef struct {
    tceu_app* app;
    tceu_nevt evt;
#if CEU_QUEUE_MAX == 256
    s8        sz;
#else
    s16       sz;   /* signed because of fill */
#endif
    byte      buf[0];
} tceu_queue;

#ifdef CEU_ISR
typedef void(*tceu_isr_f)(tceu_app* app, tceu_org* org);
#endif

void ceu_os_init      (void);
int  ceu_os_scheduler (int(*dt)());
tceu_queue* ceu_sys_queue_nxt (void);
void        ceu_sys_queue_rem (void);

void      ceu_sys_assert    (int v);
void      ceu_sys_log       (int mode, long str);
void*     ceu_sys_realloc   (void* ptr, size_t size);
int       ceu_sys_req       (void);
tceu_app* ceu_sys_load      (void* addr);
#ifdef CEU_ISR
int       ceu_sys_isr       (int n, tceu_isr_f f, tceu_app* app);
#endif
void      ceu_sys_org_init  (tceu_org* org, int n, int lbl, int cls, int isDyn,
                             tceu_org* parent_org, tceu_ntrl parent_trl);
void      ceu_sys_start     (tceu_app* app);
int       ceu_sys_link      (tceu_app* src_app, tceu_nevt src_evt, tceu_app* dst_app, tceu_nevt dst_evt);
int       ceu_sys_unlink    (tceu_app* src_app, tceu_nevt src_evt, tceu_app* dst_app, tceu_nevt dst_evt);
int       ceu_sys_emit      (tceu_app* app, tceu_nevt evt, int sz, void* param);
void*     ceu_sys_call      (tceu_app* app, tceu_nevt evt, void* param);

enum {
    CEU_SYS_ASSERT = 0,
    CEU_SYS_LOG,
    CEU_SYS_REALLOC,
    CEU_SYS_REQ,
    CEU_SYS_LOAD,
#ifdef CEU_ISR
    CEU_SYS_ISR,
#endif
#ifdef CEU_CLEAR
    CEU_SYS_CLEAR,
#endif
    CEU_SYS_STACK_PUSH,
#ifdef CEU_ORGS
    CEU_SYS_STACK_CLEAR_ORG,
#endif
    CEU_SYS_ORG,
#ifdef CEU_ORGS
    CEU_SYS_ORG_TRAIL,
    CEU_SYS_ORG_SPAWN,
#endif
    CEU_SYS_START,
    CEU_SYS_LINK,
    CEU_SYS_UNLINK,
    CEU_SYS_EMIT,
    CEU_SYS_CALL,
#ifdef CEU_WCLOCKS
    CEU_SYS_WCLOCK,
#endif
    CEU_SYS_GO,
    CEU_SYS_MAX
};

/* SYS_VECTOR
 */
extern void* CEU_SYS_VEC[CEU_SYS_MAX];

#endif  /* CEU_OS */

#endif  /* _CEU_OS_H */


#ifdef __AVR
#ifdef CEU_OS
#error Understand this again!
#include <avr/pgmspace.h>
void* CEU_APP_ADDR = NULL;
#endif
#endif

#include <string.h>

#ifdef CEU_DEBUG
#include <stdio.h>      /* printf */
#endif

#if defined(CEU_DEBUG) || defined(CEU_NEWS) || defined(CEU_THREADS) || defined(CEU_OS_KERNEL)
void *realloc(void *ptr, size_t size);
#endif

#ifdef CEU_NEWS_POOL
#ifndef _CEU_POOL_H
#define _CEU_POOL_H

#include "ceu_types.h"

/* TODO: all "int" here, should evaluate the correct unsigned type */

typedef struct {
    byte**  queue;
                    /* queue is in the next offset to distinguish dynamic(NULL)
                       from static pools(any-address) */
    int     size;
    int     free;
    int     index;
    int     unit;
    byte*   mem;
} tceu_pool;

#define CEU_POOL_DCL(name, type, size) \
    type*     name##_queue[size];      \
    type      name##_mem[size];        \
    tceu_pool name;

void ceu_pool_init (tceu_pool* pool, int size, int unit, byte** queue, byte* mem);
byte* ceu_pool_alloc (tceu_pool* pool);
void ceu_pool_free (tceu_pool* pool, byte* val);

#endif

/*
 * Ceu pool.c is based on Contiki and TinyOS pools:
 * https://github.com/contiki-os/contiki/blob/master/core/lib/memb.c
 * https://github.com/tinyos/tinyos-main/blob/master/tos/system/PoolP.nc
 */
#ifndef _CEU_POOL_C
#define _CEU_POOL_C

#include <stdlib.h>


void ceu_pool_init (tceu_pool* pool, int size, int unit, byte** queue, byte* mem)
{
    int i;
    pool->size  = size;
    pool->free  = size;
    pool->index = 0;
    pool->unit  = unit;
    pool->queue = queue;
    pool->mem   = mem;
    for (i=0; i<size; i++) {
        queue[i] = &mem[i*unit];
    }
}

byte* ceu_pool_alloc (tceu_pool* pool) {
    byte* ret;

    if (pool->free == 0) {
        return NULL;
    }

    pool->free--;
    ret = pool->queue[pool->index];
    pool->queue[pool->index++] = NULL;
    if (pool->index == pool->size) {
        pool->index = 0;
    }
    return ret;
}

void ceu_pool_free (tceu_pool* pool, byte* val) {
    int empty = pool->index + pool->free;
    if (empty >= pool->size) {
        empty -= pool->size;
    }
    pool->queue[empty] = val;
    pool->free++;
}

/*
int ceu_pool_inside (tceu_pool* pool, byte* val) {
    return ((byte*)val >= pool->mem)
        && ((byte*)val < pool->mem+(pool->size*pool->unit));
}
*/

#endif

#endif

/*
 * pthread_t thread;
 * pthread_mutex_t mutex;
 * pthread_cond_t  cond;
 * pthread_self();
        Uint32 SDL_ThreadID(void);
 * pthread_create(&thread, NULL, f, &p);
        SDL_Thread *SDL_CreateThread(int (*fn)(void *), void *data);
 * pthread_mutex_lock(&mutex);
 * pthread_mutex_unlock(&mutex);
 * pthread_cond_wait(&cond, &mutex);
 * pthread_cond_signal(&cond);
*/

/**********************************************************************
 * "APPS" running on the OS do not need any of the below.
 **********************************************************************/

#ifndef CEU_OS_APP

#ifdef CEU_NEWS
#ifdef CEU_RUNTESTS
#define CEU_MAX_DYNS 100
static int _ceu_dyns_ = 0;  /* check if total of alloc/free match */
#endif
#endif

#if defined(CEU_NEWS) || defined(CEU_THREADS) || defined(CEU_OS_KERNEL) || defined(CEU_VECTOR_MALLOC)
void* ceu_sys_realloc (void* ptr, size_t size) {
#ifdef CEU_NEWS
#ifdef CEU_RUNTESTS
    if (size == 0) {
        if (ptr != NULL) {
            _ceu_dyns_--;
        }
    } else {
        if (_ceu_dyns_ >= CEU_MAX_DYNS) {
            return NULL;
        }
        _ceu_dyns_++;           /* assumes no malloc fails */
    }
#endif
#endif
    return realloc(ptr, size);
}
#endif

#ifdef CEU_VECTOR
#ifndef _CEU_VECTOR_H
#define _CEU_VECTOR_H

#ifndef _CEU_OS_H
#define _CEU_OS_H

#include <stddef.h>
#include "ceu_types.h"

#ifdef CEU_DEBUG
#include <assert.h>
#endif

#if defined(CEU_OS) && defined(__AVR)
#error Understand this again!
#include "Arduino.h"
#define CEU_ISR
#define CEU_ISR_ON()  interrupts()
#define CEU_ISR_OFF() noInterrupts()
#else
#define CEU_ISR_ON()
#define CEU_ISR_OFF()
#endif

/*
#if defined(CEU_CLEAR) || defined(CEU_INTS) || defined(CEU_ORGS) || defined(CEU_REENTRANT)
*/
#if 1
#include <setjmp.h>
#define CEU_STACK
#endif

#if defined(CEU_OS_KERNEL) || defined(CEU_OS_APP)
#define CEU_OS
#endif

#if defined(CEU_ORGS_NEWS) || defined(CEU_ADTS_NEWS)
#define CEU_NEWS
#endif
#if defined(CEU_ORGS_NEWS_POOL) || defined(CEU_ADTS_NEWS_POOL)
#define CEU_NEWS_POOL
#endif
#if defined(CEU_ORGS_AWAIT) || defined(CEU_ADTS_AWAIT)
#define CEU_ORGS_OR_ADTS_AWAIT
#endif

#ifdef CEU_OS

    /* TODO: all should be configurable */
    #define CEU_EXTS
    #define CEU_WCLOCKS
    #define CEU_ASYNCS
    #define CEU_RET
    #define CEU_CLEAR
    #define CEU_STACK
#ifndef __AVR
#endif
    #define CEU_INTS
    #define CEU_ORGS
    /*#define CEU_PSES*/ /* TODO: never tried */
    #define CEU_NEWS
    #define CEU_NEWS_POOL
    #define CEU_ORGS_NEWS
    #define CEU_ORGS_NEWS_MALLOC
    #define CEU_ORGS_NEWS_POOL
    #define CEU_ADTS_NEWS
    #define CEU_ADTS_NEWS_MALLOC
    #define CEU_ADTS_NEWS_POOL
    #define CEU_ORGS_AWAIT
    #define CEU_ADTS_AWAIT
    #define CEU_ORGS_OR_ADTS_AWAIT
/*
    #define CEU_THREADS
*/

#ifdef __AVR
    #define CEU_QUEUE_MAX 256
#else
    #define CEU_QUEUE_MAX 65536
#endif

    #define CEU_IN__NONE          0
    #define CEU_IN__ORG         255
    #define CEU_IN__ORG_PSED    254
    #define CEU_IN__CLEAR       253
    #define CEU_IN__ok_killed   252
    #define CEU_IN__INIT        251     /* HIGHER EXTERNAL */
    #define CEU_IN__ASYNC       250
    #define CEU_IN__THREAD      249
    #define CEU_IN__WCLOCK      248
    #define CEU_IN_OS_START     247
    #define CEU_IN_OS_STOP      246
    #define CEU_IN_OS_DT        245
    #define CEU_IN_OS_INTERRUPT 244
#ifdef CEU_TIMEMACHINE
    #define CEU_IN__WCLOCK_     243
    #define CEU_IN              243
#else
    #define CEU_IN              242
#endif

    #define CEU_IN_higher       CEU_IN__INIT  /* _INIT = HIGHER EXTERNAL */
    #define CEU_IN_lower        128     /* TODO: not checked from up and down */

    typedef s8 tceu_nlbl;   /* TODO: to small!! */

#endif /* CEU_OS */

#ifdef CEU_OS_APP

    #define ceu_out_log(mode,str) \
        ((__typeof__(ceu_sys_log)*)((_ceu_app)->sys_vec[CEU_SYS_LOG]))(mode,str)

    #define ceu_out_assert(v) \
        ((__typeof__(ceu_sys_assert)*)((_ceu_app)->sys_vec[CEU_SYS_ASSERT]))(v)

    #define ceu_out_assert_msg_ex(v,msg,file,line)       \
        {                                                \
            int __ceu_v = v;                             \
            if ((!(__ceu_v)) && ((msg)!=NULL)) {         \
                ceu_out_log(0, (long)"[");               \
                ceu_out_log(0, (long)(file));            \
                ceu_out_log(0, (long)":");               \
                ceu_out_log(2, (line));                  \
                ceu_out_log(0, (long)"] ");              \
                ceu_out_log(0, (long)"runtime error: "); \
                ceu_out_log(0, (long)(msg));             \
                ceu_out_log(0, (long)"\n");              \
            }                                            \
            ((__typeof__(ceu_sys_assert)*)((_ceu_app)->sys_vec[CEU_SYS_ASSERT]))(__ceu_v); \
        }
    #define ceu_out_assert_msg(v,msg) ceu_out_assert_msg_ex((v),(msg),__FILE__,__LINE__)

    #define ceu_out_realloc(ptr, size) \
        ((__typeof__(ceu_sys_realloc)*)((_ceu_app)->sys_vec[CEU_SYS_REALLOC]))(ptr,size)

    #define ceu_out_req() \
        ((__typeof__(ceu_sys_req)*)((_ceu_app)->sys_vec[CEU_SYS_REQ]))()

    #define ceu_out_load(addr) \
        ((__typeof__(ceu_sys_load)*)((_ceu_app)->sys_vec[CEU_SYS_LOAD]))(addr)

#ifdef CEU_ISR
    #define ceu_out_isr(n,f) \
        ((__typeof__(ceu_sys_isr)*)((_ceu_app)->sys_vec[CEU_SYS_ISR]))(n,f,_ceu_app)
#endif

    #define ceu_out_org_init(app,org,n,lbl,cls,isDyn,parent_org,parent_trl) \
        ((__typeof__(ceu_sys_org_init)*)((app)->sys_vec[CEU_SYS_ORG]))(org,n,lbl,cls,isDyn,parent_org,parent_trl)
    #define ceu_out_start(app) \
        ((__typeof__(ceu_sys_start)*)((_ceu_app)->sys_vec[CEU_SYS_START]))(app)
    #define ceu_out_link(app1,evt1 , app2,evt2) \
        ((__typeof__(ceu_sys_link)*)((_ceu_app)->sys_vec[CEU_SYS_LINK]))(app1,evt1,app2,evt2)

    #define ceu_out_emit(app,id,sz,buf) \
        ((__typeof__(ceu_sys_emit)*)((app)->sys_vec[CEU_SYS_EMIT]))(app,id,sz,buf)

    #define ceu_out_call(app,id,param) \
        ((__typeof__(ceu_sys_call)*)((app)->sys_vec[CEU_SYS_CALL]))(app,id,param)

#ifdef CEU_WCLOCKS
    #define ceu_out_wclock(app,dt,set,get) \
        ((__typeof__(ceu_sys_wclock)*)((app)->sys_vec[CEU_SYS_WCLOCK]))(app,dt,set,get)
#ifdef CEU_TIMEMACHINE
    #error TIMEMACHINE
#endif
#endif

    #define ceu_out_go(app,evt,evtp) \
        ((__typeof__(ceu_sys_go)*)((app)->sys_vec[CEU_SYS_GO]))(app,evt,evtp)

#else /* ! CEU_OS_APP (!CEU_OS||CEU_OS_KERNEL) */

    #ifndef ceu_out_assert
        #error "Missing definition for macro \"ceu_out_assert\"."
    #endif

    #ifndef ceu_out_log
        #error "Missing definition for macro \"ceu_out_log\"."
    #endif

    #define ceu_out_assert_msg_ex(v,msg,file,line)          \
        {                                                   \
            int __ceu_v = v;                                \
            if ((!(__ceu_v)) && ((msg)!=NULL)) {            \
                ceu_out_log(0, (long)"[");                  \
                ceu_out_log(0, (long)(file));               \
                ceu_out_log(0, (long)":");                  \
                ceu_out_log(2, line);                       \
                ceu_out_log(0, (long)"] ");                 \
                ceu_out_log(0, (long)"runtime error: ");    \
                ceu_out_log(0, (long)(msg));                \
                ceu_out_log(0, (long)"\n");                 \
            }                                               \
            ceu_out_assert(__ceu_v);                        \
        }
    #define ceu_out_assert_msg(v,msg) ceu_out_assert_msg_ex((v),(msg),__FILE__,__LINE__)

    #define ceu_out_realloc(ptr,size) \
            ceu_sys_realloc(ptr,size)
    #define ceu_out_req() \
            ceu_sys_req()
    #define ceu_out_org_init(app,org,n,lbl,cls,isDyn,parent_org,parent_trl) \
            ceu_sys_org_init(org,n,lbl,cls,isDyn,parent_org,parent_trl)

#ifdef CEU_WCLOCKS
    #define ceu_out_wclock(app,dt,set,get) \
            ceu_sys_wclock(app,dt,set,get)
#ifdef CEU_TIMEMACHINE
    #define ceu_out_wclock_(app,dt,set,get) \
            ceu_sys_wclock_(app,dt,set,get)
#endif
#endif
    #define ceu_out_go(app,evt,evtp) \
            ceu_sys_go(app,evt,evtp)
    #define ceu_out_go_stk(app,evt,evtp,stk) \
            ceu_sys_go_stk(app,evt,evtp,stk)

#endif /* ! CEU_OS_APP (!CEU_OS||CEU_OS_KERNEL) */

#define ceu_in_emit(app,id,n,buf) \
    ceu_out_go_stk(app,id,buf,&stk_)

#ifdef CEU_THREADS
/* TODO: app */
#include "ceu_threads.h"
#endif

#ifdef CEU_LUA
#include <stdio.h>      /* BUFSIZ */
#include <string.h>     /* strcpy */
#if defined(__ANDROID__) || defined(CEU_OS)
    #include "lua.h"
    #include "lauxlib.h"
    #include "lualib.h"
#else
    #include <lua5.1/lua.h>
    #include <lua5.1/lauxlib.h>
    #include <lua5.1/lualib.h>
#endif

#ifdef CEU_OS_APP
    #define ceu_luaL_newstate(set) { \
        set = ceu_out_call(_ceu_app, CEU_OUT_LUA_NEW, NULL); \
    }

    #define ceu_luaL_openlibs(l) { \
        lua_State* p = l;          \
        ceu_out_call(_ceu_app, CEU_OUT_LUAL_OPENLIBS, &p); \
    }

    #define ceu_lua_atpanic(l, f) {     \
    }

    #define ceu_luaL_loadstring(set, l, str) {  \
        tceu__lua_State___char_ p = { l, str }; \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUAL_LOADSTRING, &p); \
    }

    #define ceu_lua_pushnumber(l, v) {      \
        tceu__lua_State___int p = { l, v }; \
        ceu_out_call(_ceu_app, CEU_OUT_LUA_PUSHNUMBER, &p); \
    }

    #define ceu_lua_pushstring(l, v) {      \
        tceu__lua_State___char_ p = { l, v }; \
        ceu_out_call(_ceu_app, CEU_OUT_LUA_PUSHSTRING, &p); \
    }

    #define ceu_lua_pushlightuserdata(l, v) {   \
        tceu__lua_State___void_ p = { l, v };     \
        ceu_out_call(_ceu_app, CEU_OUT_LUA_PUSHLIGHTUSERDATA, &p); \
    }

    #define ceu_lua_pcall(set,l,nargs,nrets,err) {                  \
        tceu__lua_State___int__int__int p = { l, nargs, nrets, err }; \
        ceu_out_call(_ceu_app, CEU_OUT_LUA_PCALL, &p); \
    }

    #define ceu_lua_isnumber(set, l, idx) {     \
        tceu__lua_State___int p = { l, idx };   \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUA_ISNUMBER, &p); \
    }

    #define ceu_lua_tonumber(set, l, idx) {     \
        tceu__lua_State___int p = { l, idx };   \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUA_TONUMBER, &p); \
    }

    #define ceu_lua_isboolean(set, l, idx) {    \
        tceu__lua_State___int p = { l, idx };   \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUA_ISBOOLEAN, &p); \
    }

    #define ceu_lua_toboolean(set, l, idx) {    \
        tceu__lua_State___int p = { l, idx };   \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUA_TOBOOLEAN, &p); \
    }

    #define ceu_lua_pop(l, n) {             \
        tceu__lua_State___int p = { l, n }; \
        ceu_out_call(_ceu_app, CEU_OUT_LUA_POP, &p); \
    }

    #define ceu_lua_isstring(set, l, idx) {     \
        tceu__lua_State___int p = { l, idx };   \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUA_ISSTRING, &p); \
    }

    #define ceu_lua_tostring(set, l, idx) {     \
        tceu__lua_State___int p = { l, idx };   \
        set = ceu_out_call(_ceu_app, CEU_OUT_LUA_TOSTRING, &p); \
    }

    #define ceu_lua_islightuserdata(set, l, idx) {  \
        tceu__lua_State___int p = { l, idx };       \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUA_ISLIGHTUSERDATA, &p); \
    }

    #define ceu_lua_touserdata(set, l, idx) {   \
        tceu__lua_State___int p = { l, idx };   \
        set = ceu_out_call(_ceu_app, CEU_OUT_LUA_TOUSERDATA, &p); \
    }

    #define ceu_lua_error(l) {                          \
        lua_State** p = &l;                             \
        ceu_out_call(_ceu_app, CEU_OUT_LUA_ERROR, &p);  \
    }

    #define ceu_lua_objlen(set, l, idx) {                       \
        tceu__lua_State___int p = { l, idx };                   \
        set = ceu_out_call(_ceu_app, CEU_OUT_LUA_OBJLEN, &p);   \
    }

#else
    #define ceu_luaL_newstate(set)               set = luaL_newstate()
    #define ceu_luaL_openlibs(l)                 luaL_openlibs(l)
    #define ceu_lua_atpanic(l,f)                 lua_atpanic(l,f)
    #define ceu_luaL_loadstring(set,l,str)       set = luaL_loadstring(l,str)
    #define ceu_lua_pushnumber(l,v)              lua_pushnumber(l,v)
    #define ceu_lua_pushstring(l,v)              lua_pushstring(l,v)
    #define ceu_lua_pushlightuserdata(l,v)       lua_pushlightuserdata(l,v)
    #define ceu_lua_pcall(set,l,nargs,nrets,err) set = lua_pcall(l,nargs,nrets,err)
    #define ceu_lua_isnumber(set,l,idx)          set = lua_isnumber(l,idx)
    #define ceu_lua_tonumber(set,l,idx)          set = lua_tonumber(l,idx)
    #define ceu_lua_isboolean(set,l,idx)         set = lua_isboolean(l,idx)
    #define ceu_lua_toboolean(set,l,idx)         set = lua_toboolean(l,idx)
    #define ceu_lua_pop(l,n)                     lua_pop(l,n)
    #define ceu_lua_isstring(set,l,idx)          set = lua_isstring(l,idx)
    #define ceu_lua_tostring(set,l,idx)          set = lua_tostring(l,idx)
    #define ceu_lua_islightuserdata(set,l,idx)   set = lua_islightuserdata(l,idx)
    #define ceu_lua_touserdata(set,l,idx)        set = lua_touserdata(l,idx)
    #define ceu_lua_error(l)                     lua_error(l)
    #define ceu_lua_objlen(set,l,idx)            set = lua_objlen(l,idx)
#endif
#endif

typedef u8 tceu_nevt;   /* max number of events */
                        /* TODO: should "u8" be fixed? */

typedef u8 tceu_ntrl;   /* max number of trails per class */
                        /* TODO: should "u8" be fixed? */

#ifdef CEU_STACK
typedef u16 tceu_nstk;  /* max size of internal stack in bytes */
                        /* TODO: should "u16" be fixed? */
#endif

#ifdef __cplusplus
#define CEU_WCLOCK_INACTIVE 0x7fffffffL     /* TODO */
#else
#define CEU_WCLOCK_INACTIVE INT32_MAX
#endif
#define CEU_WCLOCK_EXPIRED (CEU_WCLOCK_INACTIVE-1)

/* TCEU_TRL */

struct tceu_org;
typedef union tceu_trl {
    tceu_nevt evt;

    /* normal await // IN__CLEAR */
    struct {                    /* TODO(ram): bitfields */
        tceu_nevt evt1;
        tceu_nlbl lbl;
        u8        seqno;        /* TODO(ram): 2 bits is enough */
#ifdef CEU_INTS                 /* R-9: size of trails for internal events */
#ifdef CEU_ORGS
        void*     evto;
#endif
#endif
    };

    /* IN__ORG */
#ifdef CEU_ORGS
    struct {                    /* TODO(ram): bad for alignment */
        tceu_nevt evt3;
        struct tceu_org* org;
    };
#endif

    /* _ok_killed */
#ifdef CEU_ORGS_OR_ADTS_AWAIT
    struct {
        tceu_nevt evt4;
        tceu_nlbl lbl4;
        void*     org_or_adt;
    };
#endif
} tceu_trl;

/* TCEU_EVT */

typedef struct tceu_evt {
    tceu_nevt id;
    void*     param;
#if defined(CEU_ORGS) && defined(CEU_INTS)
    void*     org;      /* emitting org */
#endif
} tceu_evt;

/* TCEU_ORG */

struct tceu_pool_orgs;
typedef struct tceu_org
{
#ifdef CEU_ORGS
    struct tceu_org* nxt; /* first field because of free list for orgs/adts */
    struct tceu_org* prv;
    struct tceu_org* parent_org;
    tceu_ntrl parent_trl;
#endif

#if defined(CEU_ORGS) || defined(CEU_OS)
    tceu_ntrl n;            /* number of trails (TODO(ram): opt, metadata) */
#endif

#ifdef CEU_ORGS

#ifdef CEU_IFCS
    tceu_ncls cls;          /* class id */
#endif
    u8 isAlive: 1;          /* Three purposes:
                             * - avoids double free
                             * - required by "watching o" to avoid awaiting a
                             *      dead org
                             * - required by "Do T" to avoid awaiting a dead 
                             *      org
                             */
#if defined(CEU_ORGS_NEWS) || defined(CEU_ORGS_AWAIT)
#endif
#ifdef CEU_ORGS_NEWS
    u8 isDyn: 1;            /* created w/ new or spawn? */
#endif
#ifdef CEU_ORGS_NEWS_POOL
    struct tceu_pool_orgs* pool;
#endif

#ifdef CEU_ORGS_AWAIT
    int ret;
#endif

#endif  /* CEU_ORGS */

    tceu_trl trls[0];       /* first trail */

} tceu_org;

/* TCEU_POOL_ORGS , TCEU_POOL_ADTS */

#if defined(CEU_ORGS_NEWS_POOL) || defined(CEU_ADTS_NEWS_POOL)
#include "ceu_pool.h"
#endif

#ifdef CEU_ORGS_NEWS
typedef struct tceu_pool_orgs {
    tceu_org* parent_org;
    tceu_ntrl parent_trl;
#ifdef CEU_ORGS_NEWS_POOL
    tceu_pool pool;
#endif
} tceu_pool_orgs;
#endif

#ifdef CEU_ADTS_NEWS
typedef struct {
    void* root;
#ifdef CEU_ADTS_NEWS_POOL
    void* pool;
#endif
} tceu_pool_adts;
#endif

/* TCEU_KILL */

#ifdef CEU_ORGS_OR_ADTS_AWAIT
typedef struct tceu_kill {
    void*     org_or_adt;
    int       ret;
} tceu_kill;
#endif

/* TCEU_LST */

#ifdef CEU_DEBUG
typedef struct tceu_lst {
#ifdef CEU_ORGS
    void*     org;
#endif
    tceu_trl* trl;
    tceu_nlbl lbl;
} tceu_lst;

#endif

/* TCEU_STK */

typedef struct tceu_stk {
    struct tceu_stk* up;
    tceu_org* org;
    tceu_ntrl trl1;
    tceu_ntrl trl2;
    jmp_buf   jmp;
} tceu_stk;

/* TCEU_JMP */

#ifdef CEU_STACK
typedef struct tceu_jmp {
#ifdef CEU_ORGS
    tceu_org* org;
#endif
    tceu_trl* trl;
    tceu_nlbl lbl;
} tceu_jmp;
#endif

/* TCEU_APP */

typedef struct tceu_app {
    /* global seqno: incremented on every reaction
     * awaiting trails matches only if trl->seqno < seqno,
     * i.e., previously awaiting the event
     */
    u8 seqno:          2;
#if defined(CEU_RET) || defined(CEU_OS)
    u8 isAlive:        1;
#endif
#ifdef CEU_ASYNCS
    u8 pendingAsyncs:  1;
#endif
#if defined(CEU_ORGS_NEWS_MALLOC) && defined(CEU_ORGS_AWAIT)
    u8 dont_emit_kill: 1;
#endif

#ifdef CEU_OS
    struct tceu_app* nxt;
#endif

#ifdef CEU_REENTRANT
    tceu_nstk stki;
#endif

#ifdef CEU_STACK
    tceu_stk* stk_bottom;
    tceu_jmp  stk_jmp;
#endif

#if defined(CEU_RET) || defined(CEU_ORGS_AWAIT)
    int ret;
#endif

#ifdef CEU_ORGS_NEWS_MALLOC
    tceu_org* tofree;
#endif

#ifdef CEU_WCLOCKS
    s32         wclk_late;
    s32         wclk_min_set;   /* used to set */
    s32         wclk_min_cmp;   /* used to compare */
                                /* cmp<-set every reaction */
#ifdef CEU_TIMEMACHINE
    s32         wclk_late_;
    s32         wclk_min_set_;
    s32         wclk_min_cmp_;
#endif
#endif

#ifndef CEU_OS
#ifdef CEU_DEBUG
    tceu_lst    lst; /* segfault printf */
#endif
#endif

#ifdef CEU_THREADS
    CEU_THREADS_MUTEX_T threads_mutex;
    /*CEU_THREADS_COND_T  threads_cond;*/
    u8                  threads_n;          /* number of running threads */
        /* TODO: u8? */
#endif
#if defined(CEU_LUA) || defined(CEU_OS)
#ifdef CEU_LUA
    lua_State*  lua;    /* TODO: move to data? */
#else
    void*       lua;
#endif
#endif

    void        (*code)  (struct tceu_app*,tceu_evt*,tceu_org*,tceu_trl*,tceu_stk*);
    void        (*init)  (struct tceu_app*);
#ifdef CEU_OS
    void*       (*calls) (struct tceu_app*,tceu_nevt,void*);
    void**      sys_vec;
    void*       addr;
#ifdef CEU_OS_LUAIFC
    char*       luaifc;
#endif
#endif
    tceu_org*   data;
} tceu_app;

#ifdef CEU_OS
typedef void (*tceu_init)   (tceu_app* app);
typedef void (*tceu_export) (uint* size, tceu_init** init
#ifdef CEU_OS_LUAIFC
                            , char** luaifc
#endif
);
#endif

/* TCEU_THREADS_P */

#ifdef CEU_THREADS
typedef struct {
    tceu_app* app;
    tceu_org* org;
    s8*       st; /* thread state:
                   * 0=ini (sync  spawns)
                   * 1=cpy (async copies)
                   * 2=lck (sync  locks)
                   * 3=end (sync/async terminates)
                   */
} tceu_threads_p;
#endif

#ifdef CEU_PSES
void ceu_pause (tceu_trl* trl, tceu_trl* trlF, int psed);
#endif

int  ceu_go_all    (tceu_app* app);

#ifdef CEU_WCLOCKS
int       ceu_sys_wclock (tceu_app* app, s32 dt, s32* set, s32* get);
#endif
void      ceu_sys_go     (tceu_app* app, int evt, void* evtp);

#ifdef CEU_OS

/* TCEU_LINK */

typedef struct tceu_lnk {
    tceu_app* src_app;
    tceu_nevt src_evt;
    tceu_app* dst_app;
    tceu_nevt dst_evt;
    struct tceu_lnk* nxt;
} tceu_lnk;

/* TCEU_QUEUE */

typedef struct {
    tceu_app* app;
    tceu_nevt evt;
#if CEU_QUEUE_MAX == 256
    s8        sz;
#else
    s16       sz;   /* signed because of fill */
#endif
    byte      buf[0];
} tceu_queue;

#ifdef CEU_ISR
typedef void(*tceu_isr_f)(tceu_app* app, tceu_org* org);
#endif

void ceu_os_init      (void);
int  ceu_os_scheduler (int(*dt)());
tceu_queue* ceu_sys_queue_nxt (void);
void        ceu_sys_queue_rem (void);

void      ceu_sys_assert    (int v);
void      ceu_sys_log       (int mode, long str);
void*     ceu_sys_realloc   (void* ptr, size_t size);
int       ceu_sys_req       (void);
tceu_app* ceu_sys_load      (void* addr);
#ifdef CEU_ISR
int       ceu_sys_isr       (int n, tceu_isr_f f, tceu_app* app);
#endif
void      ceu_sys_org_init  (tceu_org* org, int n, int lbl, int cls, int isDyn,
                             tceu_org* parent_org, tceu_ntrl parent_trl);
void      ceu_sys_start     (tceu_app* app);
int       ceu_sys_link      (tceu_app* src_app, tceu_nevt src_evt, tceu_app* dst_app, tceu_nevt dst_evt);
int       ceu_sys_unlink    (tceu_app* src_app, tceu_nevt src_evt, tceu_app* dst_app, tceu_nevt dst_evt);
int       ceu_sys_emit      (tceu_app* app, tceu_nevt evt, int sz, void* param);
void*     ceu_sys_call      (tceu_app* app, tceu_nevt evt, void* param);

enum {
    CEU_SYS_ASSERT = 0,
    CEU_SYS_LOG,
    CEU_SYS_REALLOC,
    CEU_SYS_REQ,
    CEU_SYS_LOAD,
#ifdef CEU_ISR
    CEU_SYS_ISR,
#endif
#ifdef CEU_CLEAR
    CEU_SYS_CLEAR,
#endif
    CEU_SYS_STACK_PUSH,
#ifdef CEU_ORGS
    CEU_SYS_STACK_CLEAR_ORG,
#endif
    CEU_SYS_ORG,
#ifdef CEU_ORGS
    CEU_SYS_ORG_TRAIL,
    CEU_SYS_ORG_SPAWN,
#endif
    CEU_SYS_START,
    CEU_SYS_LINK,
    CEU_SYS_UNLINK,
    CEU_SYS_EMIT,
    CEU_SYS_CALL,
#ifdef CEU_WCLOCKS
    CEU_SYS_WCLOCK,
#endif
    CEU_SYS_GO,
    CEU_SYS_MAX
};

/* SYS_VECTOR
 */
extern void* CEU_SYS_VEC[CEU_SYS_MAX];

#endif  /* CEU_OS */

#endif  /* _CEU_OS_H */


typedef struct {
    int   max;
    int   nxt;
    int   unit;
    byte* mem;
} tceu_vector;

#define CEU_VECTOR_DCL(name, type, max)  \
    type        name##_mem[max+1];       \
    tceu_vector name;
                /* [STRING] max+1: extra space for '\0' */

#define ceu_vector_getlen(vec) ((vec)->nxt)
#define ceu_vector_getmax(vec) ((vec)->max > 0 ? (vec)->max : 0)

void  ceu_vector_init   (tceu_vector* vector, int max, int unit, byte* mem);
int   ceu_vector_setlen (tceu_vector* vector, int len);
byte* ceu_vector_geti   (tceu_vector* vector, int idx);
int   ceu_vector_seti   (tceu_vector* vector, int idx, byte* v);
int   ceu_vector_push   (tceu_vector* vector, byte* v);
int   ceu_vector_concat (tceu_vector* to, tceu_vector* fr);
int   ceu_vector_concat_buffer (tceu_vector* to, const char* fr, int n);
char* ceu_vector_tochar (tceu_vector* vector);

#if 0
byte* ceu_pool_alloc (tceu_pool* pool);
void ceu_pool_free (tceu_pool* pool, byte* val);
#endif
#endif

#ifndef _CEU_VECTOR_C
#define _CEU_VECTOR_C



void ceu_vector_init (tceu_vector* vector, int max, int unit, byte* mem) {
    vector->nxt  = 0;
    vector->max  = max;
    vector->unit = unit;
    vector->mem  = (max==0) ? NULL : mem;

    /* [STRING] */
    if (vector->mem != NULL) {
        vector->mem[0] = '\0';
    }
}

#ifdef CEU_VECTOR_MALLOC
static void* ceu_vector_resize (tceu_vector* vector, int n) {
    ceu_out_assert_msg(vector->max <= 0, "bug found");

    if (n == 0) {
        /* free */
        if (vector->mem != NULL) {
            vector->max = 0;
            ceu_out_realloc(vector->mem, 0);
            vector->mem = NULL;
        }
    } else {
        /* TODO: Java does the same? */
        n = (n*3/2) + 1;
        if (n < 10) {
            n = 10;
        }

        vector->max = -n;
        vector->mem = (byte*)ceu_out_realloc(vector->mem, n*vector->unit + 1);
                                                        /* [STRING] +1 */
    }

    return vector->mem;
}
#endif

/* can only decrease vector->nxt */
int ceu_vector_setlen (tceu_vector* vector, int nxt) {
    if (nxt > vector->nxt) {
        return 0;
    } else {
        vector->nxt = nxt;

        /* [STRING] */
        if (vector->mem != NULL) {
            vector->mem[nxt*vector->unit] = '\0';
        }

#ifdef CEU_VECTOR_MALLOC
        /* shrink malloc'ed arrays */
        if (vector->max <= 0) {
            if (ceu_vector_resize(vector,nxt)==NULL && nxt>0) {
                return 0;
            }
        }
#endif

        return 1;
    }
}

/* can only get within idx < vector->nxt */
byte* ceu_vector_geti (tceu_vector* vector, int idx) {
    if (idx >= vector->nxt) {
        return NULL;
    } else {
        return &vector->mem[idx*vector->unit];
    }
}

/* can only set within idx < vector->nxt */
int ceu_vector_seti (tceu_vector* vector, int idx, byte* v) {
    if (idx >= vector->nxt) {
        return 0;
    } else {
        memcpy(&vector->mem[idx*vector->unit], v, vector->unit);
        return 1;
    }
}

/* can only push within nxt < vector->max */
int ceu_vector_push (tceu_vector* vector, byte* v) {
#ifdef CEU_VECTOR_MALLOC
    /* grow malloc'ed arrays */
    if (vector->max <= 0) {
        while (vector->nxt >= -vector->max) {
            if (ceu_vector_resize(vector,vector->nxt+1) == NULL) {
                return 0;
            }
        }
    }
#endif
#ifdef CEU_VECTOR_MALLOC
#ifdef CEU_VECTOR_POOL
    else
#endif
#endif
#ifdef CEU_VECTOR_POOL
    if (vector->nxt >= vector->max) {
        return 0;
    }
#endif

    memcpy(&vector->mem[vector->nxt*vector->unit], v, vector->unit);
    vector->nxt++;
    vector->mem[vector->nxt*vector->unit] = '\0';    /* [STRING] */
    return 1;
}

int ceu_vector_concat (tceu_vector* to, tceu_vector* fr) {
    if (to == fr) {
        return 0;
    } else {
        /* TODO: memcpy */
        int i;
        for (i=0; i<fr->nxt; i++) {
            byte* v = ceu_vector_geti(fr, i);
            if (v == NULL) {
                return 0;
            } else if (!ceu_vector_push(to,v)) {
                return 0;
            }
        }
    }
    return 1;
}

int ceu_vector_concat_buffer (tceu_vector* to, const char* fr, int n) {
    /* TODO: memcpy */
    int i;
    for (i=0; i<n; i++) {
        if (!ceu_vector_push(to,(byte*)&fr[i])) {
            return 0;
        }
    }
    return 1;
}

char* ceu_vector_tochar (tceu_vector* vector) {
    if (vector->mem == NULL) {
        return "";
    } else {
        return (char*)vector->mem;
    }
}

#endif

byte* ceu_vector_geti_ex (tceu_vector* vector, int idx, char* file, int line) {
    byte* ret = ceu_vector_geti(vector, idx);
    ceu_out_assert_msg_ex(ret!=NULL, "access out of bounds", file, line);
    return ret;
}
#endif

int CEU_REQS = 0;
int ceu_sys_req (void) {
    CEU_REQS++;
    return CEU_REQS;
}

void ceu_sys_go_ex (tceu_app* app, tceu_evt* evt,
                    tceu_stk* stk,
                    tceu_org* org, tceu_trl* trl, void* stop);

/**********************************************************************/

void ceu_sys_org_init (tceu_org* org, int n, int lbl,
                       int cls, int isDyn,
                       tceu_org* parent_org, tceu_ntrl parent_trl)
{
    /* { evt=0, seqno=0, lbl=0 } for all trails */
    memset(&org->trls, 0, n*sizeof(tceu_trl));
    org->trls[0].lbl = lbl;

#if defined(CEU_ORGS) || defined(CEU_OS_KERNEL)
    org->n  = n;
#endif

#ifdef CEU_ORGS

#ifdef CEU_IFCS
    org->cls = cls;
#endif

#if defined(CEU_ORGS_NEWS) || defined(CEU_ORGS_AWAIT)
    org->isAlive = 1;
#endif

#ifdef CEU_ORGS_NEWS
    org->isDyn = isDyn;
#endif

    org->parent_org = parent_org;
    org->parent_trl = parent_trl;
    org->nxt = NULL;
    if (parent_org != NULL) {
        tceu_trl* trl = &parent_org->trls[parent_trl];
        if (trl == NULL) {
            org->prv = NULL; /* main class */
        } else {
            /* re-link */
            if (trl->org == NULL) {
                trl->org = org;
            } else {
                tceu_org* last = trl->org->prv;
                last->nxt = org;
                org->prv = last;
            }
            trl->org->prv = org;
        }
    }

#ifdef CEU_ORGS_AWAIT
    org->ret = 0;   /* TODO: still required? */
#endif

#endif  /* CEU_ORGS */
}

#ifdef CEU_ORGS

static void ceu_sys_org_free (tceu_app* app, tceu_org* org)
{
    /* TODO: try to not depend on this and remove this field */
    if (org->isAlive) {
        org->isAlive = 0;
    } else {
        return;
    }

    /* re-link PRV <-> NXT */
    /* relink also static orgs for efficiency */
    tceu_trl* trl = &org->parent_org->trls[org->parent_trl];
    if (trl->org == org) {
        trl->org = org->nxt;        /* subst 1st org */
    } else {
        org->prv->nxt = org->nxt;
    }
    if (org->nxt == NULL) {
        if (trl->org != NULL) {
            trl->org->prv = org->prv;   /* subst lst org */
        }
    } else {
        org->nxt->prv = org->prv;
    }

#ifdef CEU_ORGS_NEWS
    /* free */
    if (org->isDyn) {
#if    defined(CEU_ORGS_NEWS_POOL) && !defined(CEU_ORGS_NEWS_MALLOC)
        ceu_pool_free(&org->pool->pool, (byte*)org);
#elif  defined(CEU_ORGS_NEWS_POOL) &&  defined(CEU_ORGS_NEWS_MALLOC)
        if (org->pool->pool.queue == NULL) {
            org->nxt = app->tofree;
            app->tofree = org;
        } else {
            ceu_pool_free(&org->pool->pool, (byte*)org);
        }
#elif !defined(CEU_ORGS_NEWS_POOL) &&  defined(CEU_ORGS_NEWS_MALLOC)
        org->nxt = app->tofree;
        app->tofree = org;
#endif
    }
#endif
}

#endif  /* CEU_ORGS */

/**********************************************************************/

#ifdef CEU_STACK
void ceu_stack_dump (tceu_app* app) {
    tceu_stk* cur;
    printf(">>> STACK DUMP:\n");
    for (cur=app->stk_bottom; cur!=NULL; cur=cur->up) {
        printf("\t[%p] up=%p org=%p trls=[%d,%d]\n",
            cur, cur->up, cur->org, cur->trl1, cur->trl2);
    }
}
#endif

/*
 * Checks if "me" is cleared due to a clear in "clr_org".
 * ;
 */
#ifdef CEU_ORGS
static int ceu_org_is_cleared (void* me, void* clr_org,
                               tceu_ntrl clr_t1, tceu_ntrl clr_t2)
{
    tceu_org* cur_org;
    for (cur_org=me; cur_org!=NULL; cur_org=cur_org->parent_org) {
        if (cur_org->parent_org == clr_org) {
            if (cur_org->parent_trl>=clr_t1 && cur_org->parent_trl<=clr_t2) {
                return 1;
            }
        }
    }
    return 0;
}
#endif

/*
 * Trails [t1,t2] of "org" are dyeing.
 * Traverse the stack to see if a pending call is enclosed by this range.
 * If so, the whole stack has to unwind and continue from what we pass in 
 * lbl_or_org.
 */
void ceu_longjmp (tceu_app* app, tceu_org* org,
                  tceu_ntrl t1, tceu_ntrl t2) {
    tceu_stk* cur;
    tceu_stk* prv;
    for (prv=app->stk_bottom, cur=app->stk_bottom->up;
         cur != NULL;
         prv=cur,cur=cur->up)
    {
#ifdef CEU_ORGS
        if (cur->org != org) {
            if (ceu_org_is_cleared(cur->org, org, t1, t2)) {
                prv->up = NULL;
                longjmp(cur->jmp, 1);
            }
        }
        else
#endif
        {
            if (t1<=cur->trl1 && cur->trl2<=t2) {
                prv->up = NULL;
                longjmp(cur->jmp, 1);
            }
        }
    }
}

/**********************************************************************/

#ifdef CEU_WCLOCKS

/* TODO: wclk_min_cmp to be global among all apps */

int ceu_sys_wclock (tceu_app* app, s32 dt, s32* set, s32* get)
{
    s32 t;          /* expiring time of track to calculate */
    int ret = 0;    /* if track expired (only for "get") */

    /* SET */
    if (set != NULL) {
        t = dt - app->wclk_late;
        *set = t;

    /* CHECK */
    } else {
        t = *get;
        if ((t > app->wclk_min_cmp) || (t > dt)) {
            *get -= dt;    /* don't expire yet */
            t = *get;
        } else {
            ret = 1;    /* single "true" return */
        }
    }

    /* didn't awake, but can be the smallest wclk */
    if ( (!ret) && (app->wclk_min_set > t) ) {
        app->wclk_min_set = t;
#ifdef ceu_out_wclock_set
        ceu_out_wclock_set(t);
#endif
    }

    return ret;
}

#ifdef CEU_TIMEMACHINE
/* TODO: unify with above */
int ceu_sys_wclock_ (tceu_app* app, s32 dt, s32* set, s32* get)
{
    s32 t;          /* expiring time of track to calculate */
    int ret = 0;    /* if track expired (only for "get") */

    /* SET */
    if (set != NULL) {
        t = dt - app->wclk_late;
        *set = t;

    /* CHECK */
    } else {
        t = *get;
        if ((t > app->wclk_min_cmp_) || (t > dt)) {
            *get -= dt;    /* don't expire yet */
            t = *get;
        } else {
            ret = 1;    /* single "true" return */
        }
    }

    /* didn't awake, but can be the smallest wclk */
    if ( (!ret) && (app->wclk_min_set_ > t) ) {
        app->wclk_min_set_ = t;
#ifdef ceu_out_wclock_set
        ceu_out_wclock_set(t);
#endif
    }

    return ret;
}
#endif

#endif

/**********************************************************************/

#ifdef CEU_LUA
int ceu_lua_atpanic_f (lua_State* lua) {
#ifdef CEU_DEBUG
    char msg[255] = "LUA_ATPANIC: ";
    strncat(msg, lua_tostring(lua,-1), 100);
    strncat(msg, "\n", 1);
    ceu_out_assert_msg(0, msg);
/*
*/
#else
    ceu_out_assert_msg(0, "bug found");
#endif
    return 0;
}
#endif

/**********************************************************************/

#ifdef CEU_PSES
#ifdef CEU_OS_KERNEL
#error Not implemented!
#endif
void ceu_pause (tceu_trl* trl, tceu_trl* trlF, int psed) {
    do {
        if (psed) {
            if (trl->evt == CEU_IN__ORG) {
                trl->evt = CEU_IN__ORG_PSED;
            }
        } else {
            if (trl->evt == CEU_IN__ORG_PSED) {
                trl->evt = CEU_IN__ORG;
            }
        }
        if ( trl->evt == CEU_IN__ORG
        ||   trl->evt == CEU_IN__ORG_PSED ) {
            trl += 2;       /* jump [fst|lst] */
        }
    } while (++trl <= trlF);

#ifdef ceu_out_wclock_set
    if (!psed) {
        ceu_out_wclock_set(0);  /* TODO: recalculate MIN clock */
                                /*       between trl => trlF   */
    }
#endif
#ifdef CEU_TIMEMACHINE
#ifdef ceu_out_wclock_set_
    if (!psed) {
        ceu_out_wclock_set_(0);  /* TODO: recalculate MIN clock */
                                 /*       between trl => trlF   */
    }
#endif
#endif
}
#endif

/**********************************************************************/

#ifdef CEU_OS_KERNEL
u8 CEU_GC = 0;  /* execute __ceu_os_gc() when "true" */
#endif

#ifdef CEU_DEBUG_TRAILS
static int spc = -1;
#define SPC(n) { int i; for(i=0; i<(spc+n)*4; i++) printf(" "); };

void ceu_sys_go_ex_dbg (tceu_app* app, tceu_evt* evt,
                        tceu_stk* stk,
                        tceu_org* org, tceu_trl* trl, void* stop);
void ceu_sys_go_ex (tceu_app* app, tceu_evt* evt,
                    tceu_stk* stk,
                    tceu_org* org, tceu_trl* trl, void* stop) {
    spc++;
    SPC(0); printf(">>> GO-EX\n");
    SPC(0); printf("evt: %d\n", evt->id);
    #ifdef CEU_ORGS
    SPC(0); printf("org: %p\n", org);
    SPC(2); printf("[%p]=>[%p]\n", &org->trls[0],
                                   &org->trls[org->n]);
    #endif

    ceu_sys_go_ex_dbg(app,evt,stk,org,trl,stop);

    SPC(0); printf("<<< GO-EX\n");
    spc--;
}
#endif

#ifdef CEU_DEBUG_TRAILS
void ceu_sys_go_ex_dbg (tceu_app* app, tceu_evt* evt,
                        tceu_stk* stk,
                        tceu_org* org, tceu_trl* trl, void* stop)
#else
void ceu_sys_go_ex (tceu_app* app, tceu_evt* evt,
                    tceu_stk* stk,
                    tceu_org* org, tceu_trl* trl, void* stop)
    /* TODO: now all arguments are required in all configurations */
#endif
{
    for (;; trl++)
    {
#ifdef CEU_CLEAR
        if (trl == stop) {
            return;    /* bounded trail traversal */
        }
#endif

        /* STK_ORG has been traversed to the end? */
        if (trl ==
            &org->trls[
#if defined(CEU_ORGS) || defined(CEU_OS_KERNEL)
                org->n
#else
                CEU_NTRAILS
#endif
            ])
        {
#ifdef CEU_ORGS
            /* clearing the whole org (stop==NULL)? */
            if (org!=app->data && evt->id==CEU_IN__CLEAR && stop==NULL) {
                /* yes, relink and put it in the free list */
                ceu_sys_org_free(app, org);
#ifdef CEU_ORGS_AWAIT
#ifdef CEU_ORGS_NEWS_MALLOC
                if (!app->dont_emit_kill)
#endif
                {
                    /* signal ok_killed */
                    {
                        tceu_kill ps = { org, org->ret };
                        tceu_evt evt_;
                                 evt_.id = CEU_IN__ok_killed;
                                 evt_.param = &ps;
                        ceu_sys_go_ex(app, &evt_,
                                      stk,
                                      app->data, &app->data->trls[0], NULL);
                    }
                }
#endif
            }
#endif
            break;
        }

#ifdef CEU_DEBUG_TRAILS
SPC(1); printf("trl: %p\n", trl);
/*SPC(2); printf("seqno: %d\n", trl->seqno);*/
SPC(2); printf("evt: %d\n", trl->evt);
SPC(2); printf("lbl: %d\n", trl->lbl);
#endif

        /* continue traversing current org */

        /* jump into linked orgs */
#ifdef CEU_ORGS
        if ( (trl->evt == CEU_IN__ORG)
#ifdef CEU_PSES
          || (trl->evt==CEU_IN__ORG_PSED && evt->id==CEU_IN__CLEAR)
#endif
           )
        {
            tceu_org* cur = trl->org;

            if (evt->id == CEU_IN__CLEAR) {
                trl->evt = CEU_IN__NONE;    /* TODO: dup w/ below */
            }

            /* traverse all children */

            if (cur != NULL) {
                tceu_stk stk_ = { NULL, org, cur->parent_trl, cur->parent_trl, {} };

#if defined(CEU_ORGS_NEWS_MALLOC) && defined(CEU_ORGS_AWAIT)
                /* In the presence of ok_killed events, we cannot simply
                 * interrupt children traversal during a IN__CLEAR, because it 
                 * might lead to memory leaks if not all children are travesed.
                 */
                tceu_org* nxt;
                int has_aborted = 0;            /* normal execution */
                if (setjmp(stk_.jmp) != 0) {
                    has_aborted = 1;            /* detected abortion */
                    if (evt->id==CEU_IN__CLEAR) {
                        cur = nxt;              /* continue from nxt */
                        app->dont_emit_kill = 1;/* but stop emitting ok_killed */
                    } else {
                        cur = NULL;             /* safe to abort now */
                    }
                }
#else
                if (setjmp(stk_.jmp) != 0) {
                    app->stk_jmp.trl->lbl = app->stk_jmp.lbl;
                    app->code(app, evt, app->stk_jmp.org, app->stk_jmp.trl, stk);
                    return;
                }
#endif

                /* SETJMP: traversing children
                 * A child might emit a global event that awakes a par/or 
                 * enclosing the parent organism with the call point.
                 */
                stk->up = &stk_;
                while (cur != NULL) {
#if defined(CEU_ORGS_NEWS_MALLOC) && defined(CEU_ORGS_AWAIT)
#else
                    tceu_org*
#endif
                    nxt = cur->nxt;
                        /* save "nxt" before the call, which might kill "cur"
                         * and reset "nxt" for the freelist */
                    ceu_sys_go_ex(app, evt,
                                  &stk_,
                                  cur, &cur->trls[0], NULL);
                    cur = nxt;
                }
                stk->up = NULL;

#if defined(CEU_ORGS_NEWS_MALLOC) && defined(CEU_ORGS_AWAIT)
                if (has_aborted) {
                    app->dont_emit_kill = 0;
                    app->stk_jmp.trl->lbl = app->stk_jmp.lbl;
                    app->code(app, evt, app->stk_jmp.org, app->stk_jmp.trl, stk);
                    return;
                }
#endif
            }
            continue;   /* next trail after handling children */
        }
#endif /* CEU_ORGS */

        /* EXECUTE THIS TRAIL */
#if 0
printf("%d==%d && %d!=%d && %d>=%d\n",
        trl->evt, evt->id,
        trl->seqno, app->seqno,
        evt->id, CEU_IN_lower
);
if (evt->param != NULL) {
    printf("trl->org_or_adt=%p // param=%p\n", trl->org_or_adt,
                 ((tceu_kill*)evt->param)->org_or_adt);
}
#endif

        if (
#ifdef CEU_CLEAR
            /* if IN__CLEAR and "finalize" clause */
            (evt->id==CEU_IN__CLEAR && trl->evt==CEU_IN__CLEAR)
        ||
#endif
#ifdef CEU_ORGS_OR_ADTS_AWAIT
            /* if */
            (evt->id==CEU_IN__ok_killed && trl->evt==CEU_IN__ok_killed &&
                (trl->org_or_adt == NULL || /* for option ptrs, init'd w/ NULL  */
                 trl->org_or_adt == ((tceu_kill*)evt->param)->org_or_adt))
        ||
#endif
            /* if evt->id matches awaiting trail */
            (trl->evt==evt->id && trl->seqno!=app->seqno
#ifdef CEU_ORGS_OR_ADTS_AWAIT
                && (evt->id != CEU_IN__ok_killed)
                    /* TODO: simplify */
#endif
#ifdef CEU_INTS
#ifdef CEU_ORGS
                && (evt->id>=CEU_IN_lower || evt->org==trl->evto)
#endif
#endif
            )
           )
        {
#if defined(CEU_OS_KERNEL) && defined(__AVR)
            CEU_APP_ADDR = app->addr;
#endif

            /*** CODE ***/
            trl->evt = CEU_IN__NONE;    /* TODO: dup w/ above */
            app->code(app, evt, org, trl, stk);

#if defined(CEU_OS_KERNEL) && defined(__AVR)
            CEU_APP_ADDR = 0;
#endif

#if defined(CEU_OS_KERNEL) || defined(CEU_LUA)
            if (!app->isAlive) {
#ifdef CEU_OS_KERNEL
                CEU_GC = 1;
#endif
#ifdef CEU_LUA
                lua_close(app->lua);
#endif
            }
#endif
        }

        /* DON'T EXECUTE THIS TRAIL */
        else
        {
#ifdef CEU_DEBUG_TRAILS
SPC(1); printf("<<< NO\n");
#endif
#ifdef CEU_CLEAR
            if (evt->id==CEU_IN__CLEAR) {
                trl->evt = CEU_IN__NONE;    /* TODO: dup w/ above */
            }
#endif
        }

        /* NEXT TRAIL */

        if (trl->evt<=CEU_IN_higher && trl->seqno!=app->seqno) {
            trl->seqno = app->seqno-1;   /* keeps the gap tight */
        }
    }
}

void ceu_sys_go_stk (tceu_app* app, int evt, void* evtp, tceu_stk* stk) {
    app->seqno++;
#ifdef CEU_DEBUG_TRAILS
    printf("===> [%d] %d\n", evt, app->seqno);
#endif

    switch (evt) {
#ifdef CEU_ASYNCS
        case CEU_IN__ASYNC:
            app->pendingAsyncs = 0;
            break;
#endif
#ifdef CEU_WCLOCKS
        case CEU_IN__WCLOCK:
            app->wclk_min_cmp = app->wclk_min_set;      /* swap "cmp" to last "set" */
            app->wclk_min_set = CEU_WCLOCK_INACTIVE;    /* new "set" resets to inactive */
            if (app->wclk_min_cmp <= *((s32*)evtp)) {
                app->wclk_late = *((s32*)evtp) - app->wclk_min_cmp;
            }
            break;
#ifdef CEU_TIMEMACHINE
        case CEU_IN__WCLOCK_:
            app->wclk_min_cmp_ = app->wclk_min_set_;
            app->wclk_min_set_ = CEU_WCLOCK_INACTIVE;
            if (app->wclk_min_cmp_ <= *((s32*)evtp)) {
                app->wclk_late_ = *((s32*)evtp) - app->wclk_min_cmp_;
            }
            break;
#endif
#endif
    }

    {
        tceu_evt evt_;
                 evt_.id = evt;
                 evt_.param = &evtp;
        ceu_sys_go_ex(app, &evt_,
                      stk,
                      app->data, &app->data->trls[0], NULL);
    }

#ifdef CEU_WCLOCKS
    if (evt==CEU_IN__WCLOCK) {
#ifdef ceu_out_wclock_set
        /* no new sets, signal inactive */
        if (app->wclk_min_set == CEU_WCLOCK_INACTIVE) {
            ceu_out_wclock_set(CEU_WCLOCK_INACTIVE);
        }
#endif
        app->wclk_late = 0;
    }
#ifdef CEU_TIMEMACHINE
    if (evt==CEU_IN__WCLOCK_) {
#ifdef ceu_out_wclock_set
        if (app->wclk_min_set_ == CEU_WCLOCK_INACTIVE) {
            ceu_out_wclock_set(CEU_WCLOCK_INACTIVE);
        }
#endif
        app->wclk_late_ = 0;
    }
#endif
#endif

#ifdef CEU_ORGS_NEWS_MALLOC
    while (app->tofree != NULL) {
        tceu_org* nxt = app->tofree->nxt;
        ceu_sys_realloc(app->tofree, 0);
        app->tofree = nxt;
    }
#endif
}

void ceu_sys_go (tceu_app* app, int evt, void* evtp)
{
    tceu_stk stk_ = { NULL, NULL, 0, 0, {} };
    app->stk_bottom = &stk_;
    ceu_sys_go_stk(app, evt, evtp, &stk_);
}

int ceu_go_all (tceu_app* app)
{
    /* All code run atomically:
     * - the program is always locked as a whole
     * -    thread spawns will unlock => re-lock
     * - but program will still run to completion
     */
    app->init(app);     /* calls CEU_THREADS_MUTEX_LOCK() */

#ifdef CEU_IN_OS_START
#if defined(CEU_RET) || defined(CEU_OS_KERNEL)
    if (app->isAlive)
#endif
    {
        ceu_sys_go(app, CEU_IN_OS_START, NULL);
    }
#endif

#ifdef CEU_ASYNCS
    while(
#if defined(CEU_RET) || defined(CEU_OS_KERNEL)
            app->isAlive &&
#endif
            (
#ifdef CEU_THREADS
                app->threads_n>0 ||
#endif
                app->pendingAsyncs
            ) )
    {
        ceu_sys_go(app, CEU_IN__ASYNC, NULL);
#ifdef CEU_THREADS
        CEU_THREADS_MUTEX_UNLOCK(&app->threads_mutex);
        /* allow threads to also execute */
        CEU_THREADS_MUTEX_LOCK(&app->threads_mutex);
#endif
    }
#endif

#ifdef CEU_THREADS
    CEU_THREADS_MUTEX_UNLOCK(&app->threads_mutex);
#endif

#ifdef CEU_NEWS
#ifdef CEU_RUNTESTS
    ceu_out_assert_msg(_ceu_dyns_ == 0, "memory leak");
#endif
#endif

#ifdef CEU_RET
    return app->ret;
#else
    return 0;
#endif
}

/**********************************************************************
 * Only the OS kernel needs any of the below.
 **********************************************************************/

#ifdef CEU_OS_KERNEL

/*
 * SYS_VECTOR:
 */
void* CEU_SYS_VEC[CEU_SYS_MAX] __attribute__((used)) = {
    (void*) &ceu_out_assert,
    (void*) &ceu_out_log,
    (void*) &ceu_sys_realloc,
    (void*) &ceu_sys_req,
    (void*) &ceu_sys_load,
#ifdef CEU_ISR
    (void*) &ceu_sys_isr,
#endif
    (void*) &ceu_sys_org_init,
    (void*) &ceu_sys_start,
    (void*) &ceu_sys_link,
    (void*) &ceu_sys_unlink,
    (void*) &ceu_sys_emit,
    (void*) &ceu_sys_call,
#ifdef CEU_WCLOCKS
    (void*) &ceu_sys_wclock,
#endif
    (void*) &ceu_sys_go
};

/*****************************************************************************
 * QUEUE
 * - 256 avoids doing modulo operations
 * - n: number of entries
 * - 0: next position to consume
 * - i: next position to enqueue
 */
#if CEU_QUEUE_MAX == 256
    byte QUEUE[CEU_QUEUE_MAX] = {0};    /* {0} avoids .bss */
    int  QUEUE_tot = 0;
    u8   QUEUE_get = 0;
    u8   QUEUE_put = 0;
#else
    byte QUEUE[CEU_QUEUE_MAX] = {0};    /* {0} avoids .bss */
    int  QUEUE_tot = 0;
    u16  QUEUE_get = 0;
    u16  QUEUE_put = 0;
#endif

tceu_queue* ceu_sys_queue_get (void) {
    tceu_queue* ret;
    CEU_ISR_OFF();
    if (QUEUE_tot == 0) {
        ret = NULL;
    } else {
#ifdef CEU_DEBUG
        ceu_sys_assert(QUEUE_tot > 0);
#endif
        ret = (tceu_queue*) &QUEUE[QUEUE_get];
    }
    CEU_ISR_ON();
    return ret;
}

int ceu_sys_queue_put (tceu_app* app, tceu_nevt evt, int sz, byte* buf) {
    CEU_ISR_OFF();

    int n = sizeof(tceu_queue) + sz;

    if (QUEUE_tot+n > CEU_QUEUE_MAX) {
        return 0;   /* TODO: add event FULL when CEU_QUEUE_MAX-1 */
    }

    /* An event+data must be continuous in the QUEUE. */
    if (QUEUE_put+n+sizeof(tceu_queue)>=CEU_QUEUE_MAX && evt!=CEU_IN__NONE) {
        int fill = CEU_QUEUE_MAX - QUEUE_put - sizeof(tceu_queue);
        /*_ceu_sys_emit(app, CEU_IN__NONE, param, fill, NULL);*/
        tceu_queue* qu = (tceu_queue*) &QUEUE[QUEUE_put];
        qu->app = app;
        qu->evt = CEU_IN__NONE;
        qu->sz  = fill;
        QUEUE_put += sizeof(tceu_queue) + fill;
        QUEUE_tot += sizeof(tceu_queue) + fill;
    }

    {
        tceu_queue* qu = (tceu_queue*) &QUEUE[QUEUE_put];
        qu->app = app;
        qu->evt = evt;
        qu->sz  = sz;
        memcpy(qu->buf, buf, sz);
    }
    QUEUE_put += n;
    QUEUE_tot += n;

    CEU_ISR_ON();
    return 1;
}

void ceu_sys_queue_rem (void) {
    CEU_ISR_OFF();
    tceu_queue* qu = (tceu_queue*) &QUEUE[QUEUE_get];
    QUEUE_tot -= sizeof(tceu_queue) + qu->sz;
    QUEUE_get += sizeof(tceu_queue) + qu->sz;
    CEU_ISR_ON();
}

/*****************************************************************************/

static tceu_app* CEU_APPS = NULL;
static tceu_lnk* CEU_LNKS = NULL;

#ifdef CEU_RET
    int ok  = 0;
    int ret = 0;
#endif

/* TODO: remove this indirection */
int ceu_sys_emit (tceu_app* app, tceu_nevt evt, int sz, void* param) {
    return ceu_sys_queue_put(app, evt, sz, param);
}

void* ceu_sys_call (tceu_app* app, tceu_nevt evt, void* param) {
    tceu_lnk* lnk = CEU_LNKS;
    for (; lnk; lnk=lnk->nxt)
    {
        if (app!=lnk->src_app || evt!=lnk->src_evt) {
            continue;
        }
#if defined(CEU_OS_KERNEL) && defined(__AVR)
        void* __old = CEU_APP_ADDR; /* must remember to resume after call */
        CEU_APP_ADDR = lnk->dst_app->addr;
#endif
        void* ret = lnk->dst_app->calls(lnk->dst_app, lnk->dst_evt, param);
#if defined(CEU_OS_KERNEL) && defined(__AVR)
        CEU_APP_ADDR = __old;
#endif
        return ret;
    }
/* TODO: error? */
    return NULL;
}

static void _ceu_sys_unlink (tceu_lnk* lnk) {
    /* remove as head */
    if (CEU_LNKS == lnk) {
        CEU_LNKS = lnk->nxt;
/* TODO: prv */
    /* remove in the middle */
    } else {
        tceu_lnk* cur = CEU_LNKS;
        while (cur->nxt!=NULL && cur->nxt!=lnk) {
			cur = cur->nxt;
        }
        if (cur->nxt != NULL) {
            cur->nxt = lnk->nxt;
        }
	}

    /*lnk->nxt = NULL;*/
    ceu_sys_realloc(lnk, 0);
}

static void __ceu_os_gc (void)
{
    if (! CEU_GC) return;
    CEU_GC = 0;

    /* remove pending events */
    {
        CEU_ISR_OFF();
        int i = 0;
        while (i < QUEUE_tot) {
            tceu_queue* qu = (tceu_queue*) &QUEUE[QUEUE_get+i];
            if (qu->app!=NULL && !qu->app->isAlive) {
                qu->evt = CEU_IN__NONE;
            }
            i += sizeof(tceu_queue) + qu->sz;
        }
        CEU_ISR_ON();
    }

    /* remove broken links */
    {
        tceu_lnk* cur = CEU_LNKS;
        while (cur != NULL) {
            tceu_lnk* nxt = cur->nxt;
            if (!cur->src_app->isAlive || !cur->dst_app->isAlive) {
                _ceu_sys_unlink(cur);
            }
            cur = nxt;
        }
    }

    /* remove dead apps */
    tceu_app* app = CEU_APPS;
    tceu_app* prv = NULL;
    while (app)
    {
        tceu_app* nxt = app->nxt;

        if (app->isAlive) {
            prv = app;

        } else {
            if (CEU_APPS == app) {
                CEU_APPS = nxt;     /* remove as head */
            } else {
                prv->nxt = nxt;     /* remove in the middle */
            }

            /* unlink all "from app" or "to app" */
            ceu_sys_unlink(app,0, 0,0);
            ceu_sys_unlink(0,0, app,0);

#ifdef CEU_RET
            ok--;
            ret += app->ret;
#endif

            /* free app memory */
            ceu_sys_realloc(app->data, 0);
            ceu_sys_realloc(app, 0);
        }

        app = nxt;
    }
}

#ifdef CEU_ISR

typedef struct {
    tceu_isr_f f;
    tceu_app*  app;
} tceu_isr;

#define CEU_ISR_MAX 40
tceu_isr CEU_ISR_VEC[CEU_ISR_MAX];

int ceu_sys_isr (int n, tceu_isr_f f, tceu_app* app) {
    tceu_isr* isr = &CEU_ISR_VEC[(n-1)];
    if (f==NULL || isr->f==NULL) {
        isr->f   = ((word)app->addr>>1) + f;
        isr->app = app;
                           /* "f" is relative to "app", make it absolute */
        return 1;
    } else {
        return 0;
    }
}
#endif

void ceu_os_init (void) {
#ifdef CEU_ISR
    int i;
    for (i=0; i<CEU_ISR_MAX; i++) {
        CEU_ISR_VEC[i].f = NULL;      /* TODO: is this required? (bss=0) */
    }
    CEU_ISR_ON();       /* enable global interrupts to start */
#endif
}

int ceu_os_scheduler (int(*dt)())
{
    /*
     * Intercalate DT->WCLOCK->ASYNC->QUEUE->...
     * QUEUE last to separate app->init() from OS_START.
     * QUEUE handles one event at a time to intercalate with WCLOCK.
     * __ceu_os_gc() only if QUEUE is emtpy: has to keep data from events 
     * accessible.
     */

#ifdef CEU_RET
    while (ok > 0)
#else
    while (1)
#endif
    {
#if defined(CEU_WCLOCKS) || defined(CEU_IN_OS_DT)
        s32 _dt = dt();
#endif

        /* DT */
#ifdef CEU_IN_OS_DT
        {
            tceu_app* app = CEU_APPS;
            while (app) {
                ceu_sys_go(app, CEU_IN_OS_DT, &dt);
                app = app->nxt;
            }
        }
#endif	/* CEU_IN_OS_DT */

        /* WCLOCK */
#ifdef CEU_WCLOCKS
        {
            tceu_app* app = CEU_APPS;
            while (app) {
/*
#error TODO: CEU_IN__WCLOCK_
*/
                ceu_sys_go(app, CEU_IN__WCLOCK, &_dt);
                app = app->nxt;
            }
        }
#endif	/* CEU_WCLOCKS */

        /* ASYNC */
#ifdef CEU_ASYNCS
        {
            tceu_app* app = CEU_APPS;
            while (app) {
                ceu_sys_go(app, CEU_IN__ASYNC, NULL);
                app = app->nxt;
            }
        }
#endif	/* CEU_ASYNCS */

        /* EVENTS */
        {
            /* clear the current size (ignore events emitted here) */
            CEU_ISR_OFF();
            int tot = QUEUE_tot;
            CEU_ISR_ON();
            if (tot > 0)
            {
                tceu_queue* qu = ceu_sys_queue_get();
                tot -= sizeof(tceu_queue) + qu->sz;
                if (qu->evt == CEU_IN__NONE) {
                    /* nothing; */
                    /* "fill event" */

                /* global events (e.g. OS_START, OS_INTERRUPT) */
                } else if (qu->app == NULL) {
                    tceu_app* app = CEU_APPS;
                    while (app) {
                        ceu_sys_go(app, qu->evt, qu->buf);
                        app = app->nxt;
                    }

                } else {
                    /* linked events */
                    tceu_lnk* lnk = CEU_LNKS;
                    while (lnk) {
                        if ( qu->app==lnk->src_app
                        &&   qu->evt==lnk->src_evt
                        &&   lnk->dst_app->isAlive ) {
                            ceu_sys_go(lnk->dst_app, lnk->dst_evt, qu->buf);
                        }
                        lnk = lnk->nxt;
                    }
                }

                ceu_sys_queue_rem();
            }
            else
            {
                __ceu_os_gc();     /* only when queue is empty */
            }
        }
    }

#ifdef CEU_RET
    return ret;
#else
    return 0;
#endif
}

/* LOAD / START */

tceu_app* ceu_sys_load (void* addr)
{
    uint       size;
    tceu_init* init;
#ifdef CEU_OS_LUAIFC
    char*      luaifc;
#endif

#ifdef __AVR
    ((tceu_export) ((word)addr>>1))(&size, &init);
#else
    ((tceu_export) addr)(&size, &init
#ifdef CEU_OS_LUAIFC
                        , &luaifc
#endif
                        );
#endif

    tceu_app* app = (tceu_app*) ceu_sys_realloc(NULL, sizeof(tceu_app));
    if (app == NULL) {
        return NULL;
    }

    app->data = (tceu_org*) ceu_sys_realloc(NULL, size);
    if (app->data == NULL) {
        return NULL;
    }

    app->sys_vec = CEU_SYS_VEC;
    app->nxt = NULL;

    /* Assumes sizeof(void*)==sizeof(WORD) and
        that gcc will word-align SIZE/INIT */
#ifdef __AVR
    app->init = (tceu_init) (((word)addr>>1) + (word)init);
#else
    app->init = (tceu_init) ((word)init);
#endif
    app->addr = addr;

#ifdef CEU_OS_LUAIFC
    app->luaifc = luaifc;
#endif

    return app;
}

void ceu_sys_start (tceu_app* app)
{
    /* add as head */
	if (CEU_APPS == NULL) {
		CEU_APPS = app;

    /* add to tail */
    } else {
		tceu_app* cur = CEU_APPS;
        while (cur->nxt != NULL) {
            cur = cur->nxt;
        }
        cur->nxt = app;
    }

    /* MAX OK */
#ifdef CEU_RET
    ok++;
#endif

    /* INIT */

    app->init(app);

    /* OS_START */

#ifdef CEU_IN_OS_START
    ceu_sys_emit(NULL, CEU_IN_OS_START, 0, NULL);
#endif
}

/* LINK & UNLINK */

int ceu_sys_link (tceu_app* src_app, tceu_nevt src_evt,
                  tceu_app* dst_app, tceu_nevt dst_evt)
{
    tceu_lnk* lnk = (tceu_lnk*) ceu_sys_realloc(NULL, sizeof(tceu_lnk));
    if (lnk == NULL) {
        return 0;
    }

    lnk->src_app = src_app;
    lnk->src_evt = src_evt;
    lnk->dst_app = dst_app;
    lnk->dst_evt = dst_evt;
    lnk->nxt = NULL;

    /* add as head */
	if (CEU_LNKS == NULL) {
		CEU_LNKS = lnk;

    /* add to tail */
    } else {
		tceu_lnk* cur = CEU_LNKS;
        while (cur->nxt != NULL) {
            cur = cur->nxt;
        }
		cur->nxt = lnk;
    }

    return 1;
}

int ceu_sys_unlink (tceu_app* src_app, tceu_nevt src_evt,
                    tceu_app* dst_app, tceu_nevt dst_evt)
{
    tceu_lnk* cur = CEU_LNKS;
    while (cur != NULL) {
        tceu_lnk* nxt = cur->nxt;
        if ( (src_app==0 || src_app==cur->src_app)
          && (src_evt==0 || src_evt==cur->src_evt)
          && (dst_app==0 || dst_app==cur->dst_app)
          && (dst_evt==0 || dst_evt==cur->dst_evt) ) {
            _ceu_sys_unlink(cur);
        }
        cur = nxt;
    }
    return 0;
}

#ifdef CEU_ISR

/* Foreach ISR, call ceu_sys_emit(CEU_IN_OS_INTERRUPT). */

#define GEN_ISR(n)                                                  \
    ISR(__vector_ ## n, ISR_BLOCK) {                                \
        tceu_isr* isr = &CEU_ISR_VEC[n-1];                          \
        if (isr->f != NULL) {                                       \
            CEU_APP_ADDR = isr->app->addr;                          \
            isr->f(isr->app, isr->app->data);                       \
            CEU_APP_ADDR = 0;                                       \
        }                                                           \
        ceu_sys_emit(NULL,CEU_IN_OS_INTERRUPT,CEU_EVTP(n),0,NULL); \
    }
#define _GEN_ISR(n)

GEN_ISR(20);
/*
GEN_ISR( 1) GEN_ISR( 2) GEN_ISR( 3) GEN_ISR( 4) GEN_ISR( 5)
GEN_ISR( 6) GEN_ISR( 7) GEN_ISR( 8) GEN_ISR( 9) GEN_ISR(10)
GEN_ISR(11) GEN_ISR(12) GEN_ISR(13) GEN_ISR(14) GEN_ISR(15)
GEN_ISR(16) GEN_ISR(17) _GEN_ISR(18) GEN_ISR(19) GEN_ISR(20)
GEN_ISR(21) GEN_ISR(22) GEN_ISR(23) GEN_ISR(24) GEN_ISR(25)
GEN_ISR(26) GEN_ISR(27) GEN_ISR(28) GEN_ISR(29) GEN_ISR(30)
GEN_ISR(31) GEN_ISR(32) GEN_ISR(33) GEN_ISR(34) GEN_ISR(35)
GEN_ISR(36) GEN_ISR(37) GEN_ISR(38) GEN_ISR(39) GEN_ISR(40)
*/

#endif /* CEU_ISR */

#endif /* ifdef CEU_OS_KERNEL */

#endif /* ifndef CEU_OS_APP */


#include <stdlib.h>
#ifdef CEU_DEBUG
#include <stdio.h>      /* printf */
#include <signal.h>     /* signal */
#endif
#ifdef CEU_RUNTESTS
#include <string.h>     /* memset */
#endif

#ifdef CEU_THREADS
#   define CEU_ATOMIC(f)                                      \
            CEU_THREADS_MUTEX_LOCK(&_ceu_app->threads_mutex); \
                f                                             \
            CEU_THREADS_MUTEX_UNLOCK(&_ceu_app->threads_mutex);
#else
#   define CEU_ATOMIC(f) f
#endif

#ifdef CEU_NEWS_POOL
#ifndef _CEU_POOL_H
#define _CEU_POOL_H

#include "ceu_types.h"

/* TODO: all "int" here, should evaluate the correct unsigned type */

typedef struct {
    byte**  queue;
                    /* queue is in the next offset to distinguish dynamic(NULL)
                       from static pools(any-address) */
    int     size;
    int     free;
    int     index;
    int     unit;
    byte*   mem;
} tceu_pool;

#define CEU_POOL_DCL(name, type, size) \
    type*     name##_queue[size];      \
    type      name##_mem[size];        \
    tceu_pool name;

void ceu_pool_init (tceu_pool* pool, int size, int unit, byte** queue, byte* mem);
byte* ceu_pool_alloc (tceu_pool* pool);
void ceu_pool_free (tceu_pool* pool, byte* val);

#endif

/*
 * Ceu pool.c is based on Contiki and TinyOS pools:
 * https://github.com/contiki-os/contiki/blob/master/core/lib/memb.c
 * https://github.com/tinyos/tinyos-main/blob/master/tos/system/PoolP.nc
 */
#ifndef _CEU_POOL_C
#define _CEU_POOL_C

#include <stdlib.h>


void ceu_pool_init (tceu_pool* pool, int size, int unit, byte** queue, byte* mem)
{
    int i;
    pool->size  = size;
    pool->free  = size;
    pool->index = 0;
    pool->unit  = unit;
    pool->queue = queue;
    pool->mem   = mem;
    for (i=0; i<size; i++) {
        queue[i] = &mem[i*unit];
    }
}

byte* ceu_pool_alloc (tceu_pool* pool) {
    byte* ret;

    if (pool->free == 0) {
        return NULL;
    }

    pool->free--;
    ret = pool->queue[pool->index];
    pool->queue[pool->index++] = NULL;
    if (pool->index == pool->size) {
        pool->index = 0;
    }
    return ret;
}

void ceu_pool_free (tceu_pool* pool, byte* val) {
    int empty = pool->index + pool->free;
    if (empty >= pool->size) {
        empty -= pool->size;
    }
    pool->queue[empty] = val;
    pool->free++;
}

/*
int ceu_pool_inside (tceu_pool* pool, byte* val) {
    return ((byte*)val >= pool->mem)
        && ((byte*)val < pool->mem+(pool->size*pool->unit));
}
*/

#endif

#endif

#ifdef CEU_VECTOR
#ifndef _CEU_VECTOR_H
#define _CEU_VECTOR_H

#ifndef _CEU_OS_H
#define _CEU_OS_H

#include <stddef.h>
#include "ceu_types.h"

#ifdef CEU_DEBUG
#include <assert.h>
#endif

#if defined(CEU_OS) && defined(__AVR)
#error Understand this again!
#include "Arduino.h"
#define CEU_ISR
#define CEU_ISR_ON()  interrupts()
#define CEU_ISR_OFF() noInterrupts()
#else
#define CEU_ISR_ON()
#define CEU_ISR_OFF()
#endif

/*
#if defined(CEU_CLEAR) || defined(CEU_INTS) || defined(CEU_ORGS) || defined(CEU_REENTRANT)
*/
#if 1
#include <setjmp.h>
#define CEU_STACK
#endif

#if defined(CEU_OS_KERNEL) || defined(CEU_OS_APP)
#define CEU_OS
#endif

#if defined(CEU_ORGS_NEWS) || defined(CEU_ADTS_NEWS)
#define CEU_NEWS
#endif
#if defined(CEU_ORGS_NEWS_POOL) || defined(CEU_ADTS_NEWS_POOL)
#define CEU_NEWS_POOL
#endif
#if defined(CEU_ORGS_AWAIT) || defined(CEU_ADTS_AWAIT)
#define CEU_ORGS_OR_ADTS_AWAIT
#endif

#ifdef CEU_OS

    /* TODO: all should be configurable */
    #define CEU_EXTS
    #define CEU_WCLOCKS
    #define CEU_ASYNCS
    #define CEU_RET
    #define CEU_CLEAR
    #define CEU_STACK
#ifndef __AVR
#endif
    #define CEU_INTS
    #define CEU_ORGS
    /*#define CEU_PSES*/ /* TODO: never tried */
    #define CEU_NEWS
    #define CEU_NEWS_POOL
    #define CEU_ORGS_NEWS
    #define CEU_ORGS_NEWS_MALLOC
    #define CEU_ORGS_NEWS_POOL
    #define CEU_ADTS_NEWS
    #define CEU_ADTS_NEWS_MALLOC
    #define CEU_ADTS_NEWS_POOL
    #define CEU_ORGS_AWAIT
    #define CEU_ADTS_AWAIT
    #define CEU_ORGS_OR_ADTS_AWAIT
/*
    #define CEU_THREADS
*/

#ifdef __AVR
    #define CEU_QUEUE_MAX 256
#else
    #define CEU_QUEUE_MAX 65536
#endif

    #define CEU_IN__NONE          0
    #define CEU_IN__ORG         255
    #define CEU_IN__ORG_PSED    254
    #define CEU_IN__CLEAR       253
    #define CEU_IN__ok_killed   252
    #define CEU_IN__INIT        251     /* HIGHER EXTERNAL */
    #define CEU_IN__ASYNC       250
    #define CEU_IN__THREAD      249
    #define CEU_IN__WCLOCK      248
    #define CEU_IN_OS_START     247
    #define CEU_IN_OS_STOP      246
    #define CEU_IN_OS_DT        245
    #define CEU_IN_OS_INTERRUPT 244
#ifdef CEU_TIMEMACHINE
    #define CEU_IN__WCLOCK_     243
    #define CEU_IN              243
#else
    #define CEU_IN              242
#endif

    #define CEU_IN_higher       CEU_IN__INIT  /* _INIT = HIGHER EXTERNAL */
    #define CEU_IN_lower        128     /* TODO: not checked from up and down */

    typedef s8 tceu_nlbl;   /* TODO: to small!! */

#endif /* CEU_OS */

#ifdef CEU_OS_APP

    #define ceu_out_log(mode,str) \
        ((__typeof__(ceu_sys_log)*)((_ceu_app)->sys_vec[CEU_SYS_LOG]))(mode,str)

    #define ceu_out_assert(v) \
        ((__typeof__(ceu_sys_assert)*)((_ceu_app)->sys_vec[CEU_SYS_ASSERT]))(v)

    #define ceu_out_assert_msg_ex(v,msg,file,line)       \
        {                                                \
            int __ceu_v = v;                             \
            if ((!(__ceu_v)) && ((msg)!=NULL)) {         \
                ceu_out_log(0, (long)"[");               \
                ceu_out_log(0, (long)(file));            \
                ceu_out_log(0, (long)":");               \
                ceu_out_log(2, (line));                  \
                ceu_out_log(0, (long)"] ");              \
                ceu_out_log(0, (long)"runtime error: "); \
                ceu_out_log(0, (long)(msg));             \
                ceu_out_log(0, (long)"\n");              \
            }                                            \
            ((__typeof__(ceu_sys_assert)*)((_ceu_app)->sys_vec[CEU_SYS_ASSERT]))(__ceu_v); \
        }
    #define ceu_out_assert_msg(v,msg) ceu_out_assert_msg_ex((v),(msg),__FILE__,__LINE__)

    #define ceu_out_realloc(ptr, size) \
        ((__typeof__(ceu_sys_realloc)*)((_ceu_app)->sys_vec[CEU_SYS_REALLOC]))(ptr,size)

    #define ceu_out_req() \
        ((__typeof__(ceu_sys_req)*)((_ceu_app)->sys_vec[CEU_SYS_REQ]))()

    #define ceu_out_load(addr) \
        ((__typeof__(ceu_sys_load)*)((_ceu_app)->sys_vec[CEU_SYS_LOAD]))(addr)

#ifdef CEU_ISR
    #define ceu_out_isr(n,f) \
        ((__typeof__(ceu_sys_isr)*)((_ceu_app)->sys_vec[CEU_SYS_ISR]))(n,f,_ceu_app)
#endif

    #define ceu_out_org_init(app,org,n,lbl,cls,isDyn,parent_org,parent_trl) \
        ((__typeof__(ceu_sys_org_init)*)((app)->sys_vec[CEU_SYS_ORG]))(org,n,lbl,cls,isDyn,parent_org,parent_trl)
    #define ceu_out_start(app) \
        ((__typeof__(ceu_sys_start)*)((_ceu_app)->sys_vec[CEU_SYS_START]))(app)
    #define ceu_out_link(app1,evt1 , app2,evt2) \
        ((__typeof__(ceu_sys_link)*)((_ceu_app)->sys_vec[CEU_SYS_LINK]))(app1,evt1,app2,evt2)

    #define ceu_out_emit(app,id,sz,buf) \
        ((__typeof__(ceu_sys_emit)*)((app)->sys_vec[CEU_SYS_EMIT]))(app,id,sz,buf)

    #define ceu_out_call(app,id,param) \
        ((__typeof__(ceu_sys_call)*)((app)->sys_vec[CEU_SYS_CALL]))(app,id,param)

#ifdef CEU_WCLOCKS
    #define ceu_out_wclock(app,dt,set,get) \
        ((__typeof__(ceu_sys_wclock)*)((app)->sys_vec[CEU_SYS_WCLOCK]))(app,dt,set,get)
#ifdef CEU_TIMEMACHINE
    #error TIMEMACHINE
#endif
#endif

    #define ceu_out_go(app,evt,evtp) \
        ((__typeof__(ceu_sys_go)*)((app)->sys_vec[CEU_SYS_GO]))(app,evt,evtp)

#else /* ! CEU_OS_APP (!CEU_OS||CEU_OS_KERNEL) */

    #ifndef ceu_out_assert
        #error "Missing definition for macro \"ceu_out_assert\"."
    #endif

    #ifndef ceu_out_log
        #error "Missing definition for macro \"ceu_out_log\"."
    #endif

    #define ceu_out_assert_msg_ex(v,msg,file,line)          \
        {                                                   \
            int __ceu_v = v;                                \
            if ((!(__ceu_v)) && ((msg)!=NULL)) {            \
                ceu_out_log(0, (long)"[");                  \
                ceu_out_log(0, (long)(file));               \
                ceu_out_log(0, (long)":");                  \
                ceu_out_log(2, line);                       \
                ceu_out_log(0, (long)"] ");                 \
                ceu_out_log(0, (long)"runtime error: ");    \
                ceu_out_log(0, (long)(msg));                \
                ceu_out_log(0, (long)"\n");                 \
            }                                               \
            ceu_out_assert(__ceu_v);                        \
        }
    #define ceu_out_assert_msg(v,msg) ceu_out_assert_msg_ex((v),(msg),__FILE__,__LINE__)

    #define ceu_out_realloc(ptr,size) \
            ceu_sys_realloc(ptr,size)
    #define ceu_out_req() \
            ceu_sys_req()
    #define ceu_out_org_init(app,org,n,lbl,cls,isDyn,parent_org,parent_trl) \
            ceu_sys_org_init(org,n,lbl,cls,isDyn,parent_org,parent_trl)

#ifdef CEU_WCLOCKS
    #define ceu_out_wclock(app,dt,set,get) \
            ceu_sys_wclock(app,dt,set,get)
#ifdef CEU_TIMEMACHINE
    #define ceu_out_wclock_(app,dt,set,get) \
            ceu_sys_wclock_(app,dt,set,get)
#endif
#endif
    #define ceu_out_go(app,evt,evtp) \
            ceu_sys_go(app,evt,evtp)
    #define ceu_out_go_stk(app,evt,evtp,stk) \
            ceu_sys_go_stk(app,evt,evtp,stk)

#endif /* ! CEU_OS_APP (!CEU_OS||CEU_OS_KERNEL) */

#define ceu_in_emit(app,id,n,buf) \
    ceu_out_go_stk(app,id,buf,&stk_)

#ifdef CEU_THREADS
/* TODO: app */
#include "ceu_threads.h"
#endif

#ifdef CEU_LUA
#include <stdio.h>      /* BUFSIZ */
#include <string.h>     /* strcpy */
#if defined(__ANDROID__) || defined(CEU_OS)
    #include "lua.h"
    #include "lauxlib.h"
    #include "lualib.h"
#else
    #include <lua5.1/lua.h>
    #include <lua5.1/lauxlib.h>
    #include <lua5.1/lualib.h>
#endif

#ifdef CEU_OS_APP
    #define ceu_luaL_newstate(set) { \
        set = ceu_out_call(_ceu_app, CEU_OUT_LUA_NEW, NULL); \
    }

    #define ceu_luaL_openlibs(l) { \
        lua_State* p = l;          \
        ceu_out_call(_ceu_app, CEU_OUT_LUAL_OPENLIBS, &p); \
    }

    #define ceu_lua_atpanic(l, f) {     \
    }

    #define ceu_luaL_loadstring(set, l, str) {  \
        tceu__lua_State___char_ p = { l, str }; \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUAL_LOADSTRING, &p); \
    }

    #define ceu_lua_pushnumber(l, v) {      \
        tceu__lua_State___int p = { l, v }; \
        ceu_out_call(_ceu_app, CEU_OUT_LUA_PUSHNUMBER, &p); \
    }

    #define ceu_lua_pushstring(l, v) {      \
        tceu__lua_State___char_ p = { l, v }; \
        ceu_out_call(_ceu_app, CEU_OUT_LUA_PUSHSTRING, &p); \
    }

    #define ceu_lua_pushlightuserdata(l, v) {   \
        tceu__lua_State___void_ p = { l, v };     \
        ceu_out_call(_ceu_app, CEU_OUT_LUA_PUSHLIGHTUSERDATA, &p); \
    }

    #define ceu_lua_pcall(set,l,nargs,nrets,err) {                  \
        tceu__lua_State___int__int__int p = { l, nargs, nrets, err }; \
        ceu_out_call(_ceu_app, CEU_OUT_LUA_PCALL, &p); \
    }

    #define ceu_lua_isnumber(set, l, idx) {     \
        tceu__lua_State___int p = { l, idx };   \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUA_ISNUMBER, &p); \
    }

    #define ceu_lua_tonumber(set, l, idx) {     \
        tceu__lua_State___int p = { l, idx };   \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUA_TONUMBER, &p); \
    }

    #define ceu_lua_isboolean(set, l, idx) {    \
        tceu__lua_State___int p = { l, idx };   \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUA_ISBOOLEAN, &p); \
    }

    #define ceu_lua_toboolean(set, l, idx) {    \
        tceu__lua_State___int p = { l, idx };   \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUA_TOBOOLEAN, &p); \
    }

    #define ceu_lua_pop(l, n) {             \
        tceu__lua_State___int p = { l, n }; \
        ceu_out_call(_ceu_app, CEU_OUT_LUA_POP, &p); \
    }

    #define ceu_lua_isstring(set, l, idx) {     \
        tceu__lua_State___int p = { l, idx };   \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUA_ISSTRING, &p); \
    }

    #define ceu_lua_tostring(set, l, idx) {     \
        tceu__lua_State___int p = { l, idx };   \
        set = ceu_out_call(_ceu_app, CEU_OUT_LUA_TOSTRING, &p); \
    }

    #define ceu_lua_islightuserdata(set, l, idx) {  \
        tceu__lua_State___int p = { l, idx };       \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUA_ISLIGHTUSERDATA, &p); \
    }

    #define ceu_lua_touserdata(set, l, idx) {   \
        tceu__lua_State___int p = { l, idx };   \
        set = ceu_out_call(_ceu_app, CEU_OUT_LUA_TOUSERDATA, &p); \
    }

    #define ceu_lua_error(l) {                          \
        lua_State** p = &l;                             \
        ceu_out_call(_ceu_app, CEU_OUT_LUA_ERROR, &p);  \
    }

    #define ceu_lua_objlen(set, l, idx) {                       \
        tceu__lua_State___int p = { l, idx };                   \
        set = ceu_out_call(_ceu_app, CEU_OUT_LUA_OBJLEN, &p);   \
    }

#else
    #define ceu_luaL_newstate(set)               set = luaL_newstate()
    #define ceu_luaL_openlibs(l)                 luaL_openlibs(l)
    #define ceu_lua_atpanic(l,f)                 lua_atpanic(l,f)
    #define ceu_luaL_loadstring(set,l,str)       set = luaL_loadstring(l,str)
    #define ceu_lua_pushnumber(l,v)              lua_pushnumber(l,v)
    #define ceu_lua_pushstring(l,v)              lua_pushstring(l,v)
    #define ceu_lua_pushlightuserdata(l,v)       lua_pushlightuserdata(l,v)
    #define ceu_lua_pcall(set,l,nargs,nrets,err) set = lua_pcall(l,nargs,nrets,err)
    #define ceu_lua_isnumber(set,l,idx)          set = lua_isnumber(l,idx)
    #define ceu_lua_tonumber(set,l,idx)          set = lua_tonumber(l,idx)
    #define ceu_lua_isboolean(set,l,idx)         set = lua_isboolean(l,idx)
    #define ceu_lua_toboolean(set,l,idx)         set = lua_toboolean(l,idx)
    #define ceu_lua_pop(l,n)                     lua_pop(l,n)
    #define ceu_lua_isstring(set,l,idx)          set = lua_isstring(l,idx)
    #define ceu_lua_tostring(set,l,idx)          set = lua_tostring(l,idx)
    #define ceu_lua_islightuserdata(set,l,idx)   set = lua_islightuserdata(l,idx)
    #define ceu_lua_touserdata(set,l,idx)        set = lua_touserdata(l,idx)
    #define ceu_lua_error(l)                     lua_error(l)
    #define ceu_lua_objlen(set,l,idx)            set = lua_objlen(l,idx)
#endif
#endif

typedef u8 tceu_nevt;   /* max number of events */
                        /* TODO: should "u8" be fixed? */

typedef u8 tceu_ntrl;   /* max number of trails per class */
                        /* TODO: should "u8" be fixed? */

#ifdef CEU_STACK
typedef u16 tceu_nstk;  /* max size of internal stack in bytes */
                        /* TODO: should "u16" be fixed? */
#endif

#ifdef __cplusplus
#define CEU_WCLOCK_INACTIVE 0x7fffffffL     /* TODO */
#else
#define CEU_WCLOCK_INACTIVE INT32_MAX
#endif
#define CEU_WCLOCK_EXPIRED (CEU_WCLOCK_INACTIVE-1)

/* TCEU_TRL */

struct tceu_org;
typedef union tceu_trl {
    tceu_nevt evt;

    /* normal await // IN__CLEAR */
    struct {                    /* TODO(ram): bitfields */
        tceu_nevt evt1;
        tceu_nlbl lbl;
        u8        seqno;        /* TODO(ram): 2 bits is enough */
#ifdef CEU_INTS                 /* R-9: size of trails for internal events */
#ifdef CEU_ORGS
        void*     evto;
#endif
#endif
    };

    /* IN__ORG */
#ifdef CEU_ORGS
    struct {                    /* TODO(ram): bad for alignment */
        tceu_nevt evt3;
        struct tceu_org* org;
    };
#endif

    /* _ok_killed */
#ifdef CEU_ORGS_OR_ADTS_AWAIT
    struct {
        tceu_nevt evt4;
        tceu_nlbl lbl4;
        void*     org_or_adt;
    };
#endif
} tceu_trl;

/* TCEU_EVT */

typedef struct tceu_evt {
    tceu_nevt id;
    void*     param;
#if defined(CEU_ORGS) && defined(CEU_INTS)
    void*     org;      /* emitting org */
#endif
} tceu_evt;

/* TCEU_ORG */

struct tceu_pool_orgs;
typedef struct tceu_org
{
#ifdef CEU_ORGS
    struct tceu_org* nxt; /* first field because of free list for orgs/adts */
    struct tceu_org* prv;
    struct tceu_org* parent_org;
    tceu_ntrl parent_trl;
#endif

#if defined(CEU_ORGS) || defined(CEU_OS)
    tceu_ntrl n;            /* number of trails (TODO(ram): opt, metadata) */
#endif

#ifdef CEU_ORGS

#ifdef CEU_IFCS
    tceu_ncls cls;          /* class id */
#endif
    u8 isAlive: 1;          /* Three purposes:
                             * - avoids double free
                             * - required by "watching o" to avoid awaiting a
                             *      dead org
                             * - required by "Do T" to avoid awaiting a dead 
                             *      org
                             */
#if defined(CEU_ORGS_NEWS) || defined(CEU_ORGS_AWAIT)
#endif
#ifdef CEU_ORGS_NEWS
    u8 isDyn: 1;            /* created w/ new or spawn? */
#endif
#ifdef CEU_ORGS_NEWS_POOL
    struct tceu_pool_orgs* pool;
#endif

#ifdef CEU_ORGS_AWAIT
    int ret;
#endif

#endif  /* CEU_ORGS */

    tceu_trl trls[0];       /* first trail */

} tceu_org;

/* TCEU_POOL_ORGS , TCEU_POOL_ADTS */

#if defined(CEU_ORGS_NEWS_POOL) || defined(CEU_ADTS_NEWS_POOL)
#include "ceu_pool.h"
#endif

#ifdef CEU_ORGS_NEWS
typedef struct tceu_pool_orgs {
    tceu_org* parent_org;
    tceu_ntrl parent_trl;
#ifdef CEU_ORGS_NEWS_POOL
    tceu_pool pool;
#endif
} tceu_pool_orgs;
#endif

#ifdef CEU_ADTS_NEWS
typedef struct {
    void* root;
#ifdef CEU_ADTS_NEWS_POOL
    void* pool;
#endif
} tceu_pool_adts;
#endif

/* TCEU_KILL */

#ifdef CEU_ORGS_OR_ADTS_AWAIT
typedef struct tceu_kill {
    void*     org_or_adt;
    int       ret;
} tceu_kill;
#endif

/* TCEU_LST */

#ifdef CEU_DEBUG
typedef struct tceu_lst {
#ifdef CEU_ORGS
    void*     org;
#endif
    tceu_trl* trl;
    tceu_nlbl lbl;
} tceu_lst;

#endif

/* TCEU_STK */

typedef struct tceu_stk {
    struct tceu_stk* up;
    tceu_org* org;
    tceu_ntrl trl1;
    tceu_ntrl trl2;
    jmp_buf   jmp;
} tceu_stk;

/* TCEU_JMP */

#ifdef CEU_STACK
typedef struct tceu_jmp {
#ifdef CEU_ORGS
    tceu_org* org;
#endif
    tceu_trl* trl;
    tceu_nlbl lbl;
} tceu_jmp;
#endif

/* TCEU_APP */

typedef struct tceu_app {
    /* global seqno: incremented on every reaction
     * awaiting trails matches only if trl->seqno < seqno,
     * i.e., previously awaiting the event
     */
    u8 seqno:          2;
#if defined(CEU_RET) || defined(CEU_OS)
    u8 isAlive:        1;
#endif
#ifdef CEU_ASYNCS
    u8 pendingAsyncs:  1;
#endif
#if defined(CEU_ORGS_NEWS_MALLOC) && defined(CEU_ORGS_AWAIT)
    u8 dont_emit_kill: 1;
#endif

#ifdef CEU_OS
    struct tceu_app* nxt;
#endif

#ifdef CEU_REENTRANT
    tceu_nstk stki;
#endif

#ifdef CEU_STACK
    tceu_stk* stk_bottom;
    tceu_jmp  stk_jmp;
#endif

#if defined(CEU_RET) || defined(CEU_ORGS_AWAIT)
    int ret;
#endif

#ifdef CEU_ORGS_NEWS_MALLOC
    tceu_org* tofree;
#endif

#ifdef CEU_WCLOCKS
    s32         wclk_late;
    s32         wclk_min_set;   /* used to set */
    s32         wclk_min_cmp;   /* used to compare */
                                /* cmp<-set every reaction */
#ifdef CEU_TIMEMACHINE
    s32         wclk_late_;
    s32         wclk_min_set_;
    s32         wclk_min_cmp_;
#endif
#endif

#ifndef CEU_OS
#ifdef CEU_DEBUG
    tceu_lst    lst; /* segfault printf */
#endif
#endif

#ifdef CEU_THREADS
    CEU_THREADS_MUTEX_T threads_mutex;
    /*CEU_THREADS_COND_T  threads_cond;*/
    u8                  threads_n;          /* number of running threads */
        /* TODO: u8? */
#endif
#if defined(CEU_LUA) || defined(CEU_OS)
#ifdef CEU_LUA
    lua_State*  lua;    /* TODO: move to data? */
#else
    void*       lua;
#endif
#endif

    void        (*code)  (struct tceu_app*,tceu_evt*,tceu_org*,tceu_trl*,tceu_stk*);
    void        (*init)  (struct tceu_app*);
#ifdef CEU_OS
    void*       (*calls) (struct tceu_app*,tceu_nevt,void*);
    void**      sys_vec;
    void*       addr;
#ifdef CEU_OS_LUAIFC
    char*       luaifc;
#endif
#endif
    tceu_org*   data;
} tceu_app;

#ifdef CEU_OS
typedef void (*tceu_init)   (tceu_app* app);
typedef void (*tceu_export) (uint* size, tceu_init** init
#ifdef CEU_OS_LUAIFC
                            , char** luaifc
#endif
);
#endif

/* TCEU_THREADS_P */

#ifdef CEU_THREADS
typedef struct {
    tceu_app* app;
    tceu_org* org;
    s8*       st; /* thread state:
                   * 0=ini (sync  spawns)
                   * 1=cpy (async copies)
                   * 2=lck (sync  locks)
                   * 3=end (sync/async terminates)
                   */
} tceu_threads_p;
#endif

#ifdef CEU_PSES
void ceu_pause (tceu_trl* trl, tceu_trl* trlF, int psed);
#endif

int  ceu_go_all    (tceu_app* app);

#ifdef CEU_WCLOCKS
int       ceu_sys_wclock (tceu_app* app, s32 dt, s32* set, s32* get);
#endif
void      ceu_sys_go     (tceu_app* app, int evt, void* evtp);

#ifdef CEU_OS

/* TCEU_LINK */

typedef struct tceu_lnk {
    tceu_app* src_app;
    tceu_nevt src_evt;
    tceu_app* dst_app;
    tceu_nevt dst_evt;
    struct tceu_lnk* nxt;
} tceu_lnk;

/* TCEU_QUEUE */

typedef struct {
    tceu_app* app;
    tceu_nevt evt;
#if CEU_QUEUE_MAX == 256
    s8        sz;
#else
    s16       sz;   /* signed because of fill */
#endif
    byte      buf[0];
} tceu_queue;

#ifdef CEU_ISR
typedef void(*tceu_isr_f)(tceu_app* app, tceu_org* org);
#endif

void ceu_os_init      (void);
int  ceu_os_scheduler (int(*dt)());
tceu_queue* ceu_sys_queue_nxt (void);
void        ceu_sys_queue_rem (void);

void      ceu_sys_assert    (int v);
void      ceu_sys_log       (int mode, long str);
void*     ceu_sys_realloc   (void* ptr, size_t size);
int       ceu_sys_req       (void);
tceu_app* ceu_sys_load      (void* addr);
#ifdef CEU_ISR
int       ceu_sys_isr       (int n, tceu_isr_f f, tceu_app* app);
#endif
void      ceu_sys_org_init  (tceu_org* org, int n, int lbl, int cls, int isDyn,
                             tceu_org* parent_org, tceu_ntrl parent_trl);
void      ceu_sys_start     (tceu_app* app);
int       ceu_sys_link      (tceu_app* src_app, tceu_nevt src_evt, tceu_app* dst_app, tceu_nevt dst_evt);
int       ceu_sys_unlink    (tceu_app* src_app, tceu_nevt src_evt, tceu_app* dst_app, tceu_nevt dst_evt);
int       ceu_sys_emit      (tceu_app* app, tceu_nevt evt, int sz, void* param);
void*     ceu_sys_call      (tceu_app* app, tceu_nevt evt, void* param);

enum {
    CEU_SYS_ASSERT = 0,
    CEU_SYS_LOG,
    CEU_SYS_REALLOC,
    CEU_SYS_REQ,
    CEU_SYS_LOAD,
#ifdef CEU_ISR
    CEU_SYS_ISR,
#endif
#ifdef CEU_CLEAR
    CEU_SYS_CLEAR,
#endif
    CEU_SYS_STACK_PUSH,
#ifdef CEU_ORGS
    CEU_SYS_STACK_CLEAR_ORG,
#endif
    CEU_SYS_ORG,
#ifdef CEU_ORGS
    CEU_SYS_ORG_TRAIL,
    CEU_SYS_ORG_SPAWN,
#endif
    CEU_SYS_START,
    CEU_SYS_LINK,
    CEU_SYS_UNLINK,
    CEU_SYS_EMIT,
    CEU_SYS_CALL,
#ifdef CEU_WCLOCKS
    CEU_SYS_WCLOCK,
#endif
    CEU_SYS_GO,
    CEU_SYS_MAX
};

/* SYS_VECTOR
 */
extern void* CEU_SYS_VEC[CEU_SYS_MAX];

#endif  /* CEU_OS */

#endif  /* _CEU_OS_H */


typedef struct {
    int   max;
    int   nxt;
    int   unit;
    byte* mem;
} tceu_vector;

#define CEU_VECTOR_DCL(name, type, max)  \
    type        name##_mem[max+1];       \
    tceu_vector name;
                /* [STRING] max+1: extra space for '\0' */

#define ceu_vector_getlen(vec) ((vec)->nxt)
#define ceu_vector_getmax(vec) ((vec)->max > 0 ? (vec)->max : 0)

void  ceu_vector_init   (tceu_vector* vector, int max, int unit, byte* mem);
int   ceu_vector_setlen (tceu_vector* vector, int len);
byte* ceu_vector_geti   (tceu_vector* vector, int idx);
int   ceu_vector_seti   (tceu_vector* vector, int idx, byte* v);
int   ceu_vector_push   (tceu_vector* vector, byte* v);
int   ceu_vector_concat (tceu_vector* to, tceu_vector* fr);
int   ceu_vector_concat_buffer (tceu_vector* to, const char* fr, int n);
char* ceu_vector_tochar (tceu_vector* vector);

#if 0
byte* ceu_pool_alloc (tceu_pool* pool);
void ceu_pool_free (tceu_pool* pool, byte* val);
#endif
#endif

#ifndef _CEU_VECTOR_C
#define _CEU_VECTOR_C



void ceu_vector_init (tceu_vector* vector, int max, int unit, byte* mem) {
    vector->nxt  = 0;
    vector->max  = max;
    vector->unit = unit;
    vector->mem  = (max==0) ? NULL : mem;

    /* [STRING] */
    if (vector->mem != NULL) {
        vector->mem[0] = '\0';
    }
}

#ifdef CEU_VECTOR_MALLOC
static void* ceu_vector_resize (tceu_vector* vector, int n) {
    ceu_out_assert_msg(vector->max <= 0, "bug found");

    if (n == 0) {
        /* free */
        if (vector->mem != NULL) {
            vector->max = 0;
            ceu_out_realloc(vector->mem, 0);
            vector->mem = NULL;
        }
    } else {
        /* TODO: Java does the same? */
        n = (n*3/2) + 1;
        if (n < 10) {
            n = 10;
        }

        vector->max = -n;
        vector->mem = (byte*)ceu_out_realloc(vector->mem, n*vector->unit + 1);
                                                        /* [STRING] +1 */
    }

    return vector->mem;
}
#endif

/* can only decrease vector->nxt */
int ceu_vector_setlen (tceu_vector* vector, int nxt) {
    if (nxt > vector->nxt) {
        return 0;
    } else {
        vector->nxt = nxt;

        /* [STRING] */
        if (vector->mem != NULL) {
            vector->mem[nxt*vector->unit] = '\0';
        }

#ifdef CEU_VECTOR_MALLOC
        /* shrink malloc'ed arrays */
        if (vector->max <= 0) {
            if (ceu_vector_resize(vector,nxt)==NULL && nxt>0) {
                return 0;
            }
        }
#endif

        return 1;
    }
}

/* can only get within idx < vector->nxt */
byte* ceu_vector_geti (tceu_vector* vector, int idx) {
    if (idx >= vector->nxt) {
        return NULL;
    } else {
        return &vector->mem[idx*vector->unit];
    }
}

/* can only set within idx < vector->nxt */
int ceu_vector_seti (tceu_vector* vector, int idx, byte* v) {
    if (idx >= vector->nxt) {
        return 0;
    } else {
        memcpy(&vector->mem[idx*vector->unit], v, vector->unit);
        return 1;
    }
}

/* can only push within nxt < vector->max */
int ceu_vector_push (tceu_vector* vector, byte* v) {
#ifdef CEU_VECTOR_MALLOC
    /* grow malloc'ed arrays */
    if (vector->max <= 0) {
        while (vector->nxt >= -vector->max) {
            if (ceu_vector_resize(vector,vector->nxt+1) == NULL) {
                return 0;
            }
        }
    }
#endif
#ifdef CEU_VECTOR_MALLOC
#ifdef CEU_VECTOR_POOL
    else
#endif
#endif
#ifdef CEU_VECTOR_POOL
    if (vector->nxt >= vector->max) {
        return 0;
    }
#endif

    memcpy(&vector->mem[vector->nxt*vector->unit], v, vector->unit);
    vector->nxt++;
    vector->mem[vector->nxt*vector->unit] = '\0';    /* [STRING] */
    return 1;
}

int ceu_vector_concat (tceu_vector* to, tceu_vector* fr) {
    if (to == fr) {
        return 0;
    } else {
        /* TODO: memcpy */
        int i;
        for (i=0; i<fr->nxt; i++) {
            byte* v = ceu_vector_geti(fr, i);
            if (v == NULL) {
                return 0;
            } else if (!ceu_vector_push(to,v)) {
                return 0;
            }
        }
    }
    return 1;
}

int ceu_vector_concat_buffer (tceu_vector* to, const char* fr, int n) {
    /* TODO: memcpy */
    int i;
    for (i=0; i<n; i++) {
        if (!ceu_vector_push(to,(byte*)&fr[i])) {
            return 0;
        }
    }
    return 1;
}

char* ceu_vector_tochar (tceu_vector* vector) {
    if (vector->mem == NULL) {
        return "";
    } else {
        return (char*)vector->mem;
    }
}

#endif

#endif

#ifdef CEU_IFCS
#include <stddef.h>
/* TODO: === direto? */
#define CEU_NCLS       (=== CEU_NCLS ===)
#endif

/* native code from the Main class */


/* goto labels */
enum {
    Main_Set_out_0 = 0,
    LeafHandler_Set_out_1 = 1,
    Class_LeafHandler = 2,
    BTreeTraverse_Set_out_3 = 3,
    BTreeTraverse_Set_jmp_4 = 4,
    Class_Scope = 5,
    Body_225_Set_out_6 = 6,
    Body_225_Set_jmp_7 = 7,
    Body_225_ParOr_sub_1_8 = 8,
    Body_225_ParOr_out_9 = 9,
    Body_225_ParOr_jmp_10 = 10,
    Body_225_Awake__ok_killed_11 = 11,
    Body_225_ParOr_sub_1_12 = 12,
    Body_225_ParOr_out_13 = 13,
    Body_225_ParOr_jmp_14 = 14,
    Body_225_Awake__ok_killed_15 = 15,
    Body_225_Awake__ok_killed_16 = 16,
    Body_225_optorg_reset_17 = 17,
    Body_225_Block_jmp_18 = 18,
    Body_225_Awake__ok_killed_19 = 19,
    Body_225_optorg_reset_20 = 20,
    Body_225_Block_jmp_21 = 21,
    Body_225_Awake__ok_killed_22 = 22,
    Body_225_optorg_reset_23 = 23,
    Body_225_Block_jmp_24 = 24,
    Body_225_Awake__ok_killed_25 = 25,
    Body_225_optorg_reset_26 = 26,
    Body_225_Block_jmp_27 = 27,
    Body_225_Awake__ok_killed_28 = 28,
    Body_225_Block_jmp_29 = 29,
    Body_225_Block__fin_30 = 30,
    Body_225_Block_jmp_31 = 31,
    Class_Body_225 = 32,
    BTreeTraverse_Awake__ok_killed_33 = 33,
    BTreeTraverse_optorg_reset_34 = 34,
    BTreeTraverse_Block_jmp_35 = 35,
    BTreeTraverse_Block__fin_36 = 36,
    BTreeTraverse_Block_jmp_37 = 37,
    BTreeTraverse_Block__fin_38 = 38,
    BTreeTraverse_Block_jmp_39 = 39,
    Class_BTreeTraverse = 40,
    Main_ParEver_sub_1_41 = 41,
    Main_ParEver_out_42 = 42,
    Main_Awake_TICK_43 = 43,
    Main_Awake__ok_killed_44 = 44,
    Main_Block_jmp_45 = 45,
    Main_Block__fin_46 = 46,
    Main_adt_fin_kill_free_47 = 47,
    Main_Block_jmp_48 = 48,
    Main_Awake_TICK_49 = 49,
    Main_Awake__ok_killed_50 = 50,
    Main_Block_jmp_51 = 51,
    Main_Block__fin_52 = 52,
    Main_adt_fin_kill_free_53 = 53,
    Main_Block_jmp_54 = 54,
    Class_Main = 55,

};

typedef struct {
#ifdef CEU_IFCS
#ifdef CEU_OS_APP
#error remove from RAM!
#endif
    s8        ifcs_clss[CEU_NCLS][=== IFCS_NIFCS ===];
            /* Does "cls" implements "ifc?"
             * (I*) ifc = (I*) cls;     // returns null if not
             * TODO(ram): bitfield
             */

    u16       ifcs_flds[CEU_NCLS][=== IFCS_NFLDS ===];
    u16       ifcs_evts[CEU_NCLS][=== IFCS_NEVTS ===];
    void*     ifcs_funs[CEU_NCLS][=== IFCS_NFUNS ===];
#endif
} _tceu_app;

/* TODO: remove from RAM */
#ifdef CEU_IFCS
static _tceu_app _CEU_APP = {
#ifdef CEU_OS_APP
#error remove from RAM!
#endif
    {
=== IFCS_CLSS ===
    },
    {
=== IFCS_FLDS ===
    },
    {
=== IFCS_EVTS ===
    },
    {
=== IFCS_FUNS ===
    }
};
#endif

void CEU_Leaf_free (void* pool, CEU_Leaf* me);

CEU_Leaf* CEU_LEAF_SENSERIGHT_assert (tceu_app* app, CEU_Leaf* me, char* file, int line) {
    ceu_out_assert_msg_ex(me->tag == CEU_LEAF_SENSERIGHT, "invalid tag", file, line);
    return me;
}

void CEU_LEAF_SENSERIGHT_free (void* pool, CEU_Leaf* me) {
    /* FREE (before ok_killed) */
#if    defined(CEU_ADTS_NEWS_POOL) && !defined(CEU_ADTS_NEWS_MALLOC)
            ceu_pool_free(pool, (void*)me);
#elif  defined(CEU_ADTS_NEWS_POOL) &&  defined(CEU_ADTS_NEWS_MALLOC)
            if (pool == NULL) {
                ceu_out_realloc(me, 0);
            } else {
                ceu_pool_free(pool, (void*)me);
            }
#elif !defined(CEU_ADTS_NEWS_POOL) &&  defined(CEU_ADTS_NEWS_MALLOC)
            ceu_out_realloc(me, 0);
#endif
}

CEU_Leaf* CEU_LEAF_SENSELEFT_assert (tceu_app* app, CEU_Leaf* me, char* file, int line) {
    ceu_out_assert_msg_ex(me->tag == CEU_LEAF_SENSELEFT, "invalid tag", file, line);
    return me;
}

void CEU_LEAF_SENSELEFT_free (void* pool, CEU_Leaf* me) {
    /* FREE (before ok_killed) */
#if    defined(CEU_ADTS_NEWS_POOL) && !defined(CEU_ADTS_NEWS_MALLOC)
            ceu_pool_free(pool, (void*)me);
#elif  defined(CEU_ADTS_NEWS_POOL) &&  defined(CEU_ADTS_NEWS_MALLOC)
            if (pool == NULL) {
                ceu_out_realloc(me, 0);
            } else {
                ceu_pool_free(pool, (void*)me);
            }
#elif !defined(CEU_ADTS_NEWS_POOL) &&  defined(CEU_ADTS_NEWS_MALLOC)
            ceu_out_realloc(me, 0);
#endif
}

CEU_Leaf* CEU_LEAF_SENSEUP_assert (tceu_app* app, CEU_Leaf* me, char* file, int line) {
    ceu_out_assert_msg_ex(me->tag == CEU_LEAF_SENSEUP, "invalid tag", file, line);
    return me;
}

void CEU_LEAF_SENSEUP_free (void* pool, CEU_Leaf* me) {
    /* FREE (before ok_killed) */
#if    defined(CEU_ADTS_NEWS_POOL) && !defined(CEU_ADTS_NEWS_MALLOC)
            ceu_pool_free(pool, (void*)me);
#elif  defined(CEU_ADTS_NEWS_POOL) &&  defined(CEU_ADTS_NEWS_MALLOC)
            if (pool == NULL) {
                ceu_out_realloc(me, 0);
            } else {
                ceu_pool_free(pool, (void*)me);
            }
#elif !defined(CEU_ADTS_NEWS_POOL) &&  defined(CEU_ADTS_NEWS_MALLOC)
            ceu_out_realloc(me, 0);
#endif
}

CEU_Leaf* CEU_LEAF_SENSEDOWN_assert (tceu_app* app, CEU_Leaf* me, char* file, int line) {
    ceu_out_assert_msg_ex(me->tag == CEU_LEAF_SENSEDOWN, "invalid tag", file, line);
    return me;
}

void CEU_LEAF_SENSEDOWN_free (void* pool, CEU_Leaf* me) {
    /* FREE (before ok_killed) */
#if    defined(CEU_ADTS_NEWS_POOL) && !defined(CEU_ADTS_NEWS_MALLOC)
            ceu_pool_free(pool, (void*)me);
#elif  defined(CEU_ADTS_NEWS_POOL) &&  defined(CEU_ADTS_NEWS_MALLOC)
            if (pool == NULL) {
                ceu_out_realloc(me, 0);
            } else {
                ceu_pool_free(pool, (void*)me);
            }
#elif !defined(CEU_ADTS_NEWS_POOL) &&  defined(CEU_ADTS_NEWS_MALLOC)
            ceu_out_realloc(me, 0);
#endif
}

CEU_Leaf* CEU_LEAF_GORIGHT_assert (tceu_app* app, CEU_Leaf* me, char* file, int line) {
    ceu_out_assert_msg_ex(me->tag == CEU_LEAF_GORIGHT, "invalid tag", file, line);
    return me;
}

void CEU_LEAF_GORIGHT_free (void* pool, CEU_Leaf* me) {
    /* FREE (before ok_killed) */
#if    defined(CEU_ADTS_NEWS_POOL) && !defined(CEU_ADTS_NEWS_MALLOC)
            ceu_pool_free(pool, (void*)me);
#elif  defined(CEU_ADTS_NEWS_POOL) &&  defined(CEU_ADTS_NEWS_MALLOC)
            if (pool == NULL) {
                ceu_out_realloc(me, 0);
            } else {
                ceu_pool_free(pool, (void*)me);
            }
#elif !defined(CEU_ADTS_NEWS_POOL) &&  defined(CEU_ADTS_NEWS_MALLOC)
            ceu_out_realloc(me, 0);
#endif
}

CEU_Leaf* CEU_LEAF_GOLEFT_assert (tceu_app* app, CEU_Leaf* me, char* file, int line) {
    ceu_out_assert_msg_ex(me->tag == CEU_LEAF_GOLEFT, "invalid tag", file, line);
    return me;
}

void CEU_LEAF_GOLEFT_free (void* pool, CEU_Leaf* me) {
    /* FREE (before ok_killed) */
#if    defined(CEU_ADTS_NEWS_POOL) && !defined(CEU_ADTS_NEWS_MALLOC)
            ceu_pool_free(pool, (void*)me);
#elif  defined(CEU_ADTS_NEWS_POOL) &&  defined(CEU_ADTS_NEWS_MALLOC)
            if (pool == NULL) {
                ceu_out_realloc(me, 0);
            } else {
                ceu_pool_free(pool, (void*)me);
            }
#elif !defined(CEU_ADTS_NEWS_POOL) &&  defined(CEU_ADTS_NEWS_MALLOC)
            ceu_out_realloc(me, 0);
#endif
}

CEU_Leaf* CEU_LEAF_GOUP_assert (tceu_app* app, CEU_Leaf* me, char* file, int line) {
    ceu_out_assert_msg_ex(me->tag == CEU_LEAF_GOUP, "invalid tag", file, line);
    return me;
}

void CEU_LEAF_GOUP_free (void* pool, CEU_Leaf* me) {
    /* FREE (before ok_killed) */
#if    defined(CEU_ADTS_NEWS_POOL) && !defined(CEU_ADTS_NEWS_MALLOC)
            ceu_pool_free(pool, (void*)me);
#elif  defined(CEU_ADTS_NEWS_POOL) &&  defined(CEU_ADTS_NEWS_MALLOC)
            if (pool == NULL) {
                ceu_out_realloc(me, 0);
            } else {
                ceu_pool_free(pool, (void*)me);
            }
#elif !defined(CEU_ADTS_NEWS_POOL) &&  defined(CEU_ADTS_NEWS_MALLOC)
            ceu_out_realloc(me, 0);
#endif
}

CEU_Leaf* CEU_LEAF_GODOWN_assert (tceu_app* app, CEU_Leaf* me, char* file, int line) {
    ceu_out_assert_msg_ex(me->tag == CEU_LEAF_GODOWN, "invalid tag", file, line);
    return me;
}

void CEU_LEAF_GODOWN_free (void* pool, CEU_Leaf* me) {
    /* FREE (before ok_killed) */
#if    defined(CEU_ADTS_NEWS_POOL) && !defined(CEU_ADTS_NEWS_MALLOC)
            ceu_pool_free(pool, (void*)me);
#elif  defined(CEU_ADTS_NEWS_POOL) &&  defined(CEU_ADTS_NEWS_MALLOC)
            if (pool == NULL) {
                ceu_out_realloc(me, 0);
            } else {
                ceu_pool_free(pool, (void*)me);
            }
#elif !defined(CEU_ADTS_NEWS_POOL) &&  defined(CEU_ADTS_NEWS_MALLOC)
            ceu_out_realloc(me, 0);
#endif
}

CEU_Leaf* CEU_LEAF_SKIP_assert (tceu_app* app, CEU_Leaf* me, char* file, int line) {
    ceu_out_assert_msg_ex(me->tag == CEU_LEAF_SKIP, "invalid tag", file, line);
    return me;
}

void CEU_LEAF_SKIP_free (void* pool, CEU_Leaf* me) {
    /* FREE (before ok_killed) */
#if    defined(CEU_ADTS_NEWS_POOL) && !defined(CEU_ADTS_NEWS_MALLOC)
            ceu_pool_free(pool, (void*)me);
#elif  defined(CEU_ADTS_NEWS_POOL) &&  defined(CEU_ADTS_NEWS_MALLOC)
            if (pool == NULL) {
                ceu_out_realloc(me, 0);
            } else {
                ceu_pool_free(pool, (void*)me);
            }
#elif !defined(CEU_ADTS_NEWS_POOL) &&  defined(CEU_ADTS_NEWS_MALLOC)
            ceu_out_realloc(me, 0);
#endif
}

void CEU_Leaf_free (void* pool, CEU_Leaf* me) {
    switch (me->tag) {
        case CEU_LEAF_SENSERIGHT:
            CEU_LEAF_SENSERIGHT_free(pool, me);
            break;
        case CEU_LEAF_SENSELEFT:
            CEU_LEAF_SENSELEFT_free(pool, me);
            break;
        case CEU_LEAF_SENSEUP:
            CEU_LEAF_SENSEUP_free(pool, me);
            break;
        case CEU_LEAF_SENSEDOWN:
            CEU_LEAF_SENSEDOWN_free(pool, me);
            break;
        case CEU_LEAF_GORIGHT:
            CEU_LEAF_GORIGHT_free(pool, me);
            break;
        case CEU_LEAF_GOLEFT:
            CEU_LEAF_GOLEFT_free(pool, me);
            break;
        case CEU_LEAF_GOUP:
            CEU_LEAF_GOUP_free(pool, me);
            break;
        case CEU_LEAF_GODOWN:
            CEU_LEAF_GODOWN_free(pool, me);
            break;
        case CEU_LEAF_SKIP:
            CEU_LEAF_SKIP_free(pool, me);
            break;
#ifdef CEU_DEBUG
        default:
            ceu_out_assert_msg(0, "invalid tag");
#endif
    }
}



static CEU_BTree CEU_BTREE_BASE;
void CEU_BTree_free (void* pool, CEU_BTree* me);

CEU_BTree* CEU_BTREE_NIL_assert (tceu_app* app, CEU_BTree* me, char* file, int line) {
    ceu_out_assert_msg_ex(me->tag == CEU_BTREE_NIL, "invalid tag", file, line);
    return me;
}

CEU_BTree* CEU_BTREE_SEQUENCE_assert (tceu_app* app, CEU_BTree* me, char* file, int line) {
    ceu_out_assert_msg_ex(me->tag == CEU_BTREE_SEQUENCE, "invalid tag", file, line);
    return me;
}

void CEU_BTREE_SEQUENCE_free (void* pool, CEU_BTree* me) {
    CEU_BTree_free(pool, me->SEQUENCE.first);
    CEU_BTree_free(pool, me->SEQUENCE.second);
    /* FREE (before ok_killed) */
#if    defined(CEU_ADTS_NEWS_POOL) && !defined(CEU_ADTS_NEWS_MALLOC)
            ceu_pool_free(pool, (void*)me);
#elif  defined(CEU_ADTS_NEWS_POOL) &&  defined(CEU_ADTS_NEWS_MALLOC)
            if (pool == NULL) {
                ceu_out_realloc(me, 0);
            } else {
                ceu_pool_free(pool, (void*)me);
            }
#elif !defined(CEU_ADTS_NEWS_POOL) &&  defined(CEU_ADTS_NEWS_MALLOC)
            ceu_out_realloc(me, 0);
#endif
}

CEU_BTree* CEU_BTREE_SELECTOR_assert (tceu_app* app, CEU_BTree* me, char* file, int line) {
    ceu_out_assert_msg_ex(me->tag == CEU_BTREE_SELECTOR, "invalid tag", file, line);
    return me;
}

void CEU_BTREE_SELECTOR_free (void* pool, CEU_BTree* me) {
    CEU_BTree_free(pool, me->SELECTOR.first);
    CEU_BTree_free(pool, me->SELECTOR.second);
    /* FREE (before ok_killed) */
#if    defined(CEU_ADTS_NEWS_POOL) && !defined(CEU_ADTS_NEWS_MALLOC)
            ceu_pool_free(pool, (void*)me);
#elif  defined(CEU_ADTS_NEWS_POOL) &&  defined(CEU_ADTS_NEWS_MALLOC)
            if (pool == NULL) {
                ceu_out_realloc(me, 0);
            } else {
                ceu_pool_free(pool, (void*)me);
            }
#elif !defined(CEU_ADTS_NEWS_POOL) &&  defined(CEU_ADTS_NEWS_MALLOC)
            ceu_out_realloc(me, 0);
#endif
}

CEU_BTree* CEU_BTREE_LEAF_assert (tceu_app* app, CEU_BTree* me, char* file, int line) {
    ceu_out_assert_msg_ex(me->tag == CEU_BTREE_LEAF, "invalid tag", file, line);
    return me;
}

void CEU_BTREE_LEAF_free (void* pool, CEU_BTree* me) {
    /* FREE (before ok_killed) */
#if    defined(CEU_ADTS_NEWS_POOL) && !defined(CEU_ADTS_NEWS_MALLOC)
            ceu_pool_free(pool, (void*)me);
#elif  defined(CEU_ADTS_NEWS_POOL) &&  defined(CEU_ADTS_NEWS_MALLOC)
            if (pool == NULL) {
                ceu_out_realloc(me, 0);
            } else {
                ceu_pool_free(pool, (void*)me);
            }
#elif !defined(CEU_ADTS_NEWS_POOL) &&  defined(CEU_ADTS_NEWS_MALLOC)
            ceu_out_realloc(me, 0);
#endif
}

void CEU_BTree_free (void* pool, CEU_BTree* me) {
    switch (me->tag) {
        case CEU_BTREE_NIL:
            /* base case */
            break;
        case CEU_BTREE_SEQUENCE:
            CEU_BTREE_SEQUENCE_free(pool, me);
            break;
        case CEU_BTREE_SELECTOR:
            CEU_BTREE_SELECTOR_free(pool, me);
            break;
        case CEU_BTREE_LEAF:
            CEU_BTREE_LEAF_free(pool, me);
            break;
#ifdef CEU_DEBUG
        default:
            ceu_out_assert_msg(0, "invalid tag");
#endif
    }
}



void CEU__Option__Body_225__ptr_free (void* pool, CEU__Option__Body_225__ptr* me);

CEU__Option__Body_225__ptr* CEU__OPTION__BODY_225__PTR_NIL_assert (tceu_app* app, CEU__Option__Body_225__ptr* me, char* file, int line) {
    ceu_out_assert_msg_ex(me->tag == CEU__OPTION__BODY_225__PTR_NIL, "invalid tag", file, line);
    return me;
}

void CEU__OPTION__BODY_225__PTR_NIL_free (void* pool, CEU__Option__Body_225__ptr* me) {
    /* FREE (before ok_killed) */
#if    defined(CEU_ADTS_NEWS_POOL) && !defined(CEU_ADTS_NEWS_MALLOC)
            ceu_pool_free(pool, (void*)me);
#elif  defined(CEU_ADTS_NEWS_POOL) &&  defined(CEU_ADTS_NEWS_MALLOC)
            if (pool == NULL) {
                ceu_out_realloc(me, 0);
            } else {
                ceu_pool_free(pool, (void*)me);
            }
#elif !defined(CEU_ADTS_NEWS_POOL) &&  defined(CEU_ADTS_NEWS_MALLOC)
            ceu_out_realloc(me, 0);
#endif
}

CEU__Option__Body_225__ptr* CEU__OPTION__BODY_225__PTR_SOME_assert (tceu_app* app, CEU__Option__Body_225__ptr* me, char* file, int line) {
    ceu_out_assert_msg_ex(me->tag == CEU__OPTION__BODY_225__PTR_SOME, "invalid tag", file, line);
    return me;
}

void CEU__OPTION__BODY_225__PTR_SOME_free (void* pool, CEU__Option__Body_225__ptr* me) {
    /* FREE (before ok_killed) */
#if    defined(CEU_ADTS_NEWS_POOL) && !defined(CEU_ADTS_NEWS_MALLOC)
            ceu_pool_free(pool, (void*)me);
#elif  defined(CEU_ADTS_NEWS_POOL) &&  defined(CEU_ADTS_NEWS_MALLOC)
            if (pool == NULL) {
                ceu_out_realloc(me, 0);
            } else {
                ceu_pool_free(pool, (void*)me);
            }
#elif !defined(CEU_ADTS_NEWS_POOL) &&  defined(CEU_ADTS_NEWS_MALLOC)
            ceu_out_realloc(me, 0);
#endif
}

void CEU__Option__Body_225__ptr_free (void* pool, CEU__Option__Body_225__ptr* me) {
    switch (me->tag) {
        case CEU__OPTION__BODY_225__PTR_NIL:
            CEU__OPTION__BODY_225__PTR_NIL_free(pool, me);
            break;
        case CEU__OPTION__BODY_225__PTR_SOME:
            CEU__OPTION__BODY_225__PTR_SOME_free(pool, me);
            break;
#ifdef CEU_DEBUG
        default:
            ceu_out_assert_msg(0, "invalid tag");
#endif
    }
}

CEU__Option__Body_225__ptr CEU__OPTION__BODY_225__PTR_pack (struct CEU_Body_225* ptr) {
    CEU__Option__Body_225__ptr ret;
    if (ptr == NULL) {
        ret.tag = CEU__OPTION__BODY_225__PTR_NIL;
    } else {
        ret.tag = CEU__OPTION__BODY_225__PTR_SOME;
        ret.SOME.v = ptr;
    }
    return ret;
}
#if 0
// TODO: now requires explicit conversions
struct CEU_Body_225* CEU__OPTION__BODY_225__PTR_unpack (CEU__Option__Body_225__ptr me) {
    if (me.tag == CEU__OPTION__BODY_225__PTR_NIL) {
        return NULL;
    } else {
        return me.SOME.v;
    }
}
#endif




/**********************************************************************/

#ifndef CEU_OS_APP
#ifdef CEU_DEBUG
tceu_app* CEU_APP_SIG = NULL;
static void ceu_segfault (int sig_num) {
#ifdef CEU_ORGS
    printf("SEGFAULT on %p : %d\n", CEU_APP_SIG->lst.org, CEU_APP_SIG->lst.lbl);
#else
    printf("SEGFAULT on %d\n", CEU_APP_SIG->lst.lbl);
#endif
    exit(0);
}
#endif
#endif

#ifdef CEU_RUNTESTS
static void ceu_stack_clr () {
    int a[1000];
    memset(a, 0, sizeof(a));
}
#endif

/**********************************************************************/

#ifdef CEU_ORGS

#endif

#ifdef CEU_ORGS
static void _ceu_constr_655 (tceu_app* _ceu_app, tceu_org* __ceu_this, tceu_org* _ceu_org) {
/* NODE: Dcl_constr 655 */
/* NODE: Block 654 */

#line 36 "btree-1.ceu"
    {/* NODE: Stmts 653 */

#line 36 "btree-1.ceu"
    {/* NODE: Set 681 */

#line 36 "btree-1.ceu"
/* SET: . *//* NODE: Op1_& 643 */

#line 36 "btree-1.ceu"
    (((*((CEU_Body_225*)__ceu_this))._bodies)) = (((*((CEU_Body_225*)_ceu_org))._bodies));/* NODE: Set 682 */

#line 36 "btree-1.ceu"
/* SET: . *//* NODE: Op1_&& 648 */

#line 36 "btree-1.ceu"
    (((*((CEU_Body_225*)__ceu_this))._parent)) = (&((CEU_Body_225*)_ceu_org)->_s_16);/* NODE: Set 683 */

#line 36 "btree-1.ceu"
/* SET: . *//* NODE: Op1_&& 150 */

#line 36 "btree-1.ceu"
    #ifdef CEU_ADTS_NEWS_POOL
(&((*((CEU_Body_225*)__ceu_this)).t))->pool = (&((CEU_Body_225*)_ceu_org)->t)->pool;
#endif
(&((*((CEU_Body_225*)__ceu_this)).t))->root = ((((CEU_BTREE_SEQUENCE_assert(_ceu_app, (((CEU_BTree *)(  ((tceu_pool_adts*) (&((CEU_Body_225*)_ceu_org)->t))->root))), __FILE__, __LINE__)->SEQUENCE)).first));

#line 36 "btree-1.ceu"
    }
#line 36 "btree-1.ceu"
/* CLEAR: Block (36) */
#line 36 "btree-1.ceu"
    if (0) {

#line 36 "btree-1.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
}
static void _ceu_constr_765 (tceu_app* _ceu_app, tceu_org* __ceu_this, tceu_org* _ceu_org) {
/* NODE: Dcl_constr 765 */
/* NODE: Block 764 */

#line 40 "btree-1.ceu"
    {/* NODE: Stmts 763 */

#line 40 "btree-1.ceu"
    {/* NODE: Set 791 */

#line 40 "btree-1.ceu"
/* SET: . *//* NODE: Op1_& 753 */

#line 40 "btree-1.ceu"
    (((*((CEU_Body_225*)__ceu_this))._bodies)) = (((*((CEU_Body_225*)_ceu_org))._bodies));/* NODE: Set 792 */

#line 40 "btree-1.ceu"
/* SET: . *//* NODE: Op1_&& 758 */

#line 40 "btree-1.ceu"
    (((*((CEU_Body_225*)__ceu_this))._parent)) = (&((CEU_Body_225*)_ceu_org)->_s_18);/* NODE: Set 793 */

#line 40 "btree-1.ceu"
/* SET: . *//* NODE: Op1_&& 165 */

#line 40 "btree-1.ceu"
    #ifdef CEU_ADTS_NEWS_POOL
(&((*((CEU_Body_225*)__ceu_this)).t))->pool = (&((CEU_Body_225*)_ceu_org)->t)->pool;
#endif
(&((*((CEU_Body_225*)__ceu_this)).t))->root = ((((CEU_BTREE_SEQUENCE_assert(_ceu_app, (((CEU_BTree *)(  ((tceu_pool_adts*) (&((CEU_Body_225*)_ceu_org)->t))->root))), __FILE__, __LINE__)->SEQUENCE)).second));

#line 40 "btree-1.ceu"
    }
#line 40 "btree-1.ceu"
/* CLEAR: Block (40) */
#line 40 "btree-1.ceu"
    if (0) {

#line 40 "btree-1.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
}
static void _ceu_constr_880 (tceu_app* _ceu_app, tceu_org* __ceu_this, tceu_org* _ceu_org) {
/* NODE: Dcl_constr 880 */
/* NODE: Block 879 */

#line 43 "btree-1.ceu"
    {/* NODE: Stmts 878 */

#line 43 "btree-1.ceu"
    {/* NODE: Set 906 */

#line 43 "btree-1.ceu"
/* SET: . *//* NODE: Op1_& 868 */

#line 43 "btree-1.ceu"
    (((*((CEU_Body_225*)__ceu_this))._bodies)) = (((*((CEU_Body_225*)_ceu_org))._bodies));/* NODE: Set 907 */

#line 43 "btree-1.ceu"
/* SET: . *//* NODE: Op1_&& 873 */

#line 43 "btree-1.ceu"
    (((*((CEU_Body_225*)__ceu_this))._parent)) = (&((CEU_Body_225*)_ceu_org)->_s_21);/* NODE: Set 908 */

#line 43 "btree-1.ceu"
/* SET: . *//* NODE: Op1_&& 178 */

#line 43 "btree-1.ceu"
    #ifdef CEU_ADTS_NEWS_POOL
(&((*((CEU_Body_225*)__ceu_this)).t))->pool = (&((CEU_Body_225*)_ceu_org)->t)->pool;
#endif
(&((*((CEU_Body_225*)__ceu_this)).t))->root = ((((CEU_BTREE_SELECTOR_assert(_ceu_app, (((CEU_BTree *)(  ((tceu_pool_adts*) (&((CEU_Body_225*)_ceu_org)->t))->root))), __FILE__, __LINE__)->SELECTOR)).first));

#line 43 "btree-1.ceu"
    }
#line 43 "btree-1.ceu"
/* CLEAR: Block (43) */
#line 43 "btree-1.ceu"
    if (0) {

#line 43 "btree-1.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
}
static void _ceu_constr_995 (tceu_app* _ceu_app, tceu_org* __ceu_this, tceu_org* _ceu_org) {
/* NODE: Dcl_constr 995 */
/* NODE: Block 994 */

#line 47 "btree-1.ceu"
    {/* NODE: Stmts 993 */

#line 47 "btree-1.ceu"
    {/* NODE: Set 1021 */

#line 47 "btree-1.ceu"
/* SET: . *//* NODE: Op1_& 983 */

#line 47 "btree-1.ceu"
    (((*((CEU_Body_225*)__ceu_this))._bodies)) = (((*((CEU_Body_225*)_ceu_org))._bodies));/* NODE: Set 1022 */

#line 47 "btree-1.ceu"
/* SET: . *//* NODE: Op1_&& 988 */

#line 47 "btree-1.ceu"
    (((*((CEU_Body_225*)__ceu_this))._parent)) = (&((CEU_Body_225*)_ceu_org)->_s_24);/* NODE: Set 1023 */

#line 47 "btree-1.ceu"
/* SET: . *//* NODE: Op1_&& 193 */

#line 47 "btree-1.ceu"
    #ifdef CEU_ADTS_NEWS_POOL
(&((*((CEU_Body_225*)__ceu_this)).t))->pool = (&((CEU_Body_225*)_ceu_org)->t)->pool;
#endif
(&((*((CEU_Body_225*)__ceu_this)).t))->root = ((((CEU_BTREE_SELECTOR_assert(_ceu_app, (((CEU_BTree *)(  ((tceu_pool_adts*) (&((CEU_Body_225*)_ceu_org)->t))->root))), __FILE__, __LINE__)->SELECTOR)).second));

#line 47 "btree-1.ceu"
    }
#line 47 "btree-1.ceu"
/* CLEAR: Block (47) */
#line 47 "btree-1.ceu"
    if (0) {

#line 47 "btree-1.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
}
static void _ceu_constr_212 (tceu_app* _ceu_app, tceu_org* __ceu_this, tceu_org* _ceu_org) {
/* NODE: Dcl_constr 212 */
/* NODE: Block 211 */

#line 52 "btree-1.ceu"
    {/* NODE: Stmts 210 */

#line 52 "btree-1.ceu"
    {/* NODE: Set 1099 */

#line 52 "btree-1.ceu"
/* SET: . *//* NODE: Op1_& 208 */

#line 52 "btree-1.ceu"
    (((*((CEU_LeafHandler*)__ceu_this)).leaf)) = (&(((CEU_BTREE_LEAF_assert(_ceu_app, (((CEU_BTree *)(  ((tceu_pool_adts*) (&((CEU_Body_225*)_ceu_org)->t))->root))), __FILE__, __LINE__)->LEAF)).leaf));
#line 52 "btree-1.ceu"
    }
#line 52 "btree-1.ceu"
/* CLEAR: Block (52) */
#line 52 "btree-1.ceu"
    if (0) {

#line 52 "btree-1.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
}
static void _ceu_constr_503 (tceu_app* _ceu_app, tceu_org* __ceu_this, tceu_org* _ceu_org) {
/* NODE: Dcl_constr 503 */
/* NODE: Block 502 */

#line 33 "btree-1.ceu"
    {/* NODE: Stmts 501 */

#line 33 "btree-1.ceu"
    {/* NODE: Set 1159 */

#line 33 "btree-1.ceu"
/* SET: . *//* NODE: Op1_& 491 */

#line 33 "btree-1.ceu"
    (((*((CEU_Body_225*)__ceu_this))._bodies)) = (&((CEU_BTreeTraverse*)_ceu_org)->_pool_225);/* NODE: Set 1160 */

#line 33 "btree-1.ceu"
/* SET: . *//* NODE: Op1_&& 496 */

#line 33 "btree-1.ceu"
    (((*((CEU_Body_225*)__ceu_this))._parent)) = (&((CEU_BTreeTraverse*)_ceu_org)->_s_10);/* NODE: Set 1161 */

#line 33 "btree-1.ceu"
/* SET: . *//* NODE: Op1_&& 460 */

#line 33 "btree-1.ceu"
    #ifdef CEU_ADTS_NEWS_POOL
(&((*((CEU_Body_225*)__ceu_this)).t))->pool = (*((CEU_BTreeTraverse*)_ceu_org)->btree).pool;
#endif
(&((*((CEU_Body_225*)__ceu_this)).t))->root = ((CEU_BTree *)(  ((tceu_pool_adts*) (((CEU_BTreeTraverse*)_ceu_org)->btree))->root));

#line 33 "btree-1.ceu"
    }
#line 33 "btree-1.ceu"
/* CLEAR: Block (33) */
#line 33 "btree-1.ceu"
    if (0) {

#line 33 "btree-1.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
}
static void _ceu_constr_285 (tceu_app* _ceu_app, tceu_org* __ceu_this, tceu_org* _ceu_org) {
/* NODE: Dcl_constr 285 */
/* NODE: Block 284 */

#line 68 "chaser.ceu"
    {/* NODE: Stmts 283 */

#line 68 "chaser.ceu"
    {/* NODE: Set 1270 */

#line 68 "chaser.ceu"
/* SET: . *//* NODE: Op1_& 281 */

#line 68 "chaser.ceu"
    (((*((CEU_BTreeTraverse*)__ceu_this)).btree)) = ((tceu_pool_adts*)(&((CEU_Main*)_ceu_org)->x_behavior_6));

#line 68 "chaser.ceu"
    }
#line 68 "chaser.ceu"
/* CLEAR: Block (68) */
#line 68 "chaser.ceu"
    if (0) {

#line 68 "chaser.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
}
static void _ceu_constr_345 (tceu_app* _ceu_app, tceu_org* __ceu_this, tceu_org* _ceu_org) {
/* NODE: Dcl_constr 345 */
/* NODE: Block 344 */

#line 81 "chaser.ceu"
    {/* NODE: Stmts 343 */

#line 81 "chaser.ceu"
    {/* NODE: Set 1345 */

#line 81 "chaser.ceu"
/* SET: . *//* NODE: Op1_& 341 */

#line 81 "chaser.ceu"
    (((*((CEU_BTreeTraverse*)__ceu_this)).btree)) = ((tceu_pool_adts*)(&((CEU_Main*)_ceu_org)->y_behavior_8));

#line 81 "chaser.ceu"
    }
#line 81 "chaser.ceu"
/* CLEAR: Block (81) */
#line 81 "chaser.ceu"
    if (0) {

#line 81 "chaser.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
}

#endif

#ifdef CEU_THREADS
/* THREADS_C */

#endif

/* FUNCTIONS_C */


#ifdef CEU_OS_APP
static void* ceu_app_calls (tceu_app* _ceu_app, tceu_nevt evt, void* param) {
    switch (evt) {
        /* STUBS */
        
        /*
        case CEU_IN_XXX:
            return CEU_Main_XXX(param);
        */
        default:;
#ifdef CEU_DEBUG
        ceu_out_log(0, (long)"invalid call\n");
#endif
    }
    return NULL;
}
#endif

static void ceu_app_go (tceu_app* _ceu_app, tceu_evt* _ceu_evt, tceu_org* _ceu_org, tceu_trl* _ceu_trl,
                        tceu_stk* _ceu_stk)
{
    tceu_nlbl _ceu_lbl = _ceu_trl->lbl;

#ifdef CEU_GOTO
_CEU_GOTO_:
#endif

#ifdef CEU_DEBUG
#ifndef CEU_OS_APP
#ifdef CEU_ORGS
    _ceu_app->lst.org = _ceu_org;
#endif
    _ceu_app->lst.trl = _ceu_trl;
    _ceu_app->lst.lbl = _ceu_lbl;
#endif
#ifdef CEU_DEBUG_TRAILS
#ifndef CEU_OS_APP
printf("OK : lbl=%d : org=%p\n", _ceu_lbl, _ceu_org);
#endif
#endif
#endif

#ifdef CEU_RUNTESTS
    ceu_stack_clr();
#endif

    switch (_ceu_lbl) {
        /* NODE: Root 368 */
/* NODE: Dcl_cls 0 */

#line 1 "chaser.ceu"
case Class_Main:;/* NODE: Block 1374 */

#line 1 "chaser.ceu"
    {/* NODE: Stmts 1373 */

#line 1 "chaser.ceu"
    {/* NODE: Block 374 */

#line 1 "chaser.ceu"
    {
#line 1 "chaser.ceu"
    #ifdef CEU_RET

#line 1 "chaser.ceu"
    int __ceu__ret_0;

#line 1 "chaser.ceu"
    #endif
/* NODE: Stmts 373 */

#line 1 "chaser.ceu"
    {/* NODE: Dcl_var 370 */
/* NODE: SetBlock 372 */
/* NODE: Block 366 */

#line 1 "chaser.ceu"
    {/* NODE: Stmts 365 */

#line 1 "chaser.ceu"
    {/* NODE: Stmts 362 */

#line 1 "chaser.ceu"
    {/* NODE: Block 355 */

#line 1 "chaser.ceu"
    {/* NODE: Stmts 353 */

#line 1 "chaser.ceu"
    {/* NODE: Stmts 378 */

#line 1 "chaser.ceu"
    {/* NODE: Dcl_ext 377 */

#line 1 "chaser.ceu"
    }/* NODE: Dcl_adt 11 */
/* NODE: Stmts 425 */

#line 23 "chaser.ceu"
    {
#line 23 "chaser.ceu"
    }/* NODE: Dcl_adt 134 */
/* NODE: Stmts 1222 */

#line 29 "btree-1.ceu"
    {
#line 29 "btree-1.ceu"
    }/* NODE: ParEver 352 */

#line 58 "chaser.ceu"
/* ParEver: spawn subs */
#line 58 "chaser.ceu"
    {
    tceu_stk stk_ = { NULL, _ceu_org, 0, 10, {} };
    if (setjmp(stk_.jmp) != 0) {
#ifdef CEU_ORGS
        _ceu_org = _ceu_app->stk_jmp.org;
#endif
        _ceu_trl = _ceu_app->stk_jmp.trl;

#line 58 "chaser.ceu"
    _ceu_lbl = _ceu_app->stk_jmp.lbl;
goto _CEU_GOTO_;

#line 58 "chaser.ceu"
        }

    /* SETJMP: starting trails in a par
     * The 1st trail might abort an enclosing par/or, or emit something that 
     * does.
     */

#line 58 "chaser.ceu"
        _ceu_org->trls[ 0 ].lbl = Main_ParEver_sub_1_41;
    _ceu_stk->up = &stk_;
    ceu_app_go(_ceu_app,NULL,_ceu_org,
               &_ceu_org->trls[ 0 ],
               &stk_);
    _ceu_stk->up = NULL;

#line 58 "chaser.ceu"
        _ceu_trl = &_ceu_org->trls[ 4 ];

#line 58 "chaser.ceu"
    }
/* NODE: Block 351 */

#line 72 "chaser.ceu"
    /*  FINALIZE */
_ceu_org->trls[ 7 ].evt = CEU_IN__CLEAR;
_ceu_org->trls[ 7 ].lbl = Main_Block__fin_52;

#line 72 "chaser.ceu"
    {
#line 72 "chaser.ceu"
    #ifdef CEU_ADTS_NEWS_POOL
(&((CEU_Main*)_ceu_org)->y_behavior_8)->pool = NULL;
#endif

#line 72 "chaser.ceu"
    (&((CEU_Main*)_ceu_org)->y_behavior_8)->root = &CEU_BTREE_BASE;

/*  FINALIZE ADT */
_ceu_org->trls[ 4 ].evt = CEU_IN__CLEAR;
_ceu_org->trls[ 4 ].lbl = Main_adt_fin_kill_free_53;

#line 72 "chaser.ceu"
    _ceu_trl = &_ceu_org->trls[ 5 ];
/* NODE: Stmts 350 */

#line 72 "chaser.ceu"
    {/* NODE: Stmts 1302 */

#line 72 "chaser.ceu"
    {/* NODE: Dcl_pool 1299 */
/* NODE: Set 1303 */

#line 72 "chaser.ceu"
/* SET: y_behavior *//* NODE: Adt_constr_root 335 */

#line 73 "chaser.ceu"
    {
#line 73 "chaser.ceu"
    {
    void* __ceu_old = ((CEU_BTree *)(  ((tceu_pool_adts*) (&((CEU_Main*)_ceu_org)->y_behavior_8))->root));    /* will kill/free old */

#line 73 "chaser.ceu"
    #ifdef CEU_ADTS_NEWS_POOL
    tceu_org* __ceu_stk_org = _ceu_org;
#endif
/* NODE: Adt_constr_one 334 */

#line 73 "chaser.ceu"
    CEU_BTree* __ceu_adt_334;

#line 73 "chaser.ceu"
    #if defined(CEU_ADTS_NEWS_MALLOC) && defined(CEU_ADTS_NEWS_POOL)
if (((&((CEU_Main*)_ceu_org)->y_behavior_8)->pool) == NULL) {
    __ceu_adt_334 = (CEU_BTree*) ceu_out_realloc(NULL, sizeof(CEU_BTree));
} else {
    __ceu_adt_334 = (CEU_BTree*) ceu_pool_alloc((tceu_pool*)((&((CEU_Main*)_ceu_org)->y_behavior_8)->pool));
}
#elif defined(CEU_ADTS_NEWS_MALLOC)
    __ceu_adt_334 = (CEU_BTree*) ceu_out_realloc(NULL, sizeof(CEU_BTree));
#elif defined(CEU_ADTS_NEWS_POOL)
    __ceu_adt_334 = (CEU_BTree*) ceu_pool_alloc((tceu_pool*)((&((CEU_Main*)_ceu_org)->y_behavior_8)->pool));
#endif

#line 73 "chaser.ceu"
    if (__ceu_adt_334 == NULL) {
    __ceu_adt_334 = &CEU_BTREE_BASE;
} else  /* rely on {,} that follows */

#line 73 "chaser.ceu"
    {/* NODE: ExpList 333 */
/* NODE: Adt_constr_one 308 */

#line 74 "chaser.ceu"
    CEU_BTree* __ceu_adt_308;

#line 74 "chaser.ceu"
    #if defined(CEU_ADTS_NEWS_MALLOC) && defined(CEU_ADTS_NEWS_POOL)
if (((&((CEU_Main*)_ceu_org)->y_behavior_8)->pool) == NULL) {
    __ceu_adt_308 = (CEU_BTree*) ceu_out_realloc(NULL, sizeof(CEU_BTree));
} else {
    __ceu_adt_308 = (CEU_BTree*) ceu_pool_alloc((tceu_pool*)((&((CEU_Main*)_ceu_org)->y_behavior_8)->pool));
}
#elif defined(CEU_ADTS_NEWS_MALLOC)
    __ceu_adt_308 = (CEU_BTree*) ceu_out_realloc(NULL, sizeof(CEU_BTree));
#elif defined(CEU_ADTS_NEWS_POOL)
    __ceu_adt_308 = (CEU_BTree*) ceu_pool_alloc((tceu_pool*)((&((CEU_Main*)_ceu_org)->y_behavior_8)->pool));
#endif

#line 74 "chaser.ceu"
    if (__ceu_adt_308 == NULL) {
    __ceu_adt_308 = &CEU_BTREE_BASE;
} else  /* rely on {,} that follows */

#line 74 "chaser.ceu"
    {/* NODE: ExpList 307 */
/* NODE: Adt_constr_one 300 */

#line 74 "chaser.ceu"
    CEU_BTree* __ceu_adt_300;

#line 74 "chaser.ceu"
    #if defined(CEU_ADTS_NEWS_MALLOC) && defined(CEU_ADTS_NEWS_POOL)
if (((&((CEU_Main*)_ceu_org)->y_behavior_8)->pool) == NULL) {
    __ceu_adt_300 = (CEU_BTree*) ceu_out_realloc(NULL, sizeof(CEU_BTree));
} else {
    __ceu_adt_300 = (CEU_BTree*) ceu_pool_alloc((tceu_pool*)((&((CEU_Main*)_ceu_org)->y_behavior_8)->pool));
}
#elif defined(CEU_ADTS_NEWS_MALLOC)
    __ceu_adt_300 = (CEU_BTree*) ceu_out_realloc(NULL, sizeof(CEU_BTree));
#elif defined(CEU_ADTS_NEWS_POOL)
    __ceu_adt_300 = (CEU_BTree*) ceu_pool_alloc((tceu_pool*)((&((CEU_Main*)_ceu_org)->y_behavior_8)->pool));
#endif

#line 74 "chaser.ceu"
    if (__ceu_adt_300 == NULL) {
    __ceu_adt_300 = &CEU_BTREE_BASE;
} else  /* rely on {,} that follows */

#line 74 "chaser.ceu"
    {/* NODE: ExpList 299 */
/* NODE: Adt_constr_one 298 */

#line 74 "chaser.ceu"
    CEU_Leaf __ceu_adt_298;

#line 74 "chaser.ceu"
    {/* NODE: ExpList 297 */

#line 74 "chaser.ceu"
    __ceu_adt_298.tag = CEU_LEAF_SENSEUP;
#line 74 "chaser.ceu"
    }
#line 74 "chaser.ceu"
    __ceu_adt_300->tag = CEU_BTREE_LEAF;
#line 74 "chaser.ceu"
    __ceu_adt_300->LEAF.leaf = __ceu_adt_298;
#line 74 "chaser.ceu"
    }/* NODE: Adt_constr_one 306 */

#line 74 "chaser.ceu"
    CEU_BTree* __ceu_adt_306;

#line 74 "chaser.ceu"
    #if defined(CEU_ADTS_NEWS_MALLOC) && defined(CEU_ADTS_NEWS_POOL)
if (((&((CEU_Main*)_ceu_org)->y_behavior_8)->pool) == NULL) {
    __ceu_adt_306 = (CEU_BTree*) ceu_out_realloc(NULL, sizeof(CEU_BTree));
} else {
    __ceu_adt_306 = (CEU_BTree*) ceu_pool_alloc((tceu_pool*)((&((CEU_Main*)_ceu_org)->y_behavior_8)->pool));
}
#elif defined(CEU_ADTS_NEWS_MALLOC)
    __ceu_adt_306 = (CEU_BTree*) ceu_out_realloc(NULL, sizeof(CEU_BTree));
#elif defined(CEU_ADTS_NEWS_POOL)
    __ceu_adt_306 = (CEU_BTree*) ceu_pool_alloc((tceu_pool*)((&((CEU_Main*)_ceu_org)->y_behavior_8)->pool));
#endif

#line 74 "chaser.ceu"
    if (__ceu_adt_306 == NULL) {
    __ceu_adt_306 = &CEU_BTREE_BASE;
} else  /* rely on {,} that follows */

#line 74 "chaser.ceu"
    {/* NODE: ExpList 305 */
/* NODE: Adt_constr_one 304 */

#line 74 "chaser.ceu"
    CEU_Leaf __ceu_adt_304;

#line 74 "chaser.ceu"
    {/* NODE: ExpList 303 */

#line 74 "chaser.ceu"
    __ceu_adt_304.tag = CEU_LEAF_GOUP;
#line 74 "chaser.ceu"
    }
#line 74 "chaser.ceu"
    __ceu_adt_306->tag = CEU_BTREE_LEAF;
#line 74 "chaser.ceu"
    __ceu_adt_306->LEAF.leaf = __ceu_adt_304;
#line 74 "chaser.ceu"
    }
#line 74 "chaser.ceu"
    __ceu_adt_308->tag = CEU_BTREE_SEQUENCE;
#line 74 "chaser.ceu"
    __ceu_adt_308->SEQUENCE.first = __ceu_adt_300;
#line 74 "chaser.ceu"
    __ceu_adt_308->SEQUENCE.second = __ceu_adt_306;
#line 74 "chaser.ceu"
    }/* NODE: Adt_constr_one 332 */

#line 75 "chaser.ceu"
    CEU_BTree* __ceu_adt_332;

#line 75 "chaser.ceu"
    #if defined(CEU_ADTS_NEWS_MALLOC) && defined(CEU_ADTS_NEWS_POOL)
if (((&((CEU_Main*)_ceu_org)->y_behavior_8)->pool) == NULL) {
    __ceu_adt_332 = (CEU_BTree*) ceu_out_realloc(NULL, sizeof(CEU_BTree));
} else {
    __ceu_adt_332 = (CEU_BTree*) ceu_pool_alloc((tceu_pool*)((&((CEU_Main*)_ceu_org)->y_behavior_8)->pool));
}
#elif defined(CEU_ADTS_NEWS_MALLOC)
    __ceu_adt_332 = (CEU_BTree*) ceu_out_realloc(NULL, sizeof(CEU_BTree));
#elif defined(CEU_ADTS_NEWS_POOL)
    __ceu_adt_332 = (CEU_BTree*) ceu_pool_alloc((tceu_pool*)((&((CEU_Main*)_ceu_org)->y_behavior_8)->pool));
#endif

#line 75 "chaser.ceu"
    if (__ceu_adt_332 == NULL) {
    __ceu_adt_332 = &CEU_BTREE_BASE;
} else  /* rely on {,} that follows */

#line 75 "chaser.ceu"
    {/* NODE: ExpList 331 */
/* NODE: Adt_constr_one 324 */

#line 76 "chaser.ceu"
    CEU_BTree* __ceu_adt_324;

#line 76 "chaser.ceu"
    #if defined(CEU_ADTS_NEWS_MALLOC) && defined(CEU_ADTS_NEWS_POOL)
if (((&((CEU_Main*)_ceu_org)->y_behavior_8)->pool) == NULL) {
    __ceu_adt_324 = (CEU_BTree*) ceu_out_realloc(NULL, sizeof(CEU_BTree));
} else {
    __ceu_adt_324 = (CEU_BTree*) ceu_pool_alloc((tceu_pool*)((&((CEU_Main*)_ceu_org)->y_behavior_8)->pool));
}
#elif defined(CEU_ADTS_NEWS_MALLOC)
    __ceu_adt_324 = (CEU_BTree*) ceu_out_realloc(NULL, sizeof(CEU_BTree));
#elif defined(CEU_ADTS_NEWS_POOL)
    __ceu_adt_324 = (CEU_BTree*) ceu_pool_alloc((tceu_pool*)((&((CEU_Main*)_ceu_org)->y_behavior_8)->pool));
#endif

#line 76 "chaser.ceu"
    if (__ceu_adt_324 == NULL) {
    __ceu_adt_324 = &CEU_BTREE_BASE;
} else  /* rely on {,} that follows */

#line 76 "chaser.ceu"
    {/* NODE: ExpList 323 */
/* NODE: Adt_constr_one 316 */

#line 76 "chaser.ceu"
    CEU_BTree* __ceu_adt_316;

#line 76 "chaser.ceu"
    #if defined(CEU_ADTS_NEWS_MALLOC) && defined(CEU_ADTS_NEWS_POOL)
if (((&((CEU_Main*)_ceu_org)->y_behavior_8)->pool) == NULL) {
    __ceu_adt_316 = (CEU_BTree*) ceu_out_realloc(NULL, sizeof(CEU_BTree));
} else {
    __ceu_adt_316 = (CEU_BTree*) ceu_pool_alloc((tceu_pool*)((&((CEU_Main*)_ceu_org)->y_behavior_8)->pool));
}
#elif defined(CEU_ADTS_NEWS_MALLOC)
    __ceu_adt_316 = (CEU_BTree*) ceu_out_realloc(NULL, sizeof(CEU_BTree));
#elif defined(CEU_ADTS_NEWS_POOL)
    __ceu_adt_316 = (CEU_BTree*) ceu_pool_alloc((tceu_pool*)((&((CEU_Main*)_ceu_org)->y_behavior_8)->pool));
#endif

#line 76 "chaser.ceu"
    if (__ceu_adt_316 == NULL) {
    __ceu_adt_316 = &CEU_BTREE_BASE;
} else  /* rely on {,} that follows */

#line 76 "chaser.ceu"
    {/* NODE: ExpList 315 */
/* NODE: Adt_constr_one 314 */

#line 76 "chaser.ceu"
    CEU_Leaf __ceu_adt_314;

#line 76 "chaser.ceu"
    {/* NODE: ExpList 313 */

#line 76 "chaser.ceu"
    __ceu_adt_314.tag = CEU_LEAF_SENSEDOWN;
#line 76 "chaser.ceu"
    }
#line 76 "chaser.ceu"
    __ceu_adt_316->tag = CEU_BTREE_LEAF;
#line 76 "chaser.ceu"
    __ceu_adt_316->LEAF.leaf = __ceu_adt_314;
#line 76 "chaser.ceu"
    }/* NODE: Adt_constr_one 322 */

#line 76 "chaser.ceu"
    CEU_BTree* __ceu_adt_322;

#line 76 "chaser.ceu"
    #if defined(CEU_ADTS_NEWS_MALLOC) && defined(CEU_ADTS_NEWS_POOL)
if (((&((CEU_Main*)_ceu_org)->y_behavior_8)->pool) == NULL) {
    __ceu_adt_322 = (CEU_BTree*) ceu_out_realloc(NULL, sizeof(CEU_BTree));
} else {
    __ceu_adt_322 = (CEU_BTree*) ceu_pool_alloc((tceu_pool*)((&((CEU_Main*)_ceu_org)->y_behavior_8)->pool));
}
#elif defined(CEU_ADTS_NEWS_MALLOC)
    __ceu_adt_322 = (CEU_BTree*) ceu_out_realloc(NULL, sizeof(CEU_BTree));
#elif defined(CEU_ADTS_NEWS_POOL)
    __ceu_adt_322 = (CEU_BTree*) ceu_pool_alloc((tceu_pool*)((&((CEU_Main*)_ceu_org)->y_behavior_8)->pool));
#endif

#line 76 "chaser.ceu"
    if (__ceu_adt_322 == NULL) {
    __ceu_adt_322 = &CEU_BTREE_BASE;
} else  /* rely on {,} that follows */

#line 76 "chaser.ceu"
    {/* NODE: ExpList 321 */
/* NODE: Adt_constr_one 320 */

#line 76 "chaser.ceu"
    CEU_Leaf __ceu_adt_320;

#line 76 "chaser.ceu"
    {/* NODE: ExpList 319 */

#line 76 "chaser.ceu"
    __ceu_adt_320.tag = CEU_LEAF_GODOWN;
#line 76 "chaser.ceu"
    }
#line 76 "chaser.ceu"
    __ceu_adt_322->tag = CEU_BTREE_LEAF;
#line 76 "chaser.ceu"
    __ceu_adt_322->LEAF.leaf = __ceu_adt_320;
#line 76 "chaser.ceu"
    }
#line 76 "chaser.ceu"
    __ceu_adt_324->tag = CEU_BTREE_SEQUENCE;
#line 76 "chaser.ceu"
    __ceu_adt_324->SEQUENCE.first = __ceu_adt_316;
#line 76 "chaser.ceu"
    __ceu_adt_324->SEQUENCE.second = __ceu_adt_322;
#line 76 "chaser.ceu"
    }/* NODE: Adt_constr_one 330 */

#line 77 "chaser.ceu"
    CEU_BTree* __ceu_adt_330;

#line 77 "chaser.ceu"
    #if defined(CEU_ADTS_NEWS_MALLOC) && defined(CEU_ADTS_NEWS_POOL)
if (((&((CEU_Main*)_ceu_org)->y_behavior_8)->pool) == NULL) {
    __ceu_adt_330 = (CEU_BTree*) ceu_out_realloc(NULL, sizeof(CEU_BTree));
} else {
    __ceu_adt_330 = (CEU_BTree*) ceu_pool_alloc((tceu_pool*)((&((CEU_Main*)_ceu_org)->y_behavior_8)->pool));
}
#elif defined(CEU_ADTS_NEWS_MALLOC)
    __ceu_adt_330 = (CEU_BTree*) ceu_out_realloc(NULL, sizeof(CEU_BTree));
#elif defined(CEU_ADTS_NEWS_POOL)
    __ceu_adt_330 = (CEU_BTree*) ceu_pool_alloc((tceu_pool*)((&((CEU_Main*)_ceu_org)->y_behavior_8)->pool));
#endif

#line 77 "chaser.ceu"
    if (__ceu_adt_330 == NULL) {
    __ceu_adt_330 = &CEU_BTREE_BASE;
} else  /* rely on {,} that follows */

#line 77 "chaser.ceu"
    {/* NODE: ExpList 329 */
/* NODE: Adt_constr_one 328 */

#line 77 "chaser.ceu"
    CEU_Leaf __ceu_adt_328;

#line 77 "chaser.ceu"
    {/* NODE: ExpList 327 */

#line 77 "chaser.ceu"
    __ceu_adt_328.tag = CEU_LEAF_SKIP;
#line 77 "chaser.ceu"
    }
#line 77 "chaser.ceu"
    __ceu_adt_330->tag = CEU_BTREE_LEAF;
#line 77 "chaser.ceu"
    __ceu_adt_330->LEAF.leaf = __ceu_adt_328;
#line 77 "chaser.ceu"
    }
#line 75 "chaser.ceu"
    __ceu_adt_332->tag = CEU_BTREE_SELECTOR;
#line 75 "chaser.ceu"
    __ceu_adt_332->SELECTOR.first = __ceu_adt_324;
#line 75 "chaser.ceu"
    __ceu_adt_332->SELECTOR.second = __ceu_adt_330;
#line 75 "chaser.ceu"
    }
#line 73 "chaser.ceu"
    __ceu_adt_334->tag = CEU_BTREE_SELECTOR;
#line 73 "chaser.ceu"
    __ceu_adt_334->SELECTOR.first = __ceu_adt_308;
#line 73 "chaser.ceu"
    __ceu_adt_334->SELECTOR.second = __ceu_adt_332;
#line 73 "chaser.ceu"
    }
#line 73 "chaser.ceu"
    (  ((tceu_pool_adts*) (&((CEU_Main*)_ceu_org)->y_behavior_8))->root) = __ceu_adt_334;

#line 73 "chaser.ceu"
                         /* 3. free */
    CEU_BTree_free(NULL, __ceu_old);

#line 73 "chaser.ceu"
    
#ifdef CEU_ADTS_AWAIT_BTree
    /* OK_KILLED (after free) */        /* 4. kill */
{
    tceu_stk stk_ = { NULL, _ceu_org, 5, 6, {} };
    if (setjmp(stk_.jmp) != 0) {
#ifdef CEU_ORGS
        _ceu_org = _ceu_app->stk_jmp.org;
#endif
        _ceu_trl = _ceu_app->stk_jmp.trl;

#line 73 "chaser.ceu"
    _ceu_lbl = _ceu_app->stk_jmp.lbl;
goto _CEU_GOTO_;

#line 73 "chaser.ceu"
        }

    /* SETJMP: mutating an adt
     * The mutation frees a subtree that might awake a par/or enclosing the 
     * call point.
     */
    {
        tceu_evt evt;
                 evt.id = CEU_IN__ok_killed;
                 evt.param = &__ceu_old;
        _ceu_stk->up = &stk_;
        ceu_sys_go_ex(_ceu_app, &evt, &stk_,
                      _ceu_app->data, &_ceu_app->data->trls[0], NULL);
        _ceu_stk->up = NULL;
    }
}
#endif

#line 73 "chaser.ceu"
    }

#line 73 "chaser.ceu"
    }
#line 72 "chaser.ceu"
    }/* NODE: Block 1310 */

#line 79 "chaser.ceu"
    {/* NODE: Stmts 1309 */

#line 79 "chaser.ceu"
    {/* NODE: Stmts 1308 */

#line 79 "chaser.ceu"
    {
#line 79 "chaser.ceu"
    }/* NODE: Loop 1307 */

#line 79 "chaser.ceu"
    for (;;) {
/* NODE: Block 348 */

#line 80 "chaser.ceu"
    {/* NODE: Stmts 347 */

#line 80 "chaser.ceu"
    {/* NODE: Stmts 1337 */

#line 79 "chaser.ceu"
    {/* NODE: Nothing 1311 */
/* NODE: Await 1304 */

#line 79 "chaser.ceu"
    _CEU_NO_1304_:
if (0) { goto _CEU_NO_1304_; /* avoids "not used" warning */ }

#line 79 "chaser.ceu"
    _ceu_trl->evt = CEU_IN_TICK;
_ceu_trl->lbl = Main_Awake_TICK_49;
_ceu_trl->seqno = _ceu_app->seqno;

#line 79 "chaser.ceu"
    return;

case Main_Awake_TICK_49:;

#line 79 "chaser.ceu"
    #ifdef CEU_DEBUG_TRAILS
#ifndef CEU_OS
printf("\tOK!\n");
#endif
#endif
/* NODE: Nothing 1473 */
/* NODE: Nothing 1474 */

#line 79 "chaser.ceu"
    }/* NODE: Do 1344 */
/* NODE: Block 1343 */

#line 80 "chaser.ceu"
    {
#line 80 "chaser.ceu"
    #ifdef CEU_ORGS
_ceu_org->trls[ 5 ].evt = CEU_IN__ORG;
_ceu_org->trls[ 5 ].org = NULL;
#endif

#line 80 "chaser.ceu"
    _ceu_trl = &_ceu_org->trls[ 6 ];
/* NODE: Stmts 1342 */

#line 80 "chaser.ceu"
    {/* NODE: Dcl_var 1341 */

#line 80 "chaser.ceu"
/* start org: _org_346 */
#line 80 "chaser.ceu"
        /* resets org memory and starts org.trail[0]=Class_XXX */
    /* TODO: BUG: _ceu_org is not necessarily the parent for pool allocations */
    ceu_out_org_init(_ceu_app, ((tceu_org*) &(((CEU_Main*)_ceu_org)->_org_346_9)),11,Class_BTreeTraverse,
                     2,
                     0,
                     _ceu_org,5);
/* TODO: currently idx is always "1" for all interfaces access because pools 
 * are all together there. When we have separate trls for pools, we'll have to 
 * indirectly access the offset in the interface. */

#line 80 "chaser.ceu"
        _ceu_constr_345(_ceu_app, ((tceu_org*) &(((CEU_Main*)_ceu_org)->_org_346_9)), _ceu_org);

#line 80 "chaser.ceu"
    {
    tceu_stk stk_ = { NULL, ((tceu_org*) &(((CEU_Main*)_ceu_org)->_org_346_9)), 0, ((tceu_org*) &(((CEU_Main*)_ceu_org)->_org_346_9))->n, {} };
    if (setjmp(stk_.jmp) != 0) {
#ifdef CEU_ORGS
        _ceu_org = _ceu_app->stk_jmp.org;
#endif
        _ceu_trl = _ceu_app->stk_jmp.trl;

#line 80 "chaser.ceu"
    _ceu_lbl = _ceu_app->stk_jmp.lbl;
goto _CEU_GOTO_;

#line 80 "chaser.ceu"
        }

    /* SETJMP: spawning a new org
     * The new org might emit a global event that awakes a par/or enclosing the 
     * call point.
     */
    _ceu_stk->up = &stk_;
    ceu_app_go(_ceu_app,NULL,
               ((tceu_org*) &(((CEU_Main*)_ceu_org)->_org_346_9)), &((tceu_org*) &(((CEU_Main*)_ceu_org)->_org_346_9))->trls[0],
               &stk_);
    _ceu_stk->up = NULL;

#line 80 "chaser.ceu"
    }
/* NODE: Stmts 1372 */

#line 80 "chaser.ceu"
    {/* NODE: Nothing 1346 */
/* NODE: Nothing 1476 */
/* NODE: Nothing 1477 */
/* NODE: Stmts 1371 */

#line 80 "chaser.ceu"
    {/* NODE: If 1370 */

#line 80 "chaser.ceu"
    if ((!(((*((tceu_org*)(&((CEU_Main*)_ceu_org)->_org_346_9))).isAlive)))) {
/* NODE: Block 1367 */

#line 80 "chaser.ceu"
    {/* NODE: Stmts 1366 */

#line 80 "chaser.ceu"
    {/* NODE: Nothing 1350 */

#line 80 "chaser.ceu"
    }
#line 80 "chaser.ceu"
/* CLEAR: Block (80) */
#line 80 "chaser.ceu"
    if (0) {

#line 80 "chaser.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
} else {
/* NODE: Block 1369 */

#line 80 "chaser.ceu"
    {/* NODE: Stmts 1368 */

#line 80 "chaser.ceu"
    {/* NODE: Await 1349 */

#line 80 "chaser.ceu"
    _CEU_NO_1349_:
if (0) { goto _CEU_NO_1349_; /* avoids "not used" warning */ }

#line 80 "chaser.ceu"
    _ceu_trl->evt = CEU_IN__ok_killed;
_ceu_trl->lbl = Main_Awake__ok_killed_50;
_ceu_trl->seqno = _ceu_app->seqno;

#line 80 "chaser.ceu"
    _ceu_trl->org_or_adt = (void*)(&((CEU_Main*)_ceu_org)->_org_346_9);

#line 80 "chaser.ceu"
    return;

case Main_Awake__ok_killed_50:;

#line 80 "chaser.ceu"
    #ifdef CEU_DEBUG_TRAILS
#ifndef CEU_OS
printf("\tOK!\n");
#endif
#endif

#line 80 "chaser.ceu"
    }
#line 80 "chaser.ceu"
/* CLEAR: Block (80) */
#line 80 "chaser.ceu"
    if (0) {

#line 80 "chaser.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
}

#line 80 "chaser.ceu"
    }
#line 80 "chaser.ceu"
    }
#line 80 "chaser.ceu"
    }
#line 80 "chaser.ceu"
/* CLEAR: Block (80) */
#line 80 "chaser.ceu"
    {
    tceu_evt evt;
             evt.id = CEU_IN__CLEAR;
    ceu_sys_go_ex(_ceu_app, &evt,
                  _ceu_stk,
                  _ceu_org,
                  &_ceu_org->trls[ 5 ],
                  &_ceu_org->trls[ 7 ]);
                                        /* excludes +1 */
}

/* LONGJMP
 * Block termination: we will abort all trails between [t1,t2].
 * Return status=1 to distinguish from longjmp from organism termination.
 * We want to continue from "me.lbl_jmp" below.
 */
#ifdef CEU_ORGS
_ceu_app->stk_jmp.org = _ceu_org;
#endif
_ceu_app->stk_jmp.trl = _ceu_trl;
_ceu_app->stk_jmp.lbl = Main_Block_jmp_51;
ceu_longjmp(_ceu_app, _ceu_org,
            5,6);

#line 80 "chaser.ceu"
case Main_Block_jmp_51:;
#line 80 "chaser.ceu"
    if (0) {

#line 80 "chaser.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 80 "chaser.ceu"
    }
#line 80 "chaser.ceu"
/* CLEAR: Block (80) */
#line 80 "chaser.ceu"
    if (0) {

#line 80 "chaser.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 79 "chaser.ceu"
    }

#line 79 "chaser.ceu"
    }
#line 79 "chaser.ceu"
/* CLEAR: Block (79) */
#line 79 "chaser.ceu"
    if (0) {

#line 79 "chaser.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 72 "chaser.ceu"
    }
#line 72 "chaser.ceu"
/* CLEAR: Block (72) */
#line 72 "chaser.ceu"
    if (0) {

#line 72 "chaser.ceu"
case Main_Block__fin_52:;
#line 72 "chaser.ceu"
    return;
#line 72 "chaser.ceu"
case Main_adt_fin_kill_free_53:;
#line 72 "chaser.ceu"
    #if 0
"kill" only while in scope
CEU_BTree_kill(_ceu_app, ((CEU_BTree *)(  ((tceu_pool_adts*) (&((CEU_Main*)_ceu_org)->y_behavior_8))->root)));
#endif

#line 72 "chaser.ceu"
    CEU_BTree_free(NULL, ((CEU_BTree *)(  ((tceu_pool_adts*) (&((CEU_Main*)_ceu_org)->y_behavior_8))->root)));

#line 72 "chaser.ceu"
    return;
#line 72 "chaser.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 58 "chaser.ceu"
case Main_ParEver_sub_1_41:;/* NODE: Block 291 */

#line 59 "chaser.ceu"
    /*  FINALIZE */
_ceu_org->trls[ 3 ].evt = CEU_IN__CLEAR;
_ceu_org->trls[ 3 ].lbl = Main_Block__fin_46;

#line 59 "chaser.ceu"
    {
#line 59 "chaser.ceu"
    #ifdef CEU_ADTS_NEWS_POOL
(&((CEU_Main*)_ceu_org)->x_behavior_6)->pool = NULL;
#endif

#line 59 "chaser.ceu"
    (&((CEU_Main*)_ceu_org)->x_behavior_6)->root = &CEU_BTREE_BASE;

/*  FINALIZE ADT */
_ceu_org->trls[ 0 ].evt = CEU_IN__CLEAR;
_ceu_org->trls[ 0 ].lbl = Main_adt_fin_kill_free_47;

#line 59 "chaser.ceu"
    _ceu_trl = &_ceu_org->trls[ 1 ];
/* NODE: Stmts 290 */

#line 59 "chaser.ceu"
    {/* NODE: Stmts 1227 */

#line 59 "chaser.ceu"
    {/* NODE: Dcl_pool 1224 */
/* NODE: Set 1228 */

#line 59 "chaser.ceu"
/* SET: x_behavior *//* NODE: Adt_constr_root 275 */

#line 60 "chaser.ceu"
    {
#line 60 "chaser.ceu"
    {
    void* __ceu_old = ((CEU_BTree *)(  ((tceu_pool_adts*) (&((CEU_Main*)_ceu_org)->x_behavior_6))->root));    /* will kill/free old */

#line 60 "chaser.ceu"
    #ifdef CEU_ADTS_NEWS_POOL
    tceu_org* __ceu_stk_org = _ceu_org;
#endif
/* NODE: Adt_constr_one 274 */

#line 60 "chaser.ceu"
    CEU_BTree* __ceu_adt_274;

#line 60 "chaser.ceu"
    #if defined(CEU_ADTS_NEWS_MALLOC) && defined(CEU_ADTS_NEWS_POOL)
if (((&((CEU_Main*)_ceu_org)->x_behavior_6)->pool) == NULL) {
    __ceu_adt_274 = (CEU_BTree*) ceu_out_realloc(NULL, sizeof(CEU_BTree));
} else {
    __ceu_adt_274 = (CEU_BTree*) ceu_pool_alloc((tceu_pool*)((&((CEU_Main*)_ceu_org)->x_behavior_6)->pool));
}
#elif defined(CEU_ADTS_NEWS_MALLOC)
    __ceu_adt_274 = (CEU_BTree*) ceu_out_realloc(NULL, sizeof(CEU_BTree));
#elif defined(CEU_ADTS_NEWS_POOL)
    __ceu_adt_274 = (CEU_BTree*) ceu_pool_alloc((tceu_pool*)((&((CEU_Main*)_ceu_org)->x_behavior_6)->pool));
#endif

#line 60 "chaser.ceu"
    if (__ceu_adt_274 == NULL) {
    __ceu_adt_274 = &CEU_BTREE_BASE;
} else  /* rely on {,} that follows */

#line 60 "chaser.ceu"
    {/* NODE: ExpList 273 */
/* NODE: Adt_constr_one 248 */

#line 61 "chaser.ceu"
    CEU_BTree* __ceu_adt_248;

#line 61 "chaser.ceu"
    #if defined(CEU_ADTS_NEWS_MALLOC) && defined(CEU_ADTS_NEWS_POOL)
if (((&((CEU_Main*)_ceu_org)->x_behavior_6)->pool) == NULL) {
    __ceu_adt_248 = (CEU_BTree*) ceu_out_realloc(NULL, sizeof(CEU_BTree));
} else {
    __ceu_adt_248 = (CEU_BTree*) ceu_pool_alloc((tceu_pool*)((&((CEU_Main*)_ceu_org)->x_behavior_6)->pool));
}
#elif defined(CEU_ADTS_NEWS_MALLOC)
    __ceu_adt_248 = (CEU_BTree*) ceu_out_realloc(NULL, sizeof(CEU_BTree));
#elif defined(CEU_ADTS_NEWS_POOL)
    __ceu_adt_248 = (CEU_BTree*) ceu_pool_alloc((tceu_pool*)((&((CEU_Main*)_ceu_org)->x_behavior_6)->pool));
#endif

#line 61 "chaser.ceu"
    if (__ceu_adt_248 == NULL) {
    __ceu_adt_248 = &CEU_BTREE_BASE;
} else  /* rely on {,} that follows */

#line 61 "chaser.ceu"
    {/* NODE: ExpList 247 */
/* NODE: Adt_constr_one 240 */

#line 61 "chaser.ceu"
    CEU_BTree* __ceu_adt_240;

#line 61 "chaser.ceu"
    #if defined(CEU_ADTS_NEWS_MALLOC) && defined(CEU_ADTS_NEWS_POOL)
if (((&((CEU_Main*)_ceu_org)->x_behavior_6)->pool) == NULL) {
    __ceu_adt_240 = (CEU_BTree*) ceu_out_realloc(NULL, sizeof(CEU_BTree));
} else {
    __ceu_adt_240 = (CEU_BTree*) ceu_pool_alloc((tceu_pool*)((&((CEU_Main*)_ceu_org)->x_behavior_6)->pool));
}
#elif defined(CEU_ADTS_NEWS_MALLOC)
    __ceu_adt_240 = (CEU_BTree*) ceu_out_realloc(NULL, sizeof(CEU_BTree));
#elif defined(CEU_ADTS_NEWS_POOL)
    __ceu_adt_240 = (CEU_BTree*) ceu_pool_alloc((tceu_pool*)((&((CEU_Main*)_ceu_org)->x_behavior_6)->pool));
#endif

#line 61 "chaser.ceu"
    if (__ceu_adt_240 == NULL) {
    __ceu_adt_240 = &CEU_BTREE_BASE;
} else  /* rely on {,} that follows */

#line 61 "chaser.ceu"
    {/* NODE: ExpList 239 */
/* NODE: Adt_constr_one 238 */

#line 61 "chaser.ceu"
    CEU_Leaf __ceu_adt_238;

#line 61 "chaser.ceu"
    {/* NODE: ExpList 237 */

#line 61 "chaser.ceu"
    __ceu_adt_238.tag = CEU_LEAF_SENSERIGHT;
#line 61 "chaser.ceu"
    }
#line 61 "chaser.ceu"
    __ceu_adt_240->tag = CEU_BTREE_LEAF;
#line 61 "chaser.ceu"
    __ceu_adt_240->LEAF.leaf = __ceu_adt_238;
#line 61 "chaser.ceu"
    }/* NODE: Adt_constr_one 246 */

#line 61 "chaser.ceu"
    CEU_BTree* __ceu_adt_246;

#line 61 "chaser.ceu"
    #if defined(CEU_ADTS_NEWS_MALLOC) && defined(CEU_ADTS_NEWS_POOL)
if (((&((CEU_Main*)_ceu_org)->x_behavior_6)->pool) == NULL) {
    __ceu_adt_246 = (CEU_BTree*) ceu_out_realloc(NULL, sizeof(CEU_BTree));
} else {
    __ceu_adt_246 = (CEU_BTree*) ceu_pool_alloc((tceu_pool*)((&((CEU_Main*)_ceu_org)->x_behavior_6)->pool));
}
#elif defined(CEU_ADTS_NEWS_MALLOC)
    __ceu_adt_246 = (CEU_BTree*) ceu_out_realloc(NULL, sizeof(CEU_BTree));
#elif defined(CEU_ADTS_NEWS_POOL)
    __ceu_adt_246 = (CEU_BTree*) ceu_pool_alloc((tceu_pool*)((&((CEU_Main*)_ceu_org)->x_behavior_6)->pool));
#endif

#line 61 "chaser.ceu"
    if (__ceu_adt_246 == NULL) {
    __ceu_adt_246 = &CEU_BTREE_BASE;
} else  /* rely on {,} that follows */

#line 61 "chaser.ceu"
    {/* NODE: ExpList 245 */
/* NODE: Adt_constr_one 244 */

#line 61 "chaser.ceu"
    CEU_Leaf __ceu_adt_244;

#line 61 "chaser.ceu"
    {/* NODE: ExpList 243 */

#line 61 "chaser.ceu"
    __ceu_adt_244.tag = CEU_LEAF_GORIGHT;
#line 61 "chaser.ceu"
    }
#line 61 "chaser.ceu"
    __ceu_adt_246->tag = CEU_BTREE_LEAF;
#line 61 "chaser.ceu"
    __ceu_adt_246->LEAF.leaf = __ceu_adt_244;
#line 61 "chaser.ceu"
    }
#line 61 "chaser.ceu"
    __ceu_adt_248->tag = CEU_BTREE_SEQUENCE;
#line 61 "chaser.ceu"
    __ceu_adt_248->SEQUENCE.first = __ceu_adt_240;
#line 61 "chaser.ceu"
    __ceu_adt_248->SEQUENCE.second = __ceu_adt_246;
#line 61 "chaser.ceu"
    }/* NODE: Adt_constr_one 272 */

#line 62 "chaser.ceu"
    CEU_BTree* __ceu_adt_272;

#line 62 "chaser.ceu"
    #if defined(CEU_ADTS_NEWS_MALLOC) && defined(CEU_ADTS_NEWS_POOL)
if (((&((CEU_Main*)_ceu_org)->x_behavior_6)->pool) == NULL) {
    __ceu_adt_272 = (CEU_BTree*) ceu_out_realloc(NULL, sizeof(CEU_BTree));
} else {
    __ceu_adt_272 = (CEU_BTree*) ceu_pool_alloc((tceu_pool*)((&((CEU_Main*)_ceu_org)->x_behavior_6)->pool));
}
#elif defined(CEU_ADTS_NEWS_MALLOC)
    __ceu_adt_272 = (CEU_BTree*) ceu_out_realloc(NULL, sizeof(CEU_BTree));
#elif defined(CEU_ADTS_NEWS_POOL)
    __ceu_adt_272 = (CEU_BTree*) ceu_pool_alloc((tceu_pool*)((&((CEU_Main*)_ceu_org)->x_behavior_6)->pool));
#endif

#line 62 "chaser.ceu"
    if (__ceu_adt_272 == NULL) {
    __ceu_adt_272 = &CEU_BTREE_BASE;
} else  /* rely on {,} that follows */

#line 62 "chaser.ceu"
    {/* NODE: ExpList 271 */
/* NODE: Adt_constr_one 264 */

#line 63 "chaser.ceu"
    CEU_BTree* __ceu_adt_264;

#line 63 "chaser.ceu"
    #if defined(CEU_ADTS_NEWS_MALLOC) && defined(CEU_ADTS_NEWS_POOL)
if (((&((CEU_Main*)_ceu_org)->x_behavior_6)->pool) == NULL) {
    __ceu_adt_264 = (CEU_BTree*) ceu_out_realloc(NULL, sizeof(CEU_BTree));
} else {
    __ceu_adt_264 = (CEU_BTree*) ceu_pool_alloc((tceu_pool*)((&((CEU_Main*)_ceu_org)->x_behavior_6)->pool));
}
#elif defined(CEU_ADTS_NEWS_MALLOC)
    __ceu_adt_264 = (CEU_BTree*) ceu_out_realloc(NULL, sizeof(CEU_BTree));
#elif defined(CEU_ADTS_NEWS_POOL)
    __ceu_adt_264 = (CEU_BTree*) ceu_pool_alloc((tceu_pool*)((&((CEU_Main*)_ceu_org)->x_behavior_6)->pool));
#endif

#line 63 "chaser.ceu"
    if (__ceu_adt_264 == NULL) {
    __ceu_adt_264 = &CEU_BTREE_BASE;
} else  /* rely on {,} that follows */

#line 63 "chaser.ceu"
    {/* NODE: ExpList 263 */
/* NODE: Adt_constr_one 256 */

#line 63 "chaser.ceu"
    CEU_BTree* __ceu_adt_256;

#line 63 "chaser.ceu"
    #if defined(CEU_ADTS_NEWS_MALLOC) && defined(CEU_ADTS_NEWS_POOL)
if (((&((CEU_Main*)_ceu_org)->x_behavior_6)->pool) == NULL) {
    __ceu_adt_256 = (CEU_BTree*) ceu_out_realloc(NULL, sizeof(CEU_BTree));
} else {
    __ceu_adt_256 = (CEU_BTree*) ceu_pool_alloc((tceu_pool*)((&((CEU_Main*)_ceu_org)->x_behavior_6)->pool));
}
#elif defined(CEU_ADTS_NEWS_MALLOC)
    __ceu_adt_256 = (CEU_BTree*) ceu_out_realloc(NULL, sizeof(CEU_BTree));
#elif defined(CEU_ADTS_NEWS_POOL)
    __ceu_adt_256 = (CEU_BTree*) ceu_pool_alloc((tceu_pool*)((&((CEU_Main*)_ceu_org)->x_behavior_6)->pool));
#endif

#line 63 "chaser.ceu"
    if (__ceu_adt_256 == NULL) {
    __ceu_adt_256 = &CEU_BTREE_BASE;
} else  /* rely on {,} that follows */

#line 63 "chaser.ceu"
    {/* NODE: ExpList 255 */
/* NODE: Adt_constr_one 254 */

#line 63 "chaser.ceu"
    CEU_Leaf __ceu_adt_254;

#line 63 "chaser.ceu"
    {/* NODE: ExpList 253 */

#line 63 "chaser.ceu"
    __ceu_adt_254.tag = CEU_LEAF_SENSELEFT;
#line 63 "chaser.ceu"
    }
#line 63 "chaser.ceu"
    __ceu_adt_256->tag = CEU_BTREE_LEAF;
#line 63 "chaser.ceu"
    __ceu_adt_256->LEAF.leaf = __ceu_adt_254;
#line 63 "chaser.ceu"
    }/* NODE: Adt_constr_one 262 */

#line 63 "chaser.ceu"
    CEU_BTree* __ceu_adt_262;

#line 63 "chaser.ceu"
    #if defined(CEU_ADTS_NEWS_MALLOC) && defined(CEU_ADTS_NEWS_POOL)
if (((&((CEU_Main*)_ceu_org)->x_behavior_6)->pool) == NULL) {
    __ceu_adt_262 = (CEU_BTree*) ceu_out_realloc(NULL, sizeof(CEU_BTree));
} else {
    __ceu_adt_262 = (CEU_BTree*) ceu_pool_alloc((tceu_pool*)((&((CEU_Main*)_ceu_org)->x_behavior_6)->pool));
}
#elif defined(CEU_ADTS_NEWS_MALLOC)
    __ceu_adt_262 = (CEU_BTree*) ceu_out_realloc(NULL, sizeof(CEU_BTree));
#elif defined(CEU_ADTS_NEWS_POOL)
    __ceu_adt_262 = (CEU_BTree*) ceu_pool_alloc((tceu_pool*)((&((CEU_Main*)_ceu_org)->x_behavior_6)->pool));
#endif

#line 63 "chaser.ceu"
    if (__ceu_adt_262 == NULL) {
    __ceu_adt_262 = &CEU_BTREE_BASE;
} else  /* rely on {,} that follows */

#line 63 "chaser.ceu"
    {/* NODE: ExpList 261 */
/* NODE: Adt_constr_one 260 */

#line 63 "chaser.ceu"
    CEU_Leaf __ceu_adt_260;

#line 63 "chaser.ceu"
    {/* NODE: ExpList 259 */

#line 63 "chaser.ceu"
    __ceu_adt_260.tag = CEU_LEAF_GOLEFT;
#line 63 "chaser.ceu"
    }
#line 63 "chaser.ceu"
    __ceu_adt_262->tag = CEU_BTREE_LEAF;
#line 63 "chaser.ceu"
    __ceu_adt_262->LEAF.leaf = __ceu_adt_260;
#line 63 "chaser.ceu"
    }
#line 63 "chaser.ceu"
    __ceu_adt_264->tag = CEU_BTREE_SEQUENCE;
#line 63 "chaser.ceu"
    __ceu_adt_264->SEQUENCE.first = __ceu_adt_256;
#line 63 "chaser.ceu"
    __ceu_adt_264->SEQUENCE.second = __ceu_adt_262;
#line 63 "chaser.ceu"
    }/* NODE: Adt_constr_one 270 */

#line 64 "chaser.ceu"
    CEU_BTree* __ceu_adt_270;

#line 64 "chaser.ceu"
    #if defined(CEU_ADTS_NEWS_MALLOC) && defined(CEU_ADTS_NEWS_POOL)
if (((&((CEU_Main*)_ceu_org)->x_behavior_6)->pool) == NULL) {
    __ceu_adt_270 = (CEU_BTree*) ceu_out_realloc(NULL, sizeof(CEU_BTree));
} else {
    __ceu_adt_270 = (CEU_BTree*) ceu_pool_alloc((tceu_pool*)((&((CEU_Main*)_ceu_org)->x_behavior_6)->pool));
}
#elif defined(CEU_ADTS_NEWS_MALLOC)
    __ceu_adt_270 = (CEU_BTree*) ceu_out_realloc(NULL, sizeof(CEU_BTree));
#elif defined(CEU_ADTS_NEWS_POOL)
    __ceu_adt_270 = (CEU_BTree*) ceu_pool_alloc((tceu_pool*)((&((CEU_Main*)_ceu_org)->x_behavior_6)->pool));
#endif

#line 64 "chaser.ceu"
    if (__ceu_adt_270 == NULL) {
    __ceu_adt_270 = &CEU_BTREE_BASE;
} else  /* rely on {,} that follows */

#line 64 "chaser.ceu"
    {/* NODE: ExpList 269 */
/* NODE: Adt_constr_one 268 */

#line 64 "chaser.ceu"
    CEU_Leaf __ceu_adt_268;

#line 64 "chaser.ceu"
    {/* NODE: ExpList 267 */

#line 64 "chaser.ceu"
    __ceu_adt_268.tag = CEU_LEAF_SKIP;
#line 64 "chaser.ceu"
    }
#line 64 "chaser.ceu"
    __ceu_adt_270->tag = CEU_BTREE_LEAF;
#line 64 "chaser.ceu"
    __ceu_adt_270->LEAF.leaf = __ceu_adt_268;
#line 64 "chaser.ceu"
    }
#line 62 "chaser.ceu"
    __ceu_adt_272->tag = CEU_BTREE_SELECTOR;
#line 62 "chaser.ceu"
    __ceu_adt_272->SELECTOR.first = __ceu_adt_264;
#line 62 "chaser.ceu"
    __ceu_adt_272->SELECTOR.second = __ceu_adt_270;
#line 62 "chaser.ceu"
    }
#line 60 "chaser.ceu"
    __ceu_adt_274->tag = CEU_BTREE_SELECTOR;
#line 60 "chaser.ceu"
    __ceu_adt_274->SELECTOR.first = __ceu_adt_248;
#line 60 "chaser.ceu"
    __ceu_adt_274->SELECTOR.second = __ceu_adt_272;
#line 60 "chaser.ceu"
    }
#line 60 "chaser.ceu"
    (  ((tceu_pool_adts*) (&((CEU_Main*)_ceu_org)->x_behavior_6))->root) = __ceu_adt_274;

#line 60 "chaser.ceu"
                         /* 3. free */
    CEU_BTree_free(NULL, __ceu_old);

#line 60 "chaser.ceu"
    
#ifdef CEU_ADTS_AWAIT_BTree
    /* OK_KILLED (after free) */        /* 4. kill */
{
    tceu_stk stk_ = { NULL, _ceu_org, 1, 2, {} };
    if (setjmp(stk_.jmp) != 0) {
#ifdef CEU_ORGS
        _ceu_org = _ceu_app->stk_jmp.org;
#endif
        _ceu_trl = _ceu_app->stk_jmp.trl;

#line 60 "chaser.ceu"
    _ceu_lbl = _ceu_app->stk_jmp.lbl;
goto _CEU_GOTO_;

#line 60 "chaser.ceu"
        }

    /* SETJMP: mutating an adt
     * The mutation frees a subtree that might awake a par/or enclosing the 
     * call point.
     */
    {
        tceu_evt evt;
                 evt.id = CEU_IN__ok_killed;
                 evt.param = &__ceu_old;
        _ceu_stk->up = &stk_;
        ceu_sys_go_ex(_ceu_app, &evt, &stk_,
                      _ceu_app->data, &_ceu_app->data->trls[0], NULL);
        _ceu_stk->up = NULL;
    }
}
#endif

#line 60 "chaser.ceu"
    }

#line 60 "chaser.ceu"
    }
#line 59 "chaser.ceu"
    }/* NODE: Block 1235 */

#line 66 "chaser.ceu"
    {/* NODE: Stmts 1234 */

#line 66 "chaser.ceu"
    {/* NODE: Stmts 1233 */

#line 66 "chaser.ceu"
    {
#line 66 "chaser.ceu"
    }/* NODE: Loop 1232 */

#line 66 "chaser.ceu"
    for (;;) {
/* NODE: Block 288 */

#line 67 "chaser.ceu"
    {/* NODE: Stmts 287 */

#line 67 "chaser.ceu"
    {/* NODE: Stmts 1262 */

#line 66 "chaser.ceu"
    {/* NODE: Nothing 1236 */
/* NODE: Await 1229 */

#line 66 "chaser.ceu"
    _CEU_NO_1229_:
if (0) { goto _CEU_NO_1229_; /* avoids "not used" warning */ }

#line 66 "chaser.ceu"
    _ceu_trl->evt = CEU_IN_TICK;
_ceu_trl->lbl = Main_Awake_TICK_43;
_ceu_trl->seqno = _ceu_app->seqno;

#line 66 "chaser.ceu"
    return;

case Main_Awake_TICK_43:;

#line 66 "chaser.ceu"
    #ifdef CEU_DEBUG_TRAILS
#ifndef CEU_OS
printf("\tOK!\n");
#endif
#endif
/* NODE: Nothing 1468 */
/* NODE: Nothing 1469 */

#line 66 "chaser.ceu"
    }/* NODE: Do 1269 */
/* NODE: Block 1268 */

#line 67 "chaser.ceu"
    {
#line 67 "chaser.ceu"
    #ifdef CEU_ORGS
_ceu_org->trls[ 1 ].evt = CEU_IN__ORG;
_ceu_org->trls[ 1 ].org = NULL;
#endif

#line 67 "chaser.ceu"
    _ceu_trl = &_ceu_org->trls[ 2 ];
/* NODE: Stmts 1267 */

#line 67 "chaser.ceu"
    {/* NODE: Dcl_var 1266 */

#line 67 "chaser.ceu"
/* start org: _org_286 */
#line 67 "chaser.ceu"
        /* resets org memory and starts org.trail[0]=Class_XXX */
    /* TODO: BUG: _ceu_org is not necessarily the parent for pool allocations */
    ceu_out_org_init(_ceu_app, ((tceu_org*) &(((CEU_Main*)_ceu_org)->_org_286_7)),11,Class_BTreeTraverse,
                     2,
                     0,
                     _ceu_org,1);
/* TODO: currently idx is always "1" for all interfaces access because pools 
 * are all together there. When we have separate trls for pools, we'll have to 
 * indirectly access the offset in the interface. */

#line 67 "chaser.ceu"
        _ceu_constr_285(_ceu_app, ((tceu_org*) &(((CEU_Main*)_ceu_org)->_org_286_7)), _ceu_org);

#line 67 "chaser.ceu"
    {
    tceu_stk stk_ = { NULL, ((tceu_org*) &(((CEU_Main*)_ceu_org)->_org_286_7)), 0, ((tceu_org*) &(((CEU_Main*)_ceu_org)->_org_286_7))->n, {} };
    if (setjmp(stk_.jmp) != 0) {
#ifdef CEU_ORGS
        _ceu_org = _ceu_app->stk_jmp.org;
#endif
        _ceu_trl = _ceu_app->stk_jmp.trl;

#line 67 "chaser.ceu"
    _ceu_lbl = _ceu_app->stk_jmp.lbl;
goto _CEU_GOTO_;

#line 67 "chaser.ceu"
        }

    /* SETJMP: spawning a new org
     * The new org might emit a global event that awakes a par/or enclosing the 
     * call point.
     */
    _ceu_stk->up = &stk_;
    ceu_app_go(_ceu_app,NULL,
               ((tceu_org*) &(((CEU_Main*)_ceu_org)->_org_286_7)), &((tceu_org*) &(((CEU_Main*)_ceu_org)->_org_286_7))->trls[0],
               &stk_);
    _ceu_stk->up = NULL;

#line 67 "chaser.ceu"
    }
/* NODE: Stmts 1297 */

#line 67 "chaser.ceu"
    {/* NODE: Nothing 1271 */
/* NODE: Nothing 1471 */
/* NODE: Nothing 1472 */
/* NODE: Stmts 1296 */

#line 67 "chaser.ceu"
    {/* NODE: If 1295 */

#line 67 "chaser.ceu"
    if ((!(((*((tceu_org*)(&((CEU_Main*)_ceu_org)->_org_286_7))).isAlive)))) {
/* NODE: Block 1292 */

#line 67 "chaser.ceu"
    {/* NODE: Stmts 1291 */

#line 67 "chaser.ceu"
    {/* NODE: Nothing 1275 */

#line 67 "chaser.ceu"
    }
#line 67 "chaser.ceu"
/* CLEAR: Block (67) */
#line 67 "chaser.ceu"
    if (0) {

#line 67 "chaser.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
} else {
/* NODE: Block 1294 */

#line 67 "chaser.ceu"
    {/* NODE: Stmts 1293 */

#line 67 "chaser.ceu"
    {/* NODE: Await 1274 */

#line 67 "chaser.ceu"
    _CEU_NO_1274_:
if (0) { goto _CEU_NO_1274_; /* avoids "not used" warning */ }

#line 67 "chaser.ceu"
    _ceu_trl->evt = CEU_IN__ok_killed;
_ceu_trl->lbl = Main_Awake__ok_killed_44;
_ceu_trl->seqno = _ceu_app->seqno;

#line 67 "chaser.ceu"
    _ceu_trl->org_or_adt = (void*)(&((CEU_Main*)_ceu_org)->_org_286_7);

#line 67 "chaser.ceu"
    return;

case Main_Awake__ok_killed_44:;

#line 67 "chaser.ceu"
    #ifdef CEU_DEBUG_TRAILS
#ifndef CEU_OS
printf("\tOK!\n");
#endif
#endif

#line 67 "chaser.ceu"
    }
#line 67 "chaser.ceu"
/* CLEAR: Block (67) */
#line 67 "chaser.ceu"
    if (0) {

#line 67 "chaser.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
}

#line 67 "chaser.ceu"
    }
#line 67 "chaser.ceu"
    }
#line 67 "chaser.ceu"
    }
#line 67 "chaser.ceu"
/* CLEAR: Block (67) */
#line 67 "chaser.ceu"
    {
    tceu_evt evt;
             evt.id = CEU_IN__CLEAR;
    ceu_sys_go_ex(_ceu_app, &evt,
                  _ceu_stk,
                  _ceu_org,
                  &_ceu_org->trls[ 1 ],
                  &_ceu_org->trls[ 3 ]);
                                        /* excludes +1 */
}

/* LONGJMP
 * Block termination: we will abort all trails between [t1,t2].
 * Return status=1 to distinguish from longjmp from organism termination.
 * We want to continue from "me.lbl_jmp" below.
 */
#ifdef CEU_ORGS
_ceu_app->stk_jmp.org = _ceu_org;
#endif
_ceu_app->stk_jmp.trl = _ceu_trl;
_ceu_app->stk_jmp.lbl = Main_Block_jmp_45;
ceu_longjmp(_ceu_app, _ceu_org,
            1,2);

#line 67 "chaser.ceu"
case Main_Block_jmp_45:;
#line 67 "chaser.ceu"
    if (0) {

#line 67 "chaser.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 67 "chaser.ceu"
    }
#line 67 "chaser.ceu"
/* CLEAR: Block (67) */
#line 67 "chaser.ceu"
    if (0) {

#line 67 "chaser.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 66 "chaser.ceu"
    }

#line 66 "chaser.ceu"
    }
#line 66 "chaser.ceu"
/* CLEAR: Block (66) */
#line 66 "chaser.ceu"
    if (0) {

#line 66 "chaser.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 59 "chaser.ceu"
    }
#line 59 "chaser.ceu"
/* CLEAR: Block (59) */
#line 59 "chaser.ceu"
    if (0) {

#line 59 "chaser.ceu"
case Main_Block__fin_46:;
#line 59 "chaser.ceu"
    return;
#line 59 "chaser.ceu"
case Main_adt_fin_kill_free_47:;
#line 59 "chaser.ceu"
    #if 0
"kill" only while in scope
CEU_BTree_kill(_ceu_app, ((CEU_BTree *)(  ((tceu_pool_adts*) (&((CEU_Main*)_ceu_org)->x_behavior_6))->root)));
#endif

#line 59 "chaser.ceu"
    CEU_BTree_free(NULL, ((CEU_BTree *)(  ((tceu_pool_adts*) (&((CEU_Main*)_ceu_org)->x_behavior_6))->root)));

#line 59 "chaser.ceu"
    return;
#line 59 "chaser.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 1 "chaser.ceu"
    }
#line 1 "chaser.ceu"
/* CLEAR: Block (1) */
#line 1 "chaser.ceu"
    if (0) {

#line 1 "chaser.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 1 "chaser.ceu"
    }
#line 1 "chaser.ceu"
    }
#line 1 "chaser.ceu"
/* CLEAR: Block (1) */
#line 1 "chaser.ceu"
    if (0) {

#line 1 "chaser.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 1 "chaser.ceu"
    return;
#line 1 "chaser.ceu"
    }
#line 1 "chaser.ceu"
/* CLEAR: Block (1) */
#line 1 "chaser.ceu"
    if (0) {

#line 1 "chaser.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 1 "chaser.ceu"
    }
#line 1 "chaser.ceu"
/* CLEAR: Block (1) */
#line 1 "chaser.ceu"
    if (0) {

#line 1 "chaser.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
/* NODE: Dcl_cls 1 */

#line 23 "chaser.ceu"
case Class_LeafHandler:;/* NODE: Block 424 */

#line 23 "chaser.ceu"
    {/* NODE: Stmts 423 */

#line 23 "chaser.ceu"
    {/* NODE: Block 384 */

#line 23 "chaser.ceu"
    {
#line 23 "chaser.ceu"
    #ifdef CEU_RET

#line 23 "chaser.ceu"
    int __ceu__ret_2;

#line 23 "chaser.ceu"
    #endif
/* NODE: Stmts 383 */

#line 23 "chaser.ceu"
    {/* NODE: Dcl_var 380 */
/* NODE: SetBlock 382 */
/* NODE: Block 118 */

#line 26 "chaser.ceu"
    {/* NODE: Stmts 117 */

#line 26 "chaser.ceu"
    {/* NODE: Stmts 395 */

#line 26 "chaser.ceu"
    {/* NODE: Dcl_var 392 */
/* NODE: Set 396 */

#line 26 "chaser.ceu"
/* SET: answer *//* NODE: NUMBER 16 */

#line 26 "chaser.ceu"
    (((CEU_LeafHandler*)_ceu_org)->answer) = 0;
#line 26 "chaser.ceu"
    }/* NODE: If 405 */

#line 27 "chaser.ceu"
    if ((((((CEU_LeafHandler*)_ceu_org)->leaf)->tag == CEU_LEAF_SENSEUP) /* XXXX */)) {
/* NODE: Block 26 */

#line 28 "chaser.ceu"
    {/* NODE: Stmts 25 */

#line 28 "chaser.ceu"
    {/* NODE: Set 406 */

#line 28 "chaser.ceu"
/* SET: answer *//* NODE: Op2_< 23 */

#line 28 "chaser.ceu"
    (((CEU_LeafHandler*)_ceu_org)->answer) = (player_y<chaser_y);
#line 28 "chaser.ceu"
    }
#line 28 "chaser.ceu"
/* CLEAR: Block (28) */
#line 28 "chaser.ceu"
    if (0) {

#line 28 "chaser.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
} else {
/* NODE: If 404 */

#line 29 "chaser.ceu"
    if ((((((CEU_LeafHandler*)_ceu_org)->leaf)->tag == CEU_LEAF_SENSEDOWN) /* XXXX */)) {
/* NODE: Block 35 */

#line 30 "chaser.ceu"
    {/* NODE: Stmts 34 */

#line 30 "chaser.ceu"
    {/* NODE: Set 407 */

#line 30 "chaser.ceu"
/* SET: answer *//* NODE: Op2_> 32 */

#line 30 "chaser.ceu"
    (((CEU_LeafHandler*)_ceu_org)->answer) = (player_y>chaser_y);
#line 30 "chaser.ceu"
    }
#line 30 "chaser.ceu"
/* CLEAR: Block (30) */
#line 30 "chaser.ceu"
    if (0) {

#line 30 "chaser.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
} else {
/* NODE: If 403 */

#line 31 "chaser.ceu"
    if ((((((CEU_LeafHandler*)_ceu_org)->leaf)->tag == CEU_LEAF_SENSELEFT) /* XXXX */)) {
/* NODE: Block 44 */

#line 32 "chaser.ceu"
    {/* NODE: Stmts 43 */

#line 32 "chaser.ceu"
    {/* NODE: Set 408 */

#line 32 "chaser.ceu"
/* SET: answer *//* NODE: Op2_< 41 */

#line 32 "chaser.ceu"
    (((CEU_LeafHandler*)_ceu_org)->answer) = (player_x<chaser_x);
#line 32 "chaser.ceu"
    }
#line 32 "chaser.ceu"
/* CLEAR: Block (32) */
#line 32 "chaser.ceu"
    if (0) {

#line 32 "chaser.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
} else {
/* NODE: If 402 */

#line 33 "chaser.ceu"
    if ((((((CEU_LeafHandler*)_ceu_org)->leaf)->tag == CEU_LEAF_SENSERIGHT) /* XXXX */)) {
/* NODE: Block 53 */

#line 34 "chaser.ceu"
    {/* NODE: Stmts 52 */

#line 34 "chaser.ceu"
    {/* NODE: Set 409 */

#line 34 "chaser.ceu"
/* SET: answer *//* NODE: Op2_> 50 */

#line 34 "chaser.ceu"
    (((CEU_LeafHandler*)_ceu_org)->answer) = (player_x>chaser_x);
#line 34 "chaser.ceu"
    }
#line 34 "chaser.ceu"
/* CLEAR: Block (34) */
#line 34 "chaser.ceu"
    if (0) {

#line 34 "chaser.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
} else {
/* NODE: If 401 */

#line 35 "chaser.ceu"
    if ((((((CEU_LeafHandler*)_ceu_org)->leaf)->tag == CEU_LEAF_GOUP) /* XXXX */)) {
/* NODE: Block 66 */

#line 36 "chaser.ceu"
    {/* NODE: Stmts 65 */

#line 36 "chaser.ceu"
    {/* NODE: Set 410 */

#line 36 "chaser.ceu"
/* SET: _chaser_dy *//* NODE: Op2_* 60 */

#line 36 "chaser.ceu"
    chaser_dy = ((-1)*CHASER_SPEED);/* NODE: Set 411 */

#line 37 "chaser.ceu"
/* SET: answer *//* NODE: NUMBER 63 */

#line 37 "chaser.ceu"
    (((CEU_LeafHandler*)_ceu_org)->answer) = 1;
#line 36 "chaser.ceu"
    }
#line 36 "chaser.ceu"
/* CLEAR: Block (36) */
#line 36 "chaser.ceu"
    if (0) {

#line 36 "chaser.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
} else {
/* NODE: If 400 */

#line 38 "chaser.ceu"
    if ((((((CEU_LeafHandler*)_ceu_org)->leaf)->tag == CEU_LEAF_GODOWN) /* XXXX */)) {
/* NODE: Block 76 */

#line 39 "chaser.ceu"
    {/* NODE: Stmts 75 */

#line 39 "chaser.ceu"
    {/* NODE: Set 412 */

#line 39 "chaser.ceu"
/* SET: _chaser_dy *//* NODE: Nat 70 */

#line 39 "chaser.ceu"
    chaser_dy = CHASER_SPEED;/* NODE: Set 413 */

#line 40 "chaser.ceu"
/* SET: answer *//* NODE: NUMBER 73 */

#line 40 "chaser.ceu"
    (((CEU_LeafHandler*)_ceu_org)->answer) = 1;
#line 39 "chaser.ceu"
    }
#line 39 "chaser.ceu"
/* CLEAR: Block (39) */
#line 39 "chaser.ceu"
    if (0) {

#line 39 "chaser.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
} else {
/* NODE: If 399 */

#line 41 "chaser.ceu"
    if ((((((CEU_LeafHandler*)_ceu_org)->leaf)->tag == CEU_LEAF_GOLEFT) /* XXXX */)) {
/* NODE: Block 89 */

#line 42 "chaser.ceu"
    {/* NODE: Stmts 88 */

#line 42 "chaser.ceu"
    {/* NODE: Set 414 */

#line 42 "chaser.ceu"
/* SET: _chaser_dx *//* NODE: Op2_* 83 */

#line 42 "chaser.ceu"
    chaser_dx = ((-1)*CHASER_SPEED);/* NODE: Set 415 */

#line 43 "chaser.ceu"
/* SET: answer *//* NODE: NUMBER 86 */

#line 43 "chaser.ceu"
    (((CEU_LeafHandler*)_ceu_org)->answer) = 1;
#line 42 "chaser.ceu"
    }
#line 42 "chaser.ceu"
/* CLEAR: Block (42) */
#line 42 "chaser.ceu"
    if (0) {

#line 42 "chaser.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
} else {
/* NODE: If 398 */

#line 44 "chaser.ceu"
    if ((((((CEU_LeafHandler*)_ceu_org)->leaf)->tag == CEU_LEAF_GORIGHT) /* XXXX */)) {
/* NODE: Block 99 */

#line 45 "chaser.ceu"
    {/* NODE: Stmts 98 */

#line 45 "chaser.ceu"
    {/* NODE: Set 416 */

#line 45 "chaser.ceu"
/* SET: _chaser_dx *//* NODE: Nat 93 */

#line 45 "chaser.ceu"
    chaser_dx = CHASER_SPEED;/* NODE: Set 417 */

#line 46 "chaser.ceu"
/* SET: answer *//* NODE: NUMBER 96 */

#line 46 "chaser.ceu"
    (((CEU_LeafHandler*)_ceu_org)->answer) = 1;
#line 45 "chaser.ceu"
    }
#line 45 "chaser.ceu"
/* CLEAR: Block (45) */
#line 45 "chaser.ceu"
    if (0) {

#line 45 "chaser.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
} else {
/* NODE: If 397 */

#line 47 "chaser.ceu"
    if ((((((CEU_LeafHandler*)_ceu_org)->leaf)->tag == CEU_LEAF_SKIP) /* XXXX */)) {
/* NODE: Block 106 */

#line 48 "chaser.ceu"
    {/* NODE: Stmts 105 */

#line 48 "chaser.ceu"
    {/* NODE: Set 418 */

#line 48 "chaser.ceu"
/* SET: answer *//* NODE: NUMBER 103 */

#line 48 "chaser.ceu"
    (((CEU_LeafHandler*)_ceu_org)->answer) = 1;
#line 48 "chaser.ceu"
    }
#line 48 "chaser.ceu"
/* CLEAR: Block (48) */
#line 48 "chaser.ceu"
    if (0) {

#line 48 "chaser.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
} else {
/* NODE: Block 113 */

#line 50 "chaser.ceu"
    {/* NODE: Stmts 112 */

#line 50 "chaser.ceu"
    {/* NODE: CallStmt 111 */

#line 50 "chaser.ceu"
    assert(0);
#line 50 "chaser.ceu"
    }
#line 50 "chaser.ceu"
/* CLEAR: Block (50) */
#line 50 "chaser.ceu"
    if (0) {

#line 50 "chaser.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
}
}
}
}
}
}
}
}
}
/* NODE: Stmts 422 */

#line 52 "chaser.ceu"
    {/* NODE: Set 420 */

#line 52 "chaser.ceu"
/* SET: _ret *//* NODE: Var 115 */

#line 52 "chaser.ceu"
    (__ceu__ret_2) = (((CEU_LeafHandler*)_ceu_org)->answer);
#line 52 "chaser.ceu"
    #ifdef CEU_ORGS_AWAIT
    _ceu_org->ret = (__ceu__ret_2);
    /* HACK_8: result of immediate spawn termination */
    _ceu_app->ret = _ceu_org->ret;
#endif
/* NODE: Escape 421 */

#line 52 "chaser.ceu"
    _ceu_lbl = LeafHandler_Set_out_1;
goto _CEU_GOTO_;

#line 52 "chaser.ceu"
    }
#line 26 "chaser.ceu"
    }
#line 26 "chaser.ceu"
/* CLEAR: Block (26) */
#line 26 "chaser.ceu"
    if (0) {

#line 26 "chaser.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 23 "chaser.ceu"
    return;
#line 23 "chaser.ceu"
case LeafHandler_Set_out_1:;
#line 23 "chaser.ceu"
/* CLEAR: SetBlock (23) */
#line 23 "chaser.ceu"
    }
#line 23 "chaser.ceu"
/* CLEAR: Block (23) */
#line 23 "chaser.ceu"
    if (0) {

#line 23 "chaser.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 23 "chaser.ceu"
    }
#line 23 "chaser.ceu"
/* CLEAR: Block (23) */
#line 23 "chaser.ceu"
    if (0) {

#line 23 "chaser.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 23 "chaser.ceu"
    {
    tceu_evt evt;
             evt.id = CEU_IN__CLEAR;
    ceu_sys_go_ex(_ceu_app, &evt,
                  _ceu_stk,
                  _ceu_org,
                  &_ceu_org->trls[_ceu_org->n], /* to the end, only free it */
                  NULL);
}

#line 23 "chaser.ceu"
    return;/* NODE: Dcl_cls 2 */

#line 29 "btree-1.ceu"
case Class_BTreeTraverse:;/* NODE: Block 1221 */

#line 29 "btree-1.ceu"
    /*  FINALIZE */
_ceu_org->trls[ 9 ].evt = CEU_IN__CLEAR;
_ceu_org->trls[ 9 ].lbl = BTreeTraverse_Block__fin_38;

#line 29 "btree-1.ceu"
    {/* NODE: Stmts 1220 */

#line 29 "btree-1.ceu"
    {/* NODE: Block 446 */

#line 29 "btree-1.ceu"
    {/* NODE: Stmts 445 */

#line 29 "btree-1.ceu"
    {/* NODE: Dcl_var 442 */
/* NODE: SetBlock 444 */
/* NODE: Block 230 */

#line 32 "btree-1.ceu"
    /*  FINALIZE */
_ceu_org->trls[ 8 ].evt = CEU_IN__CLEAR;
_ceu_org->trls[ 8 ].lbl = BTreeTraverse_Block__fin_36;

#line 32 "btree-1.ceu"
    {
#line 32 "btree-1.ceu"
    (((CEU_BTreeTraverse*)_ceu_org)->_pool_225).parent_org = _ceu_org;
(((CEU_BTreeTraverse*)_ceu_org)->_pool_225).parent_trl = 0;
#ifdef CEU_ORGS_NEWS_POOL
(((CEU_BTreeTraverse*)_ceu_org)->_pool_225).pool.queue = NULL;            /* dynamic pool */
#endif

#line 32 "btree-1.ceu"
    #ifdef CEU_ORGS
_ceu_org->trls[ 0 ].evt = CEU_IN__ORG;
_ceu_org->trls[ 0 ].org = NULL;
#endif

#line 32 "btree-1.ceu"
    _ceu_trl = &_ceu_org->trls[ 1 ];
/* NODE: Stmts 229 */

#line 32 "btree-1.ceu"
    {/* NODE: Stmts 457 */

#line 32 "btree-1.ceu"
    {/* NODE: Dcl_var 454 */
/* NODE: Stmts 535 */

#line 33 "btree-1.ceu"
    {/* NODE: Stmts 546 */

#line 33 "btree-1.ceu"
    {
#line 33 "btree-1.ceu"
    }/* NODE: Nothing 464 */
/* NODE: Stmts 1157 */

#line 33 "btree-1.ceu"
    {
#line 33 "btree-1.ceu"
    }/* NODE: Dcl_pool 466 */
/* NODE: Block 527 */

#line 33 "btree-1.ceu"
    {
#line 33 "btree-1.ceu"
    #ifdef CEU_ORGS
_ceu_org->trls[ 1 ].evt = CEU_IN__ORG;
_ceu_org->trls[ 1 ].org = NULL;
#endif

#line 33 "btree-1.ceu"
    (((CEU_BTreeTraverse*)_ceu_org)->_body_225_11).tag = CEU__OPTION__BODY_225__PTR_NIL;

#line 33 "btree-1.ceu"
    /*  RESET OPT-ORG TO NULL */
_ceu_org->trls[ 2 ].evt = CEU_IN__ok_killed;
_ceu_org->trls[ 2 ].lbl = BTreeTraverse_optorg_reset_34;
_ceu_org->trls[ 2 ].org_or_adt = NULL;

#line 33 "btree-1.ceu"
    _ceu_trl = &_ceu_org->trls[ 3 ];
/* NODE: Stmts 526 */

#line 33 "btree-1.ceu"
    {/* NODE: Dcl_var 514 */

#line 33 "btree-1.ceu"
/* start org: _s */
#line 33 "btree-1.ceu"
        /* resets org memory and starts org.trail[0]=Class_XXX */
    /* TODO: BUG: _ceu_org is not necessarily the parent for pool allocations */
    ceu_out_org_init(_ceu_app, ((tceu_org*) &(((CEU_BTreeTraverse*)_ceu_org)->_s_10)),2,Class_Scope,
                     3,
                     0,
                     _ceu_org,1);
/* TODO: currently idx is always "1" for all interfaces access because pools 
 * are all together there. When we have separate trls for pools, we'll have to 
 * indirectly access the offset in the interface. */

#line 33 "btree-1.ceu"
    {
    tceu_stk stk_ = { NULL, ((tceu_org*) &(((CEU_BTreeTraverse*)_ceu_org)->_s_10)), 0, ((tceu_org*) &(((CEU_BTreeTraverse*)_ceu_org)->_s_10))->n, {} };
    if (setjmp(stk_.jmp) != 0) {
#ifdef CEU_ORGS
        _ceu_org = _ceu_app->stk_jmp.org;
#endif
        _ceu_trl = _ceu_app->stk_jmp.trl;

#line 33 "btree-1.ceu"
    _ceu_lbl = _ceu_app->stk_jmp.lbl;
goto _CEU_GOTO_;

#line 33 "btree-1.ceu"
        }

    /* SETJMP: spawning a new org
     * The new org might emit a global event that awakes a par/or enclosing the 
     * call point.
     */
    _ceu_stk->up = &stk_;
    ceu_app_go(_ceu_app,NULL,
               ((tceu_org*) &(((CEU_BTreeTraverse*)_ceu_org)->_s_10)), &((tceu_org*) &(((CEU_BTreeTraverse*)_ceu_org)->_s_10))->trls[0],
               &stk_);
    _ceu_stk->up = NULL;

#line 33 "btree-1.ceu"
    }
/* NODE: Dcl_var 516 */
/* NODE: Set 1158 */

#line 33 "btree-1.ceu"
/* SET: _body_225 *//* NODE: Spawn 504 */

#line 33 "btree-1.ceu"
    /*{*/
    tceu_org* __ceu_new_504;

#line 33 "btree-1.ceu"
        __ceu_new_504 = (tceu_org*) ceu_out_realloc(NULL, sizeof(CEU_Body_225));

#line 33 "btree-1.ceu"
    (((CEU_BTreeTraverse*)_ceu_org)->_body_225_11) = (CEU__OPTION__BODY_225__PTR_pack(((CEU_Body_225*)__ceu_new_504)));
#line 33 "btree-1.ceu"
        if (__ceu_new_504 != NULL) {

#line 33 "btree-1.ceu"
    #ifdef CEU_ORGS_NEWS_POOL
        __ceu_new_504->pool = &(((CEU_BTreeTraverse*)_ceu_org)->_pool_225);
#endif

#line 33 "btree-1.ceu"
/* start org: dyn */
#line 33 "btree-1.ceu"
        /* resets org memory and starts org.trail[0]=Class_XXX */
    /* TODO: BUG: _ceu_org is not necessarily the parent for pool allocations */
    ceu_out_org_init(_ceu_app, ((tceu_org*) &(*((CEU_Body_225*)__ceu_new_504))),7,Class_Body_225,
                     4,
                     1,
                     (((CEU_BTreeTraverse*)_ceu_org)->_pool_225).parent_org,(((CEU_BTreeTraverse*)_ceu_org)->_pool_225).parent_trl);
/* TODO: currently idx is always "1" for all interfaces access because pools 
 * are all together there. When we have separate trls for pools, we'll have to 
 * indirectly access the offset in the interface. */

#line 33 "btree-1.ceu"
        ((CEU_Body_225*)((tceu_org*) &(*((CEU_Body_225*)__ceu_new_504))))->_out = 
        (__typeof__(((CEU_Body_225*)((tceu_org*) &(*((CEU_Body_225*)__ceu_new_504))))->_out)) _ceu_org;

#line 33 "btree-1.ceu"
        _ceu_constr_503(_ceu_app, ((tceu_org*) &(*((CEU_Body_225*)__ceu_new_504))), _ceu_org);

#line 33 "btree-1.ceu"
    {
    tceu_stk stk_ = { NULL, ((tceu_org*) &(*((CEU_Body_225*)__ceu_new_504))), 0, ((tceu_org*) &(*((CEU_Body_225*)__ceu_new_504)))->n, {} };
    if (setjmp(stk_.jmp) != 0) {
#ifdef CEU_ORGS
        _ceu_org = _ceu_app->stk_jmp.org;
#endif
        _ceu_trl = _ceu_app->stk_jmp.trl;

#line 33 "btree-1.ceu"
    _ceu_lbl = _ceu_app->stk_jmp.lbl;
goto _CEU_GOTO_;

#line 33 "btree-1.ceu"
        }

    /* SETJMP: spawning a new org
     * The new org might emit a global event that awakes a par/or enclosing the 
     * call point.
     */
    _ceu_stk->up = &stk_;
    ceu_app_go(_ceu_app,NULL,
               ((tceu_org*) &(*((CEU_Body_225*)__ceu_new_504))), &((tceu_org*) &(*((CEU_Body_225*)__ceu_new_504)))->trls[0],
               &stk_);
    _ceu_stk->up = NULL;

#line 33 "btree-1.ceu"
        if (!((tceu_org*) &(*((CEU_Body_225*)__ceu_new_504)))->isAlive) {
        (((CEU_BTreeTraverse*)_ceu_org)->_body_225_11) = CEU__OPTION__BODY_225__PTR_pack(NULL);
    }

#line 33 "btree-1.ceu"
    }

#line 33 "btree-1.ceu"
        }
/*}*/
/* NODE: If 525 */

#line 33 "btree-1.ceu"
    if (((((CEU_BTreeTraverse*)_ceu_org)->_body_225_11).tag != CEU__OPTION__BODY_225__PTR_NIL)) {
/* NODE: Block 522 */

#line 33 "btree-1.ceu"
    {/* NODE: Stmts 521 */

#line 33 "btree-1.ceu"
    {/* NODE: Stmts 1210 */

#line 33 "btree-1.ceu"
    {/* NODE: Nothing 1164 */
/* NODE: Nothing 1466 */
/* NODE: Nothing 1467 */
/* NODE: Stmts 1209 */

#line 33 "btree-1.ceu"
    {/* NODE: If 1208 */

#line 33 "btree-1.ceu"
    if ((!(((*((tceu_org*)(((CEU__OPTION__BODY_225__PTR_SOME_assert(_ceu_app, (&((CEU_BTreeTraverse*)_ceu_org)->_body_225_11),__FILE__,__LINE__)->SOME.v))))).isAlive)))) {
/* NODE: Block 1205 */

#line 33 "btree-1.ceu"
    {/* NODE: Stmts 1204 */

#line 33 "btree-1.ceu"
    {/* NODE: Set 1184 */

#line 33 "btree-1.ceu"
/* SET: ok *//* NODE: Op1_cast 1182 */

#line 33 "btree-1.ceu"
    (((CEU_BTreeTraverse*)_ceu_org)->ok) = ((int)(((*((tceu_org*)(((CEU__OPTION__BODY_225__PTR_SOME_assert(_ceu_app, (&((CEU_BTreeTraverse*)_ceu_org)->_body_225_11),__FILE__,__LINE__)->SOME.v))))).ret)));
#line 33 "btree-1.ceu"
    }
#line 33 "btree-1.ceu"
/* CLEAR: Block (33) */
#line 33 "btree-1.ceu"
    if (0) {

#line 33 "btree-1.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
} else {
/* NODE: Block 1207 */

#line 33 "btree-1.ceu"
    {/* NODE: Stmts 1206 */

#line 33 "btree-1.ceu"
    {/* NODE: Set 1214 */

#line 33 "btree-1.ceu"
/* SET: table: 0x131d420 *//* NODE: Await 1169 */

#line 33 "btree-1.ceu"
    _CEU_NO_1169_:
if (0) { goto _CEU_NO_1169_; /* avoids "not used" warning */ }

#line 33 "btree-1.ceu"
    _ceu_trl->evt = CEU_IN__ok_killed;
_ceu_trl->lbl = BTreeTraverse_Awake__ok_killed_33;
_ceu_trl->seqno = _ceu_app->seqno;

#line 33 "btree-1.ceu"
    _ceu_trl->org_or_adt = (void*)(((CEU__OPTION__BODY_225__PTR_SOME_assert(_ceu_app, (&((CEU_BTreeTraverse*)_ceu_org)->_body_225_11),__FILE__,__LINE__)->SOME.v)));

#line 33 "btree-1.ceu"
    return;

case BTreeTraverse_Awake__ok_killed_33:;

#line 33 "btree-1.ceu"
    #ifdef CEU_DEBUG_TRAILS
#ifndef CEU_OS
printf("\tOK!\n");
#endif
#endif

#line 33 "btree-1.ceu"
    {

#line 33 "btree-1.ceu"
        tceu_kill* __ceu_casted = (tceu_kill*) _ceu_evt->param;

#line 33 "btree-1.ceu"
        (((CEU_BTreeTraverse*)_ceu_org)->ok) = ((__ceu_casted)->ret);
}

#line 33 "btree-1.ceu"
    }
#line 33 "btree-1.ceu"
/* CLEAR: Block (33) */
#line 33 "btree-1.ceu"
    if (0) {

#line 33 "btree-1.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
}

#line 33 "btree-1.ceu"
    }
#line 33 "btree-1.ceu"
    }
#line 33 "btree-1.ceu"
    }
#line 33 "btree-1.ceu"
/* CLEAR: Block (33) */
#line 33 "btree-1.ceu"
    if (0) {

#line 33 "btree-1.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
} else {
/* NODE: Block 524 */

#line 33 "btree-1.ceu"
    {/* NODE: Stmts 523 */

#line 33 "btree-1.ceu"
    {/* NODE: Set 1215 */

#line 33 "btree-1.ceu"
/* SET: ok *//* NODE: RawExp 511 */

#line 33 "btree-1.ceu"
    (((CEU_BTreeTraverse*)_ceu_org)->ok) = _ceu_app->ret;
#line 33 "btree-1.ceu"
    }
#line 33 "btree-1.ceu"
/* CLEAR: Block (33) */
#line 33 "btree-1.ceu"
    if (0) {

#line 33 "btree-1.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
}

#line 33 "btree-1.ceu"
    }
#line 33 "btree-1.ceu"
/* CLEAR: Block (33) */
#line 33 "btree-1.ceu"
    {
    tceu_evt evt;
             evt.id = CEU_IN__CLEAR;
    ceu_sys_go_ex(_ceu_app, &evt,
                  _ceu_stk,
                  _ceu_org,
                  &_ceu_org->trls[ 1 ],
                  &_ceu_org->trls[ 8 ]);
                                        /* excludes +1 */
}

/* LONGJMP
 * Block termination: we will abort all trails between [t1,t2].
 * Return status=1 to distinguish from longjmp from organism termination.
 * We want to continue from "me.lbl_jmp" below.
 */
#ifdef CEU_ORGS
_ceu_app->stk_jmp.org = _ceu_org;
#endif
_ceu_app->stk_jmp.trl = _ceu_trl;
_ceu_app->stk_jmp.lbl = BTreeTraverse_Block_jmp_35;
ceu_longjmp(_ceu_app, _ceu_org,
            1,7);

#line 33 "btree-1.ceu"
case BTreeTraverse_Block_jmp_35:;
#line 33 "btree-1.ceu"
    if (0) {

#line 33 "btree-1.ceu"
case BTreeTraverse_optorg_reset_34:;
#line 33 "btree-1.ceu"
        {
        tceu_kill* __ceu_casted = (tceu_kill*)_ceu_evt->param;
        if ( ((((CEU_BTreeTraverse*)_ceu_org)->_body_225_11).tag != CEU__OPTION__BODY_225__PTR_NIL) &&
             ((((CEU_BTreeTraverse*)_ceu_org)->_body_225_11).SOME.v == __ceu_casted->org_or_adt) )
        {
            (((CEU_BTreeTraverse*)_ceu_org)->_body_225_11) = CEU__OPTION__BODY_225__PTR_pack(NULL);
        }
    }

#line 33 "btree-1.ceu"
    /*  RESET OPT-ORG TO NULL */
_ceu_org->trls[ 2 ].evt = CEU_IN__ok_killed;
_ceu_org->trls[ 2 ].lbl = BTreeTraverse_optorg_reset_34;

#line 33 "btree-1.ceu"
    return;
#line 33 "btree-1.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 33 "btree-1.ceu"
    }
#line 32 "btree-1.ceu"
    }/* NODE: Stmts 1219 */

#line 58 "btree-1.ceu"
    {/* NODE: Set 1217 */

#line 58 "btree-1.ceu"
/* SET: _ret *//* NODE: Var 227 */

#line 58 "btree-1.ceu"
    (((CEU_BTreeTraverse*)_ceu_org)->_ret_7) = (((CEU_BTreeTraverse*)_ceu_org)->ok);
#line 58 "btree-1.ceu"
    #ifdef CEU_ORGS_AWAIT
    _ceu_org->ret = (((CEU_BTreeTraverse*)_ceu_org)->_ret_7);
    /* HACK_8: result of immediate spawn termination */
    _ceu_app->ret = _ceu_org->ret;
#endif
/* NODE: Escape 1218 */

#line 58 "btree-1.ceu"
    _ceu_lbl = BTreeTraverse_Set_out_3;
goto _CEU_GOTO_;

#line 58 "btree-1.ceu"
    }
#line 32 "btree-1.ceu"
    }
#line 32 "btree-1.ceu"
/* CLEAR: Block (32) */
#line 32 "btree-1.ceu"
    if (0) {

#line 32 "btree-1.ceu"
case BTreeTraverse_Block__fin_36:;
#line 32 "btree-1.ceu"
    return;
#line 32 "btree-1.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 29 "btree-1.ceu"
    return;
#line 29 "btree-1.ceu"
case BTreeTraverse_Set_out_3:;
#line 29 "btree-1.ceu"
/* CLEAR: SetBlock (29) */
#line 29 "btree-1.ceu"
    {
    tceu_evt evt;
             evt.id = CEU_IN__CLEAR;
    ceu_sys_go_ex(_ceu_app, &evt,
                  _ceu_stk,
                  _ceu_org,
                  &_ceu_org->trls[ 0 ],
                  &_ceu_org->trls[ 9 ]);
                                        /* excludes +1 */
}

/* LONGJMP
 * Block termination: we will abort all trails between [t1,t2].
 * Return status=1 to distinguish from longjmp from organism termination.
 * We want to continue from "me.lbl_jmp" below.
 */
#ifdef CEU_ORGS
_ceu_app->stk_jmp.org = _ceu_org;
#endif
_ceu_app->stk_jmp.trl = _ceu_trl;
_ceu_app->stk_jmp.lbl = BTreeTraverse_Set_jmp_4;
ceu_longjmp(_ceu_app, _ceu_org,
            0,8);

#line 29 "btree-1.ceu"
case BTreeTraverse_Set_jmp_4:;
#line 29 "btree-1.ceu"
    }
#line 29 "btree-1.ceu"
/* CLEAR: Block (29) */
#line 29 "btree-1.ceu"
    if (0) {

#line 29 "btree-1.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 29 "btree-1.ceu"
    }
#line 29 "btree-1.ceu"
/* CLEAR: Block (29) */
#line 29 "btree-1.ceu"
    {
    tceu_evt evt;
             evt.id = CEU_IN__CLEAR;
    ceu_sys_go_ex(_ceu_app, &evt,
                  _ceu_stk,
                  _ceu_org,
                  &_ceu_org->trls[ 0 ],
                  &_ceu_org->trls[ 11 ]);
                                        /* excludes +1 */
}

/* LONGJMP
 * Block termination: we will abort all trails between [t1,t2].
 * Return status=1 to distinguish from longjmp from organism termination.
 * We want to continue from "me.lbl_jmp" below.
 */
#ifdef CEU_ORGS
_ceu_app->stk_jmp.org = _ceu_org;
#endif
_ceu_app->stk_jmp.trl = _ceu_trl;
_ceu_app->stk_jmp.lbl = BTreeTraverse_Block_jmp_39;
ceu_longjmp(_ceu_app, _ceu_org,
            0,10);

#line 29 "btree-1.ceu"
case BTreeTraverse_Block_jmp_39:;
#line 29 "btree-1.ceu"
    if (0) {

#line 29 "btree-1.ceu"
case BTreeTraverse_Block__fin_38:;
#line 29 "btree-1.ceu"
    return;
#line 29 "btree-1.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 29 "btree-1.ceu"
    {
    tceu_evt evt;
             evt.id = CEU_IN__CLEAR;
    ceu_sys_go_ex(_ceu_app, &evt,
                  _ceu_stk,
                  _ceu_org,
                  &_ceu_org->trls[_ceu_org->n], /* to the end, only free it */
                  NULL);
}

#line 29 "btree-1.ceu"
    return;/* NODE: Dcl_cls 3 */

#line 33 "btree-1.ceu"
case Class_Scope:;/* NODE: Block 544 */

#line 33 "btree-1.ceu"
    {/* NODE: Stmts 543 */

#line 33 "btree-1.ceu"
    {/* NODE: Block 541 */

#line 33 "btree-1.ceu"
    {/* NODE: Stmts 545 */

#line 33 "btree-1.ceu"
    {/* NODE: Block 533 */

#line 33 "btree-1.ceu"
    {/* NODE: Stmts 532 */

#line 33 "btree-1.ceu"
    {/* NODE: AwaitN 531 */

#line 33 "btree-1.ceu"
    return;
#line 33 "btree-1.ceu"
    }
#line 33 "btree-1.ceu"
/* CLEAR: Block (33) */
#line 33 "btree-1.ceu"
    if (0) {

#line 33 "btree-1.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 33 "btree-1.ceu"
    }
#line 33 "btree-1.ceu"
/* CLEAR: Block (33) */
#line 33 "btree-1.ceu"
    if (0) {

#line 33 "btree-1.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 33 "btree-1.ceu"
    }
#line 33 "btree-1.ceu"
/* CLEAR: Block (33) */
#line 33 "btree-1.ceu"
    if (0) {

#line 33 "btree-1.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 33 "btree-1.ceu"
    {
    tceu_evt evt;
             evt.id = CEU_IN__CLEAR;
    ceu_sys_go_ex(_ceu_app, &evt,
                  _ceu_stk,
                  _ceu_org,
                  &_ceu_org->trls[_ceu_org->n], /* to the end, only free it */
                  NULL);
}

#line 33 "btree-1.ceu"
    return;/* NODE: Dcl_cls 4 */

#line 33 "btree-1.ceu"
case Class_Body_225:;/* NODE: Block 1156 */

#line 33 "btree-1.ceu"
    /*  FINALIZE */
_ceu_org->trls[ 5 ].evt = CEU_IN__CLEAR;
_ceu_org->trls[ 5 ].lbl = Body_225_Block__fin_30;

#line 33 "btree-1.ceu"
    {/* NODE: Stmts 1155 */

#line 33 "btree-1.ceu"
    {/* NODE: Block 552 */

#line 33 "btree-1.ceu"
    {/* NODE: Stmts 551 */

#line 33 "btree-1.ceu"
    {/* NODE: Dcl_var 548 */
/* NODE: SetBlock 550 */
/* NODE: Block 485 */

#line 33 "btree-1.ceu"
    {/* NODE: Stmts 484 */

#line 33 "btree-1.ceu"
    {/* NODE: ParOr 560 */

#line 33 "btree-1.ceu"
/* ParOr: spawn subs */
#line 33 "btree-1.ceu"
    {
    tceu_stk stk_ = { NULL, _ceu_org, 0, 4, {} };
    if (setjmp(stk_.jmp) != 0) {
#ifdef CEU_ORGS
        _ceu_org = _ceu_app->stk_jmp.org;
#endif
        _ceu_trl = _ceu_app->stk_jmp.trl;

#line 33 "btree-1.ceu"
    _ceu_lbl = _ceu_app->stk_jmp.lbl;
goto _CEU_GOTO_;

#line 33 "btree-1.ceu"
        }

    /* SETJMP: starting trails in a par
     * The 1st trail might abort an enclosing par/or, or emit something that 
     * does.
     */

#line 33 "btree-1.ceu"
        _ceu_org->trls[ 0 ].lbl = Body_225_ParOr_sub_1_8;
    _ceu_stk->up = &stk_;
    ceu_app_go(_ceu_app,NULL,_ceu_org,
               &_ceu_org->trls[ 0 ],
               &stk_);
    _ceu_stk->up = NULL;

#line 33 "btree-1.ceu"
        _ceu_trl = &_ceu_org->trls[ 1 ];

#line 33 "btree-1.ceu"
    }
/* NODE: Block 480 */

#line 33 "btree-1.ceu"
    {/* NODE: Stmts 479 */

#line 33 "btree-1.ceu"
    {/* NODE: Block 224 */

#line 34 "btree-1.ceu"
    {/* NODE: Stmts 223 */

#line 34 "btree-1.ceu"
    {/* NODE: ParOr 594 */

#line 34 "btree-1.ceu"
/* ParOr: spawn subs */
#line 34 "btree-1.ceu"
    {
    tceu_stk stk_ = { NULL, _ceu_org, 1, 4, {} };
    if (setjmp(stk_.jmp) != 0) {
#ifdef CEU_ORGS
        _ceu_org = _ceu_app->stk_jmp.org;
#endif
        _ceu_trl = _ceu_app->stk_jmp.trl;

#line 34 "btree-1.ceu"
    _ceu_lbl = _ceu_app->stk_jmp.lbl;
goto _CEU_GOTO_;

#line 34 "btree-1.ceu"
        }

    /* SETJMP: starting trails in a par
     * The 1st trail might abort an enclosing par/or, or emit something that 
     * does.
     */

#line 34 "btree-1.ceu"
        _ceu_org->trls[ 1 ].lbl = Body_225_ParOr_sub_1_12;
    _ceu_stk->up = &stk_;
    ceu_app_go(_ceu_app,NULL,_ceu_org,
               &_ceu_org->trls[ 1 ],
               &stk_);
    _ceu_stk->up = NULL;

#line 34 "btree-1.ceu"
        _ceu_trl = &_ceu_org->trls[ 2 ];

#line 34 "btree-1.ceu"
    }
/* NODE: Block 221 */

#line 35 "btree-1.ceu"
    {/* NODE: Stmts 220 */

#line 35 "btree-1.ceu"
    {/* NODE: If 628 */

#line 35 "btree-1.ceu"
    if ((((((CEU_BTree *)(  ((tceu_pool_adts*) (&((CEU_Body_225*)_ceu_org)->t))->root)))->tag == CEU_BTREE_SEQUENCE) /* XXXX */)) {
/* NODE: Block 171 */

#line 36 "btree-1.ceu"
    {/* NODE: Stmts 170 */

#line 36 "btree-1.ceu"
    {/* NODE: Stmts 635 */

#line 36 "btree-1.ceu"
    {/* NODE: Dcl_var 632 */
/* NODE: Block 679 */

#line 36 "btree-1.ceu"
    {
#line 36 "btree-1.ceu"
    #ifdef CEU_ORGS
_ceu_org->trls[ 2 ].evt = CEU_IN__ORG;
_ceu_org->trls[ 2 ].org = NULL;
#endif

#line 36 "btree-1.ceu"
    (((CEU_Body_225*)_ceu_org)->_body_151_17).tag = CEU__OPTION__BODY_225__PTR_NIL;

#line 36 "btree-1.ceu"
    /*  RESET OPT-ORG TO NULL */
_ceu_org->trls[ 3 ].evt = CEU_IN__ok_killed;
_ceu_org->trls[ 3 ].lbl = Body_225_optorg_reset_17;
_ceu_org->trls[ 3 ].org_or_adt = NULL;

#line 36 "btree-1.ceu"
    _ceu_trl = &_ceu_org->trls[ 4 ];
/* NODE: Stmts 678 */

#line 36 "btree-1.ceu"
    {/* NODE: Dcl_adt 1380 */
/* NODE: Dcl_var 666 */

#line 36 "btree-1.ceu"
/* start org: _s */
#line 36 "btree-1.ceu"
        /* resets org memory and starts org.trail[0]=Class_XXX */
    /* TODO: BUG: _ceu_org is not necessarily the parent for pool allocations */
    ceu_out_org_init(_ceu_app, ((tceu_org*) &(((CEU_Body_225*)_ceu_org)->_s_16)),2,Class_Scope,
                     3,
                     0,
                     _ceu_org,2);
/* TODO: currently idx is always "1" for all interfaces access because pools 
 * are all together there. When we have separate trls for pools, we'll have to 
 * indirectly access the offset in the interface. */

#line 36 "btree-1.ceu"
    {
    tceu_stk stk_ = { NULL, ((tceu_org*) &(((CEU_Body_225*)_ceu_org)->_s_16)), 0, ((tceu_org*) &(((CEU_Body_225*)_ceu_org)->_s_16))->n, {} };
    if (setjmp(stk_.jmp) != 0) {
#ifdef CEU_ORGS
        _ceu_org = _ceu_app->stk_jmp.org;
#endif
        _ceu_trl = _ceu_app->stk_jmp.trl;

#line 36 "btree-1.ceu"
    _ceu_lbl = _ceu_app->stk_jmp.lbl;
goto _CEU_GOTO_;

#line 36 "btree-1.ceu"
        }

    /* SETJMP: spawning a new org
     * The new org might emit a global event that awakes a par/or enclosing the 
     * call point.
     */
    _ceu_stk->up = &stk_;
    ceu_app_go(_ceu_app,NULL,
               ((tceu_org*) &(((CEU_Body_225*)_ceu_org)->_s_16)), &((tceu_org*) &(((CEU_Body_225*)_ceu_org)->_s_16))->trls[0],
               &stk_);
    _ceu_stk->up = NULL;

#line 36 "btree-1.ceu"
    }
/* NODE: Dcl_var 668 */
/* NODE: Set 680 */

#line 36 "btree-1.ceu"
/* SET: _body_151 *//* NODE: Spawn 656 */

#line 36 "btree-1.ceu"
    /*{*/
    tceu_org* __ceu_new_656;

#line 36 "btree-1.ceu"
    #if !defined(CEU_ORGS_NEWS_MALLOC)
    __ceu_new_656 = (tceu_org*) ceu_pool_alloc(&(*((CEU_Body_225*)_ceu_org)->_bodies).pool);
#elif !defined(CEU_ORGS_NEWS_POOL)
    __ceu_new_656 = (tceu_org*) ceu_out_realloc(NULL, sizeof(CEU_Body_225));
#else
    if ((*((CEU_Body_225*)_ceu_org)->_bodies).pool.queue == NULL) {
        __ceu_new_656 = (tceu_org*) ceu_out_realloc(NULL, sizeof(CEU_Body_225));
    } else {
        __ceu_new_656 = (tceu_org*) ceu_pool_alloc(&(*((CEU_Body_225*)_ceu_org)->_bodies).pool);
    }
#endif

#line 36 "btree-1.ceu"
    (((CEU_Body_225*)_ceu_org)->_body_151_17) = (CEU__OPTION__BODY_225__PTR_pack(((CEU_Body_225*)__ceu_new_656)));
#line 36 "btree-1.ceu"
        if (__ceu_new_656 != NULL) {

#line 36 "btree-1.ceu"
    #ifdef CEU_ORGS_NEWS_POOL
        __ceu_new_656->pool = &(*((CEU_Body_225*)_ceu_org)->_bodies);
#endif

#line 36 "btree-1.ceu"
/* start org: dyn */
#line 36 "btree-1.ceu"
        /* resets org memory and starts org.trail[0]=Class_XXX */
    /* TODO: BUG: _ceu_org is not necessarily the parent for pool allocations */
    ceu_out_org_init(_ceu_app, ((tceu_org*) &(*((CEU_Body_225*)__ceu_new_656))),7,Class_Body_225,
                     4,
                     1,
                     (*((CEU_Body_225*)_ceu_org)->_bodies).parent_org,(*((CEU_Body_225*)_ceu_org)->_bodies).parent_trl);
/* TODO: currently idx is always "1" for all interfaces access because pools 
 * are all together there. When we have separate trls for pools, we'll have to 
 * indirectly access the offset in the interface. */

#line 36 "btree-1.ceu"
        ((CEU_Body_225*)((tceu_org*) &(*((CEU_Body_225*)__ceu_new_656))))->_out =
        ((CEU_Body_225*)_ceu_org)->_out;

#line 36 "btree-1.ceu"
        _ceu_constr_655(_ceu_app, ((tceu_org*) &(*((CEU_Body_225*)__ceu_new_656))), _ceu_org);

#line 36 "btree-1.ceu"
    {
    tceu_stk stk_ = { NULL, ((tceu_org*) &(*((CEU_Body_225*)__ceu_new_656))), 0, ((tceu_org*) &(*((CEU_Body_225*)__ceu_new_656)))->n, {} };
    if (setjmp(stk_.jmp) != 0) {
#ifdef CEU_ORGS
        _ceu_org = _ceu_app->stk_jmp.org;
#endif
        _ceu_trl = _ceu_app->stk_jmp.trl;

#line 36 "btree-1.ceu"
    _ceu_lbl = _ceu_app->stk_jmp.lbl;
goto _CEU_GOTO_;

#line 36 "btree-1.ceu"
        }

    /* SETJMP: spawning a new org
     * The new org might emit a global event that awakes a par/or enclosing the 
     * call point.
     */
    _ceu_stk->up = &stk_;
    ceu_app_go(_ceu_app,NULL,
               ((tceu_org*) &(*((CEU_Body_225*)__ceu_new_656))), &((tceu_org*) &(*((CEU_Body_225*)__ceu_new_656)))->trls[0],
               &stk_);
    _ceu_stk->up = NULL;

#line 36 "btree-1.ceu"
        if (!((tceu_org*) &(*((CEU_Body_225*)__ceu_new_656)))->isAlive) {
        (((CEU_Body_225*)_ceu_org)->_body_151_17) = CEU__OPTION__BODY_225__PTR_pack(NULL);
    }

#line 36 "btree-1.ceu"
    }

#line 36 "btree-1.ceu"
        }
/*}*/
/* NODE: If 677 */

#line 36 "btree-1.ceu"
    if (((((CEU_Body_225*)_ceu_org)->_body_151_17).tag != CEU__OPTION__BODY_225__PTR_NIL)) {
/* NODE: Block 674 */

#line 36 "btree-1.ceu"
    {/* NODE: Stmts 673 */

#line 36 "btree-1.ceu"
    {/* NODE: Stmts 734 */

#line 36 "btree-1.ceu"
    {/* NODE: Nothing 688 */
/* NODE: Nothing 1440 */
/* NODE: Nothing 1441 */
/* NODE: Stmts 733 */

#line 36 "btree-1.ceu"
    {/* NODE: If 732 */

#line 36 "btree-1.ceu"
    if ((!(((*((tceu_org*)(((CEU__OPTION__BODY_225__PTR_SOME_assert(_ceu_app, (&((CEU_Body_225*)_ceu_org)->_body_151_17),__FILE__,__LINE__)->SOME.v))))).isAlive)))) {
/* NODE: Block 729 */

#line 36 "btree-1.ceu"
    {/* NODE: Stmts 728 */

#line 36 "btree-1.ceu"
    {/* NODE: Set 708 */

#line 36 "btree-1.ceu"
/* SET: ok *//* NODE: Op1_cast 706 */

#line 36 "btree-1.ceu"
    (((CEU_Body_225*)_ceu_org)->ok_14) = ((int)(((*((tceu_org*)(((CEU__OPTION__BODY_225__PTR_SOME_assert(_ceu_app, (&((CEU_Body_225*)_ceu_org)->_body_151_17),__FILE__,__LINE__)->SOME.v))))).ret)));
#line 36 "btree-1.ceu"
    }
#line 36 "btree-1.ceu"
/* CLEAR: Block (36) */
#line 36 "btree-1.ceu"
    if (0) {

#line 36 "btree-1.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
} else {
/* NODE: Block 731 */

#line 36 "btree-1.ceu"
    {/* NODE: Stmts 730 */

#line 36 "btree-1.ceu"
    {/* NODE: Set 738 */

#line 36 "btree-1.ceu"
/* SET: table: 0x135e4a0 *//* NODE: Await 693 */

#line 36 "btree-1.ceu"
    _CEU_NO_693_:
if (0) { goto _CEU_NO_693_; /* avoids "not used" warning */ }

#line 36 "btree-1.ceu"
    _ceu_trl->evt = CEU_IN__ok_killed;
_ceu_trl->lbl = Body_225_Awake__ok_killed_16;
_ceu_trl->seqno = _ceu_app->seqno;

#line 36 "btree-1.ceu"
    _ceu_trl->org_or_adt = (void*)(((CEU__OPTION__BODY_225__PTR_SOME_assert(_ceu_app, (&((CEU_Body_225*)_ceu_org)->_body_151_17),__FILE__,__LINE__)->SOME.v)));

#line 36 "btree-1.ceu"
    return;

case Body_225_Awake__ok_killed_16:;

#line 36 "btree-1.ceu"
    #ifdef CEU_DEBUG_TRAILS
#ifndef CEU_OS
printf("\tOK!\n");
#endif
#endif

#line 36 "btree-1.ceu"
    {

#line 36 "btree-1.ceu"
        tceu_kill* __ceu_casted = (tceu_kill*) _ceu_evt->param;

#line 36 "btree-1.ceu"
        (((CEU_Body_225*)_ceu_org)->ok_14) = ((__ceu_casted)->ret);
}

#line 36 "btree-1.ceu"
    }
#line 36 "btree-1.ceu"
/* CLEAR: Block (36) */
#line 36 "btree-1.ceu"
    if (0) {

#line 36 "btree-1.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
}

#line 36 "btree-1.ceu"
    }
#line 36 "btree-1.ceu"
    }
#line 36 "btree-1.ceu"
    }
#line 36 "btree-1.ceu"
/* CLEAR: Block (36) */
#line 36 "btree-1.ceu"
    if (0) {

#line 36 "btree-1.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
} else {
/* NODE: Block 676 */

#line 36 "btree-1.ceu"
    {/* NODE: Stmts 675 */

#line 36 "btree-1.ceu"
    {/* NODE: Set 739 */

#line 36 "btree-1.ceu"
/* SET: ok *//* NODE: RawExp 663 */

#line 36 "btree-1.ceu"
    (((CEU_Body_225*)_ceu_org)->ok_14) = _ceu_app->ret;
#line 36 "btree-1.ceu"
    }
#line 36 "btree-1.ceu"
/* CLEAR: Block (36) */
#line 36 "btree-1.ceu"
    if (0) {

#line 36 "btree-1.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
}

#line 36 "btree-1.ceu"
    }
#line 36 "btree-1.ceu"
/* CLEAR: Block (36) */
#line 36 "btree-1.ceu"
    {
    tceu_evt evt;
             evt.id = CEU_IN__CLEAR;
    ceu_sys_go_ex(_ceu_app, &evt,
                  _ceu_stk,
                  _ceu_org,
                  &_ceu_org->trls[ 2 ],
                  &_ceu_org->trls[ 5 ]);
                                        /* excludes +1 */
}

/* LONGJMP
 * Block termination: we will abort all trails between [t1,t2].
 * Return status=1 to distinguish from longjmp from organism termination.
 * We want to continue from "me.lbl_jmp" below.
 */
#ifdef CEU_ORGS
_ceu_app->stk_jmp.org = _ceu_org;
#endif
_ceu_app->stk_jmp.trl = _ceu_trl;
_ceu_app->stk_jmp.lbl = Body_225_Block_jmp_18;
ceu_longjmp(_ceu_app, _ceu_org,
            2,4);

#line 36 "btree-1.ceu"
case Body_225_Block_jmp_18:;
#line 36 "btree-1.ceu"
    if (0) {

#line 36 "btree-1.ceu"
case Body_225_optorg_reset_17:;
#line 36 "btree-1.ceu"
        {
        tceu_kill* __ceu_casted = (tceu_kill*)_ceu_evt->param;
        if ( ((((CEU_Body_225*)_ceu_org)->_body_151_17).tag != CEU__OPTION__BODY_225__PTR_NIL) &&
             ((((CEU_Body_225*)_ceu_org)->_body_151_17).SOME.v == __ceu_casted->org_or_adt) )
        {
            (((CEU_Body_225*)_ceu_org)->_body_151_17) = CEU__OPTION__BODY_225__PTR_pack(NULL);
        }
    }

#line 36 "btree-1.ceu"
    /*  RESET OPT-ORG TO NULL */
_ceu_org->trls[ 3 ].evt = CEU_IN__ok_killed;
_ceu_org->trls[ 3 ].lbl = Body_225_optorg_reset_17;

#line 36 "btree-1.ceu"
    return;
#line 36 "btree-1.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 36 "btree-1.ceu"
    }/* NODE: If 741 */

#line 37 "btree-1.ceu"
    if (((((CEU_Body_225*)_ceu_org)->ok_14)==0)) {
/* NODE: Block 159 */

#line 38 "btree-1.ceu"
    {/* NODE: Stmts 158 */

#line 38 "btree-1.ceu"
    {/* NODE: Stmts 745 */

#line 38 "btree-1.ceu"
    {/* NODE: Set 743 */

#line 38 "btree-1.ceu"
/* SET: _ret *//* NODE: Var 156 */

#line 38 "btree-1.ceu"
    (((CEU_Body_225*)_ceu_org)->_ret_13) = (((CEU_Body_225*)_ceu_org)->ok_14);
#line 38 "btree-1.ceu"
    #ifdef CEU_ORGS_AWAIT
    _ceu_org->ret = (((CEU_Body_225*)_ceu_org)->_ret_13);
    /* HACK_8: result of immediate spawn termination */
    _ceu_app->ret = _ceu_org->ret;
#endif
/* NODE: Escape 744 */

#line 38 "btree-1.ceu"
    _ceu_lbl = Body_225_Set_out_6;
goto _CEU_GOTO_;

#line 38 "btree-1.ceu"
    }
#line 38 "btree-1.ceu"
    }
#line 38 "btree-1.ceu"
/* CLEAR: Block (38) */
#line 38 "btree-1.ceu"
    if (0) {

#line 38 "btree-1.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
} else {
/* NODE: Nothing 740 */
}
/* NODE: Block 789 */

#line 40 "btree-1.ceu"
    {
#line 40 "btree-1.ceu"
    #ifdef CEU_ORGS
_ceu_org->trls[ 2 ].evt = CEU_IN__ORG;
_ceu_org->trls[ 2 ].org = NULL;
#endif

#line 40 "btree-1.ceu"
    (((CEU_Body_225*)_ceu_org)->_body_166_19).tag = CEU__OPTION__BODY_225__PTR_NIL;

#line 40 "btree-1.ceu"
    /*  RESET OPT-ORG TO NULL */
_ceu_org->trls[ 3 ].evt = CEU_IN__ok_killed;
_ceu_org->trls[ 3 ].lbl = Body_225_optorg_reset_20;
_ceu_org->trls[ 3 ].org_or_adt = NULL;

#line 40 "btree-1.ceu"
    _ceu_trl = &_ceu_org->trls[ 4 ];
/* NODE: Stmts 788 */

#line 40 "btree-1.ceu"
    {/* NODE: Dcl_var 776 */

#line 40 "btree-1.ceu"
/* start org: _s */
#line 40 "btree-1.ceu"
        /* resets org memory and starts org.trail[0]=Class_XXX */
    /* TODO: BUG: _ceu_org is not necessarily the parent for pool allocations */
    ceu_out_org_init(_ceu_app, ((tceu_org*) &(((CEU_Body_225*)_ceu_org)->_s_18)),2,Class_Scope,
                     3,
                     0,
                     _ceu_org,2);
/* TODO: currently idx is always "1" for all interfaces access because pools 
 * are all together there. When we have separate trls for pools, we'll have to 
 * indirectly access the offset in the interface. */

#line 40 "btree-1.ceu"
    {
    tceu_stk stk_ = { NULL, ((tceu_org*) &(((CEU_Body_225*)_ceu_org)->_s_18)), 0, ((tceu_org*) &(((CEU_Body_225*)_ceu_org)->_s_18))->n, {} };
    if (setjmp(stk_.jmp) != 0) {
#ifdef CEU_ORGS
        _ceu_org = _ceu_app->stk_jmp.org;
#endif
        _ceu_trl = _ceu_app->stk_jmp.trl;

#line 40 "btree-1.ceu"
    _ceu_lbl = _ceu_app->stk_jmp.lbl;
goto _CEU_GOTO_;

#line 40 "btree-1.ceu"
        }

    /* SETJMP: spawning a new org
     * The new org might emit a global event that awakes a par/or enclosing the 
     * call point.
     */
    _ceu_stk->up = &stk_;
    ceu_app_go(_ceu_app,NULL,
               ((tceu_org*) &(((CEU_Body_225*)_ceu_org)->_s_18)), &((tceu_org*) &(((CEU_Body_225*)_ceu_org)->_s_18))->trls[0],
               &stk_);
    _ceu_stk->up = NULL;

#line 40 "btree-1.ceu"
    }
/* NODE: Dcl_var 778 */
/* NODE: Set 790 */

#line 40 "btree-1.ceu"
/* SET: _body_166 *//* NODE: Spawn 766 */

#line 40 "btree-1.ceu"
    /*{*/
    tceu_org* __ceu_new_766;

#line 40 "btree-1.ceu"
    #if !defined(CEU_ORGS_NEWS_MALLOC)
    __ceu_new_766 = (tceu_org*) ceu_pool_alloc(&(*((CEU_Body_225*)_ceu_org)->_bodies).pool);
#elif !defined(CEU_ORGS_NEWS_POOL)
    __ceu_new_766 = (tceu_org*) ceu_out_realloc(NULL, sizeof(CEU_Body_225));
#else
    if ((*((CEU_Body_225*)_ceu_org)->_bodies).pool.queue == NULL) {
        __ceu_new_766 = (tceu_org*) ceu_out_realloc(NULL, sizeof(CEU_Body_225));
    } else {
        __ceu_new_766 = (tceu_org*) ceu_pool_alloc(&(*((CEU_Body_225*)_ceu_org)->_bodies).pool);
    }
#endif

#line 40 "btree-1.ceu"
    (((CEU_Body_225*)_ceu_org)->_body_166_19) = (CEU__OPTION__BODY_225__PTR_pack(((CEU_Body_225*)__ceu_new_766)));
#line 40 "btree-1.ceu"
        if (__ceu_new_766 != NULL) {

#line 40 "btree-1.ceu"
    #ifdef CEU_ORGS_NEWS_POOL
        __ceu_new_766->pool = &(*((CEU_Body_225*)_ceu_org)->_bodies);
#endif

#line 40 "btree-1.ceu"
/* start org: dyn */
#line 40 "btree-1.ceu"
        /* resets org memory and starts org.trail[0]=Class_XXX */
    /* TODO: BUG: _ceu_org is not necessarily the parent for pool allocations */
    ceu_out_org_init(_ceu_app, ((tceu_org*) &(*((CEU_Body_225*)__ceu_new_766))),7,Class_Body_225,
                     4,
                     1,
                     (*((CEU_Body_225*)_ceu_org)->_bodies).parent_org,(*((CEU_Body_225*)_ceu_org)->_bodies).parent_trl);
/* TODO: currently idx is always "1" for all interfaces access because pools 
 * are all together there. When we have separate trls for pools, we'll have to 
 * indirectly access the offset in the interface. */

#line 40 "btree-1.ceu"
        ((CEU_Body_225*)((tceu_org*) &(*((CEU_Body_225*)__ceu_new_766))))->_out =
        ((CEU_Body_225*)_ceu_org)->_out;

#line 40 "btree-1.ceu"
        _ceu_constr_765(_ceu_app, ((tceu_org*) &(*((CEU_Body_225*)__ceu_new_766))), _ceu_org);

#line 40 "btree-1.ceu"
    {
    tceu_stk stk_ = { NULL, ((tceu_org*) &(*((CEU_Body_225*)__ceu_new_766))), 0, ((tceu_org*) &(*((CEU_Body_225*)__ceu_new_766)))->n, {} };
    if (setjmp(stk_.jmp) != 0) {
#ifdef CEU_ORGS
        _ceu_org = _ceu_app->stk_jmp.org;
#endif
        _ceu_trl = _ceu_app->stk_jmp.trl;

#line 40 "btree-1.ceu"
    _ceu_lbl = _ceu_app->stk_jmp.lbl;
goto _CEU_GOTO_;

#line 40 "btree-1.ceu"
        }

    /* SETJMP: spawning a new org
     * The new org might emit a global event that awakes a par/or enclosing the 
     * call point.
     */
    _ceu_stk->up = &stk_;
    ceu_app_go(_ceu_app,NULL,
               ((tceu_org*) &(*((CEU_Body_225*)__ceu_new_766))), &((tceu_org*) &(*((CEU_Body_225*)__ceu_new_766)))->trls[0],
               &stk_);
    _ceu_stk->up = NULL;

#line 40 "btree-1.ceu"
        if (!((tceu_org*) &(*((CEU_Body_225*)__ceu_new_766)))->isAlive) {
        (((CEU_Body_225*)_ceu_org)->_body_166_19) = CEU__OPTION__BODY_225__PTR_pack(NULL);
    }

#line 40 "btree-1.ceu"
    }

#line 40 "btree-1.ceu"
        }
/*}*/
/* NODE: If 787 */

#line 40 "btree-1.ceu"
    if (((((CEU_Body_225*)_ceu_org)->_body_166_19).tag != CEU__OPTION__BODY_225__PTR_NIL)) {
/* NODE: Block 784 */

#line 40 "btree-1.ceu"
    {/* NODE: Stmts 783 */

#line 40 "btree-1.ceu"
    {/* NODE: Stmts 844 */

#line 40 "btree-1.ceu"
    {/* NODE: Nothing 798 */
/* NODE: Nothing 1446 */
/* NODE: Nothing 1447 */
/* NODE: Stmts 843 */

#line 40 "btree-1.ceu"
    {/* NODE: If 842 */

#line 40 "btree-1.ceu"
    if ((!(((*((tceu_org*)(((CEU__OPTION__BODY_225__PTR_SOME_assert(_ceu_app, (&((CEU_Body_225*)_ceu_org)->_body_166_19),__FILE__,__LINE__)->SOME.v))))).isAlive)))) {
/* NODE: Block 839 */

#line 40 "btree-1.ceu"
    {/* NODE: Stmts 838 */

#line 40 "btree-1.ceu"
    {/* NODE: Set 818 */

#line 40 "btree-1.ceu"
/* SET: ok *//* NODE: Op1_cast 816 */

#line 40 "btree-1.ceu"
    (((CEU_Body_225*)_ceu_org)->ok_14) = ((int)(((*((tceu_org*)(((CEU__OPTION__BODY_225__PTR_SOME_assert(_ceu_app, (&((CEU_Body_225*)_ceu_org)->_body_166_19),__FILE__,__LINE__)->SOME.v))))).ret)));
#line 40 "btree-1.ceu"
    }
#line 40 "btree-1.ceu"
/* CLEAR: Block (40) */
#line 40 "btree-1.ceu"
    if (0) {

#line 40 "btree-1.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
} else {
/* NODE: Block 841 */

#line 40 "btree-1.ceu"
    {/* NODE: Stmts 840 */

#line 40 "btree-1.ceu"
    {/* NODE: Set 848 */

#line 40 "btree-1.ceu"
/* SET: table: 0x135daf0 *//* NODE: Await 803 */

#line 40 "btree-1.ceu"
    _CEU_NO_803_:
if (0) { goto _CEU_NO_803_; /* avoids "not used" warning */ }

#line 40 "btree-1.ceu"
    _ceu_trl->evt = CEU_IN__ok_killed;
_ceu_trl->lbl = Body_225_Awake__ok_killed_19;
_ceu_trl->seqno = _ceu_app->seqno;

#line 40 "btree-1.ceu"
    _ceu_trl->org_or_adt = (void*)(((CEU__OPTION__BODY_225__PTR_SOME_assert(_ceu_app, (&((CEU_Body_225*)_ceu_org)->_body_166_19),__FILE__,__LINE__)->SOME.v)));

#line 40 "btree-1.ceu"
    return;

case Body_225_Awake__ok_killed_19:;

#line 40 "btree-1.ceu"
    #ifdef CEU_DEBUG_TRAILS
#ifndef CEU_OS
printf("\tOK!\n");
#endif
#endif

#line 40 "btree-1.ceu"
    {

#line 40 "btree-1.ceu"
        tceu_kill* __ceu_casted = (tceu_kill*) _ceu_evt->param;

#line 40 "btree-1.ceu"
        (((CEU_Body_225*)_ceu_org)->ok_14) = ((__ceu_casted)->ret);
}

#line 40 "btree-1.ceu"
    }
#line 40 "btree-1.ceu"
/* CLEAR: Block (40) */
#line 40 "btree-1.ceu"
    if (0) {

#line 40 "btree-1.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
}

#line 40 "btree-1.ceu"
    }
#line 40 "btree-1.ceu"
    }
#line 40 "btree-1.ceu"
    }
#line 40 "btree-1.ceu"
/* CLEAR: Block (40) */
#line 40 "btree-1.ceu"
    if (0) {

#line 40 "btree-1.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
} else {
/* NODE: Block 786 */

#line 40 "btree-1.ceu"
    {/* NODE: Stmts 785 */

#line 40 "btree-1.ceu"
    {/* NODE: Set 849 */

#line 40 "btree-1.ceu"
/* SET: ok *//* NODE: RawExp 773 */

#line 40 "btree-1.ceu"
    (((CEU_Body_225*)_ceu_org)->ok_14) = _ceu_app->ret;
#line 40 "btree-1.ceu"
    }
#line 40 "btree-1.ceu"
/* CLEAR: Block (40) */
#line 40 "btree-1.ceu"
    if (0) {

#line 40 "btree-1.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
}

#line 40 "btree-1.ceu"
    }
#line 40 "btree-1.ceu"
/* CLEAR: Block (40) */
#line 40 "btree-1.ceu"
    {
    tceu_evt evt;
             evt.id = CEU_IN__CLEAR;
    ceu_sys_go_ex(_ceu_app, &evt,
                  _ceu_stk,
                  _ceu_org,
                  &_ceu_org->trls[ 2 ],
                  &_ceu_org->trls[ 5 ]);
                                        /* excludes +1 */
}

/* LONGJMP
 * Block termination: we will abort all trails between [t1,t2].
 * Return status=1 to distinguish from longjmp from organism termination.
 * We want to continue from "me.lbl_jmp" below.
 */
#ifdef CEU_ORGS
_ceu_app->stk_jmp.org = _ceu_org;
#endif
_ceu_app->stk_jmp.trl = _ceu_trl;
_ceu_app->stk_jmp.lbl = Body_225_Block_jmp_21;
ceu_longjmp(_ceu_app, _ceu_org,
            2,4);

#line 40 "btree-1.ceu"
case Body_225_Block_jmp_21:;
#line 40 "btree-1.ceu"
    if (0) {

#line 40 "btree-1.ceu"
case Body_225_optorg_reset_20:;
#line 40 "btree-1.ceu"
        {
        tceu_kill* __ceu_casted = (tceu_kill*)_ceu_evt->param;
        if ( ((((CEU_Body_225*)_ceu_org)->_body_166_19).tag != CEU__OPTION__BODY_225__PTR_NIL) &&
             ((((CEU_Body_225*)_ceu_org)->_body_166_19).SOME.v == __ceu_casted->org_or_adt) )
        {
            (((CEU_Body_225*)_ceu_org)->_body_166_19) = CEU__OPTION__BODY_225__PTR_pack(NULL);
        }
    }

#line 40 "btree-1.ceu"
    /*  RESET OPT-ORG TO NULL */
_ceu_org->trls[ 3 ].evt = CEU_IN__ok_killed;
_ceu_org->trls[ 3 ].lbl = Body_225_optorg_reset_20;

#line 40 "btree-1.ceu"
    return;
#line 40 "btree-1.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
/* NODE: Stmts 853 */

#line 41 "btree-1.ceu"
    {/* NODE: Set 851 */

#line 41 "btree-1.ceu"
/* SET: _ret *//* NODE: Var 168 */

#line 41 "btree-1.ceu"
    (((CEU_Body_225*)_ceu_org)->_ret_13) = (((CEU_Body_225*)_ceu_org)->ok_14);
#line 41 "btree-1.ceu"
    #ifdef CEU_ORGS_AWAIT
    _ceu_org->ret = (((CEU_Body_225*)_ceu_org)->_ret_13);
    /* HACK_8: result of immediate spawn termination */
    _ceu_app->ret = _ceu_org->ret;
#endif
/* NODE: Escape 852 */

#line 41 "btree-1.ceu"
    _ceu_lbl = Body_225_Set_out_6;
goto _CEU_GOTO_;

#line 41 "btree-1.ceu"
    }
#line 36 "btree-1.ceu"
    }
#line 36 "btree-1.ceu"
/* CLEAR: Block (36) */
#line 36 "btree-1.ceu"
    if (0) {

#line 36 "btree-1.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
} else {
/* NODE: If 627 */

#line 42 "btree-1.ceu"
    if ((((((CEU_BTree *)(  ((tceu_pool_adts*) (&((CEU_Body_225*)_ceu_org)->t))->root)))->tag == CEU_BTREE_SELECTOR) /* XXXX */)) {
/* NODE: Block 199 */

#line 43 "btree-1.ceu"
    {/* NODE: Stmts 198 */

#line 43 "btree-1.ceu"
    {/* NODE: Stmts 860 */

#line 43 "btree-1.ceu"
    {/* NODE: Dcl_var 857 */
/* NODE: Block 904 */

#line 43 "btree-1.ceu"
    {
#line 43 "btree-1.ceu"
    #ifdef CEU_ORGS
_ceu_org->trls[ 2 ].evt = CEU_IN__ORG;
_ceu_org->trls[ 2 ].org = NULL;
#endif

#line 43 "btree-1.ceu"
    (((CEU_Body_225*)_ceu_org)->_body_179_22).tag = CEU__OPTION__BODY_225__PTR_NIL;

#line 43 "btree-1.ceu"
    /*  RESET OPT-ORG TO NULL */
_ceu_org->trls[ 3 ].evt = CEU_IN__ok_killed;
_ceu_org->trls[ 3 ].lbl = Body_225_optorg_reset_23;
_ceu_org->trls[ 3 ].org_or_adt = NULL;

#line 43 "btree-1.ceu"
    _ceu_trl = &_ceu_org->trls[ 4 ];
/* NODE: Stmts 903 */

#line 43 "btree-1.ceu"
    {/* NODE: Dcl_var 891 */

#line 43 "btree-1.ceu"
/* start org: _s */
#line 43 "btree-1.ceu"
        /* resets org memory and starts org.trail[0]=Class_XXX */
    /* TODO: BUG: _ceu_org is not necessarily the parent for pool allocations */
    ceu_out_org_init(_ceu_app, ((tceu_org*) &(((CEU_Body_225*)_ceu_org)->_s_21)),2,Class_Scope,
                     3,
                     0,
                     _ceu_org,2);
/* TODO: currently idx is always "1" for all interfaces access because pools 
 * are all together there. When we have separate trls for pools, we'll have to 
 * indirectly access the offset in the interface. */

#line 43 "btree-1.ceu"
    {
    tceu_stk stk_ = { NULL, ((tceu_org*) &(((CEU_Body_225*)_ceu_org)->_s_21)), 0, ((tceu_org*) &(((CEU_Body_225*)_ceu_org)->_s_21))->n, {} };
    if (setjmp(stk_.jmp) != 0) {
#ifdef CEU_ORGS
        _ceu_org = _ceu_app->stk_jmp.org;
#endif
        _ceu_trl = _ceu_app->stk_jmp.trl;

#line 43 "btree-1.ceu"
    _ceu_lbl = _ceu_app->stk_jmp.lbl;
goto _CEU_GOTO_;

#line 43 "btree-1.ceu"
        }

    /* SETJMP: spawning a new org
     * The new org might emit a global event that awakes a par/or enclosing the 
     * call point.
     */
    _ceu_stk->up = &stk_;
    ceu_app_go(_ceu_app,NULL,
               ((tceu_org*) &(((CEU_Body_225*)_ceu_org)->_s_21)), &((tceu_org*) &(((CEU_Body_225*)_ceu_org)->_s_21))->trls[0],
               &stk_);
    _ceu_stk->up = NULL;

#line 43 "btree-1.ceu"
    }
/* NODE: Dcl_var 893 */
/* NODE: Set 905 */

#line 43 "btree-1.ceu"
/* SET: _body_179 *//* NODE: Spawn 881 */

#line 43 "btree-1.ceu"
    /*{*/
    tceu_org* __ceu_new_881;

#line 43 "btree-1.ceu"
    #if !defined(CEU_ORGS_NEWS_MALLOC)
    __ceu_new_881 = (tceu_org*) ceu_pool_alloc(&(*((CEU_Body_225*)_ceu_org)->_bodies).pool);
#elif !defined(CEU_ORGS_NEWS_POOL)
    __ceu_new_881 = (tceu_org*) ceu_out_realloc(NULL, sizeof(CEU_Body_225));
#else
    if ((*((CEU_Body_225*)_ceu_org)->_bodies).pool.queue == NULL) {
        __ceu_new_881 = (tceu_org*) ceu_out_realloc(NULL, sizeof(CEU_Body_225));
    } else {
        __ceu_new_881 = (tceu_org*) ceu_pool_alloc(&(*((CEU_Body_225*)_ceu_org)->_bodies).pool);
    }
#endif

#line 43 "btree-1.ceu"
    (((CEU_Body_225*)_ceu_org)->_body_179_22) = (CEU__OPTION__BODY_225__PTR_pack(((CEU_Body_225*)__ceu_new_881)));
#line 43 "btree-1.ceu"
        if (__ceu_new_881 != NULL) {

#line 43 "btree-1.ceu"
    #ifdef CEU_ORGS_NEWS_POOL
        __ceu_new_881->pool = &(*((CEU_Body_225*)_ceu_org)->_bodies);
#endif

#line 43 "btree-1.ceu"
/* start org: dyn */
#line 43 "btree-1.ceu"
        /* resets org memory and starts org.trail[0]=Class_XXX */
    /* TODO: BUG: _ceu_org is not necessarily the parent for pool allocations */
    ceu_out_org_init(_ceu_app, ((tceu_org*) &(*((CEU_Body_225*)__ceu_new_881))),7,Class_Body_225,
                     4,
                     1,
                     (*((CEU_Body_225*)_ceu_org)->_bodies).parent_org,(*((CEU_Body_225*)_ceu_org)->_bodies).parent_trl);
/* TODO: currently idx is always "1" for all interfaces access because pools 
 * are all together there. When we have separate trls for pools, we'll have to 
 * indirectly access the offset in the interface. */

#line 43 "btree-1.ceu"
        ((CEU_Body_225*)((tceu_org*) &(*((CEU_Body_225*)__ceu_new_881))))->_out =
        ((CEU_Body_225*)_ceu_org)->_out;

#line 43 "btree-1.ceu"
        _ceu_constr_880(_ceu_app, ((tceu_org*) &(*((CEU_Body_225*)__ceu_new_881))), _ceu_org);

#line 43 "btree-1.ceu"
    {
    tceu_stk stk_ = { NULL, ((tceu_org*) &(*((CEU_Body_225*)__ceu_new_881))), 0, ((tceu_org*) &(*((CEU_Body_225*)__ceu_new_881)))->n, {} };
    if (setjmp(stk_.jmp) != 0) {
#ifdef CEU_ORGS
        _ceu_org = _ceu_app->stk_jmp.org;
#endif
        _ceu_trl = _ceu_app->stk_jmp.trl;

#line 43 "btree-1.ceu"
    _ceu_lbl = _ceu_app->stk_jmp.lbl;
goto _CEU_GOTO_;

#line 43 "btree-1.ceu"
        }

    /* SETJMP: spawning a new org
     * The new org might emit a global event that awakes a par/or enclosing the 
     * call point.
     */
    _ceu_stk->up = &stk_;
    ceu_app_go(_ceu_app,NULL,
               ((tceu_org*) &(*((CEU_Body_225*)__ceu_new_881))), &((tceu_org*) &(*((CEU_Body_225*)__ceu_new_881)))->trls[0],
               &stk_);
    _ceu_stk->up = NULL;

#line 43 "btree-1.ceu"
        if (!((tceu_org*) &(*((CEU_Body_225*)__ceu_new_881)))->isAlive) {
        (((CEU_Body_225*)_ceu_org)->_body_179_22) = CEU__OPTION__BODY_225__PTR_pack(NULL);
    }

#line 43 "btree-1.ceu"
    }

#line 43 "btree-1.ceu"
        }
/*}*/
/* NODE: If 902 */

#line 43 "btree-1.ceu"
    if (((((CEU_Body_225*)_ceu_org)->_body_179_22).tag != CEU__OPTION__BODY_225__PTR_NIL)) {
/* NODE: Block 899 */

#line 43 "btree-1.ceu"
    {/* NODE: Stmts 898 */

#line 43 "btree-1.ceu"
    {/* NODE: Stmts 959 */

#line 43 "btree-1.ceu"
    {/* NODE: Nothing 913 */
/* NODE: Nothing 1452 */
/* NODE: Nothing 1453 */
/* NODE: Stmts 958 */

#line 43 "btree-1.ceu"
    {/* NODE: If 957 */

#line 43 "btree-1.ceu"
    if ((!(((*((tceu_org*)(((CEU__OPTION__BODY_225__PTR_SOME_assert(_ceu_app, (&((CEU_Body_225*)_ceu_org)->_body_179_22),__FILE__,__LINE__)->SOME.v))))).isAlive)))) {
/* NODE: Block 954 */

#line 43 "btree-1.ceu"
    {/* NODE: Stmts 953 */

#line 43 "btree-1.ceu"
    {/* NODE: Set 933 */

#line 43 "btree-1.ceu"
/* SET: ok *//* NODE: Op1_cast 931 */

#line 43 "btree-1.ceu"
    (((CEU_Body_225*)_ceu_org)->ok_20) = ((int)(((*((tceu_org*)(((CEU__OPTION__BODY_225__PTR_SOME_assert(_ceu_app, (&((CEU_Body_225*)_ceu_org)->_body_179_22),__FILE__,__LINE__)->SOME.v))))).ret)));
#line 43 "btree-1.ceu"
    }
#line 43 "btree-1.ceu"
/* CLEAR: Block (43) */
#line 43 "btree-1.ceu"
    if (0) {

#line 43 "btree-1.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
} else {
/* NODE: Block 956 */

#line 43 "btree-1.ceu"
    {/* NODE: Stmts 955 */

#line 43 "btree-1.ceu"
    {/* NODE: Set 963 */

#line 43 "btree-1.ceu"
/* SET: table: 0x137c180 *//* NODE: Await 918 */

#line 43 "btree-1.ceu"
    _CEU_NO_918_:
if (0) { goto _CEU_NO_918_; /* avoids "not used" warning */ }

#line 43 "btree-1.ceu"
    _ceu_trl->evt = CEU_IN__ok_killed;
_ceu_trl->lbl = Body_225_Awake__ok_killed_22;
_ceu_trl->seqno = _ceu_app->seqno;

#line 43 "btree-1.ceu"
    _ceu_trl->org_or_adt = (void*)(((CEU__OPTION__BODY_225__PTR_SOME_assert(_ceu_app, (&((CEU_Body_225*)_ceu_org)->_body_179_22),__FILE__,__LINE__)->SOME.v)));

#line 43 "btree-1.ceu"
    return;

case Body_225_Awake__ok_killed_22:;

#line 43 "btree-1.ceu"
    #ifdef CEU_DEBUG_TRAILS
#ifndef CEU_OS
printf("\tOK!\n");
#endif
#endif

#line 43 "btree-1.ceu"
    {

#line 43 "btree-1.ceu"
        tceu_kill* __ceu_casted = (tceu_kill*) _ceu_evt->param;

#line 43 "btree-1.ceu"
        (((CEU_Body_225*)_ceu_org)->ok_20) = ((__ceu_casted)->ret);
}

#line 43 "btree-1.ceu"
    }
#line 43 "btree-1.ceu"
/* CLEAR: Block (43) */
#line 43 "btree-1.ceu"
    if (0) {

#line 43 "btree-1.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
}

#line 43 "btree-1.ceu"
    }
#line 43 "btree-1.ceu"
    }
#line 43 "btree-1.ceu"
    }
#line 43 "btree-1.ceu"
/* CLEAR: Block (43) */
#line 43 "btree-1.ceu"
    if (0) {

#line 43 "btree-1.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
} else {
/* NODE: Block 901 */

#line 43 "btree-1.ceu"
    {/* NODE: Stmts 900 */

#line 43 "btree-1.ceu"
    {/* NODE: Set 964 */

#line 43 "btree-1.ceu"
/* SET: ok *//* NODE: RawExp 888 */

#line 43 "btree-1.ceu"
    (((CEU_Body_225*)_ceu_org)->ok_20) = _ceu_app->ret;
#line 43 "btree-1.ceu"
    }
#line 43 "btree-1.ceu"
/* CLEAR: Block (43) */
#line 43 "btree-1.ceu"
    if (0) {

#line 43 "btree-1.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
}

#line 43 "btree-1.ceu"
    }
#line 43 "btree-1.ceu"
/* CLEAR: Block (43) */
#line 43 "btree-1.ceu"
    {
    tceu_evt evt;
             evt.id = CEU_IN__CLEAR;
    ceu_sys_go_ex(_ceu_app, &evt,
                  _ceu_stk,
                  _ceu_org,
                  &_ceu_org->trls[ 2 ],
                  &_ceu_org->trls[ 5 ]);
                                        /* excludes +1 */
}

/* LONGJMP
 * Block termination: we will abort all trails between [t1,t2].
 * Return status=1 to distinguish from longjmp from organism termination.
 * We want to continue from "me.lbl_jmp" below.
 */
#ifdef CEU_ORGS
_ceu_app->stk_jmp.org = _ceu_org;
#endif
_ceu_app->stk_jmp.trl = _ceu_trl;
_ceu_app->stk_jmp.lbl = Body_225_Block_jmp_24;
ceu_longjmp(_ceu_app, _ceu_org,
            2,4);

#line 43 "btree-1.ceu"
case Body_225_Block_jmp_24:;
#line 43 "btree-1.ceu"
    if (0) {

#line 43 "btree-1.ceu"
case Body_225_optorg_reset_23:;
#line 43 "btree-1.ceu"
        {
        tceu_kill* __ceu_casted = (tceu_kill*)_ceu_evt->param;
        if ( ((((CEU_Body_225*)_ceu_org)->_body_179_22).tag != CEU__OPTION__BODY_225__PTR_NIL) &&
             ((((CEU_Body_225*)_ceu_org)->_body_179_22).SOME.v == __ceu_casted->org_or_adt) )
        {
            (((CEU_Body_225*)_ceu_org)->_body_179_22) = CEU__OPTION__BODY_225__PTR_pack(NULL);
        }
    }

#line 43 "btree-1.ceu"
    /*  RESET OPT-ORG TO NULL */
_ceu_org->trls[ 3 ].evt = CEU_IN__ok_killed;
_ceu_org->trls[ 3 ].lbl = Body_225_optorg_reset_23;

#line 43 "btree-1.ceu"
    return;
#line 43 "btree-1.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 43 "btree-1.ceu"
    }/* NODE: If 966 */

#line 44 "btree-1.ceu"
    if (((((CEU_Body_225*)_ceu_org)->ok_20)!=0)) {
/* NODE: Block 187 */

#line 45 "btree-1.ceu"
    {/* NODE: Stmts 186 */

#line 45 "btree-1.ceu"
    {/* NODE: Stmts 970 */

#line 45 "btree-1.ceu"
    {/* NODE: Set 968 */

#line 45 "btree-1.ceu"
/* SET: _ret *//* NODE: Var 184 */

#line 45 "btree-1.ceu"
    (((CEU_Body_225*)_ceu_org)->_ret_13) = (((CEU_Body_225*)_ceu_org)->ok_20);
#line 45 "btree-1.ceu"
    #ifdef CEU_ORGS_AWAIT
    _ceu_org->ret = (((CEU_Body_225*)_ceu_org)->_ret_13);
    /* HACK_8: result of immediate spawn termination */
    _ceu_app->ret = _ceu_org->ret;
#endif
/* NODE: Escape 969 */

#line 45 "btree-1.ceu"
    _ceu_lbl = Body_225_Set_out_6;
goto _CEU_GOTO_;

#line 45 "btree-1.ceu"
    }
#line 45 "btree-1.ceu"
    }
#line 45 "btree-1.ceu"
/* CLEAR: Block (45) */
#line 45 "btree-1.ceu"
    if (0) {

#line 45 "btree-1.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
} else {
/* NODE: Nothing 965 */
}
/* NODE: Stmts 975 */

#line 47 "btree-1.ceu"
    {/* NODE: Dcl_var 972 */
/* NODE: Block 1019 */

#line 47 "btree-1.ceu"
    {
#line 47 "btree-1.ceu"
    #ifdef CEU_ORGS
_ceu_org->trls[ 2 ].evt = CEU_IN__ORG;
_ceu_org->trls[ 2 ].org = NULL;
#endif

#line 47 "btree-1.ceu"
    (((CEU_Body_225*)_ceu_org)->_body_194_25).tag = CEU__OPTION__BODY_225__PTR_NIL;

#line 47 "btree-1.ceu"
    /*  RESET OPT-ORG TO NULL */
_ceu_org->trls[ 3 ].evt = CEU_IN__ok_killed;
_ceu_org->trls[ 3 ].lbl = Body_225_optorg_reset_26;
_ceu_org->trls[ 3 ].org_or_adt = NULL;

#line 47 "btree-1.ceu"
    _ceu_trl = &_ceu_org->trls[ 4 ];
/* NODE: Stmts 1018 */

#line 47 "btree-1.ceu"
    {/* NODE: Dcl_var 1006 */

#line 47 "btree-1.ceu"
/* start org: _s */
#line 47 "btree-1.ceu"
        /* resets org memory and starts org.trail[0]=Class_XXX */
    /* TODO: BUG: _ceu_org is not necessarily the parent for pool allocations */
    ceu_out_org_init(_ceu_app, ((tceu_org*) &(((CEU_Body_225*)_ceu_org)->_s_24)),2,Class_Scope,
                     3,
                     0,
                     _ceu_org,2);
/* TODO: currently idx is always "1" for all interfaces access because pools 
 * are all together there. When we have separate trls for pools, we'll have to 
 * indirectly access the offset in the interface. */

#line 47 "btree-1.ceu"
    {
    tceu_stk stk_ = { NULL, ((tceu_org*) &(((CEU_Body_225*)_ceu_org)->_s_24)), 0, ((tceu_org*) &(((CEU_Body_225*)_ceu_org)->_s_24))->n, {} };
    if (setjmp(stk_.jmp) != 0) {
#ifdef CEU_ORGS
        _ceu_org = _ceu_app->stk_jmp.org;
#endif
        _ceu_trl = _ceu_app->stk_jmp.trl;

#line 47 "btree-1.ceu"
    _ceu_lbl = _ceu_app->stk_jmp.lbl;
goto _CEU_GOTO_;

#line 47 "btree-1.ceu"
        }

    /* SETJMP: spawning a new org
     * The new org might emit a global event that awakes a par/or enclosing the 
     * call point.
     */
    _ceu_stk->up = &stk_;
    ceu_app_go(_ceu_app,NULL,
               ((tceu_org*) &(((CEU_Body_225*)_ceu_org)->_s_24)), &((tceu_org*) &(((CEU_Body_225*)_ceu_org)->_s_24))->trls[0],
               &stk_);
    _ceu_stk->up = NULL;

#line 47 "btree-1.ceu"
    }
/* NODE: Dcl_var 1008 */
/* NODE: Set 1020 */

#line 47 "btree-1.ceu"
/* SET: _body_194 *//* NODE: Spawn 996 */

#line 47 "btree-1.ceu"
    /*{*/
    tceu_org* __ceu_new_996;

#line 47 "btree-1.ceu"
    #if !defined(CEU_ORGS_NEWS_MALLOC)
    __ceu_new_996 = (tceu_org*) ceu_pool_alloc(&(*((CEU_Body_225*)_ceu_org)->_bodies).pool);
#elif !defined(CEU_ORGS_NEWS_POOL)
    __ceu_new_996 = (tceu_org*) ceu_out_realloc(NULL, sizeof(CEU_Body_225));
#else
    if ((*((CEU_Body_225*)_ceu_org)->_bodies).pool.queue == NULL) {
        __ceu_new_996 = (tceu_org*) ceu_out_realloc(NULL, sizeof(CEU_Body_225));
    } else {
        __ceu_new_996 = (tceu_org*) ceu_pool_alloc(&(*((CEU_Body_225*)_ceu_org)->_bodies).pool);
    }
#endif

#line 47 "btree-1.ceu"
    (((CEU_Body_225*)_ceu_org)->_body_194_25) = (CEU__OPTION__BODY_225__PTR_pack(((CEU_Body_225*)__ceu_new_996)));
#line 47 "btree-1.ceu"
        if (__ceu_new_996 != NULL) {

#line 47 "btree-1.ceu"
    #ifdef CEU_ORGS_NEWS_POOL
        __ceu_new_996->pool = &(*((CEU_Body_225*)_ceu_org)->_bodies);
#endif

#line 47 "btree-1.ceu"
/* start org: dyn */
#line 47 "btree-1.ceu"
        /* resets org memory and starts org.trail[0]=Class_XXX */
    /* TODO: BUG: _ceu_org is not necessarily the parent for pool allocations */
    ceu_out_org_init(_ceu_app, ((tceu_org*) &(*((CEU_Body_225*)__ceu_new_996))),7,Class_Body_225,
                     4,
                     1,
                     (*((CEU_Body_225*)_ceu_org)->_bodies).parent_org,(*((CEU_Body_225*)_ceu_org)->_bodies).parent_trl);
/* TODO: currently idx is always "1" for all interfaces access because pools 
 * are all together there. When we have separate trls for pools, we'll have to 
 * indirectly access the offset in the interface. */

#line 47 "btree-1.ceu"
        ((CEU_Body_225*)((tceu_org*) &(*((CEU_Body_225*)__ceu_new_996))))->_out =
        ((CEU_Body_225*)_ceu_org)->_out;

#line 47 "btree-1.ceu"
        _ceu_constr_995(_ceu_app, ((tceu_org*) &(*((CEU_Body_225*)__ceu_new_996))), _ceu_org);

#line 47 "btree-1.ceu"
    {
    tceu_stk stk_ = { NULL, ((tceu_org*) &(*((CEU_Body_225*)__ceu_new_996))), 0, ((tceu_org*) &(*((CEU_Body_225*)__ceu_new_996)))->n, {} };
    if (setjmp(stk_.jmp) != 0) {
#ifdef CEU_ORGS
        _ceu_org = _ceu_app->stk_jmp.org;
#endif
        _ceu_trl = _ceu_app->stk_jmp.trl;

#line 47 "btree-1.ceu"
    _ceu_lbl = _ceu_app->stk_jmp.lbl;
goto _CEU_GOTO_;

#line 47 "btree-1.ceu"
        }

    /* SETJMP: spawning a new org
     * The new org might emit a global event that awakes a par/or enclosing the 
     * call point.
     */
    _ceu_stk->up = &stk_;
    ceu_app_go(_ceu_app,NULL,
               ((tceu_org*) &(*((CEU_Body_225*)__ceu_new_996))), &((tceu_org*) &(*((CEU_Body_225*)__ceu_new_996)))->trls[0],
               &stk_);
    _ceu_stk->up = NULL;

#line 47 "btree-1.ceu"
        if (!((tceu_org*) &(*((CEU_Body_225*)__ceu_new_996)))->isAlive) {
        (((CEU_Body_225*)_ceu_org)->_body_194_25) = CEU__OPTION__BODY_225__PTR_pack(NULL);
    }

#line 47 "btree-1.ceu"
    }

#line 47 "btree-1.ceu"
        }
/*}*/
/* NODE: If 1017 */

#line 47 "btree-1.ceu"
    if (((((CEU_Body_225*)_ceu_org)->_body_194_25).tag != CEU__OPTION__BODY_225__PTR_NIL)) {
/* NODE: Block 1014 */

#line 47 "btree-1.ceu"
    {/* NODE: Stmts 1013 */

#line 47 "btree-1.ceu"
    {/* NODE: Stmts 1074 */

#line 47 "btree-1.ceu"
    {/* NODE: Nothing 1028 */
/* NODE: Nothing 1458 */
/* NODE: Nothing 1459 */
/* NODE: Stmts 1073 */

#line 47 "btree-1.ceu"
    {/* NODE: If 1072 */

#line 47 "btree-1.ceu"
    if ((!(((*((tceu_org*)(((CEU__OPTION__BODY_225__PTR_SOME_assert(_ceu_app, (&((CEU_Body_225*)_ceu_org)->_body_194_25),__FILE__,__LINE__)->SOME.v))))).isAlive)))) {
/* NODE: Block 1069 */

#line 47 "btree-1.ceu"
    {/* NODE: Stmts 1068 */

#line 47 "btree-1.ceu"
    {/* NODE: Set 1048 */

#line 47 "btree-1.ceu"
/* SET: ok *//* NODE: Op1_cast 1046 */

#line 47 "btree-1.ceu"
    (((CEU_Body_225*)_ceu_org)->ok_23) = ((int)(((*((tceu_org*)(((CEU__OPTION__BODY_225__PTR_SOME_assert(_ceu_app, (&((CEU_Body_225*)_ceu_org)->_body_194_25),__FILE__,__LINE__)->SOME.v))))).ret)));
#line 47 "btree-1.ceu"
    }
#line 47 "btree-1.ceu"
/* CLEAR: Block (47) */
#line 47 "btree-1.ceu"
    if (0) {

#line 47 "btree-1.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
} else {
/* NODE: Block 1071 */

#line 47 "btree-1.ceu"
    {/* NODE: Stmts 1070 */

#line 47 "btree-1.ceu"
    {/* NODE: Set 1078 */

#line 47 "btree-1.ceu"
/* SET: table: 0x1389600 *//* NODE: Await 1033 */

#line 47 "btree-1.ceu"
    _CEU_NO_1033_:
if (0) { goto _CEU_NO_1033_; /* avoids "not used" warning */ }

#line 47 "btree-1.ceu"
    _ceu_trl->evt = CEU_IN__ok_killed;
_ceu_trl->lbl = Body_225_Awake__ok_killed_25;
_ceu_trl->seqno = _ceu_app->seqno;

#line 47 "btree-1.ceu"
    _ceu_trl->org_or_adt = (void*)(((CEU__OPTION__BODY_225__PTR_SOME_assert(_ceu_app, (&((CEU_Body_225*)_ceu_org)->_body_194_25),__FILE__,__LINE__)->SOME.v)));

#line 47 "btree-1.ceu"
    return;

case Body_225_Awake__ok_killed_25:;

#line 47 "btree-1.ceu"
    #ifdef CEU_DEBUG_TRAILS
#ifndef CEU_OS
printf("\tOK!\n");
#endif
#endif

#line 47 "btree-1.ceu"
    {

#line 47 "btree-1.ceu"
        tceu_kill* __ceu_casted = (tceu_kill*) _ceu_evt->param;

#line 47 "btree-1.ceu"
        (((CEU_Body_225*)_ceu_org)->ok_23) = ((__ceu_casted)->ret);
}

#line 47 "btree-1.ceu"
    }
#line 47 "btree-1.ceu"
/* CLEAR: Block (47) */
#line 47 "btree-1.ceu"
    if (0) {

#line 47 "btree-1.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
}

#line 47 "btree-1.ceu"
    }
#line 47 "btree-1.ceu"
    }
#line 47 "btree-1.ceu"
    }
#line 47 "btree-1.ceu"
/* CLEAR: Block (47) */
#line 47 "btree-1.ceu"
    if (0) {

#line 47 "btree-1.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
} else {
/* NODE: Block 1016 */

#line 47 "btree-1.ceu"
    {/* NODE: Stmts 1015 */

#line 47 "btree-1.ceu"
    {/* NODE: Set 1079 */

#line 47 "btree-1.ceu"
/* SET: ok *//* NODE: RawExp 1003 */

#line 47 "btree-1.ceu"
    (((CEU_Body_225*)_ceu_org)->ok_23) = _ceu_app->ret;
#line 47 "btree-1.ceu"
    }
#line 47 "btree-1.ceu"
/* CLEAR: Block (47) */
#line 47 "btree-1.ceu"
    if (0) {

#line 47 "btree-1.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
}

#line 47 "btree-1.ceu"
    }
#line 47 "btree-1.ceu"
/* CLEAR: Block (47) */
#line 47 "btree-1.ceu"
    {
    tceu_evt evt;
             evt.id = CEU_IN__CLEAR;
    ceu_sys_go_ex(_ceu_app, &evt,
                  _ceu_stk,
                  _ceu_org,
                  &_ceu_org->trls[ 2 ],
                  &_ceu_org->trls[ 5 ]);
                                        /* excludes +1 */
}

/* LONGJMP
 * Block termination: we will abort all trails between [t1,t2].
 * Return status=1 to distinguish from longjmp from organism termination.
 * We want to continue from "me.lbl_jmp" below.
 */
#ifdef CEU_ORGS
_ceu_app->stk_jmp.org = _ceu_org;
#endif
_ceu_app->stk_jmp.trl = _ceu_trl;
_ceu_app->stk_jmp.lbl = Body_225_Block_jmp_27;
ceu_longjmp(_ceu_app, _ceu_org,
            2,4);

#line 47 "btree-1.ceu"
case Body_225_Block_jmp_27:;
#line 47 "btree-1.ceu"
    if (0) {

#line 47 "btree-1.ceu"
case Body_225_optorg_reset_26:;
#line 47 "btree-1.ceu"
        {
        tceu_kill* __ceu_casted = (tceu_kill*)_ceu_evt->param;
        if ( ((((CEU_Body_225*)_ceu_org)->_body_194_25).tag != CEU__OPTION__BODY_225__PTR_NIL) &&
             ((((CEU_Body_225*)_ceu_org)->_body_194_25).SOME.v == __ceu_casted->org_or_adt) )
        {
            (((CEU_Body_225*)_ceu_org)->_body_194_25) = CEU__OPTION__BODY_225__PTR_pack(NULL);
        }
    }

#line 47 "btree-1.ceu"
    /*  RESET OPT-ORG TO NULL */
_ceu_org->trls[ 3 ].evt = CEU_IN__ok_killed;
_ceu_org->trls[ 3 ].lbl = Body_225_optorg_reset_26;

#line 47 "btree-1.ceu"
    return;
#line 47 "btree-1.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 47 "btree-1.ceu"
    }/* NODE: Stmts 1083 */

#line 48 "btree-1.ceu"
    {/* NODE: Set 1081 */

#line 48 "btree-1.ceu"
/* SET: _ret *//* NODE: Var 196 */

#line 48 "btree-1.ceu"
    (((CEU_Body_225*)_ceu_org)->_ret_13) = (((CEU_Body_225*)_ceu_org)->ok_23);
#line 48 "btree-1.ceu"
    #ifdef CEU_ORGS_AWAIT
    _ceu_org->ret = (((CEU_Body_225*)_ceu_org)->_ret_13);
    /* HACK_8: result of immediate spawn termination */
    _ceu_app->ret = _ceu_org->ret;
#endif
/* NODE: Escape 1082 */

#line 48 "btree-1.ceu"
    _ceu_lbl = Body_225_Set_out_6;
goto _CEU_GOTO_;

#line 48 "btree-1.ceu"
    }
#line 43 "btree-1.ceu"
    }
#line 43 "btree-1.ceu"
/* CLEAR: Block (43) */
#line 43 "btree-1.ceu"
    if (0) {

#line 43 "btree-1.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
} else {
/* NODE: If 626 */

#line 49 "btree-1.ceu"
    if ((((((CEU_BTree *)(  ((tceu_pool_adts*) (&((CEU_Body_225*)_ceu_org)->t))->root)))->tag == CEU_BTREE_LEAF) /* XXXX */)) {
/* NODE: Block 218 */

#line 50 "btree-1.ceu"
    {/* NODE: Stmts 217 */

#line 50 "btree-1.ceu"
    {/* NODE: Stmts 1090 */

#line 50 "btree-1.ceu"
    {/* NODE: Dcl_var 1087 */
/* NODE: Do 1098 */
/* NODE: Block 1097 */

#line 51 "btree-1.ceu"
    {
#line 51 "btree-1.ceu"
    #ifdef CEU_ORGS
_ceu_org->trls[ 2 ].evt = CEU_IN__ORG;
_ceu_org->trls[ 2 ].org = NULL;
#endif

#line 51 "btree-1.ceu"
    _ceu_trl = &_ceu_org->trls[ 3 ];
/* NODE: Stmts 1096 */

#line 51 "btree-1.ceu"
    {/* NODE: Dcl_var 1095 */

#line 51 "btree-1.ceu"
/* start org: _org_213 */
#line 51 "btree-1.ceu"
        /* resets org memory and starts org.trail[0]=Class_XXX */
    /* TODO: BUG: _ceu_org is not necessarily the parent for pool allocations */
    ceu_out_org_init(_ceu_app, ((tceu_org*) &(((CEU_Body_225*)_ceu_org)->_org_213_27)),2,Class_LeafHandler,
                     1,
                     0,
                     _ceu_org,2);
/* TODO: currently idx is always "1" for all interfaces access because pools 
 * are all together there. When we have separate trls for pools, we'll have to 
 * indirectly access the offset in the interface. */

#line 51 "btree-1.ceu"
        _ceu_constr_212(_ceu_app, ((tceu_org*) &(((CEU_Body_225*)_ceu_org)->_org_213_27)), _ceu_org);

#line 51 "btree-1.ceu"
    {
    tceu_stk stk_ = { NULL, ((tceu_org*) &(((CEU_Body_225*)_ceu_org)->_org_213_27)), 0, ((tceu_org*) &(((CEU_Body_225*)_ceu_org)->_org_213_27))->n, {} };
    if (setjmp(stk_.jmp) != 0) {
#ifdef CEU_ORGS
        _ceu_org = _ceu_app->stk_jmp.org;
#endif
        _ceu_trl = _ceu_app->stk_jmp.trl;

#line 51 "btree-1.ceu"
    _ceu_lbl = _ceu_app->stk_jmp.lbl;
goto _CEU_GOTO_;

#line 51 "btree-1.ceu"
        }

    /* SETJMP: spawning a new org
     * The new org might emit a global event that awakes a par/or enclosing the 
     * call point.
     */
    _ceu_stk->up = &stk_;
    ceu_app_go(_ceu_app,NULL,
               ((tceu_org*) &(((CEU_Body_225*)_ceu_org)->_org_213_27)), &((tceu_org*) &(((CEU_Body_225*)_ceu_org)->_org_213_27))->trls[0],
               &stk_);
    _ceu_stk->up = NULL;

#line 51 "btree-1.ceu"
    }
/* NODE: Stmts 1142 */

#line 51 "btree-1.ceu"
    {/* NODE: Nothing 1104 */
/* NODE: Nothing 1461 */
/* NODE: Nothing 1462 */
/* NODE: Stmts 1141 */

#line 51 "btree-1.ceu"
    {/* NODE: If 1140 */

#line 51 "btree-1.ceu"
    if ((!(((*((tceu_org*)(&((CEU_Body_225*)_ceu_org)->_org_213_27))).isAlive)))) {
/* NODE: Block 1137 */

#line 51 "btree-1.ceu"
    {/* NODE: Stmts 1136 */

#line 51 "btree-1.ceu"
    {/* NODE: Set 1120 */

#line 51 "btree-1.ceu"
/* SET: ok *//* NODE: Op1_cast 1118 */

#line 51 "btree-1.ceu"
    (((CEU_Body_225*)_ceu_org)->ok_26) = ((int)(((*((tceu_org*)(&((CEU_Body_225*)_ceu_org)->_org_213_27))).ret)));
#line 51 "btree-1.ceu"
    }
#line 51 "btree-1.ceu"
/* CLEAR: Block (51) */
#line 51 "btree-1.ceu"
    if (0) {

#line 51 "btree-1.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
} else {
/* NODE: Block 1139 */

#line 51 "btree-1.ceu"
    {/* NODE: Stmts 1138 */

#line 51 "btree-1.ceu"
    {/* NODE: Set 1146 */

#line 51 "btree-1.ceu"
/* SET: table: 0x1390740 *//* NODE: Await 1107 */

#line 51 "btree-1.ceu"
    _CEU_NO_1107_:
if (0) { goto _CEU_NO_1107_; /* avoids "not used" warning */ }

#line 51 "btree-1.ceu"
    _ceu_trl->evt = CEU_IN__ok_killed;
_ceu_trl->lbl = Body_225_Awake__ok_killed_28;
_ceu_trl->seqno = _ceu_app->seqno;

#line 51 "btree-1.ceu"
    _ceu_trl->org_or_adt = (void*)(&((CEU_Body_225*)_ceu_org)->_org_213_27);

#line 51 "btree-1.ceu"
    return;

case Body_225_Awake__ok_killed_28:;

#line 51 "btree-1.ceu"
    #ifdef CEU_DEBUG_TRAILS
#ifndef CEU_OS
printf("\tOK!\n");
#endif
#endif

#line 51 "btree-1.ceu"
    {

#line 51 "btree-1.ceu"
        tceu_kill* __ceu_casted = (tceu_kill*) _ceu_evt->param;

#line 51 "btree-1.ceu"
        (((CEU_Body_225*)_ceu_org)->ok_26) = ((__ceu_casted)->ret);
}

#line 51 "btree-1.ceu"
    }
#line 51 "btree-1.ceu"
/* CLEAR: Block (51) */
#line 51 "btree-1.ceu"
    if (0) {

#line 51 "btree-1.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
}

#line 51 "btree-1.ceu"
    }
#line 51 "btree-1.ceu"
    }
#line 51 "btree-1.ceu"
    }
#line 51 "btree-1.ceu"
/* CLEAR: Block (51) */
#line 51 "btree-1.ceu"
    {
    tceu_evt evt;
             evt.id = CEU_IN__CLEAR;
    ceu_sys_go_ex(_ceu_app, &evt,
                  _ceu_stk,
                  _ceu_org,
                  &_ceu_org->trls[ 2 ],
                  &_ceu_org->trls[ 4 ]);
                                        /* excludes +1 */
}

/* LONGJMP
 * Block termination: we will abort all trails between [t1,t2].
 * Return status=1 to distinguish from longjmp from organism termination.
 * We want to continue from "me.lbl_jmp" below.
 */
#ifdef CEU_ORGS
_ceu_app->stk_jmp.org = _ceu_org;
#endif
_ceu_app->stk_jmp.trl = _ceu_trl;
_ceu_app->stk_jmp.lbl = Body_225_Block_jmp_29;
ceu_longjmp(_ceu_app, _ceu_org,
            2,3);

#line 51 "btree-1.ceu"
case Body_225_Block_jmp_29:;
#line 51 "btree-1.ceu"
    if (0) {

#line 51 "btree-1.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 50 "btree-1.ceu"
    }/* NODE: Stmts 1150 */

#line 54 "btree-1.ceu"
    {/* NODE: Set 1148 */

#line 54 "btree-1.ceu"
/* SET: _ret *//* NODE: Var 215 */

#line 54 "btree-1.ceu"
    (((CEU_Body_225*)_ceu_org)->_ret_13) = (((CEU_Body_225*)_ceu_org)->ok_26);
#line 54 "btree-1.ceu"
    #ifdef CEU_ORGS_AWAIT
    _ceu_org->ret = (((CEU_Body_225*)_ceu_org)->_ret_13);
    /* HACK_8: result of immediate spawn termination */
    _ceu_app->ret = _ceu_org->ret;
#endif
/* NODE: Escape 1149 */

#line 54 "btree-1.ceu"
    _ceu_lbl = Body_225_Set_out_6;
goto _CEU_GOTO_;

#line 54 "btree-1.ceu"
    }
#line 50 "btree-1.ceu"
    }
#line 50 "btree-1.ceu"
/* CLEAR: Block (50) */
#line 50 "btree-1.ceu"
    if (0) {

#line 50 "btree-1.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
} else {
/* NODE: Nothing 625 */
}
}
}

#line 35 "btree-1.ceu"
    }
#line 35 "btree-1.ceu"
/* CLEAR: Block (35) */
#line 35 "btree-1.ceu"
    if (0) {

#line 35 "btree-1.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 34 "btree-1.ceu"
/* PAROR JOIN */
#line 34 "btree-1.ceu"
    _ceu_lbl = Body_225_ParOr_out_13;
goto _CEU_GOTO_;

#line 34 "btree-1.ceu"
case Body_225_ParOr_sub_1_12:;/* NODE: Block 593 */

#line 34 "btree-1.ceu"
    {/* NODE: Stmts 592 */

#line 34 "btree-1.ceu"
    {/* NODE: Stmts 624 */

#line 34 "btree-1.ceu"
    {/* NODE: Nothing 595 */
/* NODE: Nothing 1431 */
/* NODE: If 609 */

#line 34 "btree-1.ceu"
    if ((((((CEU_BTree *)(  ((tceu_pool_adts*) (&((CEU_Body_225*)_ceu_org)->t))->root)))->tag == CEU_BTREE_NIL) /* XXXX */)) {
/* NODE: Block 606 */

#line 34 "btree-1.ceu"
    {/* NODE: Stmts 605 */

#line 34 "btree-1.ceu"
    {/* NODE: Nothing 604 */

#line 34 "btree-1.ceu"
    }
#line 34 "btree-1.ceu"
/* CLEAR: Block (34) */
#line 34 "btree-1.ceu"
    if (0) {

#line 34 "btree-1.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
} else {
/* NODE: Block 608 */

#line 34 "btree-1.ceu"
    {/* NODE: Stmts 607 */

#line 34 "btree-1.ceu"
    {/* NODE: Await 599 */

#line 34 "btree-1.ceu"
    _CEU_NO_599_:
if (0) { goto _CEU_NO_599_; /* avoids "not used" warning */ }

#line 34 "btree-1.ceu"
    _ceu_trl->evt = CEU_IN__ok_killed;
_ceu_trl->lbl = Body_225_Awake__ok_killed_15;
_ceu_trl->seqno = _ceu_app->seqno;

#line 34 "btree-1.ceu"
    _ceu_trl->org_or_adt = (void*)(((CEU_BTree *)(  ((tceu_pool_adts*) (&((CEU_Body_225*)_ceu_org)->t))->root)));

#line 34 "btree-1.ceu"
    return;

case Body_225_Awake__ok_killed_15:;

#line 34 "btree-1.ceu"
    #ifdef CEU_DEBUG_TRAILS
#ifndef CEU_OS
printf("\tOK!\n");
#endif
#endif

#line 34 "btree-1.ceu"
    }
#line 34 "btree-1.ceu"
/* CLEAR: Block (34) */
#line 34 "btree-1.ceu"
    if (0) {

#line 34 "btree-1.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
}
/* NODE: Nothing 1432 */

#line 34 "btree-1.ceu"
    }
#line 34 "btree-1.ceu"
    }
#line 34 "btree-1.ceu"
/* CLEAR: Block (34) */
#line 34 "btree-1.ceu"
    if (0) {

#line 34 "btree-1.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 34 "btree-1.ceu"
/* PAROR JOIN */
#line 34 "btree-1.ceu"
    _ceu_lbl = Body_225_ParOr_out_13;
goto _CEU_GOTO_;

#line 34 "btree-1.ceu"
case Body_225_ParOr_out_13:;
#line 34 "btree-1.ceu"
/* CLEAR: ParOr (34) */
#line 34 "btree-1.ceu"
    {
    tceu_evt evt;
             evt.id = CEU_IN__CLEAR;
    ceu_sys_go_ex(_ceu_app, &evt,
                  _ceu_stk,
                  _ceu_org,
                  &_ceu_org->trls[ 1 ],
                  &_ceu_org->trls[ 5 ]);
                                        /* excludes +1 */
}

/* LONGJMP
 * Block termination: we will abort all trails between [t1,t2].
 * Return status=1 to distinguish from longjmp from organism termination.
 * We want to continue from "me.lbl_jmp" below.
 */
#ifdef CEU_ORGS
_ceu_app->stk_jmp.org = _ceu_org;
#endif
_ceu_app->stk_jmp.trl = _ceu_trl;
_ceu_app->stk_jmp.lbl = Body_225_ParOr_jmp_14;
ceu_longjmp(_ceu_app, _ceu_org,
            1,4);

#line 34 "btree-1.ceu"
case Body_225_ParOr_jmp_14:;
#line 34 "btree-1.ceu"
    }
#line 34 "btree-1.ceu"
/* CLEAR: Block (34) */
#line 34 "btree-1.ceu"
    if (0) {

#line 34 "btree-1.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 33 "btree-1.ceu"
    }
#line 33 "btree-1.ceu"
/* CLEAR: Block (33) */
#line 33 "btree-1.ceu"
    if (0) {

#line 33 "btree-1.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 33 "btree-1.ceu"
/* PAROR JOIN */
#line 33 "btree-1.ceu"
    _ceu_lbl = Body_225_ParOr_out_9;
goto _CEU_GOTO_;

#line 33 "btree-1.ceu"
case Body_225_ParOr_sub_1_8:;/* NODE: Block 559 */

#line 33 "btree-1.ceu"
    {/* NODE: Stmts 558 */

#line 33 "btree-1.ceu"
    {/* NODE: Stmts 590 */

#line 33 "btree-1.ceu"
    {/* NODE: Nothing 561 */
/* NODE: Nothing 1429 */
/* NODE: Nothing 1430 */
/* NODE: Stmts 589 */

#line 33 "btree-1.ceu"
    {/* NODE: If 588 */

#line 33 "btree-1.ceu"
    if ((!(((*((tceu_org*)((((CEU_Body_225*)_ceu_org)->_parent)))).isAlive)))) {
/* NODE: Block 585 */

#line 33 "btree-1.ceu"
    {/* NODE: Stmts 584 */

#line 33 "btree-1.ceu"
    {/* NODE: Nothing 566 */

#line 33 "btree-1.ceu"
    }
#line 33 "btree-1.ceu"
/* CLEAR: Block (33) */
#line 33 "btree-1.ceu"
    if (0) {

#line 33 "btree-1.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
} else {
/* NODE: Block 587 */

#line 33 "btree-1.ceu"
    {/* NODE: Stmts 586 */

#line 33 "btree-1.ceu"
    {/* NODE: Await 565 */

#line 33 "btree-1.ceu"
    _CEU_NO_565_:
if (0) { goto _CEU_NO_565_; /* avoids "not used" warning */ }

#line 33 "btree-1.ceu"
    _ceu_trl->evt = CEU_IN__ok_killed;
_ceu_trl->lbl = Body_225_Awake__ok_killed_11;
_ceu_trl->seqno = _ceu_app->seqno;

#line 33 "btree-1.ceu"
    _ceu_trl->org_or_adt = (void*)((((CEU_Body_225*)_ceu_org)->_parent));

#line 33 "btree-1.ceu"
    return;

case Body_225_Awake__ok_killed_11:;

#line 33 "btree-1.ceu"
    #ifdef CEU_DEBUG_TRAILS
#ifndef CEU_OS
printf("\tOK!\n");
#endif
#endif

#line 33 "btree-1.ceu"
    }
#line 33 "btree-1.ceu"
/* CLEAR: Block (33) */
#line 33 "btree-1.ceu"
    if (0) {

#line 33 "btree-1.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
}

#line 33 "btree-1.ceu"
    }
#line 33 "btree-1.ceu"
    }
#line 33 "btree-1.ceu"
    }
#line 33 "btree-1.ceu"
/* CLEAR: Block (33) */
#line 33 "btree-1.ceu"
    if (0) {

#line 33 "btree-1.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 33 "btree-1.ceu"
/* PAROR JOIN */
#line 33 "btree-1.ceu"
    _ceu_lbl = Body_225_ParOr_out_9;
goto _CEU_GOTO_;

#line 33 "btree-1.ceu"
case Body_225_ParOr_out_9:;
#line 33 "btree-1.ceu"
/* CLEAR: ParOr (33) */
#line 33 "btree-1.ceu"
    {
    tceu_evt evt;
             evt.id = CEU_IN__CLEAR;
    ceu_sys_go_ex(_ceu_app, &evt,
                  _ceu_stk,
                  _ceu_org,
                  &_ceu_org->trls[ 0 ],
                  &_ceu_org->trls[ 5 ]);
                                        /* excludes +1 */
}

/* LONGJMP
 * Block termination: we will abort all trails between [t1,t2].
 * Return status=1 to distinguish from longjmp from organism termination.
 * We want to continue from "me.lbl_jmp" below.
 */
#ifdef CEU_ORGS
_ceu_app->stk_jmp.org = _ceu_org;
#endif
_ceu_app->stk_jmp.trl = _ceu_trl;
_ceu_app->stk_jmp.lbl = Body_225_ParOr_jmp_10;
ceu_longjmp(_ceu_app, _ceu_org,
            0,4);

#line 33 "btree-1.ceu"
case Body_225_ParOr_jmp_10:;/* NODE: Stmts 1154 */

#line 33 "btree-1.ceu"
    {/* NODE: Set 1152 */

#line 33 "btree-1.ceu"
/* SET: _ret *//* NODE: NUMBER 482 */

#line 33 "btree-1.ceu"
    (((CEU_Body_225*)_ceu_org)->_ret_13) = 0;
#line 33 "btree-1.ceu"
    #ifdef CEU_ORGS_AWAIT
    _ceu_org->ret = (((CEU_Body_225*)_ceu_org)->_ret_13);
    /* HACK_8: result of immediate spawn termination */
    _ceu_app->ret = _ceu_org->ret;
#endif
/* NODE: Escape 1153 */

#line 33 "btree-1.ceu"
    _ceu_lbl = Body_225_Set_out_6;
goto _CEU_GOTO_;

#line 33 "btree-1.ceu"
    }
#line 33 "btree-1.ceu"
    }
#line 33 "btree-1.ceu"
/* CLEAR: Block (33) */
#line 33 "btree-1.ceu"
    if (0) {

#line 33 "btree-1.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 33 "btree-1.ceu"
    return;
#line 33 "btree-1.ceu"
case Body_225_Set_out_6:;
#line 33 "btree-1.ceu"
/* CLEAR: SetBlock (33) */
#line 33 "btree-1.ceu"
    {
    tceu_evt evt;
             evt.id = CEU_IN__CLEAR;
    ceu_sys_go_ex(_ceu_app, &evt,
                  _ceu_stk,
                  _ceu_org,
                  &_ceu_org->trls[ 0 ],
                  &_ceu_org->trls[ 5 ]);
                                        /* excludes +1 */
}

/* LONGJMP
 * Block termination: we will abort all trails between [t1,t2].
 * Return status=1 to distinguish from longjmp from organism termination.
 * We want to continue from "me.lbl_jmp" below.
 */
#ifdef CEU_ORGS
_ceu_app->stk_jmp.org = _ceu_org;
#endif
_ceu_app->stk_jmp.trl = _ceu_trl;
_ceu_app->stk_jmp.lbl = Body_225_Set_jmp_7;
ceu_longjmp(_ceu_app, _ceu_org,
            0,4);

#line 33 "btree-1.ceu"
case Body_225_Set_jmp_7:;
#line 33 "btree-1.ceu"
    }
#line 33 "btree-1.ceu"
/* CLEAR: Block (33) */
#line 33 "btree-1.ceu"
    if (0) {

#line 33 "btree-1.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 33 "btree-1.ceu"
    }
#line 33 "btree-1.ceu"
/* CLEAR: Block (33) */
#line 33 "btree-1.ceu"
    {
    tceu_evt evt;
             evt.id = CEU_IN__CLEAR;
    ceu_sys_go_ex(_ceu_app, &evt,
                  _ceu_stk,
                  _ceu_org,
                  &_ceu_org->trls[ 0 ],
                  &_ceu_org->trls[ 7 ]);
                                        /* excludes +1 */
}

/* LONGJMP
 * Block termination: we will abort all trails between [t1,t2].
 * Return status=1 to distinguish from longjmp from organism termination.
 * We want to continue from "me.lbl_jmp" below.
 */
#ifdef CEU_ORGS
_ceu_app->stk_jmp.org = _ceu_org;
#endif
_ceu_app->stk_jmp.trl = _ceu_trl;
_ceu_app->stk_jmp.lbl = Body_225_Block_jmp_31;
ceu_longjmp(_ceu_app, _ceu_org,
            0,6);

#line 33 "btree-1.ceu"
case Body_225_Block_jmp_31:;
#line 33 "btree-1.ceu"
    if (0) {

#line 33 "btree-1.ceu"
case Body_225_Block__fin_30:;
#line 33 "btree-1.ceu"
    return;
#line 33 "btree-1.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 33 "btree-1.ceu"
    {
    tceu_evt evt;
             evt.id = CEU_IN__CLEAR;
    ceu_sys_go_ex(_ceu_app, &evt,
                  _ceu_stk,
                  _ceu_org,
                  &_ceu_org->trls[_ceu_org->n], /* to the end, only free it */
                  NULL);
}

#line 33 "btree-1.ceu"
    return;
    }
#ifdef CEU_DEBUG
    ceu_out_assert_msg(0, "no return");
#endif
}

#ifdef CEU_OS_APP
static __attribute__((noinline))  __attribute__((noclone))
#endif
void
ceu_app_init (tceu_app* app)
{
    app->seqno = 0;
#if defined(CEU_RET) || defined(CEU_OS_APP)
    app->isAlive = 1;
#endif
#ifdef CEU_ASYNCS
    app->pendingAsyncs = 1;
#endif
#if defined(CEU_ORGS_NEWS_MALLOC) && defined(CEU_ORGS_AWAIT)
    app->dont_emit_kill = 0;
#endif
#ifdef CEU_REENTRANT
    app->stki = 0;
#endif
#ifdef CEU_RET
    app->ret = 0;
#endif
#ifdef CEU_ORGS_NEWS_MALLOC
    app->tofree = NULL;
#endif
#ifdef CEU_WCLOCKS
    app->wclk_late = 0;
    app->wclk_min_set = CEU_WCLOCK_INACTIVE;
    app->wclk_min_cmp = CEU_WCLOCK_INACTIVE;
#ifdef CEU_TIMEMACHINE
    app->wclk_late_ = 0;
    app->wclk_min_set_ = CEU_WCLOCK_INACTIVE;
    app->wclk_min_cmp_ = CEU_WCLOCK_INACTIVE;
#endif
#endif
#ifdef CEU_THREADS
    pthread_mutex_init(&app->threads_mutex, NULL);
    /*PTHREAD_COND_INITIALIZER,*/
    app->threads_n = 0;

    /* All code run atomically:
     * - the program is always locked as a whole
     * -    thread spawns will unlock => re-lock
     * - but program will still run to completion
     */
    CEU_THREADS_MUTEX_LOCK(&app->threads_mutex);
#endif

    CEU_BTREE_BASE.tag = CEU_BTREE_NIL;


#ifdef CEU_OS_APP

#ifdef __AVR
    app->code  = (__typeof__(ceu_app_go)*)    (((word)app->addr>>1) + &ceu_app_go);
    app->calls = (__typeof__(ceu_app_calls)*) (((word)app->addr>>1) + &ceu_app_calls);
#else
    app->code  = (__typeof__(ceu_app_go)*)    (&ceu_app_go);
    app->calls = (__typeof__(ceu_app_calls)*) (&ceu_app_calls);
#endif

#else   /* !CEU_OS_APP */

    app->code  = (__typeof__(ceu_app_go)*)    (&ceu_app_go);

#endif  /* CEU_OS_APP */

#ifndef CEU_OS_APP
#ifdef CEU_DEBUG
    CEU_APP_SIG = app;
    signal(SIGSEGV, ceu_segfault);
#endif
#endif

    ceu_out_org_init(app, app->data, CEU_NTRAILS, Class_Main,
                     0, 0,
                     NULL, 0);

#ifdef CEU_LUA
    ceu_luaL_newstate(app->lua);
    ceu_out_assert(app->lua != NULL);
    ceu_luaL_openlibs(app->lua);
    ceu_lua_atpanic(app->lua, ceu_lua_atpanic_f);    /* TODO: CEU_OS */
#endif

    app->data->trls[0].evt = CEU_IN__INIT;
    app->data->trls[0].seqno = 0;
    ceu_sys_go(app, CEU_IN__INIT, NULL);
}

/* EXPORTED ENTRY POINT
 * CEU_EXPORT is put in a separate section ".export".
 * "gcc-ld" should place it at 0x00, before ".text".
 */

#ifdef CEU_OS_APP
__attribute__ ((section (".export")))
void CEU_EXPORT (uint* size, tceu_init** init
#ifdef CEU_OS_LUAIFC
                , char** luaifc
#endif
) {
    *size = sizeof(CEU_Main);
    *init = (tceu_init*) &ceu_app_init;
#ifdef CEU_OS_LUAIFC
    *luaifc = (=== APP_LUAIFC ===);
#endif
}
#endif
