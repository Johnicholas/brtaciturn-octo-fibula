/*
 * This file is automatically generated.
 * Check the github repository for a readable version:
 * http://github.com/fsantanna/ceu
 *
 * CÃ©u is distributed under the MIT License:
 *

Copyright (C) 2012 Francisco Sant'Anna

Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the "Software"), to deal in
the Software without restriction, including without limitation the rights to
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
of the Software, and to permit persons to whom the Software is furnished to do
so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/
#line 1 "garden.ceu"

#ifndef _CEU_APP_H
#define _CEU_APP_H

#include "ceu_types.h"

#define CEU_INTS
#define CEU_EXTS
#define CEU_ORGS_AWAIT
#define CEU_ORGS_NEWS_MALLOC
#define CEU_ORGS_NEWS_POOL
#define CEU_CLEAR
#define CEU_ORGS
#define CEU_ORGS_NEWS
#define CEU_GOTO
#define CEU_STACK_CLEAR
     /* CEU_EXTS, CEU_WCLOCKS, CEU_INTS, ... */

/* TODO: lbl => unsigned */
#ifndef CEU_OS
typedef s16 tceu_nlbl;
#endif

#ifdef CEU_IFCS
/* (x) number of different classes */
typedef s16 tceu_ncls;
#endif

/* TODO: remove */
#define CEU_NTRAILS 13

#ifndef _CEU_OS_H
#define _CEU_OS_H

#include <stddef.h>
#include "ceu_types.h"

#ifdef CEU_DEBUG
#include <assert.h>
#endif

#if defined(CEU_OS) && defined(__AVR)
#error Understand this again!
#include "Arduino.h"
#define CEU_ISR
#define CEU_ISR_ON()  interrupts()
#define CEU_ISR_OFF() noInterrupts()
#else
#define CEU_ISR_ON()
#define CEU_ISR_OFF()
#endif

#if defined(CEU_OS_KERNEL) || defined(CEU_OS_APP)
#define CEU_OS
#endif

#if defined(CEU_ORGS_NEWS) || defined(CEU_ADTS_NEWS)
#define CEU_NEWS
#endif
#if defined(CEU_ORGS_NEWS_POOL) || defined(CEU_ADTS_NEWS_POOL)
#define CEU_NEWS_POOL
#endif
#if defined(CEU_ORGS_AWAIT) || defined(CEU_ADTS_AWAIT)
#define CEU_ORGS_OR_ADTS_AWAIT
#endif

#ifdef CEU_OS

    /* TODO: all should be configurable */
    #define CEU_EXTS
    #define CEU_WCLOCKS
    #define CEU_ASYNCS
    #define CEU_RET
    #define CEU_CLEAR
    #define CEU_STACK_CLEAR
#ifndef __AVR
#endif
    #define CEU_INTS
    #define CEU_ORGS
    /*#define CEU_PSES*/ /* TODO: never tried */
    #define CEU_NEWS
    #define CEU_NEWS_POOL
    #define CEU_ORGS_NEWS
    #define CEU_ORGS_NEWS_MALLOC
    #define CEU_ORGS_NEWS_POOL
    #define CEU_ADTS_NEWS
    #define CEU_ADTS_NEWS_MALLOC
    #define CEU_ADTS_NEWS_POOL
    #define CEU_ORGS_AWAIT
    #define CEU_ADTS_AWAIT
    #define CEU_ORGS_OR_ADTS_AWAIT
/*
    #define CEU_THREADS
*/

#ifdef __AVR
    #define CEU_QUEUE_MAX 256
#else
    #define CEU_QUEUE_MAX 65536
#endif

    #define CEU_IN__NONE          0
    #define CEU_IN__ORG         255
    #define CEU_IN__ORG_PSED    254
    #define CEU_IN__CLEAR       253
    #define CEU_IN__ok_killed   252
    #define CEU_IN__INIT        251     /* HIGHER EXTERNAL */
    #define CEU_IN__ASYNC       250
    #define CEU_IN__THREAD      249
    #define CEU_IN__WCLOCK      248
    #define CEU_IN_OS_START     247
    #define CEU_IN_OS_STOP      246
    #define CEU_IN_OS_DT        245
    #define CEU_IN_OS_INTERRUPT 244
#ifdef CEU_TIMEMACHINE
    #define CEU_IN__WCLOCK_     243
    #define CEU_IN              243
#else
    #define CEU_IN              242
#endif

    #define CEU_IN_higher       CEU_IN__INIT  /* _INIT = HIGHER EXTERNAL */
    #define CEU_IN_lower        128     /* TODO: not checked from up and down */

    typedef s8 tceu_nlbl;   /* TODO: to small!! */

#endif /* CEU_OS */

#ifdef CEU_OS_APP

    #define ceu_out_log(mode,str) \
        ((__typeof__(ceu_sys_log)*)((_ceu_app)->sys_vec[CEU_SYS_LOG]))(mode,str)

    #define ceu_out_assert(v) \
        ((__typeof__(ceu_sys_assert)*)((_ceu_app)->sys_vec[CEU_SYS_ASSERT]))(v)

    #define ceu_out_assert_msg_ex(v,msg,file,line)       \
        {                                                \
            int __ceu_v = v;                             \
            if ((!(__ceu_v)) && ((msg)!=NULL)) {         \
                ceu_out_log(0, (long)"[");               \
                ceu_out_log(0, (long)(file));            \
                ceu_out_log(0, (long)":");               \
                ceu_out_log(2, (line));                  \
                ceu_out_log(0, (long)"] ");              \
                ceu_out_log(0, (long)"runtime error: "); \
                ceu_out_log(0, (long)(msg));             \
                ceu_out_log(0, (long)"\n");              \
            }                                            \
            ((__typeof__(ceu_sys_assert)*)((_ceu_app)->sys_vec[CEU_SYS_ASSERT]))(__ceu_v); \
        }
    #define ceu_out_assert_msg(v,msg) ceu_out_assert_msg_ex((v),(msg),__FILE__,__LINE__)

    #define ceu_out_realloc(ptr, size) \
        ((__typeof__(ceu_sys_realloc)*)((_ceu_app)->sys_vec[CEU_SYS_REALLOC]))(ptr,size)

    #define ceu_out_req() \
        ((__typeof__(ceu_sys_req)*)((_ceu_app)->sys_vec[CEU_SYS_REQ]))()

    #define ceu_out_load(addr) \
        ((__typeof__(ceu_sys_load)*)((_ceu_app)->sys_vec[CEU_SYS_LOAD]))(addr)

#ifdef CEU_ISR
    #define ceu_out_isr(n,f) \
        ((__typeof__(ceu_sys_isr)*)((_ceu_app)->sys_vec[CEU_SYS_ISR]))(n,f,_ceu_app)
#endif

    #define ceu_out_org_init(app,org,n,lbl,cls,isDyn,parent_org,parent_trl) \
        ((__typeof__(ceu_sys_org_init)*)((app)->sys_vec[CEU_SYS_ORG]))(org,n,lbl,cls,isDyn,parent_org,parent_trl)
    #define ceu_out_start(app) \
        ((__typeof__(ceu_sys_start)*)((_ceu_app)->sys_vec[CEU_SYS_START]))(app)
    #define ceu_out_link(app1,evt1 , app2,evt2) \
        ((__typeof__(ceu_sys_link)*)((_ceu_app)->sys_vec[CEU_SYS_LINK]))(app1,evt1,app2,evt2)

    #define ceu_out_emit(app,id,sz,buf) \
        ((__typeof__(ceu_sys_emit)*)((app)->sys_vec[CEU_SYS_EMIT]))(app,id,sz,buf)

    #define ceu_out_call(app,id,param) \
        ((__typeof__(ceu_sys_call)*)((app)->sys_vec[CEU_SYS_CALL]))(app,id,param)

#ifdef CEU_WCLOCKS
    #define ceu_out_wclock(app,dt,set,get) \
        ((__typeof__(ceu_sys_wclock)*)((app)->sys_vec[CEU_SYS_WCLOCK]))(app,dt,set,get)
#ifdef CEU_TIMEMACHINE
    #error TIMEMACHINE
#endif
#endif

    #define ceu_out_go(app,evt,evtp) \
        ((__typeof__(ceu_sys_go)*)((app)->sys_vec[CEU_SYS_GO]))(app,evt,evtp)

#else /* ! CEU_OS_APP (!CEU_OS||CEU_OS_KERNEL) */

    #ifndef ceu_out_assert
        #error "Missing definition for macro \"ceu_out_assert\"."
    #endif

    #ifndef ceu_out_log
        #error "Missing definition for macro \"ceu_out_log\"."
    #endif

    #define ceu_out_assert_msg_ex(v,msg,file,line)          \
        {                                                   \
            int __ceu_v = v;                                \
            if ((!(__ceu_v)) && ((msg)!=NULL)) {            \
                ceu_out_log(0, (long)"[");                  \
                ceu_out_log(0, (long)(file));               \
                ceu_out_log(0, (long)":");                  \
                ceu_out_log(2, line);                       \
                ceu_out_log(0, (long)"] ");                 \
                ceu_out_log(0, (long)"runtime error: ");    \
                ceu_out_log(0, (long)(msg));                \
                ceu_out_log(0, (long)"\n");                 \
            }                                               \
            ceu_out_assert(__ceu_v);                        \
        }
    #define ceu_out_assert_msg(v,msg) ceu_out_assert_msg_ex((v),(msg),__FILE__,__LINE__)

    #define ceu_out_realloc(ptr,size) \
            ceu_sys_realloc(ptr,size)
    #define ceu_out_req() \
            ceu_sys_req()
    #define ceu_out_org_init(app,org,n,lbl,cls,isDyn,parent_org,parent_trl) \
            ceu_sys_org_init(org,n,lbl,cls,isDyn,parent_org,parent_trl)

#ifdef CEU_WCLOCKS
    #define ceu_out_wclock(app,dt,set,get) \
            ceu_sys_wclock(app,dt,set,get)
#ifdef CEU_TIMEMACHINE
    #define ceu_out_wclock_(app,dt,set,get) \
            ceu_sys_wclock_(app,dt,set,get)
#endif
#endif
    #define ceu_out_go(app,evt,evtp) \
            ceu_sys_go(app,evt,evtp)
    #define ceu_out_go_stk(app,evt,evtp,stk) \
            ceu_sys_go_stk(app,evt,evtp,stk)

#endif /* ! CEU_OS_APP (!CEU_OS||CEU_OS_KERNEL) */

#ifdef CEU_STACK_CLEAR
#define ceu_in_emit(app,id,n,buf) \
    ceu_out_go_stk(app,id,buf,&stk_)
#else
#define ceu_in_emit(app,id,n,buf) \
    ceu_out_go_stk(app,id,buf,NULL)
#endif

#ifdef CEU_THREADS
/* TODO: app */
#ifndef _CEU_THREADS_H
#define _CEU_THREADS_H

#include <pthread.h>
#define CEU_THREADS_T               pthread_t
#define CEU_THREADS_MUTEX_T         pthread_mutex_t
#define CEU_THREADS_COND_T          pthread_cond_t
#define CEU_THREADS_SELF()          pthread_self()
#define CEU_THREADS_CREATE(t,f,p)   pthread_create(t,NULL,f,p)
#define CEU_THREADS_DETACH(t)       pthread_detach(t)
/*
#define CEU_THREADS_MUTEX_LOCK(m)   pthread_mutex_lock(m); printf("L[%d]\n",__LINE__)
#define CEU_THREADS_MUTEX_UNLOCK(m) pthread_mutex_unlock(m); printf("U[%d]\n",__LINE__)
*/
#define CEU_THREADS_MUTEX_LOCK(m)   pthread_mutex_lock(m)
#define CEU_THREADS_MUTEX_UNLOCK(m) pthread_mutex_unlock(m);
/*
#define CEU_THREADS_COND_WAIT(c,m)  pthread_cond_wait(c,m)
#define CEU_THREADS_COND_SIGNAL(c)  pthread_cond_signal(c)
*/

#endif

#endif

#ifdef CEU_LUA
#include <stdio.h>      /* BUFSIZ */
#include <string.h>     /* strcpy */
#if defined(__ANDROID__) || defined(CEU_OS)
    #include "lua.h"
    #include "lauxlib.h"
    #include "lualib.h"
#else
    #include <lua5.1/lua.h>
    #include <lua5.1/lauxlib.h>
    #include <lua5.1/lualib.h>
#endif

#ifdef CEU_OS_APP
    #define ceu_luaL_newstate(set) { \
        set = ceu_out_call(_ceu_app, CEU_OUT_LUA_NEW, NULL); \
    }

    #define ceu_luaL_openlibs(l) { \
        lua_State* p = l;          \
        ceu_out_call(_ceu_app, CEU_OUT_LUAL_OPENLIBS, &p); \
    }

    #define ceu_lua_atpanic(l, f) {     \
    }

    #define ceu_luaL_loadstring(set, l, str) {  \
        tceu__lua_State___char_ p = { l, str }; \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUAL_LOADSTRING, &p); \
    }

    #define ceu_lua_pushnumber(l, v) {      \
        tceu__lua_State___int p = { l, v }; \
        ceu_out_call(_ceu_app, CEU_OUT_LUA_PUSHNUMBER, &p); \
    }

    #define ceu_lua_pushstring(l, v) {      \
        tceu__lua_State___char_ p = { l, v }; \
        ceu_out_call(_ceu_app, CEU_OUT_LUA_PUSHSTRING, &p); \
    }

    #define ceu_lua_pushlightuserdata(l, v) {   \
        tceu__lua_State___void_ p = { l, v };     \
        ceu_out_call(_ceu_app, CEU_OUT_LUA_PUSHLIGHTUSERDATA, &p); \
    }

    #define ceu_lua_pcall(set,l,nargs,nrets,err) {                  \
        tceu__lua_State___int__int__int p = { l, nargs, nrets, err }; \
        ceu_out_call(_ceu_app, CEU_OUT_LUA_PCALL, &p); \
    }

    #define ceu_lua_isnumber(set, l, idx) {     \
        tceu__lua_State___int p = { l, idx };   \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUA_ISNUMBER, &p); \
    }

    #define ceu_lua_tonumber(set, l, idx) {     \
        tceu__lua_State___int p = { l, idx };   \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUA_TONUMBER, &p); \
    }

    #define ceu_lua_isboolean(set, l, idx) {    \
        tceu__lua_State___int p = { l, idx };   \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUA_ISBOOLEAN, &p); \
    }

    #define ceu_lua_toboolean(set, l, idx) {    \
        tceu__lua_State___int p = { l, idx };   \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUA_TOBOOLEAN, &p); \
    }

    #define ceu_lua_pop(l, n) {             \
        tceu__lua_State___int p = { l, n }; \
        ceu_out_call(_ceu_app, CEU_OUT_LUA_POP, &p); \
    }

    #define ceu_lua_isstring(set, l, idx) {     \
        tceu__lua_State___int p = { l, idx };   \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUA_ISSTRING, &p); \
    }

    #define ceu_lua_tostring(set, l, idx) {     \
        tceu__lua_State___int p = { l, idx };   \
        set = ceu_out_call(_ceu_app, CEU_OUT_LUA_TOSTRING, &p); \
    }

    #define ceu_lua_islightuserdata(set, l, idx) {  \
        tceu__lua_State___int p = { l, idx };       \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUA_ISLIGHTUSERDATA, &p); \
    }

    #define ceu_lua_touserdata(set, l, idx) {   \
        tceu__lua_State___int p = { l, idx };   \
        set = ceu_out_call(_ceu_app, CEU_OUT_LUA_TOUSERDATA, &p); \
    }

    #define ceu_lua_error(l) {                          \
        lua_State** p = &l;                             \
        ceu_out_call(_ceu_app, CEU_OUT_LUA_ERROR, &p);  \
    }

    #define ceu_lua_objlen(set, l, idx) {                       \
        tceu__lua_State___int p = { l, idx };                   \
        set = ceu_out_call(_ceu_app, CEU_OUT_LUA_OBJLEN, &p);   \
    }

#else
    #define ceu_luaL_newstate(set)               set = luaL_newstate()
    #define ceu_luaL_openlibs(l)                 luaL_openlibs(l)
    #define ceu_lua_atpanic(l,f)                 lua_atpanic(l,f)
    #define ceu_luaL_loadstring(set,l,str)       set = luaL_loadstring(l,str)
    #define ceu_lua_pushnumber(l,v)              lua_pushnumber(l,v)
    #define ceu_lua_pushstring(l,v)              lua_pushstring(l,v)
    #define ceu_lua_pushlightuserdata(l,v)       lua_pushlightuserdata(l,v)
    #define ceu_lua_pcall(set,l,nargs,nrets,err) set = lua_pcall(l,nargs,nrets,err)
    #define ceu_lua_isnumber(set,l,idx)          set = lua_isnumber(l,idx)
    #define ceu_lua_tonumber(set,l,idx)          set = lua_tonumber(l,idx)
    #define ceu_lua_isboolean(set,l,idx)         set = lua_isboolean(l,idx)
    #define ceu_lua_toboolean(set,l,idx)         set = lua_toboolean(l,idx)
    #define ceu_lua_pop(l,n)                     lua_pop(l,n)
    #define ceu_lua_isstring(set,l,idx)          set = lua_isstring(l,idx)
    #define ceu_lua_tostring(set,l,idx)          set = lua_tostring(l,idx)
    #define ceu_lua_islightuserdata(set,l,idx)   set = lua_islightuserdata(l,idx)
    #define ceu_lua_touserdata(set,l,idx)        set = lua_touserdata(l,idx)
    #define ceu_lua_error(l)                     lua_error(l)
    #define ceu_lua_objlen(set,l,idx)            set = lua_objlen(l,idx)
#endif
#endif

typedef u8 tceu_nevt;   /* max number of events */
                        /* TODO: should "u8" be fixed? */

typedef u8 tceu_ntrl;   /* max number of trails per class */
                        /* TODO: should "u8" be fixed? */

#ifdef CEU_STACK_CLEAR
typedef u16 tceu_nstk;  /* max size of internal stack in bytes */
                        /* TODO: should "u16" be fixed? */
#endif

#ifdef __cplusplus
#define CEU_WCLOCK_INACTIVE 0x7fffffffL     /* TODO */
#else
#define CEU_WCLOCK_INACTIVE INT32_MAX
#endif
#define CEU_WCLOCK_EXPIRED (CEU_WCLOCK_INACTIVE-1)

/* TCEU_TRL */

struct tceu_org;
typedef union tceu_trl {
    tceu_nevt evt;

    /* normal await // IN__CLEAR */
    struct {                    /* TODO(ram): bitfields */
        tceu_nevt evt1;
        tceu_nlbl lbl;
        u8        seqno;        /* TODO(ram): 2 bits is enough */
#ifdef CEU_INTS                 /* R-9: size of trails for internal events */
#ifdef CEU_ORGS
        void*     evto;
#endif
#endif
    };

    /* IN__ORG */
#ifdef CEU_ORGS
    struct {                    /* TODO(ram): bad for alignment */
        tceu_nevt evt3;
        struct tceu_org* org;
    };
#endif

    /* _ok_killed */
#ifdef CEU_ORGS_OR_ADTS_AWAIT
    struct {
        tceu_nevt evt4;
        tceu_nlbl lbl4;
#ifdef CEU_ORGS_AWAIT
#ifdef CEU_ADTS_AWAIT
        u8        is_org;
#endif
#endif
        void*     org_or_adt;
    };
#endif
} tceu_trl;

/* TCEU_EVT */

typedef struct tceu_evt {
    tceu_nevt id;
    void*     param;
#if defined(CEU_ORGS) && defined(CEU_INTS)
    void*     org;      /* emitting org */
#endif
} tceu_evt;

/* TCEU_ORG */

struct tceu_pool_orgs;
typedef struct tceu_org
{
#ifdef CEU_ORGS
    struct tceu_org* nxt; /* first field because of free list for orgs/adts */
    struct tceu_org* prv;
    struct tceu_org* parent_org;
    tceu_ntrl parent_trl;
#endif

#if defined(CEU_ORGS) || defined(CEU_OS)
    tceu_ntrl n;            /* number of trails (TODO(ram): opt, metadata) */
#endif

#ifdef CEU_ORGS

#ifdef CEU_IFCS
    tceu_ncls cls;          /* class id */
#endif
    u8 isAlive: 1;          /* Three purposes:
                             * - avoids double free
                             * - required by "watching o" to avoid awaiting a
                             *      dead org
                             * - required by "Do T" to avoid awaiting a dead 
                             *      org
                             */
#if defined(CEU_ORGS_NEWS) || defined(CEU_ORGS_AWAIT)
#endif
#ifdef CEU_ORGS_NEWS
    u8 isDyn: 1;            /* created w/ new or spawn? */
#endif
#ifdef CEU_ORGS_NEWS_POOL
    struct tceu_pool_orgs* pool;
#endif

#ifdef CEU_ORGS_AWAIT
    int ret;
#endif

#endif  /* CEU_ORGS */

    tceu_trl trls[0];       /* first trail */

} tceu_org;

/* TCEU_POOL_ORGS , TCEU_POOL_ADTS */

#if defined(CEU_ORGS_NEWS_POOL) || defined(CEU_ADTS_NEWS_POOL)
#ifndef _CEU_POOL_H
#define _CEU_POOL_H

#include "ceu_types.h"

/* TODO: all "int" here, should evaluate the correct unsigned type */

typedef struct {
    byte**  queue;
                    /* queue is in the next offset to distinguish dynamic(NULL)
                       from static pools(any-address) */
    int     size;
    int     free;
    int     index;
    int     unit;
    byte*   mem;
} tceu_pool;

#define CEU_POOL_DCL(name, type, size) \
    type*     name##_queue[size];      \
    type      name##_mem[size];        \
    tceu_pool name;

void ceu_pool_init (tceu_pool* pool, int size, int unit, byte** queue, byte* mem);
byte* ceu_pool_alloc (tceu_pool* pool);
void ceu_pool_free (tceu_pool* pool, byte* val);

#endif

#endif

#ifdef CEU_ORGS_NEWS
typedef struct tceu_pool_orgs {
    tceu_org* parent_org;
    tceu_ntrl parent_trl;
#ifdef CEU_ORGS_NEWS_POOL
    tceu_pool pool;
#endif
} tceu_pool_orgs;
#endif

#ifdef CEU_ADTS_NEWS
typedef struct {
    void* root;
#ifdef CEU_ADTS_NEWS_POOL
    void* pool;
#endif
} tceu_pool_adts;
#endif

/* TCEU_KILL */

#ifdef CEU_ORGS_OR_ADTS_AWAIT
typedef struct tceu_kill {
    void*     org_or_adt;
    int       ret;
    tceu_ntrl t1;
    tceu_ntrl t2;
} tceu_kill;
#endif

/* TCEU_LST */

#ifdef CEU_DEBUG
typedef struct tceu_lst {
#ifdef CEU_ORGS
    void*     org;
#endif
    tceu_trl* trl;
    tceu_nlbl lbl;
} tceu_lst;

#endif

/* TCEU_STK */

#ifdef CEU_STACK_CLEAR
typedef struct tceu_stk {
    struct tceu_stk* down;
    tceu_org*   org;
    tceu_ntrl   trl1;
    tceu_ntrl   trl2;
    char        is_alive;
} tceu_stk;
#else
typedef void tceu_stk;
#endif

/* TCEU_APP */

typedef struct tceu_app {
    /* global seqno: incremented on every reaction
     * awaiting trails matches only if trl->seqno < seqno,
     * i.e., previously awaiting the event
     */
    u8 seqno:          2;
#if defined(CEU_RET) || defined(CEU_OS)
    u8 isAlive:        1;
#endif
#ifdef CEU_ASYNCS
    u8 pendingAsyncs:  1;
#endif
#if defined(CEU_ORGS_NEWS_MALLOC) && defined(CEU_ORGS_AWAIT)
    u8 dont_emit_kill: 1;
#endif

#ifdef CEU_OS
    struct tceu_app* nxt;
#endif

#if defined(CEU_RET) || defined(CEU_ORGS_AWAIT)
    int ret;
#endif

#ifdef CEU_ORGS_NEWS_MALLOC
    tceu_org* tofree;
#endif

#ifdef CEU_WCLOCKS
    s32         wclk_late;
    s32         wclk_min_set;   /* used to set */
    s32         wclk_min_cmp;   /* used to compare */
                                /* cmp<-set every reaction */
#ifdef CEU_TIMEMACHINE
    s32         wclk_late_;
    s32         wclk_min_set_;
    s32         wclk_min_cmp_;
#endif
#endif

#ifndef CEU_OS
#ifdef CEU_DEBUG
    tceu_lst    lst; /* segfault printf */
#endif
#endif

#ifdef CEU_THREADS
    CEU_THREADS_MUTEX_T threads_mutex;
    /*CEU_THREADS_COND_T  threads_cond;*/
    u8                  threads_n;          /* number of running threads */
        /* TODO: u8? */
#endif
#if defined(CEU_LUA) || defined(CEU_OS)
#ifdef CEU_LUA
    lua_State*  lua;    /* TODO: move to data? */
#else
    void*       lua;
#endif
#endif

    void        (*code)  (struct tceu_app*,tceu_evt*,tceu_org*,tceu_trl*,tceu_stk*);
    void        (*init)  (struct tceu_app*);
#ifdef CEU_OS
    void*       (*calls) (struct tceu_app*,tceu_nevt,void*);
    void**      sys_vec;
    void*       addr;
#ifdef CEU_OS_LUAIFC
    char*       luaifc;
#endif
#endif
    tceu_org*   data;
} tceu_app;

#ifdef CEU_OS
typedef void (*tceu_init)   (tceu_app* app);
typedef void (*tceu_export) (uint* size, tceu_init** init
#ifdef CEU_OS_LUAIFC
                            , char** luaifc
#endif
);
#endif

/* TCEU_THREADS_P */

#ifdef CEU_THREADS
typedef struct {
    tceu_app* app;
    tceu_org* org;
    s8*       st; /* thread state:
                   * 0=ini (sync  spawns)
                   * 1=cpy (async copies)
                   * 2=lck (sync  locks)
                   * 3=end (sync/async terminates)
                   */
} tceu_threads_p;
#endif

#ifdef CEU_PSES
void ceu_pause (tceu_trl* trl, tceu_trl* trlF, int psed);
#endif

int  ceu_go_all    (tceu_app* app);

#ifdef CEU_WCLOCKS
int       ceu_sys_wclock (tceu_app* app, s32 dt, s32* set, s32* get);
#endif
void      ceu_sys_go     (tceu_app* app, int evt, void* evtp);

#ifdef CEU_OS

/* TCEU_LINK */

typedef struct tceu_lnk {
    tceu_app* src_app;
    tceu_nevt src_evt;
    tceu_app* dst_app;
    tceu_nevt dst_evt;
    struct tceu_lnk* nxt;
} tceu_lnk;

/* TCEU_QUEUE */

typedef struct {
    tceu_app* app;
    tceu_nevt evt;
#if CEU_QUEUE_MAX == 256
    s8        sz;
#else
    s16       sz;   /* signed because of fill */
#endif
    byte      buf[0];
} tceu_queue;

#ifdef CEU_ISR
typedef void(*tceu_isr_f)(tceu_app* app, tceu_org* org);
#endif

void ceu_os_init      (void);
int  ceu_os_scheduler (int(*dt)());
tceu_queue* ceu_sys_queue_nxt (void);
void        ceu_sys_queue_rem (void);

void      ceu_sys_assert    (int v);
void      ceu_sys_log       (int mode, long str);
void*     ceu_sys_realloc   (void* ptr, size_t size);
int       ceu_sys_req       (void);
tceu_app* ceu_sys_load      (void* addr);
#ifdef CEU_ISR
int       ceu_sys_isr       (int n, tceu_isr_f f, tceu_app* app);
#endif
void      ceu_sys_org_init  (tceu_org* org, int n, int lbl, int cls, int isDyn,
                             tceu_org* parent_org, tceu_ntrl parent_trl);
void      ceu_sys_start     (tceu_app* app);
int       ceu_sys_link      (tceu_app* src_app, tceu_nevt src_evt, tceu_app* dst_app, tceu_nevt dst_evt);
int       ceu_sys_unlink    (tceu_app* src_app, tceu_nevt src_evt, tceu_app* dst_app, tceu_nevt dst_evt);
int       ceu_sys_emit      (tceu_app* app, tceu_nevt evt, int sz, void* param);
void*     ceu_sys_call      (tceu_app* app, tceu_nevt evt, void* param);

enum {
    CEU_SYS_ASSERT = 0,
    CEU_SYS_LOG,
    CEU_SYS_REALLOC,
    CEU_SYS_REQ,
    CEU_SYS_LOAD,
#ifdef CEU_ISR
    CEU_SYS_ISR,
#endif
#ifdef CEU_CLEAR
    CEU_SYS_CLEAR,
#endif
    CEU_SYS_STACK_PUSH,
#ifdef CEU_ORGS
    CEU_SYS_STACK_CLEAR_ORG,
#endif
    CEU_SYS_ORG,
#ifdef CEU_ORGS
    CEU_SYS_ORG_TRAIL,
    CEU_SYS_ORG_SPAWN,
#endif
    CEU_SYS_START,
    CEU_SYS_LINK,
    CEU_SYS_UNLINK,
    CEU_SYS_EMIT,
    CEU_SYS_CALL,
#ifdef CEU_WCLOCKS
    CEU_SYS_WCLOCK,
#endif
    CEU_SYS_GO,
    CEU_SYS_MAX
};

/* SYS_VECTOR
 */
extern void* CEU_SYS_VEC[CEU_SYS_MAX];

#endif  /* CEU_OS */

#endif  /* _CEU_OS_H */


#ifdef CEU_NEWS_POOL
#ifndef _CEU_POOL_H
#define _CEU_POOL_H

#include "ceu_types.h"

/* TODO: all "int" here, should evaluate the correct unsigned type */

typedef struct {
    byte**  queue;
                    /* queue is in the next offset to distinguish dynamic(NULL)
                       from static pools(any-address) */
    int     size;
    int     free;
    int     index;
    int     unit;
    byte*   mem;
} tceu_pool;

#define CEU_POOL_DCL(name, type, size) \
    type*     name##_queue[size];      \
    type      name##_mem[size];        \
    tceu_pool name;

void ceu_pool_init (tceu_pool* pool, int size, int unit, byte** queue, byte* mem);
byte* ceu_pool_alloc (tceu_pool* pool);
void ceu_pool_free (tceu_pool* pool, byte* val);

#endif

#endif

#ifdef CEU_VECTOR
#ifndef _CEU_VECTOR_H
#define _CEU_VECTOR_H

#ifndef _CEU_OS_H
#define _CEU_OS_H

#include <stddef.h>
#include "ceu_types.h"

#ifdef CEU_DEBUG
#include <assert.h>
#endif

#if defined(CEU_OS) && defined(__AVR)
#error Understand this again!
#include "Arduino.h"
#define CEU_ISR
#define CEU_ISR_ON()  interrupts()
#define CEU_ISR_OFF() noInterrupts()
#else
#define CEU_ISR_ON()
#define CEU_ISR_OFF()
#endif

#if defined(CEU_OS_KERNEL) || defined(CEU_OS_APP)
#define CEU_OS
#endif

#if defined(CEU_ORGS_NEWS) || defined(CEU_ADTS_NEWS)
#define CEU_NEWS
#endif
#if defined(CEU_ORGS_NEWS_POOL) || defined(CEU_ADTS_NEWS_POOL)
#define CEU_NEWS_POOL
#endif
#if defined(CEU_ORGS_AWAIT) || defined(CEU_ADTS_AWAIT)
#define CEU_ORGS_OR_ADTS_AWAIT
#endif

#ifdef CEU_OS

    /* TODO: all should be configurable */
    #define CEU_EXTS
    #define CEU_WCLOCKS
    #define CEU_ASYNCS
    #define CEU_RET
    #define CEU_CLEAR
    #define CEU_STACK_CLEAR
#ifndef __AVR
#endif
    #define CEU_INTS
    #define CEU_ORGS
    /*#define CEU_PSES*/ /* TODO: never tried */
    #define CEU_NEWS
    #define CEU_NEWS_POOL
    #define CEU_ORGS_NEWS
    #define CEU_ORGS_NEWS_MALLOC
    #define CEU_ORGS_NEWS_POOL
    #define CEU_ADTS_NEWS
    #define CEU_ADTS_NEWS_MALLOC
    #define CEU_ADTS_NEWS_POOL
    #define CEU_ORGS_AWAIT
    #define CEU_ADTS_AWAIT
    #define CEU_ORGS_OR_ADTS_AWAIT
/*
    #define CEU_THREADS
*/

#ifdef __AVR
    #define CEU_QUEUE_MAX 256
#else
    #define CEU_QUEUE_MAX 65536
#endif

    #define CEU_IN__NONE          0
    #define CEU_IN__ORG         255
    #define CEU_IN__ORG_PSED    254
    #define CEU_IN__CLEAR       253
    #define CEU_IN__ok_killed   252
    #define CEU_IN__INIT        251     /* HIGHER EXTERNAL */
    #define CEU_IN__ASYNC       250
    #define CEU_IN__THREAD      249
    #define CEU_IN__WCLOCK      248
    #define CEU_IN_OS_START     247
    #define CEU_IN_OS_STOP      246
    #define CEU_IN_OS_DT        245
    #define CEU_IN_OS_INTERRUPT 244
#ifdef CEU_TIMEMACHINE
    #define CEU_IN__WCLOCK_     243
    #define CEU_IN              243
#else
    #define CEU_IN              242
#endif

    #define CEU_IN_higher       CEU_IN__INIT  /* _INIT = HIGHER EXTERNAL */
    #define CEU_IN_lower        128     /* TODO: not checked from up and down */

    typedef s8 tceu_nlbl;   /* TODO: to small!! */

#endif /* CEU_OS */

#ifdef CEU_OS_APP

    #define ceu_out_log(mode,str) \
        ((__typeof__(ceu_sys_log)*)((_ceu_app)->sys_vec[CEU_SYS_LOG]))(mode,str)

    #define ceu_out_assert(v) \
        ((__typeof__(ceu_sys_assert)*)((_ceu_app)->sys_vec[CEU_SYS_ASSERT]))(v)

    #define ceu_out_assert_msg_ex(v,msg,file,line)       \
        {                                                \
            int __ceu_v = v;                             \
            if ((!(__ceu_v)) && ((msg)!=NULL)) {         \
                ceu_out_log(0, (long)"[");               \
                ceu_out_log(0, (long)(file));            \
                ceu_out_log(0, (long)":");               \
                ceu_out_log(2, (line));                  \
                ceu_out_log(0, (long)"] ");              \
                ceu_out_log(0, (long)"runtime error: "); \
                ceu_out_log(0, (long)(msg));             \
                ceu_out_log(0, (long)"\n");              \
            }                                            \
            ((__typeof__(ceu_sys_assert)*)((_ceu_app)->sys_vec[CEU_SYS_ASSERT]))(__ceu_v); \
        }
    #define ceu_out_assert_msg(v,msg) ceu_out_assert_msg_ex((v),(msg),__FILE__,__LINE__)

    #define ceu_out_realloc(ptr, size) \
        ((__typeof__(ceu_sys_realloc)*)((_ceu_app)->sys_vec[CEU_SYS_REALLOC]))(ptr,size)

    #define ceu_out_req() \
        ((__typeof__(ceu_sys_req)*)((_ceu_app)->sys_vec[CEU_SYS_REQ]))()

    #define ceu_out_load(addr) \
        ((__typeof__(ceu_sys_load)*)((_ceu_app)->sys_vec[CEU_SYS_LOAD]))(addr)

#ifdef CEU_ISR
    #define ceu_out_isr(n,f) \
        ((__typeof__(ceu_sys_isr)*)((_ceu_app)->sys_vec[CEU_SYS_ISR]))(n,f,_ceu_app)
#endif

    #define ceu_out_org_init(app,org,n,lbl,cls,isDyn,parent_org,parent_trl) \
        ((__typeof__(ceu_sys_org_init)*)((app)->sys_vec[CEU_SYS_ORG]))(org,n,lbl,cls,isDyn,parent_org,parent_trl)
    #define ceu_out_start(app) \
        ((__typeof__(ceu_sys_start)*)((_ceu_app)->sys_vec[CEU_SYS_START]))(app)
    #define ceu_out_link(app1,evt1 , app2,evt2) \
        ((__typeof__(ceu_sys_link)*)((_ceu_app)->sys_vec[CEU_SYS_LINK]))(app1,evt1,app2,evt2)

    #define ceu_out_emit(app,id,sz,buf) \
        ((__typeof__(ceu_sys_emit)*)((app)->sys_vec[CEU_SYS_EMIT]))(app,id,sz,buf)

    #define ceu_out_call(app,id,param) \
        ((__typeof__(ceu_sys_call)*)((app)->sys_vec[CEU_SYS_CALL]))(app,id,param)

#ifdef CEU_WCLOCKS
    #define ceu_out_wclock(app,dt,set,get) \
        ((__typeof__(ceu_sys_wclock)*)((app)->sys_vec[CEU_SYS_WCLOCK]))(app,dt,set,get)
#ifdef CEU_TIMEMACHINE
    #error TIMEMACHINE
#endif
#endif

    #define ceu_out_go(app,evt,evtp) \
        ((__typeof__(ceu_sys_go)*)((app)->sys_vec[CEU_SYS_GO]))(app,evt,evtp)

#else /* ! CEU_OS_APP (!CEU_OS||CEU_OS_KERNEL) */

    #ifndef ceu_out_assert
        #error "Missing definition for macro \"ceu_out_assert\"."
    #endif

    #ifndef ceu_out_log
        #error "Missing definition for macro \"ceu_out_log\"."
    #endif

    #define ceu_out_assert_msg_ex(v,msg,file,line)          \
        {                                                   \
            int __ceu_v = v;                                \
            if ((!(__ceu_v)) && ((msg)!=NULL)) {            \
                ceu_out_log(0, (long)"[");                  \
                ceu_out_log(0, (long)(file));               \
                ceu_out_log(0, (long)":");                  \
                ceu_out_log(2, line);                       \
                ceu_out_log(0, (long)"] ");                 \
                ceu_out_log(0, (long)"runtime error: ");    \
                ceu_out_log(0, (long)(msg));                \
                ceu_out_log(0, (long)"\n");                 \
            }                                               \
            ceu_out_assert(__ceu_v);                        \
        }
    #define ceu_out_assert_msg(v,msg) ceu_out_assert_msg_ex((v),(msg),__FILE__,__LINE__)

    #define ceu_out_realloc(ptr,size) \
            ceu_sys_realloc(ptr,size)
    #define ceu_out_req() \
            ceu_sys_req()
    #define ceu_out_org_init(app,org,n,lbl,cls,isDyn,parent_org,parent_trl) \
            ceu_sys_org_init(org,n,lbl,cls,isDyn,parent_org,parent_trl)

#ifdef CEU_WCLOCKS
    #define ceu_out_wclock(app,dt,set,get) \
            ceu_sys_wclock(app,dt,set,get)
#ifdef CEU_TIMEMACHINE
    #define ceu_out_wclock_(app,dt,set,get) \
            ceu_sys_wclock_(app,dt,set,get)
#endif
#endif
    #define ceu_out_go(app,evt,evtp) \
            ceu_sys_go(app,evt,evtp)
    #define ceu_out_go_stk(app,evt,evtp,stk) \
            ceu_sys_go_stk(app,evt,evtp,stk)

#endif /* ! CEU_OS_APP (!CEU_OS||CEU_OS_KERNEL) */

#ifdef CEU_STACK_CLEAR
#define ceu_in_emit(app,id,n,buf) \
    ceu_out_go_stk(app,id,buf,&stk_)
#else
#define ceu_in_emit(app,id,n,buf) \
    ceu_out_go_stk(app,id,buf,NULL)
#endif

#ifdef CEU_THREADS
/* TODO: app */
#include "ceu_threads.h"
#endif

#ifdef CEU_LUA
#include <stdio.h>      /* BUFSIZ */
#include <string.h>     /* strcpy */
#if defined(__ANDROID__) || defined(CEU_OS)
    #include "lua.h"
    #include "lauxlib.h"
    #include "lualib.h"
#else
    #include <lua5.1/lua.h>
    #include <lua5.1/lauxlib.h>
    #include <lua5.1/lualib.h>
#endif

#ifdef CEU_OS_APP
    #define ceu_luaL_newstate(set) { \
        set = ceu_out_call(_ceu_app, CEU_OUT_LUA_NEW, NULL); \
    }

    #define ceu_luaL_openlibs(l) { \
        lua_State* p = l;          \
        ceu_out_call(_ceu_app, CEU_OUT_LUAL_OPENLIBS, &p); \
    }

    #define ceu_lua_atpanic(l, f) {     \
    }

    #define ceu_luaL_loadstring(set, l, str) {  \
        tceu__lua_State___char_ p = { l, str }; \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUAL_LOADSTRING, &p); \
    }

    #define ceu_lua_pushnumber(l, v) {      \
        tceu__lua_State___int p = { l, v }; \
        ceu_out_call(_ceu_app, CEU_OUT_LUA_PUSHNUMBER, &p); \
    }

    #define ceu_lua_pushstring(l, v) {      \
        tceu__lua_State___char_ p = { l, v }; \
        ceu_out_call(_ceu_app, CEU_OUT_LUA_PUSHSTRING, &p); \
    }

    #define ceu_lua_pushlightuserdata(l, v) {   \
        tceu__lua_State___void_ p = { l, v };     \
        ceu_out_call(_ceu_app, CEU_OUT_LUA_PUSHLIGHTUSERDATA, &p); \
    }

    #define ceu_lua_pcall(set,l,nargs,nrets,err) {                  \
        tceu__lua_State___int__int__int p = { l, nargs, nrets, err }; \
        ceu_out_call(_ceu_app, CEU_OUT_LUA_PCALL, &p); \
    }

    #define ceu_lua_isnumber(set, l, idx) {     \
        tceu__lua_State___int p = { l, idx };   \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUA_ISNUMBER, &p); \
    }

    #define ceu_lua_tonumber(set, l, idx) {     \
        tceu__lua_State___int p = { l, idx };   \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUA_TONUMBER, &p); \
    }

    #define ceu_lua_isboolean(set, l, idx) {    \
        tceu__lua_State___int p = { l, idx };   \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUA_ISBOOLEAN, &p); \
    }

    #define ceu_lua_toboolean(set, l, idx) {    \
        tceu__lua_State___int p = { l, idx };   \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUA_TOBOOLEAN, &p); \
    }

    #define ceu_lua_pop(l, n) {             \
        tceu__lua_State___int p = { l, n }; \
        ceu_out_call(_ceu_app, CEU_OUT_LUA_POP, &p); \
    }

    #define ceu_lua_isstring(set, l, idx) {     \
        tceu__lua_State___int p = { l, idx };   \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUA_ISSTRING, &p); \
    }

    #define ceu_lua_tostring(set, l, idx) {     \
        tceu__lua_State___int p = { l, idx };   \
        set = ceu_out_call(_ceu_app, CEU_OUT_LUA_TOSTRING, &p); \
    }

    #define ceu_lua_islightuserdata(set, l, idx) {  \
        tceu__lua_State___int p = { l, idx };       \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUA_ISLIGHTUSERDATA, &p); \
    }

    #define ceu_lua_touserdata(set, l, idx) {   \
        tceu__lua_State___int p = { l, idx };   \
        set = ceu_out_call(_ceu_app, CEU_OUT_LUA_TOUSERDATA, &p); \
    }

    #define ceu_lua_error(l) {                          \
        lua_State** p = &l;                             \
        ceu_out_call(_ceu_app, CEU_OUT_LUA_ERROR, &p);  \
    }

    #define ceu_lua_objlen(set, l, idx) {                       \
        tceu__lua_State___int p = { l, idx };                   \
        set = ceu_out_call(_ceu_app, CEU_OUT_LUA_OBJLEN, &p);   \
    }

#else
    #define ceu_luaL_newstate(set)               set = luaL_newstate()
    #define ceu_luaL_openlibs(l)                 luaL_openlibs(l)
    #define ceu_lua_atpanic(l,f)                 lua_atpanic(l,f)
    #define ceu_luaL_loadstring(set,l,str)       set = luaL_loadstring(l,str)
    #define ceu_lua_pushnumber(l,v)              lua_pushnumber(l,v)
    #define ceu_lua_pushstring(l,v)              lua_pushstring(l,v)
    #define ceu_lua_pushlightuserdata(l,v)       lua_pushlightuserdata(l,v)
    #define ceu_lua_pcall(set,l,nargs,nrets,err) set = lua_pcall(l,nargs,nrets,err)
    #define ceu_lua_isnumber(set,l,idx)          set = lua_isnumber(l,idx)
    #define ceu_lua_tonumber(set,l,idx)          set = lua_tonumber(l,idx)
    #define ceu_lua_isboolean(set,l,idx)         set = lua_isboolean(l,idx)
    #define ceu_lua_toboolean(set,l,idx)         set = lua_toboolean(l,idx)
    #define ceu_lua_pop(l,n)                     lua_pop(l,n)
    #define ceu_lua_isstring(set,l,idx)          set = lua_isstring(l,idx)
    #define ceu_lua_tostring(set,l,idx)          set = lua_tostring(l,idx)
    #define ceu_lua_islightuserdata(set,l,idx)   set = lua_islightuserdata(l,idx)
    #define ceu_lua_touserdata(set,l,idx)        set = lua_touserdata(l,idx)
    #define ceu_lua_error(l)                     lua_error(l)
    #define ceu_lua_objlen(set,l,idx)            set = lua_objlen(l,idx)
#endif
#endif

typedef u8 tceu_nevt;   /* max number of events */
                        /* TODO: should "u8" be fixed? */

typedef u8 tceu_ntrl;   /* max number of trails per class */
                        /* TODO: should "u8" be fixed? */

#ifdef CEU_STACK_CLEAR
typedef u16 tceu_nstk;  /* max size of internal stack in bytes */
                        /* TODO: should "u16" be fixed? */
#endif

#ifdef __cplusplus
#define CEU_WCLOCK_INACTIVE 0x7fffffffL     /* TODO */
#else
#define CEU_WCLOCK_INACTIVE INT32_MAX
#endif
#define CEU_WCLOCK_EXPIRED (CEU_WCLOCK_INACTIVE-1)

/* TCEU_TRL */

struct tceu_org;
typedef union tceu_trl {
    tceu_nevt evt;

    /* normal await // IN__CLEAR */
    struct {                    /* TODO(ram): bitfields */
        tceu_nevt evt1;
        tceu_nlbl lbl;
        u8        seqno;        /* TODO(ram): 2 bits is enough */
#ifdef CEU_INTS                 /* R-9: size of trails for internal events */
#ifdef CEU_ORGS
        void*     evto;
#endif
#endif
    };

    /* IN__ORG */
#ifdef CEU_ORGS
    struct {                    /* TODO(ram): bad for alignment */
        tceu_nevt evt3;
        struct tceu_org* org;
    };
#endif

    /* _ok_killed */
#ifdef CEU_ORGS_OR_ADTS_AWAIT
    struct {
        tceu_nevt evt4;
        tceu_nlbl lbl4;
#ifdef CEU_ORGS_AWAIT
#ifdef CEU_ADTS_AWAIT
        u8        is_org;
#endif
#endif
        void*     org_or_adt;
    };
#endif
} tceu_trl;

/* TCEU_EVT */

typedef struct tceu_evt {
    tceu_nevt id;
    void*     param;
#if defined(CEU_ORGS) && defined(CEU_INTS)
    void*     org;      /* emitting org */
#endif
} tceu_evt;

/* TCEU_ORG */

struct tceu_pool_orgs;
typedef struct tceu_org
{
#ifdef CEU_ORGS
    struct tceu_org* nxt; /* first field because of free list for orgs/adts */
    struct tceu_org* prv;
    struct tceu_org* parent_org;
    tceu_ntrl parent_trl;
#endif

#if defined(CEU_ORGS) || defined(CEU_OS)
    tceu_ntrl n;            /* number of trails (TODO(ram): opt, metadata) */
#endif

#ifdef CEU_ORGS

#ifdef CEU_IFCS
    tceu_ncls cls;          /* class id */
#endif
    u8 isAlive: 1;          /* Three purposes:
                             * - avoids double free
                             * - required by "watching o" to avoid awaiting a
                             *      dead org
                             * - required by "Do T" to avoid awaiting a dead 
                             *      org
                             */
#if defined(CEU_ORGS_NEWS) || defined(CEU_ORGS_AWAIT)
#endif
#ifdef CEU_ORGS_NEWS
    u8 isDyn: 1;            /* created w/ new or spawn? */
#endif
#ifdef CEU_ORGS_NEWS_POOL
    struct tceu_pool_orgs* pool;
#endif

#ifdef CEU_ORGS_AWAIT
    int ret;
#endif

#endif  /* CEU_ORGS */

    tceu_trl trls[0];       /* first trail */

} tceu_org;

/* TCEU_POOL_ORGS , TCEU_POOL_ADTS */

#if defined(CEU_ORGS_NEWS_POOL) || defined(CEU_ADTS_NEWS_POOL)
#include "ceu_pool.h"
#endif

#ifdef CEU_ORGS_NEWS
typedef struct tceu_pool_orgs {
    tceu_org* parent_org;
    tceu_ntrl parent_trl;
#ifdef CEU_ORGS_NEWS_POOL
    tceu_pool pool;
#endif
} tceu_pool_orgs;
#endif

#ifdef CEU_ADTS_NEWS
typedef struct {
    void* root;
#ifdef CEU_ADTS_NEWS_POOL
    void* pool;
#endif
} tceu_pool_adts;
#endif

/* TCEU_KILL */

#ifdef CEU_ORGS_OR_ADTS_AWAIT
typedef struct tceu_kill {
    void*     org_or_adt;
    int       ret;
    tceu_ntrl t1;
    tceu_ntrl t2;
} tceu_kill;
#endif

/* TCEU_LST */

#ifdef CEU_DEBUG
typedef struct tceu_lst {
#ifdef CEU_ORGS
    void*     org;
#endif
    tceu_trl* trl;
    tceu_nlbl lbl;
} tceu_lst;

#endif

/* TCEU_STK */

#ifdef CEU_STACK_CLEAR
typedef struct tceu_stk {
    struct tceu_stk* down;
    tceu_org*   org;
    tceu_ntrl   trl1;
    tceu_ntrl   trl2;
    char        is_alive;
} tceu_stk;
#else
typedef void tceu_stk;
#endif

/* TCEU_APP */

typedef struct tceu_app {
    /* global seqno: incremented on every reaction
     * awaiting trails matches only if trl->seqno < seqno,
     * i.e., previously awaiting the event
     */
    u8 seqno:          2;
#if defined(CEU_RET) || defined(CEU_OS)
    u8 isAlive:        1;
#endif
#ifdef CEU_ASYNCS
    u8 pendingAsyncs:  1;
#endif
#if defined(CEU_ORGS_NEWS_MALLOC) && defined(CEU_ORGS_AWAIT)
    u8 dont_emit_kill: 1;
#endif

#ifdef CEU_OS
    struct tceu_app* nxt;
#endif

#if defined(CEU_RET) || defined(CEU_ORGS_AWAIT)
    int ret;
#endif

#ifdef CEU_ORGS_NEWS_MALLOC
    tceu_org* tofree;
#endif

#ifdef CEU_WCLOCKS
    s32         wclk_late;
    s32         wclk_min_set;   /* used to set */
    s32         wclk_min_cmp;   /* used to compare */
                                /* cmp<-set every reaction */
#ifdef CEU_TIMEMACHINE
    s32         wclk_late_;
    s32         wclk_min_set_;
    s32         wclk_min_cmp_;
#endif
#endif

#ifndef CEU_OS
#ifdef CEU_DEBUG
    tceu_lst    lst; /* segfault printf */
#endif
#endif

#ifdef CEU_THREADS
    CEU_THREADS_MUTEX_T threads_mutex;
    /*CEU_THREADS_COND_T  threads_cond;*/
    u8                  threads_n;          /* number of running threads */
        /* TODO: u8? */
#endif
#if defined(CEU_LUA) || defined(CEU_OS)
#ifdef CEU_LUA
    lua_State*  lua;    /* TODO: move to data? */
#else
    void*       lua;
#endif
#endif

    void        (*code)  (struct tceu_app*,tceu_evt*,tceu_org*,tceu_trl*,tceu_stk*);
    void        (*init)  (struct tceu_app*);
#ifdef CEU_OS
    void*       (*calls) (struct tceu_app*,tceu_nevt,void*);
    void**      sys_vec;
    void*       addr;
#ifdef CEU_OS_LUAIFC
    char*       luaifc;
#endif
#endif
    tceu_org*   data;
} tceu_app;

#ifdef CEU_OS
typedef void (*tceu_init)   (tceu_app* app);
typedef void (*tceu_export) (uint* size, tceu_init** init
#ifdef CEU_OS_LUAIFC
                            , char** luaifc
#endif
);
#endif

/* TCEU_THREADS_P */

#ifdef CEU_THREADS
typedef struct {
    tceu_app* app;
    tceu_org* org;
    s8*       st; /* thread state:
                   * 0=ini (sync  spawns)
                   * 1=cpy (async copies)
                   * 2=lck (sync  locks)
                   * 3=end (sync/async terminates)
                   */
} tceu_threads_p;
#endif

#ifdef CEU_PSES
void ceu_pause (tceu_trl* trl, tceu_trl* trlF, int psed);
#endif

int  ceu_go_all    (tceu_app* app);

#ifdef CEU_WCLOCKS
int       ceu_sys_wclock (tceu_app* app, s32 dt, s32* set, s32* get);
#endif
void      ceu_sys_go     (tceu_app* app, int evt, void* evtp);

#ifdef CEU_OS

/* TCEU_LINK */

typedef struct tceu_lnk {
    tceu_app* src_app;
    tceu_nevt src_evt;
    tceu_app* dst_app;
    tceu_nevt dst_evt;
    struct tceu_lnk* nxt;
} tceu_lnk;

/* TCEU_QUEUE */

typedef struct {
    tceu_app* app;
    tceu_nevt evt;
#if CEU_QUEUE_MAX == 256
    s8        sz;
#else
    s16       sz;   /* signed because of fill */
#endif
    byte      buf[0];
} tceu_queue;

#ifdef CEU_ISR
typedef void(*tceu_isr_f)(tceu_app* app, tceu_org* org);
#endif

void ceu_os_init      (void);
int  ceu_os_scheduler (int(*dt)());
tceu_queue* ceu_sys_queue_nxt (void);
void        ceu_sys_queue_rem (void);

void      ceu_sys_assert    (int v);
void      ceu_sys_log       (int mode, long str);
void*     ceu_sys_realloc   (void* ptr, size_t size);
int       ceu_sys_req       (void);
tceu_app* ceu_sys_load      (void* addr);
#ifdef CEU_ISR
int       ceu_sys_isr       (int n, tceu_isr_f f, tceu_app* app);
#endif
void      ceu_sys_org_init  (tceu_org* org, int n, int lbl, int cls, int isDyn,
                             tceu_org* parent_org, tceu_ntrl parent_trl);
void      ceu_sys_start     (tceu_app* app);
int       ceu_sys_link      (tceu_app* src_app, tceu_nevt src_evt, tceu_app* dst_app, tceu_nevt dst_evt);
int       ceu_sys_unlink    (tceu_app* src_app, tceu_nevt src_evt, tceu_app* dst_app, tceu_nevt dst_evt);
int       ceu_sys_emit      (tceu_app* app, tceu_nevt evt, int sz, void* param);
void*     ceu_sys_call      (tceu_app* app, tceu_nevt evt, void* param);

enum {
    CEU_SYS_ASSERT = 0,
    CEU_SYS_LOG,
    CEU_SYS_REALLOC,
    CEU_SYS_REQ,
    CEU_SYS_LOAD,
#ifdef CEU_ISR
    CEU_SYS_ISR,
#endif
#ifdef CEU_CLEAR
    CEU_SYS_CLEAR,
#endif
    CEU_SYS_STACK_PUSH,
#ifdef CEU_ORGS
    CEU_SYS_STACK_CLEAR_ORG,
#endif
    CEU_SYS_ORG,
#ifdef CEU_ORGS
    CEU_SYS_ORG_TRAIL,
    CEU_SYS_ORG_SPAWN,
#endif
    CEU_SYS_START,
    CEU_SYS_LINK,
    CEU_SYS_UNLINK,
    CEU_SYS_EMIT,
    CEU_SYS_CALL,
#ifdef CEU_WCLOCKS
    CEU_SYS_WCLOCK,
#endif
    CEU_SYS_GO,
    CEU_SYS_MAX
};

/* SYS_VECTOR
 */
extern void* CEU_SYS_VEC[CEU_SYS_MAX];

#endif  /* CEU_OS */

#endif  /* _CEU_OS_H */


typedef struct {
    int   max;
    int   nxt;
    int   unit;
    byte* mem;
} tceu_vector;

#define CEU_VECTOR_DCL(name, type, max)  \
    type        name##_mem[max+1];       \
    tceu_vector name;
                /* [STRING] max+1: extra space for '\0' */

#define ceu_vector_getlen(vec) ((vec)->nxt)
#define ceu_vector_getmax(vec) ((vec)->max > 0 ? (vec)->max : 0)

void  ceu_vector_init   (tceu_vector* vector, int max, int unit, byte* mem);
int   ceu_vector_setlen (tceu_vector* vector, int len);
byte* ceu_vector_geti   (tceu_vector* vector, int idx);
int   ceu_vector_seti   (tceu_vector* vector, int idx, byte* v);
int   ceu_vector_push   (tceu_vector* vector, byte* v);
int   ceu_vector_concat (tceu_vector* to, tceu_vector* fr);
int   ceu_vector_concat_buffer (tceu_vector* to, const char* fr, int n);
char* ceu_vector_tochar (tceu_vector* vector);

#if 0
byte* ceu_pool_alloc (tceu_pool* pool);
void ceu_pool_free (tceu_pool* pool, byte* val);
#endif
#endif

#endif


#define CEU_IN__NONE 0
#define CEU_IN__ORG 255
#define CEU_IN__ORG_PSED 254
#define CEU_IN__CLEAR 253
#define CEU_IN__ok_killed 252
#define CEU_IN__INIT 251
#define CEU_IN__ASYNC 250
#define CEU_IN__THREAD 249
#define CEU_IN__WCLOCK 248
#define CEU_IN_KEY_DOWN 247
#define CEU_IN_KEY_UP 246
#define CEU_IN_UPDATE 245
#define CEU_IN_MOUSE_DOWN 244
#define CEU_IN_MOUSE_UP 243
#define CEU_IN_MOUSE_OVER 242
#define CEU_IN_MOUSE_OUT 241
#define CEU_IN_MOUSE_MOVE 240
#define CEU_OUT_NEW_SPRITE 1
#define CEU_OUT_FREE_SPRITE 2
#define CEU_OUT_SET_SPRITE_POSITION 3
#define CEU_OUT_SET_SPRITE_TINT 4
#define CEU_OUT_SET_SPRITE_ROTATION 5
#define CEU_OUT_SET_COUNT 6
#define CEU_OUT_SET_MUTED 7
#define CEU_OUT_PRINT_DEBUG 8
#define CEU_IN_higher CEU_IN__INIT
#define CEU_IN_lower 240
#define CEU_OUT_n 8
      /* CEU_IN_, CEU_OUT_ */
#define CEU_FUN_sqrt
#define CEU_FUN_printf
#define CEU_FUN_d
   /* CEU_FUN_ */
typedef struct {
	int _1;
	int _2;
} tceu__int__int;
typedef struct {
	charptr _1;
} tceu__charptr;
typedef struct {
	int _1;
	float _2;
} tceu__int__float;
typedef struct {
	int _1;
} tceu__int;
typedef struct {
	int _1;
	int _2;
	int _3;
	int _4;
} tceu__int__int__int__int;
typedef struct {
	int _1;
	int _2;
	int _3;
	int _4;
	int _5;
} tceu__int__int__int__int__int;
typedef struct {
	bool _1;
} tceu__bool;
typedef struct {
	s32 _1;
} tceu__s32;


/* class/adts definitions */
/* may use types defined above in "NATIVE" */
/* each class may define new native code that appear after its struct declaration */

typedef struct CEU_Delay {
#ifdef CEU_ORGS
  struct tceu_org org;
#endif
  tceu_trl trls_[ 2 ];
                            struct { /* BLOCK ln=49 */
                              int ticks;
                              union {
                                  union {
                                  };
                                struct { /* BLOCK ln=49 */
                                  union {
                                    struct { /* BLOCK ln=53 */
                                      int ticker;
                                      union {
                                        union {
                                        };
                                        struct { /* BLOCK ln=54 */
                                          union {
                                            union {
                                            };
                                              struct { /* BLOCK ln=55 */
                                                union {
                                                  union {
                                                  };
                                                    struct { /* BLOCK ln=57 */
                                                      union {
                                                      };
                                                    } ;
                                                    struct { /* BLOCK ln=59 */
                                                      union {
                                                      };
                                                    } ;
                                                };
                                              } ;
                                          };
                                        } ;
                                      };
                                    } ;
                                  };
                                } ;
                              };
                            } ;

} CEU_Delay;





typedef struct CEU_Garden {
#ifdef CEU_ORGS
  struct tceu_org org;
#endif
  tceu_trl trls_[ 3 ];
                            struct { /* BLOCK ln=65 */
                              float score;
                              int t0_plants;
                              int t1_plants;
                              int t2_plants;
                              int t3_plants;
                              union {
                                  union {
                                  };
                                struct { /* BLOCK ln=65 */
                                  union {
                                    struct { /* BLOCK ln=75 */
                                      union {
                                        struct { /* BLOCK ln=75 */
                                          union {
                                            union {
                                            };
                                              struct { /* BLOCK ln=76 */
                                                union {
                                                    struct { /* BLOCK ln=76 */
                                                      struct CEU_Delay _org_156_11;
                                                      union {
                                                            struct { /* BLOCK ln=77 */
                                                              union {
                                                              };
                                                            } ;
                                                        union {
                                                          union {
                                                              struct { /* BLOCK ln=76 */
                                                                union {
                                                                };
                                                              } ;
                                                              struct { /* BLOCK ln=76 */
                                                                union {
                                                                };
                                                              } ;
                                                          };
                                                        };
                                                      };
                                                    } ;
                                                };
                                              } ;
                                          };
                                        } ;
                                      };
                                    } ;
                                  };
                                } ;
                              };
                            } ;

} CEU_Garden;





typedef struct CEU_Konami {
#ifdef CEU_ORGS
  struct tceu_org org;
#endif
  tceu_trl trls_[ 2 ];
                            struct { /* BLOCK ln=83 */
                              union {
                                  union {
                                  };
                                struct { /* BLOCK ln=83 */
                                  union {
                                    struct { /* BLOCK ln=86 */
                                      union {
                                        struct { /* BLOCK ln=86 */
                                          union {
                                            union {
                                            };
                                              struct { /* BLOCK ln=87 */
                                                union {
                                                  union {
                                                    union {
                                                    };
                                                  };
                                                    struct { /* BLOCK ln=88 */
                                                      union {
                                                      };
                                                    } ;
                                                    struct { /* BLOCK ln=86 */
                                                      union {
                                                        union {
                                                        };
                                                          struct { /* BLOCK ln=90 */
                                                            union {
                                                            };
                                                          } ;
                                                          struct { /* BLOCK ln=86 */
                                                            union {
                                                              union {
                                                              };
                                                                struct { /* BLOCK ln=92 */
                                                                  union {
                                                                  };
                                                                } ;
                                                                struct { /* BLOCK ln=86 */
                                                                  union {
                                                                    union {
                                                                    };
                                                                      struct { /* BLOCK ln=94 */
                                                                        union {
                                                                        };
                                                                      } ;
                                                                      struct { /* BLOCK ln=86 */
                                                                        union {
                                                                          union {
                                                                          };
                                                                            struct { /* BLOCK ln=96 */
                                                                              union {
                                                                              };
                                                                            } ;
                                                                            struct { /* BLOCK ln=86 */
                                                                              union {
                                                                                union {
                                                                                };
                                                                                  struct { /* BLOCK ln=98 */
                                                                                    union {
                                                                                    };
                                                                                  } ;
                                                                                  struct { /* BLOCK ln=86 */
                                                                                    union {
                                                                                      union {
                                                                                      };
                                                                                        struct { /* BLOCK ln=100 */
                                                                                          union {
                                                                                          };
                                                                                        } ;
                                                                                        struct { /* BLOCK ln=86 */
                                                                                          union {
                                                                                            union {
                                                                                            };
                                                                                              struct { /* BLOCK ln=102 */
                                                                                                union {
                                                                                                };
                                                                                              } ;
                                                                                              struct { /* BLOCK ln=86 */
                                                                                                union {
                                                                                                  union {
                                                                                                  };
                                                                                                    struct { /* BLOCK ln=104 */
                                                                                                      union {
                                                                                                      };
                                                                                                    } ;
                                                                                                    struct { /* BLOCK ln=86 */
                                                                                                      union {
                                                                                                        union {
                                                                                                        };
                                                                                                          struct { /* BLOCK ln=106 */
                                                                                                            union {
                                                                                                            };
                                                                                                          } ;
                                                                                                          struct { /* BLOCK ln=86 */
                                                                                                            union {
                                                                                                            };
                                                                                                          } ;
                                                                                                      };
                                                                                                    } ;
                                                                                                };
                                                                                              } ;
                                                                                          };
                                                                                        } ;
                                                                                    };
                                                                                  } ;
                                                                              };
                                                                            } ;
                                                                        };
                                                                      } ;
                                                                  };
                                                                } ;
                                                            };
                                                          } ;
                                                      };
                                                    } ;
                                                };
                                              } ;
                                          };
                                        } ;
                                      };
                                    } ;
                                  };
                                } ;
                              };
                            } ;

} CEU_Konami;





typedef struct CEU_Growing {
#ifdef CEU_ORGS
  struct tceu_org org;
#endif
  tceu_trl trls_[ 7 ];
                            struct { /* BLOCK ln=118 */
                              int* gensym;
                              int x;
                              int y;
                              int layer;
                              union {
                                  union {
                                  };
                                struct { /* BLOCK ln=118 */
                                  union {
                                    struct { /* BLOCK ln=126 */
                                    u8 __fin_519_1: 1;
                                      int id;
                                      int water;
                                      union {
                                        union {
                                        };
                                            struct { /* BLOCK ln=130 */
                                              union {
                                              };
                                            } ;
                                        union {
                                        };
                                          struct { /* BLOCK ln=134 */
                                            union {
                                            };
                                          } ;
                                            struct { /* BLOCK ln=136 */
                                              union {
                                              };
                                            } ;
                                            struct { /* BLOCK ln=138 */
                                              union {
                                              };
                                            } ;
                                        struct {
                                          struct { /* BLOCK ln=141 */
                                            union {
                                                struct { /* BLOCK ln=141 */
                                                  struct CEU_Delay _org_386_11;
                                                  union {
                                                        struct { /* BLOCK ln=142 */
                                                          union {
                                                          };
                                                        } ;
                                                    union {
                                                      union {
                                                          struct { /* BLOCK ln=141 */
                                                            union {
                                                            };
                                                          } ;
                                                          struct { /* BLOCK ln=141 */
                                                            union {
                                                            };
                                                          } ;
                                                      };
                                                    };
                                                  };
                                                } ;
                                            };
                                          } ;
                                          struct { /* BLOCK ln=145 */
                                            union {
                                              struct { /* BLOCK ln=145 */
                                                union {
                                                  union {
                                                  };
                                                    struct { /* BLOCK ln=146 */
                                                      union {
                                                          struct { /* BLOCK ln=146 */
                                                            struct CEU_Delay _org_411_12;
                                                            union {
                                                                  struct { /* BLOCK ln=147 */
                                                                    union {
                                                                    };
                                                                  } ;
                                                              union {
                                                                union {
                                                                    struct { /* BLOCK ln=146 */
                                                                      union {
                                                                      };
                                                                    } ;
                                                                    struct { /* BLOCK ln=146 */
                                                                      union {
                                                                      };
                                                                    } ;
                                                                };
                                                              };
                                                            };
                                                          } ;
                                                          struct { /* BLOCK ln=150 */
                                                            union {
                                                                struct { /* BLOCK ln=152 */
                                                                  union {
                                                                  };
                                                                } ;
                                                                  struct { /* BLOCK ln=154 */
                                                                    union {
                                                                    };
                                                                  } ;
                                                                  struct { /* BLOCK ln=156 */
                                                                    union {
                                                                    };
                                                                  } ;
                                                            };
                                                          } ;
                                                          struct { /* BLOCK ln=159 */
                                                            union {
                                                            };
                                                          } ;
                                                      };
                                                    } ;
                                                };
                                              } ;
                                            };
                                          } ;
                                          struct { /* BLOCK ln=163 */
                                            union {
                                              struct { /* BLOCK ln=163 */
                                                union {
                                                  union {
                                                  };
                                                    struct { /* BLOCK ln=164 */
                                                      union {
                                                        union {
                                                        };
                                                          struct { /* BLOCK ln=167 */
                                                            union {
                                                            };
                                                          } ;
                                                          struct { /* BLOCK ln=170 */
                                                            union {
                                                            };
                                                          } ;
                                                            struct { /* BLOCK ln=172 */
                                                              union {
                                                              };
                                                            } ;
                                                            struct { /* BLOCK ln=174 */
                                                              union {
                                                              };
                                                            } ;
                                                      };
                                                    } ;
                                                };
                                              } ;
                                            };
                                          } ;
                                        };
                                      };
                                    } ;
                                  };
                                } ;
                              };
                            } ;

} CEU_Growing;





typedef struct CEU_Philodendron {
#ifdef CEU_ORGS
  struct tceu_org org;
#endif
  tceu_trl trls_[ 6 ];
                            struct { /* BLOCK ln=188 */
                              int* gensym;
                              struct CEU_Garden* garden;
                              int plot;
                              union {
                                  union {
                                  };
                                struct { /* BLOCK ln=188 */
                                  union {
                                    struct { /* BLOCK ln=193 */
                                    u8 __fin_707_1: 1;
                                      int x;
                                      int y;
                                      int layer;
                                      union {
                                            struct { /* BLOCK ln=195 */
                                              union {
                                              };
                                            } ;
                                        union {
                                        };
                                        union {
                                        };
                                        union {
                                        };
                                        struct {
                                          struct { /* BLOCK ln=201 */
                                            union {
                                              struct { /* BLOCK ln=201 */
                                                union {
                                                  union {
                                                  };
                                                    struct { /* BLOCK ln=202 */
                                                      union {
                                                        union {
                                                          union {
                                                          };
                                                        };
                                                          struct { /* BLOCK ln=204 */
                                                            union {
                                                            };
                                                          } ;
                                                      };
                                                    } ;
                                                };
                                              } ;
                                            };
                                          } ;
                                          struct { /* BLOCK ln=209 */
                                            struct CEU_Growing growing_10;
                                            bool survived_11;
                                            union {
                                                  struct { /* BLOCK ln=210 */
                                                    union {
                                                    };
                                                  } ;
                                              union {
                                              };
                                              struct {
                                                struct { /* BLOCK ln=217 */
                                                  union {
                                                    struct { /* BLOCK ln=217 */
                                                      union {
                                                        union {
                                                        };
                                                          struct { /* BLOCK ln=218 */
                                                            union {
                                                              union {
                                                                union {
                                                                };
                                                              };
                                                                struct { /* BLOCK ln=220 */
                                                                  union {
                                                                  };
                                                                } ;
                                                            };
                                                          } ;
                                                      };
                                                    } ;
                                                  };
                                                } ;
                                                struct { /* BLOCK ln=225 */
                                                  union {
                                                    union {
                                                    };
                                                  };
                                                } ;
                                              };
                                                struct { /* BLOCK ln=228 */
                                                u8 __fin_701_1: 1;
                                                u8 __fin_701_2: 1;
                                                  int id_13;
                                                  union {
                                                        struct { /* BLOCK ln=231 */
                                                          union {
                                                          };
                                                        } ;
                                                    union {
                                                    };
                                                        struct { /* BLOCK ln=238 */
                                                          union {
                                                          };
                                                        } ;
                                                  };
                                                } ;
                                            };
                                          } ;
                                        };
                                      };
                                    } ;
                                  };
                                } ;
                              };
                            } ;

} CEU_Philodendron;





typedef struct CEU_Pitcher {
#ifdef CEU_ORGS
  struct tceu_org org;
#endif
  tceu_trl trls_[ 6 ];
                            struct { /* BLOCK ln=246 */
                              int* gensym;
                              struct CEU_Garden* garden;
                              int plot;
                              union {
                                  union {
                                  };
                                struct { /* BLOCK ln=246 */
                                  union {
                                    struct { /* BLOCK ln=251 */
                                    u8 __fin_888_1: 1;
                                      int x;
                                      int y;
                                      int layer;
                                      union {
                                            struct { /* BLOCK ln=253 */
                                              union {
                                              };
                                            } ;
                                        union {
                                        };
                                        union {
                                        };
                                        union {
                                        };
                                        struct {
                                          struct { /* BLOCK ln=259 */
                                            union {
                                              struct { /* BLOCK ln=259 */
                                                union {
                                                  union {
                                                  };
                                                    struct { /* BLOCK ln=260 */
                                                      union {
                                                        union {
                                                          union {
                                                          };
                                                        };
                                                          struct { /* BLOCK ln=262 */
                                                            union {
                                                            };
                                                          } ;
                                                      };
                                                    } ;
                                                };
                                              } ;
                                            };
                                          } ;
                                          struct { /* BLOCK ln=267 */
                                            struct CEU_Growing growing_10;
                                            bool survived_11;
                                            union {
                                                  struct { /* BLOCK ln=268 */
                                                    union {
                                                    };
                                                  } ;
                                              union {
                                              };
                                              struct {
                                                struct { /* BLOCK ln=275 */
                                                  union {
                                                    struct { /* BLOCK ln=275 */
                                                      union {
                                                        union {
                                                        };
                                                          struct { /* BLOCK ln=276 */
                                                            union {
                                                              union {
                                                                union {
                                                                };
                                                              };
                                                                struct { /* BLOCK ln=278 */
                                                                  union {
                                                                  };
                                                                } ;
                                                            };
                                                          } ;
                                                      };
                                                    } ;
                                                  };
                                                } ;
                                                struct { /* BLOCK ln=282 */
                                                  union {
                                                    union {
                                                    };
                                                  };
                                                } ;
                                              };
                                                struct { /* BLOCK ln=285 */
                                                u8 __fin_882_1: 1;
                                                u8 __fin_882_2: 1;
                                                  int id_13;
                                                  union {
                                                        struct { /* BLOCK ln=288 */
                                                          union {
                                                          };
                                                        } ;
                                                    union {
                                                    };
                                                        struct { /* BLOCK ln=295 */
                                                          union {
                                                          };
                                                        } ;
                                                  };
                                                } ;
                                            };
                                          } ;
                                        };
                                      };
                                    } ;
                                  };
                                } ;
                              };
                            } ;

} CEU_Pitcher;





typedef struct CEU_Orchid {
#ifdef CEU_ORGS
  struct tceu_org org;
#endif
  tceu_trl trls_[ 6 ];
                            struct { /* BLOCK ln=303 */
                              int* gensym;
                              struct CEU_Garden* garden;
                              int plot;
                              union {
                                  union {
                                  };
                                struct { /* BLOCK ln=303 */
                                  union {
                                    struct { /* BLOCK ln=308 */
                                    u8 __fin_1069_1: 1;
                                      int x;
                                      int y;
                                      int layer;
                                      union {
                                            struct { /* BLOCK ln=310 */
                                              union {
                                              };
                                            } ;
                                        union {
                                        };
                                        union {
                                        };
                                        union {
                                        };
                                        struct {
                                          struct { /* BLOCK ln=316 */
                                            union {
                                              struct { /* BLOCK ln=316 */
                                                union {
                                                  union {
                                                  };
                                                    struct { /* BLOCK ln=317 */
                                                      union {
                                                        union {
                                                          union {
                                                          };
                                                        };
                                                          struct { /* BLOCK ln=319 */
                                                            union {
                                                            };
                                                          } ;
                                                      };
                                                    } ;
                                                };
                                              } ;
                                            };
                                          } ;
                                          struct { /* BLOCK ln=324 */
                                            struct CEU_Growing growing_10;
                                            bool survived_11;
                                            union {
                                                  struct { /* BLOCK ln=325 */
                                                    union {
                                                    };
                                                  } ;
                                              union {
                                              };
                                              struct {
                                                struct { /* BLOCK ln=332 */
                                                  union {
                                                    struct { /* BLOCK ln=332 */
                                                      union {
                                                        union {
                                                        };
                                                          struct { /* BLOCK ln=333 */
                                                            union {
                                                              union {
                                                                union {
                                                                };
                                                              };
                                                                struct { /* BLOCK ln=335 */
                                                                  union {
                                                                  };
                                                                } ;
                                                            };
                                                          } ;
                                                      };
                                                    } ;
                                                  };
                                                } ;
                                                struct { /* BLOCK ln=339 */
                                                  union {
                                                    union {
                                                    };
                                                  };
                                                } ;
                                              };
                                                struct { /* BLOCK ln=342 */
                                                u8 __fin_1063_1: 1;
                                                u8 __fin_1063_2: 1;
                                                  int id_13;
                                                  union {
                                                        struct { /* BLOCK ln=345 */
                                                          union {
                                                          };
                                                        } ;
                                                    union {
                                                    };
                                                        struct { /* BLOCK ln=352 */
                                                          union {
                                                          };
                                                        } ;
                                                  };
                                                } ;
                                            };
                                          } ;
                                        };
                                      };
                                    } ;
                                  };
                                } ;
                              };
                            } ;

} CEU_Orchid;





typedef struct CEU_Heliconia {
#ifdef CEU_ORGS
  struct tceu_org org;
#endif
  tceu_trl trls_[ 6 ];
                            struct { /* BLOCK ln=360 */
                              int* gensym;
                              struct CEU_Garden* garden;
                              int plot;
                              union {
                                  union {
                                  };
                                struct { /* BLOCK ln=360 */
                                  union {
                                    struct { /* BLOCK ln=365 */
                                    u8 __fin_1250_1: 1;
                                      int x;
                                      int y;
                                      int layer;
                                      union {
                                            struct { /* BLOCK ln=367 */
                                              union {
                                              };
                                            } ;
                                        union {
                                        };
                                        union {
                                        };
                                        union {
                                        };
                                        struct {
                                          struct { /* BLOCK ln=373 */
                                            union {
                                              struct { /* BLOCK ln=373 */
                                                union {
                                                  union {
                                                  };
                                                    struct { /* BLOCK ln=374 */
                                                      union {
                                                        union {
                                                          union {
                                                          };
                                                        };
                                                          struct { /* BLOCK ln=376 */
                                                            union {
                                                            };
                                                          } ;
                                                      };
                                                    } ;
                                                };
                                              } ;
                                            };
                                          } ;
                                          struct { /* BLOCK ln=381 */
                                            struct CEU_Growing growing_10;
                                            bool survived_11;
                                            union {
                                                  struct { /* BLOCK ln=382 */
                                                    union {
                                                    };
                                                  } ;
                                              union {
                                              };
                                              struct {
                                                struct { /* BLOCK ln=389 */
                                                  union {
                                                    struct { /* BLOCK ln=389 */
                                                      union {
                                                        union {
                                                        };
                                                          struct { /* BLOCK ln=390 */
                                                            union {
                                                              union {
                                                                union {
                                                                };
                                                              };
                                                                struct { /* BLOCK ln=392 */
                                                                  union {
                                                                  };
                                                                } ;
                                                            };
                                                          } ;
                                                      };
                                                    } ;
                                                  };
                                                } ;
                                                struct { /* BLOCK ln=396 */
                                                  union {
                                                    union {
                                                    };
                                                  };
                                                } ;
                                              };
                                                struct { /* BLOCK ln=399 */
                                                u8 __fin_1244_1: 1;
                                                u8 __fin_1244_2: 1;
                                                  int id_13;
                                                  union {
                                                        struct { /* BLOCK ln=402 */
                                                          union {
                                                          };
                                                        } ;
                                                    union {
                                                    };
                                                        struct { /* BLOCK ln=409 */
                                                          union {
                                                          };
                                                        } ;
                                                  };
                                                } ;
                                            };
                                          } ;
                                        };
                                      };
                                    } ;
                                  };
                                } ;
                              };
                            } ;

} CEU_Heliconia;





typedef struct CEU_BagActive {
#ifdef CEU_ORGS
  struct tceu_org org;
#endif
  tceu_trl trls_[ 4 ];
                            struct { /* BLOCK ln=450 */
                              int id;
                              int* x;
                              int* y;
                              int seed;
                              struct CEU_Garden* garden;
                              union {
                                  union {
                                  };
                                struct { /* BLOCK ln=450 */
                                  union {
                                    struct { /* BLOCK ln=458 */
                                    u8 __fin_1542_1: 1;
                                      int patch;
                                      union {
                                        union {
                                        };
                                            struct { /* BLOCK ln=461 */
                                              union {
                                              };
                                            } ;
                                        struct {
                                          struct { /* BLOCK ln=464 */
                                            union {
                                              union {
                                              };
                                            };
                                          } ;
                                          struct { /* BLOCK ln=466 */
                                            union {
                                              struct { /* BLOCK ln=466 */
                                                union {
                                                  union {
                                                  };
                                                    struct { /* BLOCK ln=467 */
                                                      bool rightborder_10;
                                                      bool leftmidborder_12;
                                                      bool rightmidborder_11;
                                                      bool leftborder_13;
                                                      union {
                                                        union {
                                                        };
                                                        union {
                                                        };
                                                        union {
                                                        };
                                                        union {
                                                        };
                                                          struct { /* BLOCK ln=473 */
                                                            union {
                                                                struct { /* BLOCK ln=474 */
                                                                  union {
                                                                      struct { /* BLOCK ln=475 */
                                                                        union {
                                                                        };
                                                                      } ;
                                                                  };
                                                                } ;
                                                                  struct { /* BLOCK ln=479 */
                                                                    union {
                                                                        struct { /* BLOCK ln=480 */
                                                                          union {
                                                                          };
                                                                        } ;
                                                                    };
                                                                  } ;
                                                                    struct { /* BLOCK ln=484 */
                                                                      union {
                                                                          struct { /* BLOCK ln=485 */
                                                                            union {
                                                                            };
                                                                          } ;
                                                                      };
                                                                    } ;
                                                                    struct { /* BLOCK ln=489 */
                                                                      union {
                                                                      };
                                                                    } ;
                                                            };
                                                          } ;
                                                            struct { /* BLOCK ln=492 */
                                                              union {
                                                                  struct { /* BLOCK ln=493 */
                                                                    union {
                                                                        struct { /* BLOCK ln=494 */
                                                                          union {
                                                                          };
                                                                        } ;
                                                                    };
                                                                  } ;
                                                                    struct { /* BLOCK ln=498 */
                                                                      union {
                                                                          struct { /* BLOCK ln=499 */
                                                                            union {
                                                                            };
                                                                          } ;
                                                                      };
                                                                    } ;
                                                                      struct { /* BLOCK ln=503 */
                                                                        union {
                                                                            struct { /* BLOCK ln=504 */
                                                                              union {
                                                                              };
                                                                            } ;
                                                                        };
                                                                      } ;
                                                                      struct { /* BLOCK ln=508 */
                                                                        union {
                                                                        };
                                                                      } ;
                                                              };
                                                            } ;
                                                        union {
                                                        };
                                                      };
                                                    } ;
                                                };
                                              } ;
                                            };
                                          } ;
                                        };
                                      };
                                    } ;
                                  };
                                } ;
                              };
                            } ;

} CEU_BagActive;





typedef struct CEU_Bag {
#ifdef CEU_ORGS
  struct tceu_org org;
#endif
  tceu_trl trls_[ 5 ];
                            struct { /* BLOCK ln=518 */
                              int* gensym;
                              int x;
                              int y;
                              int seed;
                              struct CEU_Garden* garden;
                              union {
                                  union {
                                  };
                                struct { /* BLOCK ln=518 */
                                  union {
                                    struct { /* BLOCK ln=526 */
                                    u8 __fin_1652_1: 1;
                                      int id;
                                      union {
                                        union {
                                        };
                                            struct { /* BLOCK ln=530 */
                                              union {
                                              };
                                            } ;
                                        struct {
                                          struct { /* BLOCK ln=534 */
                                            union {
                                              struct { /* BLOCK ln=534 */
                                                union {
                                                  union {
                                                  };
                                                    struct { /* BLOCK ln=535 */
                                                      union {
                                                        union {
                                                        };
                                                      };
                                                    } ;
                                                };
                                              } ;
                                            };
                                          } ;
                                          struct { /* BLOCK ln=539 */
                                            union {
                                              struct { /* BLOCK ln=539 */
                                                union {
                                                  union {
                                                  };
                                                    struct { /* BLOCK ln=540 */
                                                      union {
                                                        struct {
                                                          struct { /* BLOCK ln=541 */
                                                            union {
                                                              union {
                                                              };
                                                            };
                                                          } ;
                                                          struct { /* BLOCK ln=544 */
                                                            union {
                                                              union {
                                                              };
                                                            };
                                                          } ;
                                                        };
                                                          struct { /* BLOCK ln=546 */
                                                            struct CEU_BagActive _org_1642_10;
                                                            union {
                                                                  struct { /* BLOCK ln=547 */
                                                                    union {
                                                                    };
                                                                  } ;
                                                              union {
                                                                union {
                                                                    struct { /* BLOCK ln=546 */
                                                                      union {
                                                                      };
                                                                    } ;
                                                                    struct { /* BLOCK ln=546 */
                                                                      union {
                                                                      };
                                                                    } ;
                                                                };
                                                              };
                                                            };
                                                          } ;
                                                      };
                                                    } ;
                                                };
                                              } ;
                                            };
                                          } ;
                                        };
                                      };
                                    } ;
                                  };
                                } ;
                              };
                            } ;

} CEU_Bag;





typedef struct CEU_WateringCanActive {
#ifdef CEU_ORGS
  struct tceu_org org;
#endif
  tceu_trl trls_[ 4 ];
                            struct { /* BLOCK ln=558 */
                              int id;
                              int* x;
                              int* y;
                              struct CEU_Garden* garden;
                              union {
                                  union {
                                  };
                                struct { /* BLOCK ln=558 */
                                  union {
                                    struct { /* BLOCK ln=565 */
                                    u8 __fin_1860_1: 1;
                                      union {
                                            struct { /* BLOCK ln=567 */
                                              union {
                                              };
                                            } ;
                                        struct {
                                          struct { /* BLOCK ln=570 */
                                            union {
                                              union {
                                              };
                                            };
                                          } ;
                                          struct { /* BLOCK ln=572 */
                                            union {
                                              struct { /* BLOCK ln=572 */
                                                union {
                                                  union {
                                                  };
                                                    struct { /* BLOCK ln=573 */
                                                      bool rightborder_8;
                                                      bool leftmidborder_10;
                                                      bool rightmidborder_9;
                                                      bool leftborder_11;
                                                      union {
                                                        union {
                                                        };
                                                        union {
                                                        };
                                                        union {
                                                        };
                                                        union {
                                                        };
                                                          struct { /* BLOCK ln=579 */
                                                            union {
                                                                struct { /* BLOCK ln=580 */
                                                                  union {
                                                                  };
                                                                } ;
                                                                  struct { /* BLOCK ln=582 */
                                                                    union {
                                                                    };
                                                                  } ;
                                                                    struct { /* BLOCK ln=584 */
                                                                      union {
                                                                      };
                                                                    } ;
                                                            };
                                                          } ;
                                                            struct { /* BLOCK ln=587 */
                                                              union {
                                                                  struct { /* BLOCK ln=588 */
                                                                    union {
                                                                    };
                                                                  } ;
                                                                    struct { /* BLOCK ln=590 */
                                                                      union {
                                                                      };
                                                                    } ;
                                                                      struct { /* BLOCK ln=592 */
                                                                        union {
                                                                        };
                                                                      } ;
                                                              };
                                                            } ;
                                                        union {
                                                        };
                                                      };
                                                    } ;
                                                };
                                              } ;
                                            };
                                          } ;
                                        };
                                      };
                                    } ;
                                  };
                                } ;
                              };
                            } ;

} CEU_WateringCanActive;





typedef struct CEU_WateringCan {
#ifdef CEU_ORGS
  struct tceu_org org;
#endif
  tceu_trl trls_[ 5 ];
                            struct { /* BLOCK ln=602 */
                              int* gensym;
                              int x;
                              int y;
                              struct CEU_Garden* garden;
                              union {
                                  union {
                                  };
                                struct { /* BLOCK ln=602 */
                                  union {
                                    struct { /* BLOCK ln=609 */
                                    u8 __fin_1964_1: 1;
                                      int id;
                                      union {
                                        union {
                                        };
                                            struct { /* BLOCK ln=613 */
                                              union {
                                              };
                                            } ;
                                        struct {
                                          struct { /* BLOCK ln=617 */
                                            union {
                                              struct { /* BLOCK ln=617 */
                                                union {
                                                  union {
                                                  };
                                                    struct { /* BLOCK ln=618 */
                                                      union {
                                                        union {
                                                        };
                                                      };
                                                    } ;
                                                };
                                              } ;
                                            };
                                          } ;
                                          struct { /* BLOCK ln=622 */
                                            union {
                                              struct { /* BLOCK ln=622 */
                                                union {
                                                  union {
                                                  };
                                                    struct { /* BLOCK ln=623 */
                                                      union {
                                                        struct {
                                                          struct { /* BLOCK ln=624 */
                                                            union {
                                                              union {
                                                              };
                                                            };
                                                          } ;
                                                          struct { /* BLOCK ln=627 */
                                                            union {
                                                              union {
                                                              };
                                                            };
                                                          } ;
                                                        };
                                                          struct { /* BLOCK ln=629 */
                                                            struct CEU_WateringCanActive _org_1954_9;
                                                            union {
                                                                  struct { /* BLOCK ln=630 */
                                                                    union {
                                                                    };
                                                                  } ;
                                                              union {
                                                                union {
                                                                    struct { /* BLOCK ln=629 */
                                                                      union {
                                                                      };
                                                                    } ;
                                                                    struct { /* BLOCK ln=629 */
                                                                      union {
                                                                      };
                                                                    } ;
                                                                };
                                                              };
                                                            };
                                                          } ;
                                                      };
                                                    } ;
                                                };
                                              } ;
                                            };
                                          } ;
                                        };
                                      };
                                    } ;
                                  };
                                } ;
                              };
                            } ;

} CEU_WateringCan;





typedef struct CEU_ShovelActive {
#ifdef CEU_ORGS
  struct tceu_org org;
#endif
  tceu_trl trls_[ 4 ];
                            struct { /* BLOCK ln=640 */
                              int id;
                              int* x;
                              int* y;
                              struct CEU_Garden* garden;
                              union {
                                  union {
                                  };
                                struct { /* BLOCK ln=640 */
                                  union {
                                    struct { /* BLOCK ln=647 */
                                    u8 __fin_2202_1: 1;
                                      union {
                                            struct { /* BLOCK ln=649 */
                                              union {
                                              };
                                            } ;
                                        struct {
                                          struct { /* BLOCK ln=652 */
                                            union {
                                              union {
                                              };
                                            };
                                          } ;
                                          struct { /* BLOCK ln=654 */
                                            union {
                                              struct { /* BLOCK ln=654 */
                                                union {
                                                  union {
                                                  };
                                                    struct { /* BLOCK ln=655 */
                                                      bool rightborder_8;
                                                      bool leftmidborder_10;
                                                      bool rightmidborder_9;
                                                      bool leftborder_11;
                                                      union {
                                                        union {
                                                        };
                                                        union {
                                                        };
                                                        union {
                                                        };
                                                        union {
                                                        };
                                                          struct { /* BLOCK ln=661 */
                                                            union {
                                                                struct { /* BLOCK ln=662 */
                                                                  union {
                                                                  };
                                                                } ;
                                                                  struct { /* BLOCK ln=665 */
                                                                    union {
                                                                    };
                                                                  } ;
                                                                    struct { /* BLOCK ln=668 */
                                                                      union {
                                                                      };
                                                                    } ;
                                                            };
                                                          } ;
                                                            struct { /* BLOCK ln=672 */
                                                              union {
                                                                  struct { /* BLOCK ln=673 */
                                                                    union {
                                                                    };
                                                                  } ;
                                                                    struct { /* BLOCK ln=676 */
                                                                      union {
                                                                      };
                                                                    } ;
                                                                      struct { /* BLOCK ln=679 */
                                                                        union {
                                                                        };
                                                                      } ;
                                                              };
                                                            } ;
                                                        union {
                                                        };
                                                      };
                                                    } ;
                                                };
                                              } ;
                                            };
                                          } ;
                                        };
                                      };
                                    } ;
                                  };
                                } ;
                              };
                            } ;

} CEU_ShovelActive;





typedef struct CEU_Shovel {
#ifdef CEU_ORGS
  struct tceu_org org;
#endif
  tceu_trl trls_[ 5 ];
                            struct { /* BLOCK ln=690 */
                              int* gensym;
                              int x;
                              int y;
                              struct CEU_Garden* garden;
                              union {
                                  union {
                                  };
                                struct { /* BLOCK ln=690 */
                                  union {
                                    struct { /* BLOCK ln=697 */
                                    u8 __fin_2306_1: 1;
                                      int id;
                                      union {
                                        union {
                                        };
                                            struct { /* BLOCK ln=701 */
                                              union {
                                              };
                                            } ;
                                        struct {
                                          struct { /* BLOCK ln=705 */
                                            union {
                                              struct { /* BLOCK ln=705 */
                                                union {
                                                  union {
                                                  };
                                                    struct { /* BLOCK ln=706 */
                                                      union {
                                                        union {
                                                        };
                                                      };
                                                    } ;
                                                };
                                              } ;
                                            };
                                          } ;
                                          struct { /* BLOCK ln=710 */
                                            union {
                                              struct { /* BLOCK ln=710 */
                                                union {
                                                  union {
                                                  };
                                                    struct { /* BLOCK ln=711 */
                                                      union {
                                                        struct {
                                                          struct { /* BLOCK ln=712 */
                                                            union {
                                                              union {
                                                              };
                                                            };
                                                          } ;
                                                          struct { /* BLOCK ln=715 */
                                                            union {
                                                              union {
                                                              };
                                                            };
                                                          } ;
                                                        };
                                                          struct { /* BLOCK ln=717 */
                                                            struct CEU_ShovelActive _org_2296_9;
                                                            union {
                                                                  struct { /* BLOCK ln=718 */
                                                                    union {
                                                                    };
                                                                  } ;
                                                              union {
                                                                union {
                                                                    struct { /* BLOCK ln=717 */
                                                                      union {
                                                                      };
                                                                    } ;
                                                                    struct { /* BLOCK ln=717 */
                                                                      union {
                                                                      };
                                                                    } ;
                                                                };
                                                              };
                                                            };
                                                          } ;
                                                      };
                                                    } ;
                                                };
                                              } ;
                                            };
                                          } ;
                                        };
                                      };
                                    } ;
                                  };
                                } ;
                              };
                            } ;

} CEU_Shovel;





typedef struct CEU_Tween {
#ifdef CEU_ORGS
  struct tceu_org org;
#endif
  tceu_trl trls_[ 2 ];
                            struct { /* BLOCK ln=728 */
                              int target_x;
                              int target_y;
                              float* x;
                              float* y;
                              int id;
                              float speed;
                              union {
                                  union {
                                  };
                                struct { /* BLOCK ln=728 */
                                  union {
                                    struct { /* BLOCK ln=737 */
                                      union {
                                        struct { /* BLOCK ln=737 */
                                          union {
                                            union {
                                            };
                                              struct { /* BLOCK ln=738 */
                                                float dx_10;
                                                float dy_11;
                                                float dist_12;
                                                union {
                                                    struct { /* BLOCK ln=739 */
                                                      union {
                                                      };
                                                    } ;
                                                  union {
                                                  };
                                                  union {
                                                  };
                                                  union {
                                                  };
                                                  union {
                                                  };
                                                    struct { /* BLOCK ln=747 */
                                                      union {
                                                      };
                                                    } ;
                                                    struct { /* BLOCK ln=750 */
                                                      union {
                                                      };
                                                    } ;
                                                    struct { /* BLOCK ln=755 */
                                                      union {
                                                      };
                                                    } ;
                                                    struct { /* BLOCK ln=757 */
                                                      union {
                                                      };
                                                    } ;
                                                };
                                              } ;
                                          };
                                        } ;
                                      };
                                    } ;
                                  };
                                } ;
                              };
                            } ;

} CEU_Tween;





typedef struct CEU_Fly {
#ifdef CEU_ORGS
  struct tceu_org org;
#endif
  tceu_trl trls_[ 3 ];
                            struct { /* BLOCK ln=763 */
                              int target_x;
                              int target_y;
                              float* x;
                              float* y;
                              int id;
                              union {
                                  union {
                                  };
                                struct { /* BLOCK ln=763 */
                                  union {
                                    struct { /* BLOCK ln=771 */
                                      float speed;
                                      int intermediate_y;
                                      int intermediate_x;
                                      union {
                                        union {
                                        };
                                        union {
                                        };
                                        union {
                                        };
                                          struct { /* BLOCK ln=774 */
                                            struct CEU_Tween _org_2512_12;
                                            union {
                                                  struct { /* BLOCK ln=775 */
                                                    union {
                                                    };
                                                  } ;
                                              union {
                                                union {
                                                    struct { /* BLOCK ln=774 */
                                                      union {
                                                      };
                                                    } ;
                                                    struct { /* BLOCK ln=774 */
                                                      union {
                                                      };
                                                    } ;
                                                };
                                              };
                                            };
                                          } ;
                                          struct { /* BLOCK ln=782 */
                                            struct CEU_Tween _org_2542_13;
                                            union {
                                                  struct { /* BLOCK ln=783 */
                                                    union {
                                                    };
                                                  } ;
                                              union {
                                                union {
                                                    struct { /* BLOCK ln=782 */
                                                      union {
                                                      };
                                                    } ;
                                                    struct { /* BLOCK ln=782 */
                                                      union {
                                                      };
                                                    } ;
                                                };
                                              };
                                            };
                                          } ;
                                      };
                                    } ;
                                  };
                                } ;
                              };
                            } ;

} CEU_Fly;





typedef struct CEU_Seed {
#ifdef CEU_ORGS
  struct tceu_org org;
#endif
  tceu_trl trls_[ 5 ];
                            struct { /* BLOCK ln=793 */
                              int* gensym;
                              float x;
                              float y;
                              int tier;
                              union {
                                  union {
                                  };
                                struct { /* BLOCK ln=793 */
                                  union {
                                    struct { /* BLOCK ln=799 */
                                    u8 __fin_2741_1: 1;
                                      int id;
                                      bool touched;
                                      union {
                                        union {
                                        };
                                          struct { /* BLOCK ln=804 */
                                            union {
                                            };
                                          } ;
                                            struct { /* BLOCK ln=806 */
                                              union {
                                              };
                                            } ;
                                              struct { /* BLOCK ln=808 */
                                                union {
                                                };
                                              } ;
                                            struct { /* BLOCK ln=812 */
                                              union {
                                              };
                                            } ;
                                        union {
                                        };
                                        struct {
                                          struct { /* BLOCK ln=817 */
                                            union {
                                                struct { /* BLOCK ln=817 */
                                                  struct CEU_Tween _org_2643_9;
                                                  union {
                                                        struct { /* BLOCK ln=818 */
                                                          union {
                                                          };
                                                        } ;
                                                    union {
                                                      union {
                                                          struct { /* BLOCK ln=817 */
                                                            union {
                                                            };
                                                          } ;
                                                          struct { /* BLOCK ln=817 */
                                                            union {
                                                            };
                                                          } ;
                                                      };
                                                    };
                                                  };
                                                } ;
                                            };
                                          } ;
                                          struct { /* BLOCK ln=826 */
                                            union {
                                              struct { /* BLOCK ln=826 */
                                                union {
                                                  union {
                                                  };
                                                    struct { /* BLOCK ln=827 */
                                                      union {
                                                        union {
                                                        };
                                                        union {
                                                        };
                                                          struct { /* BLOCK ln=830 */
                                                            union {
                                                            };
                                                          } ;
                                                      };
                                                    } ;
                                                };
                                              } ;
                                            };
                                          } ;
                                        };
                                          struct { /* BLOCK ln=837 */
                                            union {
                                                struct { /* BLOCK ln=837 */
                                                  struct CEU_Tween _org_2720_12;
                                                  union {
                                                        struct { /* BLOCK ln=838 */
                                                          union {
                                                          };
                                                        } ;
                                                    union {
                                                      union {
                                                          struct { /* BLOCK ln=837 */
                                                            union {
                                                            };
                                                          } ;
                                                          struct { /* BLOCK ln=837 */
                                                            union {
                                                            };
                                                          } ;
                                                      };
                                                    };
                                                  };
                                                } ;
                                            };
                                          } ;
                                      };
                                    } ;
                                  };
                                } ;
                              };
                            } ;

} CEU_Seed;





typedef struct CEU_Birb {
#ifdef CEU_ORGS
  struct tceu_org org;
#endif
  tceu_trl trls_[ 7 ];
                            struct { /* BLOCK ln=857 */
                              int* gensym;
                              int* birb_count;
                              tceu_pool_orgs* seeds;
;
                              int tier;
                              union {
                                  union {
                                  };
                                struct { /* BLOCK ln=857 */
                                  union {
                                    struct { /* BLOCK ln=863 */
                                    u8 __fin_3022_1: 1;
                                      int id;
                                      float y;
                                      float x;
                                      int perched_id;
                                      int texture;
                                      union {
                                        union {
                                        };
                                        union {
                                        };
                                        union {
                                        };
                                        union {
                                        };
                                        union {
                                        };
                                            struct { /* BLOCK ln=873 */
                                              union {
                                              };
                                            } ;
                                        struct {
                                          struct { /* BLOCK ln=880 */
                                            union {
                                              struct { /* BLOCK ln=880 */
                                                union {
                                                  union {
                                                  };
                                                    struct { /* BLOCK ln=881 */
                                                      union {
                                                        union {
                                                        };
                                                          struct { /* BLOCK ln=883 */
                                                            union {
                                                            };
                                                          } ;
                                                      };
                                                    } ;
                                                };
                                              } ;
                                            };
                                          } ;
                                          struct { /* BLOCK ln=887 */
                                            union {
                                              struct { /* BLOCK ln=887 */
                                                union {
                                                  union {
                                                  };
                                                    struct { /* BLOCK ln=888 */
                                                      int target_perch_12;
                                                      union {
                                                        union {
                                                        };
                                                          struct { /* BLOCK ln=889 */
                                                            struct CEU_Fly _org_2869_13;
                                                            union {
                                                                  struct { /* BLOCK ln=890 */
                                                                    union {
                                                                    };
                                                                  } ;
                                                              union {
                                                                union {
                                                                    struct { /* BLOCK ln=889 */
                                                                      union {
                                                                      };
                                                                    } ;
                                                                    struct { /* BLOCK ln=889 */
                                                                      union {
                                                                      };
                                                                    } ;
                                                                };
                                                              };
                                                            };
                                                          } ;
                                                          struct { /* BLOCK ln=897 */
                                                            union {
                                                            };
                                                          } ;
                                                          struct { /* BLOCK ln=887 */
                                                            union {
                                                                struct { /* BLOCK ln=901 */
                                                                u8 __fin_2945_1: 1;
                                                                  union {
                                                                        struct { /* BLOCK ln=905 */
                                                                          union {
                                                                          };
                                                                        } ;
                                                                      struct { /* BLOCK ln=910 */
                                                                        struct CEU_Delay _org_2943_14;
                                                                        union {
                                                                              struct { /* BLOCK ln=911 */
                                                                                union {
                                                                                };
                                                                              } ;
                                                                          union {
                                                                            union {
                                                                                struct { /* BLOCK ln=910 */
                                                                                  union {
                                                                                  };
                                                                                } ;
                                                                                struct { /* BLOCK ln=910 */
                                                                                  union {
                                                                                  };
                                                                                } ;
                                                                            };
                                                                          };
                                                                        };
                                                                      } ;
                                                                  };
                                                                } ;
                                                            };
                                                          } ;
                                                      };
                                                    } ;
                                                };
                                              } ;
                                            };
                                          } ;
                                        };
                                          struct { /* BLOCK ln=918 */
                                            union {
                                                  struct { /* BLOCK ln=919 */
                                                    union {
                                                    };
                                                  } ;
                                            };
                                          } ;
                                          struct { /* BLOCK ln=926 */
                                            struct CEU_Fly _org_3020_15;
                                            union {
                                                  struct { /* BLOCK ln=927 */
                                                    union {
                                                    };
                                                  } ;
                                              union {
                                                union {
                                                    struct { /* BLOCK ln=926 */
                                                      union {
                                                      };
                                                    } ;
                                                    struct { /* BLOCK ln=926 */
                                                      union {
                                                      };
                                                    } ;
                                                };
                                              };
                                            };
                                          } ;
                                      };
                                    } ;
                                  };
                                } ;
                              };
                            } ;

} CEU_Birb;




typedef struct CEU_Main {
#ifdef CEU_ORGS
  struct tceu_org org;
#endif
  tceu_trl trls_[ 13 ];
    struct { /* BLOCK ln=1 */
      union {
          union {
          };
        struct { /* BLOCK ln=1 */
          union {
              struct { /* BLOCK ln=1 */
                union {
                  union {
                    struct { /* BLOCK ln=1 */
                      tceu_pool_orgs _top_pool;
;
                      int gensym;
                      int birb_count;
                      CEU_Birb* birbs_queue[ 5 ];
CEU_Birb  birbs_mem  [ 5 ];
tceu_pool_orgs birbs;
;
                      CEU_Seed* seeds_queue[ 5 ];
CEU_Seed  seeds_mem  [ 5 ];
tceu_pool_orgs seeds;
;
                      struct CEU_Garden garden;
                      union {
                        union {
                        };
                        union {
                        };
                        union {
                        };
                        union {
                        };
                        union {
                        };
                        union {
                        };
                        union {
                        };
                        union {
                        };
                        union {
                        };
                        union {
                        };
                        union {
                        };
                        union {
                        };
                        union {
                        };
                        union {
                        };
                        union {
                        };
                        union {
                        };
                        union {
                        };
                        union {
                        };
                        union {
                        };
                        union {
                        };
                        union {
                        };
                        union {
                        };
                        union {
                        };
                        union {
                        };
                        union {
                        };
                        union {
                        };
                        union {
                        };
                        union {
                        };
                        union {
                        };
                        union {
                        };
                        union {
                        };
                        union {
                        };
                        union {
                        };
                        union {
                        };
                        union {
                        };
                        union {
                        };
                        union {
                        };
                        union {
                        };
                        union {
                              struct { /* BLOCK ln=939 */
                                union {
                                };
                              } ;
                        };
                        struct {
                          struct { /* BLOCK ln=942 */
                            union {
                              struct { /* BLOCK ln=942 */
                                union {
                                  union {
                                  };
                                    struct { /* BLOCK ln=943 */
                                      union {
                                        struct { /* BLOCK ln=943 */
                                          union {
                                            union {
                                            };
                                              struct { /* BLOCK ln=944 */
                                                union {
                                                  union {
                                                  };
                                                  union {
                                                  };
                                                  union {
                                                  };
                                                    struct { /* BLOCK ln=948 */
                                                      union {
                                                      };
                                                    } ;
                                                };
                                              } ;
                                          };
                                        } ;
                                        struct { /* BLOCK ln=952 */
                                          union {
                                            union {
                                            };
                                              struct { /* BLOCK ln=953 */
                                                union {
                                                  union {
                                                  };
                                                  union {
                                                  };
                                                  union {
                                                  };
                                                    struct { /* BLOCK ln=957 */
                                                      union {
                                                      };
                                                    } ;
                                                };
                                              } ;
                                          };
                                        } ;
                                      };
                                    } ;
                                };
                              } ;
                            };
                          } ;
                          struct { /* BLOCK ln=963 */
                            union {
                              struct { /* BLOCK ln=963 */
                                union {
                                  union {
                                  };
                                    struct { /* BLOCK ln=964 */
                                      int seed_11;
                                      int plot_12;
                                      union {
                                        union {
                                        };
                                        union {
                                        };
                                          struct { /* BLOCK ln=967 */
                                            union {
                                            };
                                          } ;
                                          struct { /* BLOCK ln=969 */
                                            union {
                                                struct { /* BLOCK ln=970 */
                                                  union {
                                                        struct { /* BLOCK ln=971 */
                                                          union {
                                                          };
                                                        } ;
                                                  };
                                                } ;
                                                  struct { /* BLOCK ln=976 */
                                                    union {
                                                          struct { /* BLOCK ln=977 */
                                                            union {
                                                            };
                                                          } ;
                                                    };
                                                  } ;
                                                    struct { /* BLOCK ln=984 */
                                                      union {
                                                            struct { /* BLOCK ln=985 */
                                                              union {
                                                              };
                                                            } ;
                                                      };
                                                    } ;
                                                      struct { /* BLOCK ln=992 */
                                                        union {
                                                              struct { /* BLOCK ln=993 */
                                                                union {
                                                                };
                                                              } ;
                                                        };
                                                      } ;
                                            };
                                          } ;
                                      };
                                    } ;
                                };
                              } ;
                            };
                          } ;
                          struct { /* BLOCK ln=1003 */
                            union {
                              struct { /* BLOCK ln=1003 */
                                union {
                                  union {
                                  };
                                    struct { /* BLOCK ln=1004 */
                                      union {
                                        struct {
                                          struct { /* BLOCK ln=1006 */
                                            union {
                                              union {
                                              };
                                            };
                                          } ;
                                          struct { /* BLOCK ln=1008 */
                                            int x_13;
                                            int y_14;
                                            union {
                                              union {
                                              };
                                              union {
                                              };
                                                struct { /* BLOCK ln=1011 */
                                                  union {
                                                      struct { /* BLOCK ln=1012 */
                                                        union {
                                                            struct { /* BLOCK ln=1012 */
                                                              struct CEU_Shovel _org_3374_15;
                                                              union {
                                                                    struct { /* BLOCK ln=1013 */
                                                                      union {
                                                                      };
                                                                    } ;
                                                                union {
                                                                  union {
                                                                      struct { /* BLOCK ln=1012 */
                                                                        union {
                                                                        };
                                                                      } ;
                                                                      struct { /* BLOCK ln=1012 */
                                                                        union {
                                                                        };
                                                                      } ;
                                                                  };
                                                                };
                                                              };
                                                            } ;
                                                        };
                                                      } ;
                                                        struct { /* BLOCK ln=1019 */
                                                          union {
                                                              struct { /* BLOCK ln=1019 */
                                                                struct CEU_WateringCan _org_3417_16;
                                                                union {
                                                                      struct { /* BLOCK ln=1020 */
                                                                        union {
                                                                        };
                                                                      } ;
                                                                  union {
                                                                    union {
                                                                        struct { /* BLOCK ln=1019 */
                                                                          union {
                                                                          };
                                                                        } ;
                                                                        struct { /* BLOCK ln=1019 */
                                                                          union {
                                                                          };
                                                                        } ;
                                                                    };
                                                                  };
                                                                };
                                                              } ;
                                                          };
                                                        } ;
                                                          struct { /* BLOCK ln=1026 */
                                                            union {
                                                                struct { /* BLOCK ln=1026 */
                                                                  struct CEU_Bag _org_3464_17;
                                                                  union {
                                                                        struct { /* BLOCK ln=1027 */
                                                                          union {
                                                                          };
                                                                        } ;
                                                                    union {
                                                                      union {
                                                                          struct { /* BLOCK ln=1026 */
                                                                            union {
                                                                            };
                                                                          } ;
                                                                          struct { /* BLOCK ln=1026 */
                                                                            union {
                                                                            };
                                                                          } ;
                                                                      };
                                                                    };
                                                                  };
                                                                } ;
                                                            };
                                                          } ;
                                                            struct { /* BLOCK ln=1034 */
                                                              union {
                                                                  struct { /* BLOCK ln=1035 */
                                                                    union {
                                                                        struct { /* BLOCK ln=1035 */
                                                                          struct CEU_Bag _org_3516_18;
                                                                          union {
                                                                                struct { /* BLOCK ln=1036 */
                                                                                  union {
                                                                                  };
                                                                                } ;
                                                                            union {
                                                                              union {
                                                                                  struct { /* BLOCK ln=1035 */
                                                                                    union {
                                                                                    };
                                                                                  } ;
                                                                                  struct { /* BLOCK ln=1035 */
                                                                                    union {
                                                                                    };
                                                                                  } ;
                                                                              };
                                                                            };
                                                                          };
                                                                        } ;
                                                                    };
                                                                  } ;
                                                              };
                                                            } ;
                                                              struct { /* BLOCK ln=1044 */
                                                                union {
                                                                    struct { /* BLOCK ln=1045 */
                                                                      union {
                                                                          struct { /* BLOCK ln=1045 */
                                                                            struct CEU_Bag _org_3571_19;
                                                                            union {
                                                                                  struct { /* BLOCK ln=1046 */
                                                                                    union {
                                                                                    };
                                                                                  } ;
                                                                              union {
                                                                                union {
                                                                                    struct { /* BLOCK ln=1045 */
                                                                                      union {
                                                                                      };
                                                                                    } ;
                                                                                    struct { /* BLOCK ln=1045 */
                                                                                      union {
                                                                                      };
                                                                                    } ;
                                                                                };
                                                                              };
                                                                            };
                                                                          } ;
                                                                      };
                                                                    } ;
                                                                };
                                                              } ;
                                                                struct { /* BLOCK ln=1054 */
                                                                  union {
                                                                      struct { /* BLOCK ln=1055 */
                                                                        union {
                                                                            struct { /* BLOCK ln=1055 */
                                                                              struct CEU_Bag _org_3626_20;
                                                                              union {
                                                                                    struct { /* BLOCK ln=1056 */
                                                                                      union {
                                                                                      };
                                                                                    } ;
                                                                                union {
                                                                                  union {
                                                                                      struct { /* BLOCK ln=1055 */
                                                                                        union {
                                                                                        };
                                                                                      } ;
                                                                                      struct { /* BLOCK ln=1055 */
                                                                                        union {
                                                                                        };
                                                                                      } ;
                                                                                  };
                                                                                };
                                                                              };
                                                                            } ;
                                                                        };
                                                                      } ;
                                                                  };
                                                                } ;
                                                  };
                                                } ;
                                            };
                                          } ;
                                        };
                                      };
                                    } ;
                                };
                              } ;
                            };
                          } ;
                          struct { /* BLOCK ln=1068 */
                            union {
                              struct { /* BLOCK ln=1068 */
                                union {
                                  union {
                                  };
                                    struct { /* BLOCK ln=1069 */
                                      union {
                                        union {
                                        };
                                          struct { /* BLOCK ln=1071 */
                                            union {
                                                  struct { /* BLOCK ln=1072 */
                                                    union {
                                                    };
                                                  } ;
                                            };
                                          } ;
                                      };
                                    } ;
                                };
                              } ;
                            };
                          } ;
                          struct { /* BLOCK ln=1080 */
                            union {
                              struct { /* BLOCK ln=1080 */
                                union {
                                  union {
                                  };
                                    struct { /* BLOCK ln=1081 */
                                      union {
                                        union {
                                        };
                                          struct { /* BLOCK ln=1083 */
                                            union {
                                                  struct { /* BLOCK ln=1084 */
                                                    union {
                                                    };
                                                  } ;
                                            };
                                          } ;
                                      };
                                    } ;
                                };
                              } ;
                            };
                          } ;
                          struct { /* BLOCK ln=1092 */
                            union {
                              struct { /* BLOCK ln=1092 */
                                union {
                                  union {
                                  };
                                    struct { /* BLOCK ln=1093 */
                                      union {
                                        union {
                                        };
                                          struct { /* BLOCK ln=1095 */
                                            union {
                                                  struct { /* BLOCK ln=1096 */
                                                    union {
                                                    };
                                                  } ;
                                            };
                                          } ;
                                      };
                                    } ;
                                };
                              } ;
                            };
                          } ;
                        };
                      };
                    } ;
                  };
                };
              } ;
          };
        } ;
      };
    } ;

} CEU_Main;






#endif

#ifndef _CEU_OS_H
#define _CEU_OS_H

#include <stddef.h>
#include "ceu_types.h"

#ifdef CEU_DEBUG
#include <assert.h>
#endif

#if defined(CEU_OS) && defined(__AVR)
#error Understand this again!
#include "Arduino.h"
#define CEU_ISR
#define CEU_ISR_ON()  interrupts()
#define CEU_ISR_OFF() noInterrupts()
#else
#define CEU_ISR_ON()
#define CEU_ISR_OFF()
#endif

#if defined(CEU_OS_KERNEL) || defined(CEU_OS_APP)
#define CEU_OS
#endif

#if defined(CEU_ORGS_NEWS) || defined(CEU_ADTS_NEWS)
#define CEU_NEWS
#endif
#if defined(CEU_ORGS_NEWS_POOL) || defined(CEU_ADTS_NEWS_POOL)
#define CEU_NEWS_POOL
#endif
#if defined(CEU_ORGS_AWAIT) || defined(CEU_ADTS_AWAIT)
#define CEU_ORGS_OR_ADTS_AWAIT
#endif

#ifdef CEU_OS

    /* TODO: all should be configurable */
    #define CEU_EXTS
    #define CEU_WCLOCKS
    #define CEU_ASYNCS
    #define CEU_RET
    #define CEU_CLEAR
    #define CEU_STACK_CLEAR
#ifndef __AVR
#endif
    #define CEU_INTS
    #define CEU_ORGS
    /*#define CEU_PSES*/ /* TODO: never tried */
    #define CEU_NEWS
    #define CEU_NEWS_POOL
    #define CEU_ORGS_NEWS
    #define CEU_ORGS_NEWS_MALLOC
    #define CEU_ORGS_NEWS_POOL
    #define CEU_ADTS_NEWS
    #define CEU_ADTS_NEWS_MALLOC
    #define CEU_ADTS_NEWS_POOL
    #define CEU_ORGS_AWAIT
    #define CEU_ADTS_AWAIT
    #define CEU_ORGS_OR_ADTS_AWAIT
/*
    #define CEU_THREADS
*/

#ifdef __AVR
    #define CEU_QUEUE_MAX 256
#else
    #define CEU_QUEUE_MAX 65536
#endif

    #define CEU_IN__NONE          0
    #define CEU_IN__ORG         255
    #define CEU_IN__ORG_PSED    254
    #define CEU_IN__CLEAR       253
    #define CEU_IN__ok_killed   252
    #define CEU_IN__INIT        251     /* HIGHER EXTERNAL */
    #define CEU_IN__ASYNC       250
    #define CEU_IN__THREAD      249
    #define CEU_IN__WCLOCK      248
    #define CEU_IN_OS_START     247
    #define CEU_IN_OS_STOP      246
    #define CEU_IN_OS_DT        245
    #define CEU_IN_OS_INTERRUPT 244
#ifdef CEU_TIMEMACHINE
    #define CEU_IN__WCLOCK_     243
    #define CEU_IN              243
#else
    #define CEU_IN              242
#endif

    #define CEU_IN_higher       CEU_IN__INIT  /* _INIT = HIGHER EXTERNAL */
    #define CEU_IN_lower        128     /* TODO: not checked from up and down */

    typedef s8 tceu_nlbl;   /* TODO: to small!! */

#endif /* CEU_OS */

#ifdef CEU_OS_APP

    #define ceu_out_log(mode,str) \
        ((__typeof__(ceu_sys_log)*)((_ceu_app)->sys_vec[CEU_SYS_LOG]))(mode,str)

    #define ceu_out_assert(v) \
        ((__typeof__(ceu_sys_assert)*)((_ceu_app)->sys_vec[CEU_SYS_ASSERT]))(v)

    #define ceu_out_assert_msg_ex(v,msg,file,line)       \
        {                                                \
            int __ceu_v = v;                             \
            if ((!(__ceu_v)) && ((msg)!=NULL)) {         \
                ceu_out_log(0, (long)"[");               \
                ceu_out_log(0, (long)(file));            \
                ceu_out_log(0, (long)":");               \
                ceu_out_log(2, (line));                  \
                ceu_out_log(0, (long)"] ");              \
                ceu_out_log(0, (long)"runtime error: "); \
                ceu_out_log(0, (long)(msg));             \
                ceu_out_log(0, (long)"\n");              \
            }                                            \
            ((__typeof__(ceu_sys_assert)*)((_ceu_app)->sys_vec[CEU_SYS_ASSERT]))(__ceu_v); \
        }
    #define ceu_out_assert_msg(v,msg) ceu_out_assert_msg_ex((v),(msg),__FILE__,__LINE__)

    #define ceu_out_realloc(ptr, size) \
        ((__typeof__(ceu_sys_realloc)*)((_ceu_app)->sys_vec[CEU_SYS_REALLOC]))(ptr,size)

    #define ceu_out_req() \
        ((__typeof__(ceu_sys_req)*)((_ceu_app)->sys_vec[CEU_SYS_REQ]))()

    #define ceu_out_load(addr) \
        ((__typeof__(ceu_sys_load)*)((_ceu_app)->sys_vec[CEU_SYS_LOAD]))(addr)

#ifdef CEU_ISR
    #define ceu_out_isr(n,f) \
        ((__typeof__(ceu_sys_isr)*)((_ceu_app)->sys_vec[CEU_SYS_ISR]))(n,f,_ceu_app)
#endif

    #define ceu_out_org_init(app,org,n,lbl,cls,isDyn,parent_org,parent_trl) \
        ((__typeof__(ceu_sys_org_init)*)((app)->sys_vec[CEU_SYS_ORG]))(org,n,lbl,cls,isDyn,parent_org,parent_trl)
    #define ceu_out_start(app) \
        ((__typeof__(ceu_sys_start)*)((_ceu_app)->sys_vec[CEU_SYS_START]))(app)
    #define ceu_out_link(app1,evt1 , app2,evt2) \
        ((__typeof__(ceu_sys_link)*)((_ceu_app)->sys_vec[CEU_SYS_LINK]))(app1,evt1,app2,evt2)

    #define ceu_out_emit(app,id,sz,buf) \
        ((__typeof__(ceu_sys_emit)*)((app)->sys_vec[CEU_SYS_EMIT]))(app,id,sz,buf)

    #define ceu_out_call(app,id,param) \
        ((__typeof__(ceu_sys_call)*)((app)->sys_vec[CEU_SYS_CALL]))(app,id,param)

#ifdef CEU_WCLOCKS
    #define ceu_out_wclock(app,dt,set,get) \
        ((__typeof__(ceu_sys_wclock)*)((app)->sys_vec[CEU_SYS_WCLOCK]))(app,dt,set,get)
#ifdef CEU_TIMEMACHINE
    #error TIMEMACHINE
#endif
#endif

    #define ceu_out_go(app,evt,evtp) \
        ((__typeof__(ceu_sys_go)*)((app)->sys_vec[CEU_SYS_GO]))(app,evt,evtp)

#else /* ! CEU_OS_APP (!CEU_OS||CEU_OS_KERNEL) */

    #ifndef ceu_out_assert
        #error "Missing definition for macro \"ceu_out_assert\"."
    #endif

    #ifndef ceu_out_log
        #error "Missing definition for macro \"ceu_out_log\"."
    #endif

    #define ceu_out_assert_msg_ex(v,msg,file,line)          \
        {                                                   \
            int __ceu_v = v;                                \
            if ((!(__ceu_v)) && ((msg)!=NULL)) {            \
                ceu_out_log(0, (long)"[");                  \
                ceu_out_log(0, (long)(file));               \
                ceu_out_log(0, (long)":");                  \
                ceu_out_log(2, line);                       \
                ceu_out_log(0, (long)"] ");                 \
                ceu_out_log(0, (long)"runtime error: ");    \
                ceu_out_log(0, (long)(msg));                \
                ceu_out_log(0, (long)"\n");                 \
            }                                               \
            ceu_out_assert(__ceu_v);                        \
        }
    #define ceu_out_assert_msg(v,msg) ceu_out_assert_msg_ex((v),(msg),__FILE__,__LINE__)

    #define ceu_out_realloc(ptr,size) \
            ceu_sys_realloc(ptr,size)
    #define ceu_out_req() \
            ceu_sys_req()
    #define ceu_out_org_init(app,org,n,lbl,cls,isDyn,parent_org,parent_trl) \
            ceu_sys_org_init(org,n,lbl,cls,isDyn,parent_org,parent_trl)

#ifdef CEU_WCLOCKS
    #define ceu_out_wclock(app,dt,set,get) \
            ceu_sys_wclock(app,dt,set,get)
#ifdef CEU_TIMEMACHINE
    #define ceu_out_wclock_(app,dt,set,get) \
            ceu_sys_wclock_(app,dt,set,get)
#endif
#endif
    #define ceu_out_go(app,evt,evtp) \
            ceu_sys_go(app,evt,evtp)
    #define ceu_out_go_stk(app,evt,evtp,stk) \
            ceu_sys_go_stk(app,evt,evtp,stk)

#endif /* ! CEU_OS_APP (!CEU_OS||CEU_OS_KERNEL) */

#ifdef CEU_STACK_CLEAR
#define ceu_in_emit(app,id,n,buf) \
    ceu_out_go_stk(app,id,buf,&stk_)
#else
#define ceu_in_emit(app,id,n,buf) \
    ceu_out_go_stk(app,id,buf,NULL)
#endif

#ifdef CEU_THREADS
/* TODO: app */
#include "ceu_threads.h"
#endif

#ifdef CEU_LUA
#include <stdio.h>      /* BUFSIZ */
#include <string.h>     /* strcpy */
#if defined(__ANDROID__) || defined(CEU_OS)
    #include "lua.h"
    #include "lauxlib.h"
    #include "lualib.h"
#else
    #include <lua5.1/lua.h>
    #include <lua5.1/lauxlib.h>
    #include <lua5.1/lualib.h>
#endif

#ifdef CEU_OS_APP
    #define ceu_luaL_newstate(set) { \
        set = ceu_out_call(_ceu_app, CEU_OUT_LUA_NEW, NULL); \
    }

    #define ceu_luaL_openlibs(l) { \
        lua_State* p = l;          \
        ceu_out_call(_ceu_app, CEU_OUT_LUAL_OPENLIBS, &p); \
    }

    #define ceu_lua_atpanic(l, f) {     \
    }

    #define ceu_luaL_loadstring(set, l, str) {  \
        tceu__lua_State___char_ p = { l, str }; \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUAL_LOADSTRING, &p); \
    }

    #define ceu_lua_pushnumber(l, v) {      \
        tceu__lua_State___int p = { l, v }; \
        ceu_out_call(_ceu_app, CEU_OUT_LUA_PUSHNUMBER, &p); \
    }

    #define ceu_lua_pushstring(l, v) {      \
        tceu__lua_State___char_ p = { l, v }; \
        ceu_out_call(_ceu_app, CEU_OUT_LUA_PUSHSTRING, &p); \
    }

    #define ceu_lua_pushlightuserdata(l, v) {   \
        tceu__lua_State___void_ p = { l, v };     \
        ceu_out_call(_ceu_app, CEU_OUT_LUA_PUSHLIGHTUSERDATA, &p); \
    }

    #define ceu_lua_pcall(set,l,nargs,nrets,err) {                  \
        tceu__lua_State___int__int__int p = { l, nargs, nrets, err }; \
        ceu_out_call(_ceu_app, CEU_OUT_LUA_PCALL, &p); \
    }

    #define ceu_lua_isnumber(set, l, idx) {     \
        tceu__lua_State___int p = { l, idx };   \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUA_ISNUMBER, &p); \
    }

    #define ceu_lua_tonumber(set, l, idx) {     \
        tceu__lua_State___int p = { l, idx };   \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUA_TONUMBER, &p); \
    }

    #define ceu_lua_isboolean(set, l, idx) {    \
        tceu__lua_State___int p = { l, idx };   \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUA_ISBOOLEAN, &p); \
    }

    #define ceu_lua_toboolean(set, l, idx) {    \
        tceu__lua_State___int p = { l, idx };   \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUA_TOBOOLEAN, &p); \
    }

    #define ceu_lua_pop(l, n) {             \
        tceu__lua_State___int p = { l, n }; \
        ceu_out_call(_ceu_app, CEU_OUT_LUA_POP, &p); \
    }

    #define ceu_lua_isstring(set, l, idx) {     \
        tceu__lua_State___int p = { l, idx };   \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUA_ISSTRING, &p); \
    }

    #define ceu_lua_tostring(set, l, idx) {     \
        tceu__lua_State___int p = { l, idx };   \
        set = ceu_out_call(_ceu_app, CEU_OUT_LUA_TOSTRING, &p); \
    }

    #define ceu_lua_islightuserdata(set, l, idx) {  \
        tceu__lua_State___int p = { l, idx };       \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUA_ISLIGHTUSERDATA, &p); \
    }

    #define ceu_lua_touserdata(set, l, idx) {   \
        tceu__lua_State___int p = { l, idx };   \
        set = ceu_out_call(_ceu_app, CEU_OUT_LUA_TOUSERDATA, &p); \
    }

    #define ceu_lua_error(l) {                          \
        lua_State** p = &l;                             \
        ceu_out_call(_ceu_app, CEU_OUT_LUA_ERROR, &p);  \
    }

    #define ceu_lua_objlen(set, l, idx) {                       \
        tceu__lua_State___int p = { l, idx };                   \
        set = ceu_out_call(_ceu_app, CEU_OUT_LUA_OBJLEN, &p);   \
    }

#else
    #define ceu_luaL_newstate(set)               set = luaL_newstate()
    #define ceu_luaL_openlibs(l)                 luaL_openlibs(l)
    #define ceu_lua_atpanic(l,f)                 lua_atpanic(l,f)
    #define ceu_luaL_loadstring(set,l,str)       set = luaL_loadstring(l,str)
    #define ceu_lua_pushnumber(l,v)              lua_pushnumber(l,v)
    #define ceu_lua_pushstring(l,v)              lua_pushstring(l,v)
    #define ceu_lua_pushlightuserdata(l,v)       lua_pushlightuserdata(l,v)
    #define ceu_lua_pcall(set,l,nargs,nrets,err) set = lua_pcall(l,nargs,nrets,err)
    #define ceu_lua_isnumber(set,l,idx)          set = lua_isnumber(l,idx)
    #define ceu_lua_tonumber(set,l,idx)          set = lua_tonumber(l,idx)
    #define ceu_lua_isboolean(set,l,idx)         set = lua_isboolean(l,idx)
    #define ceu_lua_toboolean(set,l,idx)         set = lua_toboolean(l,idx)
    #define ceu_lua_pop(l,n)                     lua_pop(l,n)
    #define ceu_lua_isstring(set,l,idx)          set = lua_isstring(l,idx)
    #define ceu_lua_tostring(set,l,idx)          set = lua_tostring(l,idx)
    #define ceu_lua_islightuserdata(set,l,idx)   set = lua_islightuserdata(l,idx)
    #define ceu_lua_touserdata(set,l,idx)        set = lua_touserdata(l,idx)
    #define ceu_lua_error(l)                     lua_error(l)
    #define ceu_lua_objlen(set,l,idx)            set = lua_objlen(l,idx)
#endif
#endif

typedef u8 tceu_nevt;   /* max number of events */
                        /* TODO: should "u8" be fixed? */

typedef u8 tceu_ntrl;   /* max number of trails per class */
                        /* TODO: should "u8" be fixed? */

#ifdef CEU_STACK_CLEAR
typedef u16 tceu_nstk;  /* max size of internal stack in bytes */
                        /* TODO: should "u16" be fixed? */
#endif

#ifdef __cplusplus
#define CEU_WCLOCK_INACTIVE 0x7fffffffL     /* TODO */
#else
#define CEU_WCLOCK_INACTIVE INT32_MAX
#endif
#define CEU_WCLOCK_EXPIRED (CEU_WCLOCK_INACTIVE-1)

/* TCEU_TRL */

struct tceu_org;
typedef union tceu_trl {
    tceu_nevt evt;

    /* normal await // IN__CLEAR */
    struct {                    /* TODO(ram): bitfields */
        tceu_nevt evt1;
        tceu_nlbl lbl;
        u8        seqno;        /* TODO(ram): 2 bits is enough */
#ifdef CEU_INTS                 /* R-9: size of trails for internal events */
#ifdef CEU_ORGS
        void*     evto;
#endif
#endif
    };

    /* IN__ORG */
#ifdef CEU_ORGS
    struct {                    /* TODO(ram): bad for alignment */
        tceu_nevt evt3;
        struct tceu_org* org;
    };
#endif

    /* _ok_killed */
#ifdef CEU_ORGS_OR_ADTS_AWAIT
    struct {
        tceu_nevt evt4;
        tceu_nlbl lbl4;
#ifdef CEU_ORGS_AWAIT
#ifdef CEU_ADTS_AWAIT
        u8        is_org;
#endif
#endif
        void*     org_or_adt;
    };
#endif
} tceu_trl;

/* TCEU_EVT */

typedef struct tceu_evt {
    tceu_nevt id;
    void*     param;
#if defined(CEU_ORGS) && defined(CEU_INTS)
    void*     org;      /* emitting org */
#endif
} tceu_evt;

/* TCEU_ORG */

struct tceu_pool_orgs;
typedef struct tceu_org
{
#ifdef CEU_ORGS
    struct tceu_org* nxt; /* first field because of free list for orgs/adts */
    struct tceu_org* prv;
    struct tceu_org* parent_org;
    tceu_ntrl parent_trl;
#endif

#if defined(CEU_ORGS) || defined(CEU_OS)
    tceu_ntrl n;            /* number of trails (TODO(ram): opt, metadata) */
#endif

#ifdef CEU_ORGS

#ifdef CEU_IFCS
    tceu_ncls cls;          /* class id */
#endif
    u8 isAlive: 1;          /* Three purposes:
                             * - avoids double free
                             * - required by "watching o" to avoid awaiting a
                             *      dead org
                             * - required by "Do T" to avoid awaiting a dead 
                             *      org
                             */
#if defined(CEU_ORGS_NEWS) || defined(CEU_ORGS_AWAIT)
#endif
#ifdef CEU_ORGS_NEWS
    u8 isDyn: 1;            /* created w/ new or spawn? */
#endif
#ifdef CEU_ORGS_NEWS_POOL
    struct tceu_pool_orgs* pool;
#endif

#ifdef CEU_ORGS_AWAIT
    int ret;
#endif

#endif  /* CEU_ORGS */

    tceu_trl trls[0];       /* first trail */

} tceu_org;

/* TCEU_POOL_ORGS , TCEU_POOL_ADTS */

#if defined(CEU_ORGS_NEWS_POOL) || defined(CEU_ADTS_NEWS_POOL)
#ifndef _CEU_POOL_H
#define _CEU_POOL_H

#include "ceu_types.h"

/* TODO: all "int" here, should evaluate the correct unsigned type */

typedef struct {
    byte**  queue;
                    /* queue is in the next offset to distinguish dynamic(NULL)
                       from static pools(any-address) */
    int     size;
    int     free;
    int     index;
    int     unit;
    byte*   mem;
} tceu_pool;

#define CEU_POOL_DCL(name, type, size) \
    type*     name##_queue[size];      \
    type      name##_mem[size];        \
    tceu_pool name;

void ceu_pool_init (tceu_pool* pool, int size, int unit, byte** queue, byte* mem);
byte* ceu_pool_alloc (tceu_pool* pool);
void ceu_pool_free (tceu_pool* pool, byte* val);

#endif

/*
 * Ceu pool.c is based on Contiki and TinyOS pools:
 * https://github.com/contiki-os/contiki/blob/master/core/lib/memb.c
 * https://github.com/tinyos/tinyos-main/blob/master/tos/system/PoolP.nc
 */
#ifndef _CEU_POOL_C
#define _CEU_POOL_C

#include <stdlib.h>


void ceu_pool_init (tceu_pool* pool, int size, int unit, byte** queue, byte* mem)
{
    int i;
    pool->size  = size;
    pool->free  = size;
    pool->index = 0;
    pool->unit  = unit;
    pool->queue = queue;
    pool->mem   = mem;
    for (i=0; i<size; i++) {
        queue[i] = &mem[i*unit];
    }
}

byte* ceu_pool_alloc (tceu_pool* pool) {
    byte* ret;

    if (pool->free == 0) {
        return NULL;
    }

    pool->free--;
    ret = pool->queue[pool->index];
    pool->queue[pool->index++] = NULL;
    if (pool->index == pool->size) {
        pool->index = 0;
    }
    return ret;
}

void ceu_pool_free (tceu_pool* pool, byte* val) {
    int empty = pool->index + pool->free;
    if (empty >= pool->size) {
        empty -= pool->size;
    }
    pool->queue[empty] = val;
    pool->free++;
}

/*
int ceu_pool_inside (tceu_pool* pool, byte* val) {
    return ((byte*)val >= pool->mem)
        && ((byte*)val < pool->mem+(pool->size*pool->unit));
}
*/

#endif

#endif

#ifdef CEU_ORGS_NEWS
typedef struct tceu_pool_orgs {
    tceu_org* parent_org;
    tceu_ntrl parent_trl;
#ifdef CEU_ORGS_NEWS_POOL
    tceu_pool pool;
#endif
} tceu_pool_orgs;
#endif

#ifdef CEU_ADTS_NEWS
typedef struct {
    void* root;
#ifdef CEU_ADTS_NEWS_POOL
    void* pool;
#endif
} tceu_pool_adts;
#endif

/* TCEU_KILL */

#ifdef CEU_ORGS_OR_ADTS_AWAIT
typedef struct tceu_kill {
    void*     org_or_adt;
    int       ret;
    tceu_ntrl t1;
    tceu_ntrl t2;
} tceu_kill;
#endif

/* TCEU_LST */

#ifdef CEU_DEBUG
typedef struct tceu_lst {
#ifdef CEU_ORGS
    void*     org;
#endif
    tceu_trl* trl;
    tceu_nlbl lbl;
} tceu_lst;

#endif

/* TCEU_STK */

#ifdef CEU_STACK_CLEAR
typedef struct tceu_stk {
    struct tceu_stk* down;
    tceu_org*   org;
    tceu_ntrl   trl1;
    tceu_ntrl   trl2;
    char        is_alive;
} tceu_stk;
#else
typedef void tceu_stk;
#endif

/* TCEU_APP */

typedef struct tceu_app {
    /* global seqno: incremented on every reaction
     * awaiting trails matches only if trl->seqno < seqno,
     * i.e., previously awaiting the event
     */
    u8 seqno:          2;
#if defined(CEU_RET) || defined(CEU_OS)
    u8 isAlive:        1;
#endif
#ifdef CEU_ASYNCS
    u8 pendingAsyncs:  1;
#endif
#if defined(CEU_ORGS_NEWS_MALLOC) && defined(CEU_ORGS_AWAIT)
    u8 dont_emit_kill: 1;
#endif

#ifdef CEU_OS
    struct tceu_app* nxt;
#endif

#if defined(CEU_RET) || defined(CEU_ORGS_AWAIT)
    int ret;
#endif

#ifdef CEU_ORGS_NEWS_MALLOC
    tceu_org* tofree;
#endif

#ifdef CEU_WCLOCKS
    s32         wclk_late;
    s32         wclk_min_set;   /* used to set */
    s32         wclk_min_cmp;   /* used to compare */
                                /* cmp<-set every reaction */
#ifdef CEU_TIMEMACHINE
    s32         wclk_late_;
    s32         wclk_min_set_;
    s32         wclk_min_cmp_;
#endif
#endif

#ifndef CEU_OS
#ifdef CEU_DEBUG
    tceu_lst    lst; /* segfault printf */
#endif
#endif

#ifdef CEU_THREADS
    CEU_THREADS_MUTEX_T threads_mutex;
    /*CEU_THREADS_COND_T  threads_cond;*/
    u8                  threads_n;          /* number of running threads */
        /* TODO: u8? */
#endif
#if defined(CEU_LUA) || defined(CEU_OS)
#ifdef CEU_LUA
    lua_State*  lua;    /* TODO: move to data? */
#else
    void*       lua;
#endif
#endif

    void        (*code)  (struct tceu_app*,tceu_evt*,tceu_org*,tceu_trl*,tceu_stk*);
    void        (*init)  (struct tceu_app*);
#ifdef CEU_OS
    void*       (*calls) (struct tceu_app*,tceu_nevt,void*);
    void**      sys_vec;
    void*       addr;
#ifdef CEU_OS_LUAIFC
    char*       luaifc;
#endif
#endif
    tceu_org*   data;
} tceu_app;

#ifdef CEU_OS
typedef void (*tceu_init)   (tceu_app* app);
typedef void (*tceu_export) (uint* size, tceu_init** init
#ifdef CEU_OS_LUAIFC
                            , char** luaifc
#endif
);
#endif

/* TCEU_THREADS_P */

#ifdef CEU_THREADS
typedef struct {
    tceu_app* app;
    tceu_org* org;
    s8*       st; /* thread state:
                   * 0=ini (sync  spawns)
                   * 1=cpy (async copies)
                   * 2=lck (sync  locks)
                   * 3=end (sync/async terminates)
                   */
} tceu_threads_p;
#endif

#ifdef CEU_PSES
void ceu_pause (tceu_trl* trl, tceu_trl* trlF, int psed);
#endif

int  ceu_go_all    (tceu_app* app);

#ifdef CEU_WCLOCKS
int       ceu_sys_wclock (tceu_app* app, s32 dt, s32* set, s32* get);
#endif
void      ceu_sys_go     (tceu_app* app, int evt, void* evtp);

#ifdef CEU_OS

/* TCEU_LINK */

typedef struct tceu_lnk {
    tceu_app* src_app;
    tceu_nevt src_evt;
    tceu_app* dst_app;
    tceu_nevt dst_evt;
    struct tceu_lnk* nxt;
} tceu_lnk;

/* TCEU_QUEUE */

typedef struct {
    tceu_app* app;
    tceu_nevt evt;
#if CEU_QUEUE_MAX == 256
    s8        sz;
#else
    s16       sz;   /* signed because of fill */
#endif
    byte      buf[0];
} tceu_queue;

#ifdef CEU_ISR
typedef void(*tceu_isr_f)(tceu_app* app, tceu_org* org);
#endif

void ceu_os_init      (void);
int  ceu_os_scheduler (int(*dt)());
tceu_queue* ceu_sys_queue_nxt (void);
void        ceu_sys_queue_rem (void);

void      ceu_sys_assert    (int v);
void      ceu_sys_log       (int mode, long str);
void*     ceu_sys_realloc   (void* ptr, size_t size);
int       ceu_sys_req       (void);
tceu_app* ceu_sys_load      (void* addr);
#ifdef CEU_ISR
int       ceu_sys_isr       (int n, tceu_isr_f f, tceu_app* app);
#endif
void      ceu_sys_org_init  (tceu_org* org, int n, int lbl, int cls, int isDyn,
                             tceu_org* parent_org, tceu_ntrl parent_trl);
void      ceu_sys_start     (tceu_app* app);
int       ceu_sys_link      (tceu_app* src_app, tceu_nevt src_evt, tceu_app* dst_app, tceu_nevt dst_evt);
int       ceu_sys_unlink    (tceu_app* src_app, tceu_nevt src_evt, tceu_app* dst_app, tceu_nevt dst_evt);
int       ceu_sys_emit      (tceu_app* app, tceu_nevt evt, int sz, void* param);
void*     ceu_sys_call      (tceu_app* app, tceu_nevt evt, void* param);

enum {
    CEU_SYS_ASSERT = 0,
    CEU_SYS_LOG,
    CEU_SYS_REALLOC,
    CEU_SYS_REQ,
    CEU_SYS_LOAD,
#ifdef CEU_ISR
    CEU_SYS_ISR,
#endif
#ifdef CEU_CLEAR
    CEU_SYS_CLEAR,
#endif
    CEU_SYS_STACK_PUSH,
#ifdef CEU_ORGS
    CEU_SYS_STACK_CLEAR_ORG,
#endif
    CEU_SYS_ORG,
#ifdef CEU_ORGS
    CEU_SYS_ORG_TRAIL,
    CEU_SYS_ORG_SPAWN,
#endif
    CEU_SYS_START,
    CEU_SYS_LINK,
    CEU_SYS_UNLINK,
    CEU_SYS_EMIT,
    CEU_SYS_CALL,
#ifdef CEU_WCLOCKS
    CEU_SYS_WCLOCK,
#endif
    CEU_SYS_GO,
    CEU_SYS_MAX
};

/* SYS_VECTOR
 */
extern void* CEU_SYS_VEC[CEU_SYS_MAX];

#endif  /* CEU_OS */

#endif  /* _CEU_OS_H */

#ifndef _CEU_OS_H
#define _CEU_OS_H

#include <stddef.h>
#include "ceu_types.h"

#ifdef CEU_DEBUG
#include <assert.h>
#endif

#if defined(CEU_OS) && defined(__AVR)
#error Understand this again!
#include "Arduino.h"
#define CEU_ISR
#define CEU_ISR_ON()  interrupts()
#define CEU_ISR_OFF() noInterrupts()
#else
#define CEU_ISR_ON()
#define CEU_ISR_OFF()
#endif

#if defined(CEU_OS_KERNEL) || defined(CEU_OS_APP)
#define CEU_OS
#endif

#if defined(CEU_ORGS_NEWS) || defined(CEU_ADTS_NEWS)
#define CEU_NEWS
#endif
#if defined(CEU_ORGS_NEWS_POOL) || defined(CEU_ADTS_NEWS_POOL)
#define CEU_NEWS_POOL
#endif
#if defined(CEU_ORGS_AWAIT) || defined(CEU_ADTS_AWAIT)
#define CEU_ORGS_OR_ADTS_AWAIT
#endif

#ifdef CEU_OS

    /* TODO: all should be configurable */
    #define CEU_EXTS
    #define CEU_WCLOCKS
    #define CEU_ASYNCS
    #define CEU_RET
    #define CEU_CLEAR
    #define CEU_STACK_CLEAR
#ifndef __AVR
#endif
    #define CEU_INTS
    #define CEU_ORGS
    /*#define CEU_PSES*/ /* TODO: never tried */
    #define CEU_NEWS
    #define CEU_NEWS_POOL
    #define CEU_ORGS_NEWS
    #define CEU_ORGS_NEWS_MALLOC
    #define CEU_ORGS_NEWS_POOL
    #define CEU_ADTS_NEWS
    #define CEU_ADTS_NEWS_MALLOC
    #define CEU_ADTS_NEWS_POOL
    #define CEU_ORGS_AWAIT
    #define CEU_ADTS_AWAIT
    #define CEU_ORGS_OR_ADTS_AWAIT
/*
    #define CEU_THREADS
*/

#ifdef __AVR
    #define CEU_QUEUE_MAX 256
#else
    #define CEU_QUEUE_MAX 65536
#endif

    #define CEU_IN__NONE          0
    #define CEU_IN__ORG         255
    #define CEU_IN__ORG_PSED    254
    #define CEU_IN__CLEAR       253
    #define CEU_IN__ok_killed   252
    #define CEU_IN__INIT        251     /* HIGHER EXTERNAL */
    #define CEU_IN__ASYNC       250
    #define CEU_IN__THREAD      249
    #define CEU_IN__WCLOCK      248
    #define CEU_IN_OS_START     247
    #define CEU_IN_OS_STOP      246
    #define CEU_IN_OS_DT        245
    #define CEU_IN_OS_INTERRUPT 244
#ifdef CEU_TIMEMACHINE
    #define CEU_IN__WCLOCK_     243
    #define CEU_IN              243
#else
    #define CEU_IN              242
#endif

    #define CEU_IN_higher       CEU_IN__INIT  /* _INIT = HIGHER EXTERNAL */
    #define CEU_IN_lower        128     /* TODO: not checked from up and down */

    typedef s8 tceu_nlbl;   /* TODO: to small!! */

#endif /* CEU_OS */

#ifdef CEU_OS_APP

    #define ceu_out_log(mode,str) \
        ((__typeof__(ceu_sys_log)*)((_ceu_app)->sys_vec[CEU_SYS_LOG]))(mode,str)

    #define ceu_out_assert(v) \
        ((__typeof__(ceu_sys_assert)*)((_ceu_app)->sys_vec[CEU_SYS_ASSERT]))(v)

    #define ceu_out_assert_msg_ex(v,msg,file,line)       \
        {                                                \
            int __ceu_v = v;                             \
            if ((!(__ceu_v)) && ((msg)!=NULL)) {         \
                ceu_out_log(0, (long)"[");               \
                ceu_out_log(0, (long)(file));            \
                ceu_out_log(0, (long)":");               \
                ceu_out_log(2, (line));                  \
                ceu_out_log(0, (long)"] ");              \
                ceu_out_log(0, (long)"runtime error: "); \
                ceu_out_log(0, (long)(msg));             \
                ceu_out_log(0, (long)"\n");              \
            }                                            \
            ((__typeof__(ceu_sys_assert)*)((_ceu_app)->sys_vec[CEU_SYS_ASSERT]))(__ceu_v); \
        }
    #define ceu_out_assert_msg(v,msg) ceu_out_assert_msg_ex((v),(msg),__FILE__,__LINE__)

    #define ceu_out_realloc(ptr, size) \
        ((__typeof__(ceu_sys_realloc)*)((_ceu_app)->sys_vec[CEU_SYS_REALLOC]))(ptr,size)

    #define ceu_out_req() \
        ((__typeof__(ceu_sys_req)*)((_ceu_app)->sys_vec[CEU_SYS_REQ]))()

    #define ceu_out_load(addr) \
        ((__typeof__(ceu_sys_load)*)((_ceu_app)->sys_vec[CEU_SYS_LOAD]))(addr)

#ifdef CEU_ISR
    #define ceu_out_isr(n,f) \
        ((__typeof__(ceu_sys_isr)*)((_ceu_app)->sys_vec[CEU_SYS_ISR]))(n,f,_ceu_app)
#endif

    #define ceu_out_org_init(app,org,n,lbl,cls,isDyn,parent_org,parent_trl) \
        ((__typeof__(ceu_sys_org_init)*)((app)->sys_vec[CEU_SYS_ORG]))(org,n,lbl,cls,isDyn,parent_org,parent_trl)
    #define ceu_out_start(app) \
        ((__typeof__(ceu_sys_start)*)((_ceu_app)->sys_vec[CEU_SYS_START]))(app)
    #define ceu_out_link(app1,evt1 , app2,evt2) \
        ((__typeof__(ceu_sys_link)*)((_ceu_app)->sys_vec[CEU_SYS_LINK]))(app1,evt1,app2,evt2)

    #define ceu_out_emit(app,id,sz,buf) \
        ((__typeof__(ceu_sys_emit)*)((app)->sys_vec[CEU_SYS_EMIT]))(app,id,sz,buf)

    #define ceu_out_call(app,id,param) \
        ((__typeof__(ceu_sys_call)*)((app)->sys_vec[CEU_SYS_CALL]))(app,id,param)

#ifdef CEU_WCLOCKS
    #define ceu_out_wclock(app,dt,set,get) \
        ((__typeof__(ceu_sys_wclock)*)((app)->sys_vec[CEU_SYS_WCLOCK]))(app,dt,set,get)
#ifdef CEU_TIMEMACHINE
    #error TIMEMACHINE
#endif
#endif

    #define ceu_out_go(app,evt,evtp) \
        ((__typeof__(ceu_sys_go)*)((app)->sys_vec[CEU_SYS_GO]))(app,evt,evtp)

#else /* ! CEU_OS_APP (!CEU_OS||CEU_OS_KERNEL) */

    #ifndef ceu_out_assert
        #error "Missing definition for macro \"ceu_out_assert\"."
    #endif

    #ifndef ceu_out_log
        #error "Missing definition for macro \"ceu_out_log\"."
    #endif

    #define ceu_out_assert_msg_ex(v,msg,file,line)          \
        {                                                   \
            int __ceu_v = v;                                \
            if ((!(__ceu_v)) && ((msg)!=NULL)) {            \
                ceu_out_log(0, (long)"[");                  \
                ceu_out_log(0, (long)(file));               \
                ceu_out_log(0, (long)":");                  \
                ceu_out_log(2, line);                       \
                ceu_out_log(0, (long)"] ");                 \
                ceu_out_log(0, (long)"runtime error: ");    \
                ceu_out_log(0, (long)(msg));                \
                ceu_out_log(0, (long)"\n");                 \
            }                                               \
            ceu_out_assert(__ceu_v);                        \
        }
    #define ceu_out_assert_msg(v,msg) ceu_out_assert_msg_ex((v),(msg),__FILE__,__LINE__)

    #define ceu_out_realloc(ptr,size) \
            ceu_sys_realloc(ptr,size)
    #define ceu_out_req() \
            ceu_sys_req()
    #define ceu_out_org_init(app,org,n,lbl,cls,isDyn,parent_org,parent_trl) \
            ceu_sys_org_init(org,n,lbl,cls,isDyn,parent_org,parent_trl)

#ifdef CEU_WCLOCKS
    #define ceu_out_wclock(app,dt,set,get) \
            ceu_sys_wclock(app,dt,set,get)
#ifdef CEU_TIMEMACHINE
    #define ceu_out_wclock_(app,dt,set,get) \
            ceu_sys_wclock_(app,dt,set,get)
#endif
#endif
    #define ceu_out_go(app,evt,evtp) \
            ceu_sys_go(app,evt,evtp)
    #define ceu_out_go_stk(app,evt,evtp,stk) \
            ceu_sys_go_stk(app,evt,evtp,stk)

#endif /* ! CEU_OS_APP (!CEU_OS||CEU_OS_KERNEL) */

#ifdef CEU_STACK_CLEAR
#define ceu_in_emit(app,id,n,buf) \
    ceu_out_go_stk(app,id,buf,&stk_)
#else
#define ceu_in_emit(app,id,n,buf) \
    ceu_out_go_stk(app,id,buf,NULL)
#endif

#ifdef CEU_THREADS
/* TODO: app */
#include "ceu_threads.h"
#endif

#ifdef CEU_LUA
#include <stdio.h>      /* BUFSIZ */
#include <string.h>     /* strcpy */
#if defined(__ANDROID__) || defined(CEU_OS)
    #include "lua.h"
    #include "lauxlib.h"
    #include "lualib.h"
#else
    #include <lua5.1/lua.h>
    #include <lua5.1/lauxlib.h>
    #include <lua5.1/lualib.h>
#endif

#ifdef CEU_OS_APP
    #define ceu_luaL_newstate(set) { \
        set = ceu_out_call(_ceu_app, CEU_OUT_LUA_NEW, NULL); \
    }

    #define ceu_luaL_openlibs(l) { \
        lua_State* p = l;          \
        ceu_out_call(_ceu_app, CEU_OUT_LUAL_OPENLIBS, &p); \
    }

    #define ceu_lua_atpanic(l, f) {     \
    }

    #define ceu_luaL_loadstring(set, l, str) {  \
        tceu__lua_State___char_ p = { l, str }; \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUAL_LOADSTRING, &p); \
    }

    #define ceu_lua_pushnumber(l, v) {      \
        tceu__lua_State___int p = { l, v }; \
        ceu_out_call(_ceu_app, CEU_OUT_LUA_PUSHNUMBER, &p); \
    }

    #define ceu_lua_pushstring(l, v) {      \
        tceu__lua_State___char_ p = { l, v }; \
        ceu_out_call(_ceu_app, CEU_OUT_LUA_PUSHSTRING, &p); \
    }

    #define ceu_lua_pushlightuserdata(l, v) {   \
        tceu__lua_State___void_ p = { l, v };     \
        ceu_out_call(_ceu_app, CEU_OUT_LUA_PUSHLIGHTUSERDATA, &p); \
    }

    #define ceu_lua_pcall(set,l,nargs,nrets,err) {                  \
        tceu__lua_State___int__int__int p = { l, nargs, nrets, err }; \
        ceu_out_call(_ceu_app, CEU_OUT_LUA_PCALL, &p); \
    }

    #define ceu_lua_isnumber(set, l, idx) {     \
        tceu__lua_State___int p = { l, idx };   \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUA_ISNUMBER, &p); \
    }

    #define ceu_lua_tonumber(set, l, idx) {     \
        tceu__lua_State___int p = { l, idx };   \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUA_TONUMBER, &p); \
    }

    #define ceu_lua_isboolean(set, l, idx) {    \
        tceu__lua_State___int p = { l, idx };   \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUA_ISBOOLEAN, &p); \
    }

    #define ceu_lua_toboolean(set, l, idx) {    \
        tceu__lua_State___int p = { l, idx };   \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUA_TOBOOLEAN, &p); \
    }

    #define ceu_lua_pop(l, n) {             \
        tceu__lua_State___int p = { l, n }; \
        ceu_out_call(_ceu_app, CEU_OUT_LUA_POP, &p); \
    }

    #define ceu_lua_isstring(set, l, idx) {     \
        tceu__lua_State___int p = { l, idx };   \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUA_ISSTRING, &p); \
    }

    #define ceu_lua_tostring(set, l, idx) {     \
        tceu__lua_State___int p = { l, idx };   \
        set = ceu_out_call(_ceu_app, CEU_OUT_LUA_TOSTRING, &p); \
    }

    #define ceu_lua_islightuserdata(set, l, idx) {  \
        tceu__lua_State___int p = { l, idx };       \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUA_ISLIGHTUSERDATA, &p); \
    }

    #define ceu_lua_touserdata(set, l, idx) {   \
        tceu__lua_State___int p = { l, idx };   \
        set = ceu_out_call(_ceu_app, CEU_OUT_LUA_TOUSERDATA, &p); \
    }

    #define ceu_lua_error(l) {                          \
        lua_State** p = &l;                             \
        ceu_out_call(_ceu_app, CEU_OUT_LUA_ERROR, &p);  \
    }

    #define ceu_lua_objlen(set, l, idx) {                       \
        tceu__lua_State___int p = { l, idx };                   \
        set = ceu_out_call(_ceu_app, CEU_OUT_LUA_OBJLEN, &p);   \
    }

#else
    #define ceu_luaL_newstate(set)               set = luaL_newstate()
    #define ceu_luaL_openlibs(l)                 luaL_openlibs(l)
    #define ceu_lua_atpanic(l,f)                 lua_atpanic(l,f)
    #define ceu_luaL_loadstring(set,l,str)       set = luaL_loadstring(l,str)
    #define ceu_lua_pushnumber(l,v)              lua_pushnumber(l,v)
    #define ceu_lua_pushstring(l,v)              lua_pushstring(l,v)
    #define ceu_lua_pushlightuserdata(l,v)       lua_pushlightuserdata(l,v)
    #define ceu_lua_pcall(set,l,nargs,nrets,err) set = lua_pcall(l,nargs,nrets,err)
    #define ceu_lua_isnumber(set,l,idx)          set = lua_isnumber(l,idx)
    #define ceu_lua_tonumber(set,l,idx)          set = lua_tonumber(l,idx)
    #define ceu_lua_isboolean(set,l,idx)         set = lua_isboolean(l,idx)
    #define ceu_lua_toboolean(set,l,idx)         set = lua_toboolean(l,idx)
    #define ceu_lua_pop(l,n)                     lua_pop(l,n)
    #define ceu_lua_isstring(set,l,idx)          set = lua_isstring(l,idx)
    #define ceu_lua_tostring(set,l,idx)          set = lua_tostring(l,idx)
    #define ceu_lua_islightuserdata(set,l,idx)   set = lua_islightuserdata(l,idx)
    #define ceu_lua_touserdata(set,l,idx)        set = lua_touserdata(l,idx)
    #define ceu_lua_error(l)                     lua_error(l)
    #define ceu_lua_objlen(set,l,idx)            set = lua_objlen(l,idx)
#endif
#endif

typedef u8 tceu_nevt;   /* max number of events */
                        /* TODO: should "u8" be fixed? */

typedef u8 tceu_ntrl;   /* max number of trails per class */
                        /* TODO: should "u8" be fixed? */

#ifdef CEU_STACK_CLEAR
typedef u16 tceu_nstk;  /* max size of internal stack in bytes */
                        /* TODO: should "u16" be fixed? */
#endif

#ifdef __cplusplus
#define CEU_WCLOCK_INACTIVE 0x7fffffffL     /* TODO */
#else
#define CEU_WCLOCK_INACTIVE INT32_MAX
#endif
#define CEU_WCLOCK_EXPIRED (CEU_WCLOCK_INACTIVE-1)

/* TCEU_TRL */

struct tceu_org;
typedef union tceu_trl {
    tceu_nevt evt;

    /* normal await // IN__CLEAR */
    struct {                    /* TODO(ram): bitfields */
        tceu_nevt evt1;
        tceu_nlbl lbl;
        u8        seqno;        /* TODO(ram): 2 bits is enough */
#ifdef CEU_INTS                 /* R-9: size of trails for internal events */
#ifdef CEU_ORGS
        void*     evto;
#endif
#endif
    };

    /* IN__ORG */
#ifdef CEU_ORGS
    struct {                    /* TODO(ram): bad for alignment */
        tceu_nevt evt3;
        struct tceu_org* org;
    };
#endif

    /* _ok_killed */
#ifdef CEU_ORGS_OR_ADTS_AWAIT
    struct {
        tceu_nevt evt4;
        tceu_nlbl lbl4;
#ifdef CEU_ORGS_AWAIT
#ifdef CEU_ADTS_AWAIT
        u8        is_org;
#endif
#endif
        void*     org_or_adt;
    };
#endif
} tceu_trl;

/* TCEU_EVT */

typedef struct tceu_evt {
    tceu_nevt id;
    void*     param;
#if defined(CEU_ORGS) && defined(CEU_INTS)
    void*     org;      /* emitting org */
#endif
} tceu_evt;

/* TCEU_ORG */

struct tceu_pool_orgs;
typedef struct tceu_org
{
#ifdef CEU_ORGS
    struct tceu_org* nxt; /* first field because of free list for orgs/adts */
    struct tceu_org* prv;
    struct tceu_org* parent_org;
    tceu_ntrl parent_trl;
#endif

#if defined(CEU_ORGS) || defined(CEU_OS)
    tceu_ntrl n;            /* number of trails (TODO(ram): opt, metadata) */
#endif

#ifdef CEU_ORGS

#ifdef CEU_IFCS
    tceu_ncls cls;          /* class id */
#endif
    u8 isAlive: 1;          /* Three purposes:
                             * - avoids double free
                             * - required by "watching o" to avoid awaiting a
                             *      dead org
                             * - required by "Do T" to avoid awaiting a dead 
                             *      org
                             */
#if defined(CEU_ORGS_NEWS) || defined(CEU_ORGS_AWAIT)
#endif
#ifdef CEU_ORGS_NEWS
    u8 isDyn: 1;            /* created w/ new or spawn? */
#endif
#ifdef CEU_ORGS_NEWS_POOL
    struct tceu_pool_orgs* pool;
#endif

#ifdef CEU_ORGS_AWAIT
    int ret;
#endif

#endif  /* CEU_ORGS */

    tceu_trl trls[0];       /* first trail */

} tceu_org;

/* TCEU_POOL_ORGS , TCEU_POOL_ADTS */

#if defined(CEU_ORGS_NEWS_POOL) || defined(CEU_ADTS_NEWS_POOL)
#ifndef _CEU_POOL_H
#define _CEU_POOL_H

#include "ceu_types.h"

/* TODO: all "int" here, should evaluate the correct unsigned type */

typedef struct {
    byte**  queue;
                    /* queue is in the next offset to distinguish dynamic(NULL)
                       from static pools(any-address) */
    int     size;
    int     free;
    int     index;
    int     unit;
    byte*   mem;
} tceu_pool;

#define CEU_POOL_DCL(name, type, size) \
    type*     name##_queue[size];      \
    type      name##_mem[size];        \
    tceu_pool name;

void ceu_pool_init (tceu_pool* pool, int size, int unit, byte** queue, byte* mem);
byte* ceu_pool_alloc (tceu_pool* pool);
void ceu_pool_free (tceu_pool* pool, byte* val);

#endif

/*
 * Ceu pool.c is based on Contiki and TinyOS pools:
 * https://github.com/contiki-os/contiki/blob/master/core/lib/memb.c
 * https://github.com/tinyos/tinyos-main/blob/master/tos/system/PoolP.nc
 */
#ifndef _CEU_POOL_C
#define _CEU_POOL_C

#include <stdlib.h>


void ceu_pool_init (tceu_pool* pool, int size, int unit, byte** queue, byte* mem)
{
    int i;
    pool->size  = size;
    pool->free  = size;
    pool->index = 0;
    pool->unit  = unit;
    pool->queue = queue;
    pool->mem   = mem;
    for (i=0; i<size; i++) {
        queue[i] = &mem[i*unit];
    }
}

byte* ceu_pool_alloc (tceu_pool* pool) {
    byte* ret;

    if (pool->free == 0) {
        return NULL;
    }

    pool->free--;
    ret = pool->queue[pool->index];
    pool->queue[pool->index++] = NULL;
    if (pool->index == pool->size) {
        pool->index = 0;
    }
    return ret;
}

void ceu_pool_free (tceu_pool* pool, byte* val) {
    int empty = pool->index + pool->free;
    if (empty >= pool->size) {
        empty -= pool->size;
    }
    pool->queue[empty] = val;
    pool->free++;
}

/*
int ceu_pool_inside (tceu_pool* pool, byte* val) {
    return ((byte*)val >= pool->mem)
        && ((byte*)val < pool->mem+(pool->size*pool->unit));
}
*/

#endif

#endif

#ifdef CEU_ORGS_NEWS
typedef struct tceu_pool_orgs {
    tceu_org* parent_org;
    tceu_ntrl parent_trl;
#ifdef CEU_ORGS_NEWS_POOL
    tceu_pool pool;
#endif
} tceu_pool_orgs;
#endif

#ifdef CEU_ADTS_NEWS
typedef struct {
    void* root;
#ifdef CEU_ADTS_NEWS_POOL
    void* pool;
#endif
} tceu_pool_adts;
#endif

/* TCEU_KILL */

#ifdef CEU_ORGS_OR_ADTS_AWAIT
typedef struct tceu_kill {
    void*     org_or_adt;
    int       ret;
    tceu_ntrl t1;
    tceu_ntrl t2;
} tceu_kill;
#endif

/* TCEU_LST */

#ifdef CEU_DEBUG
typedef struct tceu_lst {
#ifdef CEU_ORGS
    void*     org;
#endif
    tceu_trl* trl;
    tceu_nlbl lbl;
} tceu_lst;

#endif

/* TCEU_STK */

#ifdef CEU_STACK_CLEAR
typedef struct tceu_stk {
    struct tceu_stk* down;
    tceu_org*   org;
    tceu_ntrl   trl1;
    tceu_ntrl   trl2;
    char        is_alive;
} tceu_stk;
#else
typedef void tceu_stk;
#endif

/* TCEU_APP */

typedef struct tceu_app {
    /* global seqno: incremented on every reaction
     * awaiting trails matches only if trl->seqno < seqno,
     * i.e., previously awaiting the event
     */
    u8 seqno:          2;
#if defined(CEU_RET) || defined(CEU_OS)
    u8 isAlive:        1;
#endif
#ifdef CEU_ASYNCS
    u8 pendingAsyncs:  1;
#endif
#if defined(CEU_ORGS_NEWS_MALLOC) && defined(CEU_ORGS_AWAIT)
    u8 dont_emit_kill: 1;
#endif

#ifdef CEU_OS
    struct tceu_app* nxt;
#endif

#if defined(CEU_RET) || defined(CEU_ORGS_AWAIT)
    int ret;
#endif

#ifdef CEU_ORGS_NEWS_MALLOC
    tceu_org* tofree;
#endif

#ifdef CEU_WCLOCKS
    s32         wclk_late;
    s32         wclk_min_set;   /* used to set */
    s32         wclk_min_cmp;   /* used to compare */
                                /* cmp<-set every reaction */
#ifdef CEU_TIMEMACHINE
    s32         wclk_late_;
    s32         wclk_min_set_;
    s32         wclk_min_cmp_;
#endif
#endif

#ifndef CEU_OS
#ifdef CEU_DEBUG
    tceu_lst    lst; /* segfault printf */
#endif
#endif

#ifdef CEU_THREADS
    CEU_THREADS_MUTEX_T threads_mutex;
    /*CEU_THREADS_COND_T  threads_cond;*/
    u8                  threads_n;          /* number of running threads */
        /* TODO: u8? */
#endif
#if defined(CEU_LUA) || defined(CEU_OS)
#ifdef CEU_LUA
    lua_State*  lua;    /* TODO: move to data? */
#else
    void*       lua;
#endif
#endif

    void        (*code)  (struct tceu_app*,tceu_evt*,tceu_org*,tceu_trl*,tceu_stk*);
    void        (*init)  (struct tceu_app*);
#ifdef CEU_OS
    void*       (*calls) (struct tceu_app*,tceu_nevt,void*);
    void**      sys_vec;
    void*       addr;
#ifdef CEU_OS_LUAIFC
    char*       luaifc;
#endif
#endif
    tceu_org*   data;
} tceu_app;

#ifdef CEU_OS
typedef void (*tceu_init)   (tceu_app* app);
typedef void (*tceu_export) (uint* size, tceu_init** init
#ifdef CEU_OS_LUAIFC
                            , char** luaifc
#endif
);
#endif

/* TCEU_THREADS_P */

#ifdef CEU_THREADS
typedef struct {
    tceu_app* app;
    tceu_org* org;
    s8*       st; /* thread state:
                   * 0=ini (sync  spawns)
                   * 1=cpy (async copies)
                   * 2=lck (sync  locks)
                   * 3=end (sync/async terminates)
                   */
} tceu_threads_p;
#endif

#ifdef CEU_PSES
void ceu_pause (tceu_trl* trl, tceu_trl* trlF, int psed);
#endif

int  ceu_go_all    (tceu_app* app);

#ifdef CEU_WCLOCKS
int       ceu_sys_wclock (tceu_app* app, s32 dt, s32* set, s32* get);
#endif
void      ceu_sys_go     (tceu_app* app, int evt, void* evtp);

#ifdef CEU_OS

/* TCEU_LINK */

typedef struct tceu_lnk {
    tceu_app* src_app;
    tceu_nevt src_evt;
    tceu_app* dst_app;
    tceu_nevt dst_evt;
    struct tceu_lnk* nxt;
} tceu_lnk;

/* TCEU_QUEUE */

typedef struct {
    tceu_app* app;
    tceu_nevt evt;
#if CEU_QUEUE_MAX == 256
    s8        sz;
#else
    s16       sz;   /* signed because of fill */
#endif
    byte      buf[0];
} tceu_queue;

#ifdef CEU_ISR
typedef void(*tceu_isr_f)(tceu_app* app, tceu_org* org);
#endif

void ceu_os_init      (void);
int  ceu_os_scheduler (int(*dt)());
tceu_queue* ceu_sys_queue_nxt (void);
void        ceu_sys_queue_rem (void);

void      ceu_sys_assert    (int v);
void      ceu_sys_log       (int mode, long str);
void*     ceu_sys_realloc   (void* ptr, size_t size);
int       ceu_sys_req       (void);
tceu_app* ceu_sys_load      (void* addr);
#ifdef CEU_ISR
int       ceu_sys_isr       (int n, tceu_isr_f f, tceu_app* app);
#endif
void      ceu_sys_org_init  (tceu_org* org, int n, int lbl, int cls, int isDyn,
                             tceu_org* parent_org, tceu_ntrl parent_trl);
void      ceu_sys_start     (tceu_app* app);
int       ceu_sys_link      (tceu_app* src_app, tceu_nevt src_evt, tceu_app* dst_app, tceu_nevt dst_evt);
int       ceu_sys_unlink    (tceu_app* src_app, tceu_nevt src_evt, tceu_app* dst_app, tceu_nevt dst_evt);
int       ceu_sys_emit      (tceu_app* app, tceu_nevt evt, int sz, void* param);
void*     ceu_sys_call      (tceu_app* app, tceu_nevt evt, void* param);

enum {
    CEU_SYS_ASSERT = 0,
    CEU_SYS_LOG,
    CEU_SYS_REALLOC,
    CEU_SYS_REQ,
    CEU_SYS_LOAD,
#ifdef CEU_ISR
    CEU_SYS_ISR,
#endif
#ifdef CEU_CLEAR
    CEU_SYS_CLEAR,
#endif
    CEU_SYS_STACK_PUSH,
#ifdef CEU_ORGS
    CEU_SYS_STACK_CLEAR_ORG,
#endif
    CEU_SYS_ORG,
#ifdef CEU_ORGS
    CEU_SYS_ORG_TRAIL,
    CEU_SYS_ORG_SPAWN,
#endif
    CEU_SYS_START,
    CEU_SYS_LINK,
    CEU_SYS_UNLINK,
    CEU_SYS_EMIT,
    CEU_SYS_CALL,
#ifdef CEU_WCLOCKS
    CEU_SYS_WCLOCK,
#endif
    CEU_SYS_GO,
    CEU_SYS_MAX
};

/* SYS_VECTOR
 */
extern void* CEU_SYS_VEC[CEU_SYS_MAX];

#endif  /* CEU_OS */

#endif  /* _CEU_OS_H */


#ifdef __AVR
#ifdef CEU_OS
#error Understand this again!
#include <avr/pgmspace.h>
void* CEU_APP_ADDR = NULL;
#endif
#endif

#include <string.h>

#ifdef CEU_DEBUG
#include <stdio.h>      /* printf */
#endif

#if defined(CEU_DEBUG) || defined(CEU_NEWS) || defined(CEU_THREADS) || defined(CEU_OS_KERNEL)
void *realloc(void *ptr, size_t size);
#endif

#ifdef CEU_NEWS_POOL
#ifndef _CEU_POOL_H
#define _CEU_POOL_H

#include "ceu_types.h"

/* TODO: all "int" here, should evaluate the correct unsigned type */

typedef struct {
    byte**  queue;
                    /* queue is in the next offset to distinguish dynamic(NULL)
                       from static pools(any-address) */
    int     size;
    int     free;
    int     index;
    int     unit;
    byte*   mem;
} tceu_pool;

#define CEU_POOL_DCL(name, type, size) \
    type*     name##_queue[size];      \
    type      name##_mem[size];        \
    tceu_pool name;

void ceu_pool_init (tceu_pool* pool, int size, int unit, byte** queue, byte* mem);
byte* ceu_pool_alloc (tceu_pool* pool);
void ceu_pool_free (tceu_pool* pool, byte* val);

#endif

/*
 * Ceu pool.c is based on Contiki and TinyOS pools:
 * https://github.com/contiki-os/contiki/blob/master/core/lib/memb.c
 * https://github.com/tinyos/tinyos-main/blob/master/tos/system/PoolP.nc
 */
#ifndef _CEU_POOL_C
#define _CEU_POOL_C

#include <stdlib.h>


void ceu_pool_init (tceu_pool* pool, int size, int unit, byte** queue, byte* mem)
{
    int i;
    pool->size  = size;
    pool->free  = size;
    pool->index = 0;
    pool->unit  = unit;
    pool->queue = queue;
    pool->mem   = mem;
    for (i=0; i<size; i++) {
        queue[i] = &mem[i*unit];
    }
}

byte* ceu_pool_alloc (tceu_pool* pool) {
    byte* ret;

    if (pool->free == 0) {
        return NULL;
    }

    pool->free--;
    ret = pool->queue[pool->index];
    pool->queue[pool->index++] = NULL;
    if (pool->index == pool->size) {
        pool->index = 0;
    }
    return ret;
}

void ceu_pool_free (tceu_pool* pool, byte* val) {
    int empty = pool->index + pool->free;
    if (empty >= pool->size) {
        empty -= pool->size;
    }
    pool->queue[empty] = val;
    pool->free++;
}

/*
int ceu_pool_inside (tceu_pool* pool, byte* val) {
    return ((byte*)val >= pool->mem)
        && ((byte*)val < pool->mem+(pool->size*pool->unit));
}
*/

#endif

#endif

/*
 * pthread_t thread;
 * pthread_mutex_t mutex;
 * pthread_cond_t  cond;
 * pthread_self();
        Uint32 SDL_ThreadID(void);
 * pthread_create(&thread, NULL, f, &p);
        SDL_Thread *SDL_CreateThread(int (*fn)(void *), void *data);
 * pthread_mutex_lock(&mutex);
 * pthread_mutex_unlock(&mutex);
 * pthread_cond_wait(&cond, &mutex);
 * pthread_cond_signal(&cond);
*/

/**********************************************************************
 * "APPS" running on the OS do not need any of the below.
 **********************************************************************/

#ifndef CEU_OS_APP

#ifdef CEU_NEWS
#ifdef CEU_RUNTESTS
#define CEU_MAX_DYNS 100
static int _ceu_dyns_ = 0;  /* check if total of alloc/free match */
#endif
#endif

#if defined(CEU_NEWS) || defined(CEU_THREADS) || defined(CEU_OS_KERNEL) || defined(CEU_VECTOR_MALLOC)
void* ceu_sys_realloc (void* ptr, size_t size) {
#ifdef CEU_NEWS
#ifdef CEU_RUNTESTS
    if (size == 0) {
        if (ptr != NULL) {
            _ceu_dyns_--;
        }
    } else {
        if (_ceu_dyns_ >= CEU_MAX_DYNS) {
            return NULL;
        }
        _ceu_dyns_++;           /* assumes no malloc fails */
    }
#endif
#endif
    return realloc(ptr, size);
}
#endif

#ifdef CEU_VECTOR
#ifndef _CEU_VECTOR_H
#define _CEU_VECTOR_H

#ifndef _CEU_OS_H
#define _CEU_OS_H

#include <stddef.h>
#include "ceu_types.h"

#ifdef CEU_DEBUG
#include <assert.h>
#endif

#if defined(CEU_OS) && defined(__AVR)
#error Understand this again!
#include "Arduino.h"
#define CEU_ISR
#define CEU_ISR_ON()  interrupts()
#define CEU_ISR_OFF() noInterrupts()
#else
#define CEU_ISR_ON()
#define CEU_ISR_OFF()
#endif

#if defined(CEU_OS_KERNEL) || defined(CEU_OS_APP)
#define CEU_OS
#endif

#if defined(CEU_ORGS_NEWS) || defined(CEU_ADTS_NEWS)
#define CEU_NEWS
#endif
#if defined(CEU_ORGS_NEWS_POOL) || defined(CEU_ADTS_NEWS_POOL)
#define CEU_NEWS_POOL
#endif
#if defined(CEU_ORGS_AWAIT) || defined(CEU_ADTS_AWAIT)
#define CEU_ORGS_OR_ADTS_AWAIT
#endif

#ifdef CEU_OS

    /* TODO: all should be configurable */
    #define CEU_EXTS
    #define CEU_WCLOCKS
    #define CEU_ASYNCS
    #define CEU_RET
    #define CEU_CLEAR
    #define CEU_STACK_CLEAR
#ifndef __AVR
#endif
    #define CEU_INTS
    #define CEU_ORGS
    /*#define CEU_PSES*/ /* TODO: never tried */
    #define CEU_NEWS
    #define CEU_NEWS_POOL
    #define CEU_ORGS_NEWS
    #define CEU_ORGS_NEWS_MALLOC
    #define CEU_ORGS_NEWS_POOL
    #define CEU_ADTS_NEWS
    #define CEU_ADTS_NEWS_MALLOC
    #define CEU_ADTS_NEWS_POOL
    #define CEU_ORGS_AWAIT
    #define CEU_ADTS_AWAIT
    #define CEU_ORGS_OR_ADTS_AWAIT
/*
    #define CEU_THREADS
*/

#ifdef __AVR
    #define CEU_QUEUE_MAX 256
#else
    #define CEU_QUEUE_MAX 65536
#endif

    #define CEU_IN__NONE          0
    #define CEU_IN__ORG         255
    #define CEU_IN__ORG_PSED    254
    #define CEU_IN__CLEAR       253
    #define CEU_IN__ok_killed   252
    #define CEU_IN__INIT        251     /* HIGHER EXTERNAL */
    #define CEU_IN__ASYNC       250
    #define CEU_IN__THREAD      249
    #define CEU_IN__WCLOCK      248
    #define CEU_IN_OS_START     247
    #define CEU_IN_OS_STOP      246
    #define CEU_IN_OS_DT        245
    #define CEU_IN_OS_INTERRUPT 244
#ifdef CEU_TIMEMACHINE
    #define CEU_IN__WCLOCK_     243
    #define CEU_IN              243
#else
    #define CEU_IN              242
#endif

    #define CEU_IN_higher       CEU_IN__INIT  /* _INIT = HIGHER EXTERNAL */
    #define CEU_IN_lower        128     /* TODO: not checked from up and down */

    typedef s8 tceu_nlbl;   /* TODO: to small!! */

#endif /* CEU_OS */

#ifdef CEU_OS_APP

    #define ceu_out_log(mode,str) \
        ((__typeof__(ceu_sys_log)*)((_ceu_app)->sys_vec[CEU_SYS_LOG]))(mode,str)

    #define ceu_out_assert(v) \
        ((__typeof__(ceu_sys_assert)*)((_ceu_app)->sys_vec[CEU_SYS_ASSERT]))(v)

    #define ceu_out_assert_msg_ex(v,msg,file,line)       \
        {                                                \
            int __ceu_v = v;                             \
            if ((!(__ceu_v)) && ((msg)!=NULL)) {         \
                ceu_out_log(0, (long)"[");               \
                ceu_out_log(0, (long)(file));            \
                ceu_out_log(0, (long)":");               \
                ceu_out_log(2, (line));                  \
                ceu_out_log(0, (long)"] ");              \
                ceu_out_log(0, (long)"runtime error: "); \
                ceu_out_log(0, (long)(msg));             \
                ceu_out_log(0, (long)"\n");              \
            }                                            \
            ((__typeof__(ceu_sys_assert)*)((_ceu_app)->sys_vec[CEU_SYS_ASSERT]))(__ceu_v); \
        }
    #define ceu_out_assert_msg(v,msg) ceu_out_assert_msg_ex((v),(msg),__FILE__,__LINE__)

    #define ceu_out_realloc(ptr, size) \
        ((__typeof__(ceu_sys_realloc)*)((_ceu_app)->sys_vec[CEU_SYS_REALLOC]))(ptr,size)

    #define ceu_out_req() \
        ((__typeof__(ceu_sys_req)*)((_ceu_app)->sys_vec[CEU_SYS_REQ]))()

    #define ceu_out_load(addr) \
        ((__typeof__(ceu_sys_load)*)((_ceu_app)->sys_vec[CEU_SYS_LOAD]))(addr)

#ifdef CEU_ISR
    #define ceu_out_isr(n,f) \
        ((__typeof__(ceu_sys_isr)*)((_ceu_app)->sys_vec[CEU_SYS_ISR]))(n,f,_ceu_app)
#endif

    #define ceu_out_org_init(app,org,n,lbl,cls,isDyn,parent_org,parent_trl) \
        ((__typeof__(ceu_sys_org_init)*)((app)->sys_vec[CEU_SYS_ORG]))(org,n,lbl,cls,isDyn,parent_org,parent_trl)
    #define ceu_out_start(app) \
        ((__typeof__(ceu_sys_start)*)((_ceu_app)->sys_vec[CEU_SYS_START]))(app)
    #define ceu_out_link(app1,evt1 , app2,evt2) \
        ((__typeof__(ceu_sys_link)*)((_ceu_app)->sys_vec[CEU_SYS_LINK]))(app1,evt1,app2,evt2)

    #define ceu_out_emit(app,id,sz,buf) \
        ((__typeof__(ceu_sys_emit)*)((app)->sys_vec[CEU_SYS_EMIT]))(app,id,sz,buf)

    #define ceu_out_call(app,id,param) \
        ((__typeof__(ceu_sys_call)*)((app)->sys_vec[CEU_SYS_CALL]))(app,id,param)

#ifdef CEU_WCLOCKS
    #define ceu_out_wclock(app,dt,set,get) \
        ((__typeof__(ceu_sys_wclock)*)((app)->sys_vec[CEU_SYS_WCLOCK]))(app,dt,set,get)
#ifdef CEU_TIMEMACHINE
    #error TIMEMACHINE
#endif
#endif

    #define ceu_out_go(app,evt,evtp) \
        ((__typeof__(ceu_sys_go)*)((app)->sys_vec[CEU_SYS_GO]))(app,evt,evtp)

#else /* ! CEU_OS_APP (!CEU_OS||CEU_OS_KERNEL) */

    #ifndef ceu_out_assert
        #error "Missing definition for macro \"ceu_out_assert\"."
    #endif

    #ifndef ceu_out_log
        #error "Missing definition for macro \"ceu_out_log\"."
    #endif

    #define ceu_out_assert_msg_ex(v,msg,file,line)          \
        {                                                   \
            int __ceu_v = v;                                \
            if ((!(__ceu_v)) && ((msg)!=NULL)) {            \
                ceu_out_log(0, (long)"[");                  \
                ceu_out_log(0, (long)(file));               \
                ceu_out_log(0, (long)":");                  \
                ceu_out_log(2, line);                       \
                ceu_out_log(0, (long)"] ");                 \
                ceu_out_log(0, (long)"runtime error: ");    \
                ceu_out_log(0, (long)(msg));                \
                ceu_out_log(0, (long)"\n");                 \
            }                                               \
            ceu_out_assert(__ceu_v);                        \
        }
    #define ceu_out_assert_msg(v,msg) ceu_out_assert_msg_ex((v),(msg),__FILE__,__LINE__)

    #define ceu_out_realloc(ptr,size) \
            ceu_sys_realloc(ptr,size)
    #define ceu_out_req() \
            ceu_sys_req()
    #define ceu_out_org_init(app,org,n,lbl,cls,isDyn,parent_org,parent_trl) \
            ceu_sys_org_init(org,n,lbl,cls,isDyn,parent_org,parent_trl)

#ifdef CEU_WCLOCKS
    #define ceu_out_wclock(app,dt,set,get) \
            ceu_sys_wclock(app,dt,set,get)
#ifdef CEU_TIMEMACHINE
    #define ceu_out_wclock_(app,dt,set,get) \
            ceu_sys_wclock_(app,dt,set,get)
#endif
#endif
    #define ceu_out_go(app,evt,evtp) \
            ceu_sys_go(app,evt,evtp)
    #define ceu_out_go_stk(app,evt,evtp,stk) \
            ceu_sys_go_stk(app,evt,evtp,stk)

#endif /* ! CEU_OS_APP (!CEU_OS||CEU_OS_KERNEL) */

#ifdef CEU_STACK_CLEAR
#define ceu_in_emit(app,id,n,buf) \
    ceu_out_go_stk(app,id,buf,&stk_)
#else
#define ceu_in_emit(app,id,n,buf) \
    ceu_out_go_stk(app,id,buf,NULL)
#endif

#ifdef CEU_THREADS
/* TODO: app */
#include "ceu_threads.h"
#endif

#ifdef CEU_LUA
#include <stdio.h>      /* BUFSIZ */
#include <string.h>     /* strcpy */
#if defined(__ANDROID__) || defined(CEU_OS)
    #include "lua.h"
    #include "lauxlib.h"
    #include "lualib.h"
#else
    #include <lua5.1/lua.h>
    #include <lua5.1/lauxlib.h>
    #include <lua5.1/lualib.h>
#endif

#ifdef CEU_OS_APP
    #define ceu_luaL_newstate(set) { \
        set = ceu_out_call(_ceu_app, CEU_OUT_LUA_NEW, NULL); \
    }

    #define ceu_luaL_openlibs(l) { \
        lua_State* p = l;          \
        ceu_out_call(_ceu_app, CEU_OUT_LUAL_OPENLIBS, &p); \
    }

    #define ceu_lua_atpanic(l, f) {     \
    }

    #define ceu_luaL_loadstring(set, l, str) {  \
        tceu__lua_State___char_ p = { l, str }; \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUAL_LOADSTRING, &p); \
    }

    #define ceu_lua_pushnumber(l, v) {      \
        tceu__lua_State___int p = { l, v }; \
        ceu_out_call(_ceu_app, CEU_OUT_LUA_PUSHNUMBER, &p); \
    }

    #define ceu_lua_pushstring(l, v) {      \
        tceu__lua_State___char_ p = { l, v }; \
        ceu_out_call(_ceu_app, CEU_OUT_LUA_PUSHSTRING, &p); \
    }

    #define ceu_lua_pushlightuserdata(l, v) {   \
        tceu__lua_State___void_ p = { l, v };     \
        ceu_out_call(_ceu_app, CEU_OUT_LUA_PUSHLIGHTUSERDATA, &p); \
    }

    #define ceu_lua_pcall(set,l,nargs,nrets,err) {                  \
        tceu__lua_State___int__int__int p = { l, nargs, nrets, err }; \
        ceu_out_call(_ceu_app, CEU_OUT_LUA_PCALL, &p); \
    }

    #define ceu_lua_isnumber(set, l, idx) {     \
        tceu__lua_State___int p = { l, idx };   \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUA_ISNUMBER, &p); \
    }

    #define ceu_lua_tonumber(set, l, idx) {     \
        tceu__lua_State___int p = { l, idx };   \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUA_TONUMBER, &p); \
    }

    #define ceu_lua_isboolean(set, l, idx) {    \
        tceu__lua_State___int p = { l, idx };   \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUA_ISBOOLEAN, &p); \
    }

    #define ceu_lua_toboolean(set, l, idx) {    \
        tceu__lua_State___int p = { l, idx };   \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUA_TOBOOLEAN, &p); \
    }

    #define ceu_lua_pop(l, n) {             \
        tceu__lua_State___int p = { l, n }; \
        ceu_out_call(_ceu_app, CEU_OUT_LUA_POP, &p); \
    }

    #define ceu_lua_isstring(set, l, idx) {     \
        tceu__lua_State___int p = { l, idx };   \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUA_ISSTRING, &p); \
    }

    #define ceu_lua_tostring(set, l, idx) {     \
        tceu__lua_State___int p = { l, idx };   \
        set = ceu_out_call(_ceu_app, CEU_OUT_LUA_TOSTRING, &p); \
    }

    #define ceu_lua_islightuserdata(set, l, idx) {  \
        tceu__lua_State___int p = { l, idx };       \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUA_ISLIGHTUSERDATA, &p); \
    }

    #define ceu_lua_touserdata(set, l, idx) {   \
        tceu__lua_State___int p = { l, idx };   \
        set = ceu_out_call(_ceu_app, CEU_OUT_LUA_TOUSERDATA, &p); \
    }

    #define ceu_lua_error(l) {                          \
        lua_State** p = &l;                             \
        ceu_out_call(_ceu_app, CEU_OUT_LUA_ERROR, &p);  \
    }

    #define ceu_lua_objlen(set, l, idx) {                       \
        tceu__lua_State___int p = { l, idx };                   \
        set = ceu_out_call(_ceu_app, CEU_OUT_LUA_OBJLEN, &p);   \
    }

#else
    #define ceu_luaL_newstate(set)               set = luaL_newstate()
    #define ceu_luaL_openlibs(l)                 luaL_openlibs(l)
    #define ceu_lua_atpanic(l,f)                 lua_atpanic(l,f)
    #define ceu_luaL_loadstring(set,l,str)       set = luaL_loadstring(l,str)
    #define ceu_lua_pushnumber(l,v)              lua_pushnumber(l,v)
    #define ceu_lua_pushstring(l,v)              lua_pushstring(l,v)
    #define ceu_lua_pushlightuserdata(l,v)       lua_pushlightuserdata(l,v)
    #define ceu_lua_pcall(set,l,nargs,nrets,err) set = lua_pcall(l,nargs,nrets,err)
    #define ceu_lua_isnumber(set,l,idx)          set = lua_isnumber(l,idx)
    #define ceu_lua_tonumber(set,l,idx)          set = lua_tonumber(l,idx)
    #define ceu_lua_isboolean(set,l,idx)         set = lua_isboolean(l,idx)
    #define ceu_lua_toboolean(set,l,idx)         set = lua_toboolean(l,idx)
    #define ceu_lua_pop(l,n)                     lua_pop(l,n)
    #define ceu_lua_isstring(set,l,idx)          set = lua_isstring(l,idx)
    #define ceu_lua_tostring(set,l,idx)          set = lua_tostring(l,idx)
    #define ceu_lua_islightuserdata(set,l,idx)   set = lua_islightuserdata(l,idx)
    #define ceu_lua_touserdata(set,l,idx)        set = lua_touserdata(l,idx)
    #define ceu_lua_error(l)                     lua_error(l)
    #define ceu_lua_objlen(set,l,idx)            set = lua_objlen(l,idx)
#endif
#endif

typedef u8 tceu_nevt;   /* max number of events */
                        /* TODO: should "u8" be fixed? */

typedef u8 tceu_ntrl;   /* max number of trails per class */
                        /* TODO: should "u8" be fixed? */

#ifdef CEU_STACK_CLEAR
typedef u16 tceu_nstk;  /* max size of internal stack in bytes */
                        /* TODO: should "u16" be fixed? */
#endif

#ifdef __cplusplus
#define CEU_WCLOCK_INACTIVE 0x7fffffffL     /* TODO */
#else
#define CEU_WCLOCK_INACTIVE INT32_MAX
#endif
#define CEU_WCLOCK_EXPIRED (CEU_WCLOCK_INACTIVE-1)

/* TCEU_TRL */

struct tceu_org;
typedef union tceu_trl {
    tceu_nevt evt;

    /* normal await // IN__CLEAR */
    struct {                    /* TODO(ram): bitfields */
        tceu_nevt evt1;
        tceu_nlbl lbl;
        u8        seqno;        /* TODO(ram): 2 bits is enough */
#ifdef CEU_INTS                 /* R-9: size of trails for internal events */
#ifdef CEU_ORGS
        void*     evto;
#endif
#endif
    };

    /* IN__ORG */
#ifdef CEU_ORGS
    struct {                    /* TODO(ram): bad for alignment */
        tceu_nevt evt3;
        struct tceu_org* org;
    };
#endif

    /* _ok_killed */
#ifdef CEU_ORGS_OR_ADTS_AWAIT
    struct {
        tceu_nevt evt4;
        tceu_nlbl lbl4;
#ifdef CEU_ORGS_AWAIT
#ifdef CEU_ADTS_AWAIT
        u8        is_org;
#endif
#endif
        void*     org_or_adt;
    };
#endif
} tceu_trl;

/* TCEU_EVT */

typedef struct tceu_evt {
    tceu_nevt id;
    void*     param;
#if defined(CEU_ORGS) && defined(CEU_INTS)
    void*     org;      /* emitting org */
#endif
} tceu_evt;

/* TCEU_ORG */

struct tceu_pool_orgs;
typedef struct tceu_org
{
#ifdef CEU_ORGS
    struct tceu_org* nxt; /* first field because of free list for orgs/adts */
    struct tceu_org* prv;
    struct tceu_org* parent_org;
    tceu_ntrl parent_trl;
#endif

#if defined(CEU_ORGS) || defined(CEU_OS)
    tceu_ntrl n;            /* number of trails (TODO(ram): opt, metadata) */
#endif

#ifdef CEU_ORGS

#ifdef CEU_IFCS
    tceu_ncls cls;          /* class id */
#endif
    u8 isAlive: 1;          /* Three purposes:
                             * - avoids double free
                             * - required by "watching o" to avoid awaiting a
                             *      dead org
                             * - required by "Do T" to avoid awaiting a dead 
                             *      org
                             */
#if defined(CEU_ORGS_NEWS) || defined(CEU_ORGS_AWAIT)
#endif
#ifdef CEU_ORGS_NEWS
    u8 isDyn: 1;            /* created w/ new or spawn? */
#endif
#ifdef CEU_ORGS_NEWS_POOL
    struct tceu_pool_orgs* pool;
#endif

#ifdef CEU_ORGS_AWAIT
    int ret;
#endif

#endif  /* CEU_ORGS */

    tceu_trl trls[0];       /* first trail */

} tceu_org;

/* TCEU_POOL_ORGS , TCEU_POOL_ADTS */

#if defined(CEU_ORGS_NEWS_POOL) || defined(CEU_ADTS_NEWS_POOL)
#include "ceu_pool.h"
#endif

#ifdef CEU_ORGS_NEWS
typedef struct tceu_pool_orgs {
    tceu_org* parent_org;
    tceu_ntrl parent_trl;
#ifdef CEU_ORGS_NEWS_POOL
    tceu_pool pool;
#endif
} tceu_pool_orgs;
#endif

#ifdef CEU_ADTS_NEWS
typedef struct {
    void* root;
#ifdef CEU_ADTS_NEWS_POOL
    void* pool;
#endif
} tceu_pool_adts;
#endif

/* TCEU_KILL */

#ifdef CEU_ORGS_OR_ADTS_AWAIT
typedef struct tceu_kill {
    void*     org_or_adt;
    int       ret;
    tceu_ntrl t1;
    tceu_ntrl t2;
} tceu_kill;
#endif

/* TCEU_LST */

#ifdef CEU_DEBUG
typedef struct tceu_lst {
#ifdef CEU_ORGS
    void*     org;
#endif
    tceu_trl* trl;
    tceu_nlbl lbl;
} tceu_lst;

#endif

/* TCEU_STK */

#ifdef CEU_STACK_CLEAR
typedef struct tceu_stk {
    struct tceu_stk* down;
    tceu_org*   org;
    tceu_ntrl   trl1;
    tceu_ntrl   trl2;
    char        is_alive;
} tceu_stk;
#else
typedef void tceu_stk;
#endif

/* TCEU_APP */

typedef struct tceu_app {
    /* global seqno: incremented on every reaction
     * awaiting trails matches only if trl->seqno < seqno,
     * i.e., previously awaiting the event
     */
    u8 seqno:          2;
#if defined(CEU_RET) || defined(CEU_OS)
    u8 isAlive:        1;
#endif
#ifdef CEU_ASYNCS
    u8 pendingAsyncs:  1;
#endif
#if defined(CEU_ORGS_NEWS_MALLOC) && defined(CEU_ORGS_AWAIT)
    u8 dont_emit_kill: 1;
#endif

#ifdef CEU_OS
    struct tceu_app* nxt;
#endif

#if defined(CEU_RET) || defined(CEU_ORGS_AWAIT)
    int ret;
#endif

#ifdef CEU_ORGS_NEWS_MALLOC
    tceu_org* tofree;
#endif

#ifdef CEU_WCLOCKS
    s32         wclk_late;
    s32         wclk_min_set;   /* used to set */
    s32         wclk_min_cmp;   /* used to compare */
                                /* cmp<-set every reaction */
#ifdef CEU_TIMEMACHINE
    s32         wclk_late_;
    s32         wclk_min_set_;
    s32         wclk_min_cmp_;
#endif
#endif

#ifndef CEU_OS
#ifdef CEU_DEBUG
    tceu_lst    lst; /* segfault printf */
#endif
#endif

#ifdef CEU_THREADS
    CEU_THREADS_MUTEX_T threads_mutex;
    /*CEU_THREADS_COND_T  threads_cond;*/
    u8                  threads_n;          /* number of running threads */
        /* TODO: u8? */
#endif
#if defined(CEU_LUA) || defined(CEU_OS)
#ifdef CEU_LUA
    lua_State*  lua;    /* TODO: move to data? */
#else
    void*       lua;
#endif
#endif

    void        (*code)  (struct tceu_app*,tceu_evt*,tceu_org*,tceu_trl*,tceu_stk*);
    void        (*init)  (struct tceu_app*);
#ifdef CEU_OS
    void*       (*calls) (struct tceu_app*,tceu_nevt,void*);
    void**      sys_vec;
    void*       addr;
#ifdef CEU_OS_LUAIFC
    char*       luaifc;
#endif
#endif
    tceu_org*   data;
} tceu_app;

#ifdef CEU_OS
typedef void (*tceu_init)   (tceu_app* app);
typedef void (*tceu_export) (uint* size, tceu_init** init
#ifdef CEU_OS_LUAIFC
                            , char** luaifc
#endif
);
#endif

/* TCEU_THREADS_P */

#ifdef CEU_THREADS
typedef struct {
    tceu_app* app;
    tceu_org* org;
    s8*       st; /* thread state:
                   * 0=ini (sync  spawns)
                   * 1=cpy (async copies)
                   * 2=lck (sync  locks)
                   * 3=end (sync/async terminates)
                   */
} tceu_threads_p;
#endif

#ifdef CEU_PSES
void ceu_pause (tceu_trl* trl, tceu_trl* trlF, int psed);
#endif

int  ceu_go_all    (tceu_app* app);

#ifdef CEU_WCLOCKS
int       ceu_sys_wclock (tceu_app* app, s32 dt, s32* set, s32* get);
#endif
void      ceu_sys_go     (tceu_app* app, int evt, void* evtp);

#ifdef CEU_OS

/* TCEU_LINK */

typedef struct tceu_lnk {
    tceu_app* src_app;
    tceu_nevt src_evt;
    tceu_app* dst_app;
    tceu_nevt dst_evt;
    struct tceu_lnk* nxt;
} tceu_lnk;

/* TCEU_QUEUE */

typedef struct {
    tceu_app* app;
    tceu_nevt evt;
#if CEU_QUEUE_MAX == 256
    s8        sz;
#else
    s16       sz;   /* signed because of fill */
#endif
    byte      buf[0];
} tceu_queue;

#ifdef CEU_ISR
typedef void(*tceu_isr_f)(tceu_app* app, tceu_org* org);
#endif

void ceu_os_init      (void);
int  ceu_os_scheduler (int(*dt)());
tceu_queue* ceu_sys_queue_nxt (void);
void        ceu_sys_queue_rem (void);

void      ceu_sys_assert    (int v);
void      ceu_sys_log       (int mode, long str);
void*     ceu_sys_realloc   (void* ptr, size_t size);
int       ceu_sys_req       (void);
tceu_app* ceu_sys_load      (void* addr);
#ifdef CEU_ISR
int       ceu_sys_isr       (int n, tceu_isr_f f, tceu_app* app);
#endif
void      ceu_sys_org_init  (tceu_org* org, int n, int lbl, int cls, int isDyn,
                             tceu_org* parent_org, tceu_ntrl parent_trl);
void      ceu_sys_start     (tceu_app* app);
int       ceu_sys_link      (tceu_app* src_app, tceu_nevt src_evt, tceu_app* dst_app, tceu_nevt dst_evt);
int       ceu_sys_unlink    (tceu_app* src_app, tceu_nevt src_evt, tceu_app* dst_app, tceu_nevt dst_evt);
int       ceu_sys_emit      (tceu_app* app, tceu_nevt evt, int sz, void* param);
void*     ceu_sys_call      (tceu_app* app, tceu_nevt evt, void* param);

enum {
    CEU_SYS_ASSERT = 0,
    CEU_SYS_LOG,
    CEU_SYS_REALLOC,
    CEU_SYS_REQ,
    CEU_SYS_LOAD,
#ifdef CEU_ISR
    CEU_SYS_ISR,
#endif
#ifdef CEU_CLEAR
    CEU_SYS_CLEAR,
#endif
    CEU_SYS_STACK_PUSH,
#ifdef CEU_ORGS
    CEU_SYS_STACK_CLEAR_ORG,
#endif
    CEU_SYS_ORG,
#ifdef CEU_ORGS
    CEU_SYS_ORG_TRAIL,
    CEU_SYS_ORG_SPAWN,
#endif
    CEU_SYS_START,
    CEU_SYS_LINK,
    CEU_SYS_UNLINK,
    CEU_SYS_EMIT,
    CEU_SYS_CALL,
#ifdef CEU_WCLOCKS
    CEU_SYS_WCLOCK,
#endif
    CEU_SYS_GO,
    CEU_SYS_MAX
};

/* SYS_VECTOR
 */
extern void* CEU_SYS_VEC[CEU_SYS_MAX];

#endif  /* CEU_OS */

#endif  /* _CEU_OS_H */


typedef struct {
    int   max;
    int   nxt;
    int   unit;
    byte* mem;
} tceu_vector;

#define CEU_VECTOR_DCL(name, type, max)  \
    type        name##_mem[max+1];       \
    tceu_vector name;
                /* [STRING] max+1: extra space for '\0' */

#define ceu_vector_getlen(vec) ((vec)->nxt)
#define ceu_vector_getmax(vec) ((vec)->max > 0 ? (vec)->max : 0)

void  ceu_vector_init   (tceu_vector* vector, int max, int unit, byte* mem);
int   ceu_vector_setlen (tceu_vector* vector, int len);
byte* ceu_vector_geti   (tceu_vector* vector, int idx);
int   ceu_vector_seti   (tceu_vector* vector, int idx, byte* v);
int   ceu_vector_push   (tceu_vector* vector, byte* v);
int   ceu_vector_concat (tceu_vector* to, tceu_vector* fr);
int   ceu_vector_concat_buffer (tceu_vector* to, const char* fr, int n);
char* ceu_vector_tochar (tceu_vector* vector);

#if 0
byte* ceu_pool_alloc (tceu_pool* pool);
void ceu_pool_free (tceu_pool* pool, byte* val);
#endif
#endif

#ifndef _CEU_VECTOR_C
#define _CEU_VECTOR_C



void ceu_vector_init (tceu_vector* vector, int max, int unit, byte* mem) {
    vector->nxt  = 0;
    vector->max  = max;
    vector->unit = unit;
    vector->mem  = (max==0) ? NULL : mem;

    /* [STRING] */
    if (vector->mem != NULL) {
        vector->mem[0] = '\0';
    }
}

#ifdef CEU_VECTOR_MALLOC
static void* ceu_vector_resize (tceu_vector* vector, int n) {
    ceu_out_assert_msg(vector->max <= 0, "bug found");

    if (n == 0) {
        /* free */
        if (vector->mem != NULL) {
            vector->max = 0;
            ceu_out_realloc(vector->mem, 0);
            vector->mem = NULL;
        }
    } else {
        /* TODO: Java does the same? */
        n = (n*3/2) + 1;
        if (n < 10) {
            n = 10;
        }

        vector->max = -n;
        vector->mem = (byte*)ceu_out_realloc(vector->mem, n*vector->unit + 1);
                                                        /* [STRING] +1 */
    }

    return vector->mem;
}
#endif

/* can only decrease vector->nxt */
int ceu_vector_setlen (tceu_vector* vector, int nxt) {
    if (nxt > vector->nxt) {
        return 0;
    } else {
        vector->nxt = nxt;

        /* [STRING] */
        if (vector->mem != NULL) {
            vector->mem[nxt*vector->unit] = '\0';
        }

#ifdef CEU_VECTOR_MALLOC
        /* shrink malloc'ed arrays */
        if (vector->max <= 0) {
            if (ceu_vector_resize(vector,nxt)==NULL && nxt>0) {
                return 0;
            }
        }
#endif

        return 1;
    }
}

/* can only get within idx < vector->nxt */
byte* ceu_vector_geti (tceu_vector* vector, int idx) {
    if (idx >= vector->nxt) {
        return NULL;
    } else {
        return &vector->mem[idx*vector->unit];
    }
}

/* can only set within idx < vector->nxt */
int ceu_vector_seti (tceu_vector* vector, int idx, byte* v) {
    if (idx >= vector->nxt) {
        return 0;
    } else {
        memcpy(&vector->mem[idx*vector->unit], v, vector->unit);
        return 1;
    }
}

/* can only push within nxt < vector->max */
int ceu_vector_push (tceu_vector* vector, byte* v) {
#ifdef CEU_VECTOR_MALLOC
    /* grow malloc'ed arrays */
    if (vector->max <= 0) {
        while (vector->nxt >= -vector->max) {
            if (ceu_vector_resize(vector,vector->nxt+1) == NULL) {
                return 0;
            }
        }
    }
#endif
#ifdef CEU_VECTOR_MALLOC
#ifdef CEU_VECTOR_POOL
    else
#endif
#endif
#ifdef CEU_VECTOR_POOL
    if (vector->nxt >= vector->max) {
        return 0;
    }
#endif

    memcpy(&vector->mem[vector->nxt*vector->unit], v, vector->unit);
    vector->nxt++;
    vector->mem[vector->nxt*vector->unit] = '\0';    /* [STRING] */
    return 1;
}

int ceu_vector_concat (tceu_vector* to, tceu_vector* fr) {
    if (to == fr) {
        return 0;
    } else {
        /* TODO: memcpy */
        int i;
        for (i=0; i<fr->nxt; i++) {
            byte* v = ceu_vector_geti(fr, i);
            if (v == NULL) {
                return 0;
            } else if (!ceu_vector_push(to,v)) {
                return 0;
            }
        }
    }
    return 1;
}

int ceu_vector_concat_buffer (tceu_vector* to, const char* fr, int n) {
    /* TODO: memcpy */
    int i;
    for (i=0; i<n; i++) {
        if (!ceu_vector_push(to,(byte*)&fr[i])) {
            return 0;
        }
    }
    return 1;
}

char* ceu_vector_tochar (tceu_vector* vector) {
    if (vector->mem == NULL) {
        return "";
    } else {
        return (char*)vector->mem;
    }
}

#endif

byte* ceu_vector_geti_ex (tceu_vector* vector, int idx, char* file, int line) {
    byte* ret = ceu_vector_geti(vector, idx);
    ceu_out_assert_msg_ex(ret!=NULL, "access out of bounds", file, line);
    return ret;
}
#endif

int CEU_REQS = 0;
int ceu_sys_req (void) {
    CEU_REQS++;
    return CEU_REQS;
}

void ceu_sys_go_ex (tceu_app* app, tceu_evt* evt,
                    tceu_stk* stk,
                    tceu_org* org, tceu_ntrl trl0, tceu_ntrl trlF);

/**********************************************************************/

void ceu_sys_org_init (tceu_org* org, int n, int lbl,
                       int cls, int isDyn,
                       tceu_org* parent_org, tceu_ntrl parent_trl)
{
    /* { evt=0, seqno=0, lbl=0 } for all trails */
    memset(&org->trls, 0, n*sizeof(tceu_trl));
    org->trls[0].lbl = lbl;

#if defined(CEU_ORGS) || defined(CEU_OS_KERNEL)
    org->n  = n;
#endif

#ifdef CEU_ORGS

#ifdef CEU_IFCS
    org->cls = cls;
#endif

#if defined(CEU_ORGS_NEWS) || defined(CEU_ORGS_AWAIT)
    org->isAlive = 1;
#endif

#ifdef CEU_ORGS_NEWS
    org->isDyn = isDyn;
#endif

    org->parent_org = parent_org;
    org->parent_trl = parent_trl;
    org->nxt = NULL;
    if (parent_org != NULL) {
        tceu_trl* trl = &parent_org->trls[parent_trl];
        if (trl == NULL) {
            org->prv = NULL; /* main class */
        } else {
            /* re-link */
            if (trl->org == NULL) {
                trl->org = org;
            } else {
                tceu_org* last = trl->org->prv;
                last->nxt = org;
                org->prv = last;
            }
            trl->org->prv = org;
        }
    }

#ifdef CEU_ORGS_AWAIT
    org->ret = 0;   /* TODO: still required? */
#endif

#endif  /* CEU_ORGS */
}

#ifdef CEU_ORGS

static void ceu_sys_org_free (tceu_app* app, tceu_org* org)
{
    /* TODO: try to not depend on this and remove this field */
    if (org->isAlive) {
        org->isAlive = 0;
    } else {
        return;
    }

    /* re-link PRV <-> NXT */
    /* relink also static orgs for efficiency */
    tceu_trl* trl = &org->parent_org->trls[org->parent_trl];
    if (trl->org == org) {
        trl->org = org->nxt;        /* subst 1st org */
    } else {
        org->prv->nxt = org->nxt;
    }
    if (org->nxt == NULL) {
        if (trl->org != NULL) {
            trl->org->prv = org->prv;   /* subst lst org */
        }
    } else {
        org->nxt->prv = org->prv;
    }

#ifdef CEU_ORGS_NEWS
    /* free */
    if (org->isDyn) {
#if    defined(CEU_ORGS_NEWS_POOL) && !defined(CEU_ORGS_NEWS_MALLOC)
        ceu_pool_free(&org->pool->pool, (byte*)org);
#elif  defined(CEU_ORGS_NEWS_POOL) &&  defined(CEU_ORGS_NEWS_MALLOC)
        if (org->pool->pool.queue == NULL) {
            org->nxt = app->tofree;
            app->tofree = org;
        } else {
            ceu_pool_free(&org->pool->pool, (byte*)org);
        }
#elif !defined(CEU_ORGS_NEWS_POOL) &&  defined(CEU_ORGS_NEWS_MALLOC)
        org->nxt = app->tofree;
        app->tofree = org;
#endif
    }
#endif
}

/*
 * Checks if "me" is cleared due to a clear in "clr_org".
 * ;
 */
static int ceu_org_is_cleared (tceu_org* me, tceu_org* clr_org,
                               tceu_ntrl clr_t1, tceu_ntrl clr_t2)
{
    if (me == clr_org) {
        return (clr_t1==0 && clr_t2==me->n-1);
    }

    tceu_org* cur_org;
    for (cur_org=me; cur_org!=NULL; cur_org=cur_org->parent_org) {
        if (cur_org->parent_org == clr_org) {
            if (cur_org->parent_trl>=clr_t1 && cur_org->parent_trl<=clr_t2) {
                return 1;
            }
        }
    }
    return 0;
}

#endif  /* CEU_ORGS */

/**********************************************************************/

#ifdef CEU_STACK_CLEAR
void ceu_sys_stack_dump (tceu_stk* stk) {
    printf(">>> STACK DUMP:\n");
    for (; stk!=NULL; stk=stk->down) {
        printf("\t[%p] down=%p org=%p trls=[%d,%d]\n",
            stk, stk->down, stk->org, stk->trl1, stk->trl2);
    }
}

/*
 * Trails [t1,t2] of "org" are dyeing.
 * Traverse the stack to see if a pending call is enclosed by this range.
 * If so, the whole stack has to unwind and continue from what we pass in 
 * lbl_or_org.
 */
void ceu_sys_stack_clear (tceu_stk* stk, tceu_org* org,
                          tceu_ntrl t1, tceu_ntrl t2) {
    for (; stk->down!=NULL; stk=stk->down) {
        if (!stk->is_alive) {
            continue;
        }
#ifdef CEU_ORGS
        if (stk->org != org) {
            if (ceu_org_is_cleared(stk->org, org, t1, t2)) {
                stk->is_alive = 0;
            }
        }
        else
#endif
        {
            if (t1<=stk->trl1 && stk->trl2<=t2) {
                stk->is_alive = 0;
            }
        }
    }
}
#endif

/**********************************************************************/

#ifdef CEU_WCLOCKS

/* TODO: wclk_min_cmp to be global among all apps */

int ceu_sys_wclock (tceu_app* app, s32 dt, s32* set, s32* get)
{
    s32 t;          /* expiring time of track to calculate */
    int ret = 0;    /* if track expired (only for "get") */

    /* SET */
    if (set != NULL) {
        t = dt - app->wclk_late;
        *set = t;

    /* CHECK */
    } else {
        t = *get;
        if ((t > app->wclk_min_cmp) || (t > dt)) {
            *get -= dt;    /* don't expire yet */
            t = *get;
        } else {
            ret = 1;    /* single "true" return */
        }
    }

    /* didn't awake, but can be the smallest wclk */
    if ( (!ret) && (app->wclk_min_set > t) ) {
        app->wclk_min_set = t;
#ifdef ceu_out_wclock_set
        ceu_out_wclock_set(t);
#endif
    }

    return ret;
}

#ifdef CEU_TIMEMACHINE
/* TODO: unify with above */
int ceu_sys_wclock_ (tceu_app* app, s32 dt, s32* set, s32* get)
{
    s32 t;          /* expiring time of track to calculate */
    int ret = 0;    /* if track expired (only for "get") */

    /* SET */
    if (set != NULL) {
        t = dt - app->wclk_late;
        *set = t;

    /* CHECK */
    } else {
        t = *get;
        if ((t > app->wclk_min_cmp_) || (t > dt)) {
            *get -= dt;    /* don't expire yet */
            t = *get;
        } else {
            ret = 1;    /* single "true" return */
        }
    }

    /* didn't awake, but can be the smallest wclk */
    if ( (!ret) && (app->wclk_min_set_ > t) ) {
        app->wclk_min_set_ = t;
#ifdef ceu_out_wclock_set
        ceu_out_wclock_set(t);
#endif
    }

    return ret;
}
#endif

#endif

/**********************************************************************/

#ifdef CEU_LUA
int ceu_lua_atpanic_f (lua_State* lua) {
#ifdef CEU_DEBUG
    char msg[255] = "LUA_ATPANIC: ";
    strncat(msg, lua_tostring(lua,-1), 100);
    strncat(msg, "\n", 1);
    ceu_out_assert_msg(0, msg);
/*
*/
#else
    ceu_out_assert_msg(0, "bug found");
#endif
    return 0;
}
#endif

/**********************************************************************/

#ifdef CEU_PSES
#ifdef CEU_OS_KERNEL
#error Not implemented!
#endif
void ceu_pause (tceu_trl* trl, tceu_trl* trlF, int psed) {
    do {
        if (psed) {
            if (trl->evt == CEU_IN__ORG) {
                trl->evt = CEU_IN__ORG_PSED;
            }
        } else {
            if (trl->evt == CEU_IN__ORG_PSED) {
                trl->evt = CEU_IN__ORG;
            }
        }
    } while (++trl <= trlF);

#ifdef ceu_out_wclock_set
    if (!psed) {
        ceu_out_wclock_set(0);  /* TODO: recalculate MIN clock */
                                /*       between trl => trlF   */
    }
#endif
#ifdef CEU_TIMEMACHINE
#ifdef ceu_out_wclock_set_
    if (!psed) {
        ceu_out_wclock_set_(0);  /* TODO: recalculate MIN clock */
                                 /*       between trl => trlF   */
    }
#endif
#endif
}
#endif

/**********************************************************************/

#ifdef CEU_OS_KERNEL
u8 CEU_GC = 0;  /* execute __ceu_os_gc() when "true" */
#endif

#ifdef CEU_DEBUG_TRAILS
static int spc = -1;
#define SPC(n) { int i; for(i=0; i<(spc+n)*4; i++) printf(" "); };

void ceu_sys_go_ex_dbg (tceu_app* app, tceu_evt* evt,
                        tceu_stk* stk,
                        tceu_org* org, tceu_ntrl trl0, tceu_ntrl trlF);
void ceu_sys_go_ex (tceu_app* app, tceu_evt* evt,
                    tceu_stk* stk,
                    tceu_org* org, tceu_ntrl trl0, tceu_ntrl trlF) {
    spc++;
    SPC(0); printf(">>> GO-EX\n");
    SPC(0); printf("evt: %d\n", evt->id);
    #ifdef CEU_ORGS
    SPC(0); printf("org: %p\n", org);
    SPC(2); printf("[%p]=>[%p]\n", &org->trls[0],
                                   &org->trls[org->n]);
    #endif

    ceu_sys_go_ex_dbg(app,evt,stk,org,trl0,trlF);

    SPC(0); printf("<<< GO-EX\n");
    spc--;
}
#endif

#ifdef CEU_DEBUG_TRAILS
void ceu_sys_go_ex_dbg (tceu_app* app, tceu_evt* evt,
                        tceu_stk* stk,
                        tceu_org* org, tceu_ntrl trl0, tceu_ntrl trlF)
#else
void ceu_sys_go_ex (tceu_app* app, tceu_evt* evt,
                    tceu_stk* stk,
                    tceu_org* org, tceu_ntrl trl0, tceu_ntrl trlF)
    /* TODO: now all arguments are required in all configurations */
#endif
{
    tceu_ntrl trlI;
    tceu_trl* trl;
    for (trlI=trl0, trl=&org->trls[trlI];
#ifdef CEU_STACK_CLEAR
         stk->is_alive &&
#endif
            trlI<trlF;
         trlI++, trl++)
    {
#ifdef CEU_DEBUG_TRAILS
SPC(1); printf("trl: %p\n", trl);
/*SPC(2); printf("seqno: %d\n", trl->seqno);*/
SPC(2); printf("evt: %d\n", trl->evt);
SPC(2); printf("lbl: %d\n", trl->lbl);
#endif

        /* continue traversing current org */

        /* jump into linked orgs */
#ifdef CEU_ORGS
        if ( (trl->evt == CEU_IN__ORG)
#ifdef CEU_PSES
          || (trl->evt==CEU_IN__ORG_PSED && evt->id==CEU_IN__CLEAR)
#endif
           )
        {
            tceu_org* cur = trl->org;

            if (evt->id == CEU_IN__CLEAR) {
                trl->evt = CEU_IN__NONE;    /* TODO: dup w/ below */
            }

            /* traverse all children */
            if (cur != NULL) {
#ifdef CEU_STACK_CLEAR
                tceu_stk stk_ = { stk, org, cur->parent_trl, cur->parent_trl, 1 };
#endif
                while (cur != NULL) {
                    tceu_org* nxt = cur->nxt;   /* save before possible free/relink */
#ifdef CEU_STACK_CLEAR
                    ceu_sys_go_ex(app, evt, &stk_, cur, 0, cur->n);
                    if (!stk->is_alive) {
                        return; /* whole outer traversal aborted */
                    }
#if 0
if (!stk_.is_alive) {
printf("aborted\n");
    break; /* all children traversal aborted */
}
#endif
#else
                    ceu_sys_go_ex(app, evt, NULL, cur, 0, cur->n);
#endif
                    cur = nxt;
                }
            }
            continue;   /* next trail after handling children */
        }
#endif /* CEU_ORGS */

        /* EXECUTE THIS TRAIL */
#if 0
printf("%d==%d && %d!=%d && %d>=%d\n",
        trl->evt, evt->id,
        trl->seqno, app->seqno,
        evt->id, CEU_IN_lower
);
if (evt->param != NULL) {
    printf("trl->org_or_adt=%p // param=%p\n", trl->org_or_adt,
                 ((tceu_kill*)evt->param)->org_or_adt);
}
#endif

        if (
#ifdef CEU_CLEAR
            /* if IN__CLEAR and "finalize" clause */
            (evt->id==CEU_IN__CLEAR && trl->evt==CEU_IN__CLEAR)
        ||
#endif
#ifdef CEU_ORGS_AWAIT
            /* if */
            (evt->id==CEU_IN__ok_killed && trl->evt==CEU_IN__ok_killed &&
#ifdef CEU_ADTS_AWAIT
                trl->is_org &&
#endif
                (trl->org_or_adt == NULL || /* for option ptrs, init'd w/ NULL  */
                 ceu_org_is_cleared((tceu_org*)trl->org_or_adt,
                    (tceu_org*)((tceu_kill*)evt->param)->org_or_adt,
                    ((tceu_kill*)evt->param)->t1,
                    ((tceu_kill*)evt->param)->t2)))
        ||
#endif
#ifdef CEU_ADTS_AWAIT
            /* if */
            (evt->id==CEU_IN__ok_killed && trl->evt==CEU_IN__ok_killed &&
#ifdef CEU_ORGS_AWAIT
                !trl->is_org &&
#endif
                trl->org_or_adt == ((tceu_kill*)evt->param)->org_or_adt)
        ||
#endif
            /* if evt->id matches awaiting trail */
            (trl->evt==evt->id && trl->seqno!=app->seqno
#ifdef CEU_ORGS_OR_ADTS_AWAIT
                && (evt->id != CEU_IN__ok_killed)
                    /* TODO: simplify */
#endif
#ifdef CEU_INTS
#ifdef CEU_ORGS
                && (evt->id>=CEU_IN_lower || evt->org==trl->evto)
#endif
#endif
            )
           )
        {
#if defined(CEU_OS_KERNEL) && defined(__AVR)
            CEU_APP_ADDR = app->addr;
#endif

            /*** CODE ***/
            trl->evt = CEU_IN__NONE;    /* TODO: dup w/ above */
            app->code(app, evt, org, trl, stk);
#ifdef CEU_STACK_CLEAR
            if (!stk->is_alive) {
                return;
            }
#endif

#if defined(CEU_OS_KERNEL) && defined(__AVR)
            CEU_APP_ADDR = 0;
#endif

#if defined(CEU_OS_KERNEL) || defined(CEU_LUA)
            if (!app->isAlive) {
#ifdef CEU_OS_KERNEL
                CEU_GC = 1;
#endif
#ifdef CEU_LUA
                lua_close(app->lua);
#endif
            }
#endif
        }

        /* DON'T EXECUTE THIS TRAIL */
        else
        {
#ifdef CEU_DEBUG_TRAILS
SPC(1); printf("<<< NO\n");
#endif
#ifdef CEU_CLEAR
            if (evt->id==CEU_IN__CLEAR) {
                trl->evt = CEU_IN__NONE;    /* TODO: dup w/ above */
            }
#endif
        }

        /* NEXT TRAIL */

        if (trl->evt<=CEU_IN_higher && trl->seqno!=app->seqno) {
            trl->seqno = app->seqno-1;   /* keeps the gap tight */
        }
    }

#ifdef CEU_ORGS
    /* clearing the whole org? */
    if (evt->id==CEU_IN__CLEAR && org!=app->data && trl0==0 && trlF==org->n) {
        /* yes, relink and put it in the free list */
        ceu_sys_org_free(app, org);
    }
#endif
}

void ceu_sys_go_stk (tceu_app* app, int evt, void* evtp, tceu_stk* stk) {
    app->seqno++;
#ifdef CEU_DEBUG_TRAILS
    printf("===> [%d] %d\n", evt, app->seqno);
#endif

    switch (evt) {
#ifdef CEU_ASYNCS
        case CEU_IN__ASYNC:
            app->pendingAsyncs = 0;
            break;
#endif
#ifdef CEU_WCLOCKS
        case CEU_IN__WCLOCK:
            app->wclk_min_cmp = app->wclk_min_set;      /* swap "cmp" to last "set" */
            app->wclk_min_set = CEU_WCLOCK_INACTIVE;    /* new "set" resets to inactive */
            if (app->wclk_min_cmp <= *((s32*)evtp)) {
                app->wclk_late = *((s32*)evtp) - app->wclk_min_cmp;
            }
            break;
#ifdef CEU_TIMEMACHINE
        case CEU_IN__WCLOCK_:
            app->wclk_min_cmp_ = app->wclk_min_set_;
            app->wclk_min_set_ = CEU_WCLOCK_INACTIVE;
            if (app->wclk_min_cmp_ <= *((s32*)evtp)) {
                app->wclk_late_ = *((s32*)evtp) - app->wclk_min_cmp_;
            }
            break;
#endif
#endif
    }

    {
        tceu_evt evt_;
                 evt_.id = evt;
                 evt_.param = &evtp;
        ceu_sys_go_ex(app, &evt_,
                      stk,
                      app->data, 0,
#ifdef CEU_ORGS
                      app->data->n
#else
                      CEU_NTRAILS
#endif
        );
    }

#ifdef CEU_WCLOCKS
    if (evt==CEU_IN__WCLOCK) {
#ifdef ceu_out_wclock_set
        /* no new sets, signal inactive */
        if (app->wclk_min_set == CEU_WCLOCK_INACTIVE) {
            ceu_out_wclock_set(CEU_WCLOCK_INACTIVE);
        }
#endif
        app->wclk_late = 0;
    }
#ifdef CEU_TIMEMACHINE
    if (evt==CEU_IN__WCLOCK_) {
#ifdef ceu_out_wclock_set
        if (app->wclk_min_set_ == CEU_WCLOCK_INACTIVE) {
            ceu_out_wclock_set(CEU_WCLOCK_INACTIVE);
        }
#endif
        app->wclk_late_ = 0;
    }
#endif
#endif

#ifdef CEU_ORGS_NEWS_MALLOC
    while (app->tofree != NULL) {
        tceu_org* nxt = app->tofree->nxt;
        ceu_sys_realloc(app->tofree, 0);
        app->tofree = nxt;
    }
#endif
}

void ceu_sys_go (tceu_app* app, int evt, void* evtp)
{
#ifdef CEU_STACK_CLEAR
    tceu_stk stk_ = { NULL, NULL, 0, 0, 1 };
    ceu_sys_go_stk(app, evt, evtp, &stk_);
#else
    ceu_sys_go_stk(app, evt, evtp, NULL);
#endif
}

int ceu_go_all (tceu_app* app)
{
    /* All code run atomically:
     * - the program is always locked as a whole
     * -    thread spawns will unlock => re-lock
     * - but program will still run to completion
     */
    app->init(app);     /* calls CEU_THREADS_MUTEX_LOCK() */

#ifdef CEU_IN_OS_START
#if defined(CEU_RET) || defined(CEU_OS_KERNEL)
    if (app->isAlive)
#endif
    {
        ceu_sys_go(app, CEU_IN_OS_START, NULL);
    }
#endif

#ifdef CEU_ASYNCS
    while(
#if defined(CEU_RET) || defined(CEU_OS_KERNEL)
            app->isAlive &&
#endif
            (
#ifdef CEU_THREADS
                app->threads_n>0 ||
#endif
                app->pendingAsyncs
            ) )
    {
        ceu_sys_go(app, CEU_IN__ASYNC, NULL);
#ifdef CEU_THREADS
        CEU_THREADS_MUTEX_UNLOCK(&app->threads_mutex);
        /* allow threads to also execute */
        CEU_THREADS_MUTEX_LOCK(&app->threads_mutex);
#endif
    }
#endif

#ifdef CEU_THREADS
    CEU_THREADS_MUTEX_UNLOCK(&app->threads_mutex);
#endif

#ifdef CEU_NEWS
#ifdef CEU_RUNTESTS
    ceu_out_assert_msg(_ceu_dyns_ == 0, "memory leak");
#endif
#endif

#ifdef CEU_RET
    return app->ret;
#else
    return 0;
#endif
}

/**********************************************************************
 * Only the OS kernel needs any of the below.
 **********************************************************************/

#ifdef CEU_OS_KERNEL

/*
 * SYS_VECTOR:
 */
void* CEU_SYS_VEC[CEU_SYS_MAX] __attribute__((used)) = {
    (void*) &ceu_out_assert,
    (void*) &ceu_out_log,
    (void*) &ceu_sys_realloc,
    (void*) &ceu_sys_req,
    (void*) &ceu_sys_load,
#ifdef CEU_ISR
    (void*) &ceu_sys_isr,
#endif
    (void*) &ceu_sys_org_init,
    (void*) &ceu_sys_start,
    (void*) &ceu_sys_link,
    (void*) &ceu_sys_unlink,
    (void*) &ceu_sys_emit,
    (void*) &ceu_sys_call,
#ifdef CEU_WCLOCKS
    (void*) &ceu_sys_wclock,
#endif
    (void*) &ceu_sys_go
};

/*****************************************************************************
 * QUEUE
 * - 256 avoids doing modulo operations
 * - n: number of entries
 * - 0: next position to consume
 * - i: next position to enqueue
 */
#if CEU_QUEUE_MAX == 256
    byte QUEUE[CEU_QUEUE_MAX] = {0};    /* {0} avoids .bss */
    int  QUEUE_tot = 0;
    u8   QUEUE_get = 0;
    u8   QUEUE_put = 0;
#else
    byte QUEUE[CEU_QUEUE_MAX] = {0};    /* {0} avoids .bss */
    int  QUEUE_tot = 0;
    u16  QUEUE_get = 0;
    u16  QUEUE_put = 0;
#endif

tceu_queue* ceu_sys_queue_get (void) {
    tceu_queue* ret;
    CEU_ISR_OFF();
    if (QUEUE_tot == 0) {
        ret = NULL;
    } else {
#ifdef CEU_DEBUG
        ceu_sys_assert(QUEUE_tot > 0);
#endif
        ret = (tceu_queue*) &QUEUE[QUEUE_get];
    }
    CEU_ISR_ON();
    return ret;
}

int ceu_sys_queue_put (tceu_app* app, tceu_nevt evt, int sz, byte* buf) {
    CEU_ISR_OFF();

    int n = sizeof(tceu_queue) + sz;

    if (QUEUE_tot+n > CEU_QUEUE_MAX) {
        return 0;   /* TODO: add event FULL when CEU_QUEUE_MAX-1 */
    }

    /* An event+data must be continuous in the QUEUE. */
    if (QUEUE_put+n+sizeof(tceu_queue)>=CEU_QUEUE_MAX && evt!=CEU_IN__NONE) {
        int fill = CEU_QUEUE_MAX - QUEUE_put - sizeof(tceu_queue);
        /*_ceu_sys_emit(app, CEU_IN__NONE, param, fill, NULL);*/
        tceu_queue* qu = (tceu_queue*) &QUEUE[QUEUE_put];
        qu->app = app;
        qu->evt = CEU_IN__NONE;
        qu->sz  = fill;
        QUEUE_put += sizeof(tceu_queue) + fill;
        QUEUE_tot += sizeof(tceu_queue) + fill;
    }

    {
        tceu_queue* qu = (tceu_queue*) &QUEUE[QUEUE_put];
        qu->app = app;
        qu->evt = evt;
        qu->sz  = sz;
        memcpy(qu->buf, buf, sz);
    }
    QUEUE_put += n;
    QUEUE_tot += n;

    CEU_ISR_ON();
    return 1;
}

void ceu_sys_queue_rem (void) {
    CEU_ISR_OFF();
    tceu_queue* qu = (tceu_queue*) &QUEUE[QUEUE_get];
    QUEUE_tot -= sizeof(tceu_queue) + qu->sz;
    QUEUE_get += sizeof(tceu_queue) + qu->sz;
    CEU_ISR_ON();
}

/*****************************************************************************/

static tceu_app* CEU_APPS = NULL;
static tceu_lnk* CEU_LNKS = NULL;

#ifdef CEU_RET
    int ok  = 0;
    int ret = 0;
#endif

/* TODO: remove this indirection */
int ceu_sys_emit (tceu_app* app, tceu_nevt evt, int sz, void* param) {
    return ceu_sys_queue_put(app, evt, sz, param);
}

void* ceu_sys_call (tceu_app* app, tceu_nevt evt, void* param) {
    tceu_lnk* lnk = CEU_LNKS;
    for (; lnk; lnk=lnk->nxt)
    {
        if (app!=lnk->src_app || evt!=lnk->src_evt) {
            continue;
        }
#if defined(CEU_OS_KERNEL) && defined(__AVR)
        void* __old = CEU_APP_ADDR; /* must remember to resume after call */
        CEU_APP_ADDR = lnk->dst_app->addr;
#endif
        void* ret = lnk->dst_app->calls(lnk->dst_app, lnk->dst_evt, param);
#if defined(CEU_OS_KERNEL) && defined(__AVR)
        CEU_APP_ADDR = __old;
#endif
        return ret;
    }
/* TODO: error? */
    return NULL;
}

static void _ceu_sys_unlink (tceu_lnk* lnk) {
    /* remove as head */
    if (CEU_LNKS == lnk) {
        CEU_LNKS = lnk->nxt;
/* TODO: prv */
    /* remove in the middle */
    } else {
        tceu_lnk* cur = CEU_LNKS;
        while (cur->nxt!=NULL && cur->nxt!=lnk) {
			cur = cur->nxt;
        }
        if (cur->nxt != NULL) {
            cur->nxt = lnk->nxt;
        }
	}

    /*lnk->nxt = NULL;*/
    ceu_sys_realloc(lnk, 0);
}

static void __ceu_os_gc (void)
{
    if (! CEU_GC) return;
    CEU_GC = 0;

    /* remove pending events */
    {
        CEU_ISR_OFF();
        int i = 0;
        while (i < QUEUE_tot) {
            tceu_queue* qu = (tceu_queue*) &QUEUE[QUEUE_get+i];
            if (qu->app!=NULL && !qu->app->isAlive) {
                qu->evt = CEU_IN__NONE;
            }
            i += sizeof(tceu_queue) + qu->sz;
        }
        CEU_ISR_ON();
    }

    /* remove broken links */
    {
        tceu_lnk* cur = CEU_LNKS;
        while (cur != NULL) {
            tceu_lnk* nxt = cur->nxt;
            if (!cur->src_app->isAlive || !cur->dst_app->isAlive) {
                _ceu_sys_unlink(cur);
            }
            cur = nxt;
        }
    }

    /* remove dead apps */
    tceu_app* app = CEU_APPS;
    tceu_app* prv = NULL;
    while (app)
    {
        tceu_app* nxt = app->nxt;

        if (app->isAlive) {
            prv = app;

        } else {
            if (CEU_APPS == app) {
                CEU_APPS = nxt;     /* remove as head */
            } else {
                prv->nxt = nxt;     /* remove in the middle */
            }

            /* unlink all "from app" or "to app" */
            ceu_sys_unlink(app,0, 0,0);
            ceu_sys_unlink(0,0, app,0);

#ifdef CEU_RET
            ok--;
            ret += app->ret;
#endif

            /* free app memory */
            ceu_sys_realloc(app->data, 0);
            ceu_sys_realloc(app, 0);
        }

        app = nxt;
    }
}

#ifdef CEU_ISR

typedef struct {
    tceu_isr_f f;
    tceu_app*  app;
} tceu_isr;

#define CEU_ISR_MAX 40
tceu_isr CEU_ISR_VEC[CEU_ISR_MAX];

int ceu_sys_isr (int n, tceu_isr_f f, tceu_app* app) {
    tceu_isr* isr = &CEU_ISR_VEC[(n-1)];
    if (f==NULL || isr->f==NULL) {
        isr->f   = ((word)app->addr>>1) + f;
        isr->app = app;
                           /* "f" is relative to "app", make it absolute */
        return 1;
    } else {
        return 0;
    }
}
#endif

void ceu_os_init (void) {
#ifdef CEU_ISR
    int i;
    for (i=0; i<CEU_ISR_MAX; i++) {
        CEU_ISR_VEC[i].f = NULL;      /* TODO: is this required? (bss=0) */
    }
    CEU_ISR_ON();       /* enable global interrupts to start */
#endif
}

int ceu_os_scheduler (int(*dt)())
{
    /*
     * Intercalate DT->WCLOCK->ASYNC->QUEUE->...
     * QUEUE last to separate app->init() from OS_START.
     * QUEUE handles one event at a time to intercalate with WCLOCK.
     * __ceu_os_gc() only if QUEUE is emtpy: has to keep data from events 
     * accessible.
     */

#ifdef CEU_RET
    while (ok > 0)
#else
    while (1)
#endif
    {
#if defined(CEU_WCLOCKS) || defined(CEU_IN_OS_DT)
        s32 _dt = dt();
#endif

        /* DT */
#ifdef CEU_IN_OS_DT
        {
            tceu_app* app = CEU_APPS;
            while (app) {
                ceu_sys_go(app, CEU_IN_OS_DT, &dt);
                app = app->nxt;
            }
        }
#endif	/* CEU_IN_OS_DT */

        /* WCLOCK */
#ifdef CEU_WCLOCKS
        {
            tceu_app* app = CEU_APPS;
            while (app) {
/*
#error TODO: CEU_IN__WCLOCK_
*/
                ceu_sys_go(app, CEU_IN__WCLOCK, &_dt);
                app = app->nxt;
            }
        }
#endif	/* CEU_WCLOCKS */

        /* ASYNC */
#ifdef CEU_ASYNCS
        {
            tceu_app* app = CEU_APPS;
            while (app) {
                ceu_sys_go(app, CEU_IN__ASYNC, NULL);
                app = app->nxt;
            }
        }
#endif	/* CEU_ASYNCS */

        /* EVENTS */
        {
            /* clear the current size (ignore events emitted here) */
            CEU_ISR_OFF();
            int tot = QUEUE_tot;
            CEU_ISR_ON();
            if (tot > 0)
            {
                tceu_queue* qu = ceu_sys_queue_get();
                tot -= sizeof(tceu_queue) + qu->sz;
                if (qu->evt == CEU_IN__NONE) {
                    /* nothing; */
                    /* "fill event" */

                /* global events (e.g. OS_START, OS_INTERRUPT) */
                } else if (qu->app == NULL) {
                    tceu_app* app = CEU_APPS;
                    while (app) {
                        ceu_sys_go(app, qu->evt, qu->buf);
                        app = app->nxt;
                    }

                } else {
                    /* linked events */
                    tceu_lnk* lnk = CEU_LNKS;
                    while (lnk) {
                        if ( qu->app==lnk->src_app
                        &&   qu->evt==lnk->src_evt
                        &&   lnk->dst_app->isAlive ) {
                            ceu_sys_go(lnk->dst_app, lnk->dst_evt, qu->buf);
                        }
                        lnk = lnk->nxt;
                    }
                }

                ceu_sys_queue_rem();
            }
            else
            {
                __ceu_os_gc();     /* only when queue is empty */
            }
        }
    }

#ifdef CEU_RET
    return ret;
#else
    return 0;
#endif
}

/* LOAD / START */

tceu_app* ceu_sys_load (void* addr)
{
    uint       size;
    tceu_init* init;
#ifdef CEU_OS_LUAIFC
    char*      luaifc;
#endif

#ifdef __AVR
    ((tceu_export) ((word)addr>>1))(&size, &init);
#else
    ((tceu_export) addr)(&size, &init
#ifdef CEU_OS_LUAIFC
                        , &luaifc
#endif
                        );
#endif

    tceu_app* app = (tceu_app*) ceu_sys_realloc(NULL, sizeof(tceu_app));
    if (app == NULL) {
        return NULL;
    }

    app->data = (tceu_org*) ceu_sys_realloc(NULL, size);
    if (app->data == NULL) {
        return NULL;
    }

    app->sys_vec = CEU_SYS_VEC;
    app->nxt = NULL;

    /* Assumes sizeof(void*)==sizeof(WORD) and
        that gcc will word-align SIZE/INIT */
#ifdef __AVR
    app->init = (tceu_init) (((word)addr>>1) + (word)init);
#else
    app->init = (tceu_init) ((word)init);
#endif
    app->addr = addr;

#ifdef CEU_OS_LUAIFC
    app->luaifc = luaifc;
#endif

    return app;
}

void ceu_sys_start (tceu_app* app)
{
    /* add as head */
	if (CEU_APPS == NULL) {
		CEU_APPS = app;

    /* add to tail */
    } else {
		tceu_app* cur = CEU_APPS;
        while (cur->nxt != NULL) {
            cur = cur->nxt;
        }
        cur->nxt = app;
    }

    /* MAX OK */
#ifdef CEU_RET
    ok++;
#endif

    /* INIT */

    app->init(app);

    /* OS_START */

#ifdef CEU_IN_OS_START
    ceu_sys_emit(NULL, CEU_IN_OS_START, 0, NULL);
#endif
}

/* LINK & UNLINK */

int ceu_sys_link (tceu_app* src_app, tceu_nevt src_evt,
                  tceu_app* dst_app, tceu_nevt dst_evt)
{
    tceu_lnk* lnk = (tceu_lnk*) ceu_sys_realloc(NULL, sizeof(tceu_lnk));
    if (lnk == NULL) {
        return 0;
    }

    lnk->src_app = src_app;
    lnk->src_evt = src_evt;
    lnk->dst_app = dst_app;
    lnk->dst_evt = dst_evt;
    lnk->nxt = NULL;

    /* add as head */
	if (CEU_LNKS == NULL) {
		CEU_LNKS = lnk;

    /* add to tail */
    } else {
		tceu_lnk* cur = CEU_LNKS;
        while (cur->nxt != NULL) {
            cur = cur->nxt;
        }
		cur->nxt = lnk;
    }

    return 1;
}

int ceu_sys_unlink (tceu_app* src_app, tceu_nevt src_evt,
                    tceu_app* dst_app, tceu_nevt dst_evt)
{
    tceu_lnk* cur = CEU_LNKS;
    while (cur != NULL) {
        tceu_lnk* nxt = cur->nxt;
        if ( (src_app==0 || src_app==cur->src_app)
          && (src_evt==0 || src_evt==cur->src_evt)
          && (dst_app==0 || dst_app==cur->dst_app)
          && (dst_evt==0 || dst_evt==cur->dst_evt) ) {
            _ceu_sys_unlink(cur);
        }
        cur = nxt;
    }
    return 0;
}

#ifdef CEU_ISR

/* Foreach ISR, call ceu_sys_emit(CEU_IN_OS_INTERRUPT). */

#define GEN_ISR(n)                                                  \
    ISR(__vector_ ## n, ISR_BLOCK) {                                \
        tceu_isr* isr = &CEU_ISR_VEC[n-1];                          \
        if (isr->f != NULL) {                                       \
            CEU_APP_ADDR = isr->app->addr;                          \
            isr->f(isr->app, isr->app->data);                       \
            CEU_APP_ADDR = 0;                                       \
        }                                                           \
        ceu_sys_emit(NULL,CEU_IN_OS_INTERRUPT,CEU_EVTP(n),0,NULL); \
    }
#define _GEN_ISR(n)

GEN_ISR(20);
/*
GEN_ISR( 1) GEN_ISR( 2) GEN_ISR( 3) GEN_ISR( 4) GEN_ISR( 5)
GEN_ISR( 6) GEN_ISR( 7) GEN_ISR( 8) GEN_ISR( 9) GEN_ISR(10)
GEN_ISR(11) GEN_ISR(12) GEN_ISR(13) GEN_ISR(14) GEN_ISR(15)
GEN_ISR(16) GEN_ISR(17) _GEN_ISR(18) GEN_ISR(19) GEN_ISR(20)
GEN_ISR(21) GEN_ISR(22) GEN_ISR(23) GEN_ISR(24) GEN_ISR(25)
GEN_ISR(26) GEN_ISR(27) GEN_ISR(28) GEN_ISR(29) GEN_ISR(30)
GEN_ISR(31) GEN_ISR(32) GEN_ISR(33) GEN_ISR(34) GEN_ISR(35)
GEN_ISR(36) GEN_ISR(37) GEN_ISR(38) GEN_ISR(39) GEN_ISR(40)
*/

#endif /* CEU_ISR */

#endif /* ifdef CEU_OS_KERNEL */

#endif /* ifndef CEU_OS_APP */


#include <stdlib.h>
#ifdef CEU_DEBUG
#include <stdio.h>      /* printf */
#include <signal.h>     /* signal */
#endif
#ifdef CEU_RUNTESTS
#include <string.h>     /* memset */
#endif

#ifdef CEU_THREADS
#   define CEU_ATOMIC(f)                                      \
            CEU_THREADS_MUTEX_LOCK(&_ceu_app->threads_mutex); \
                f                                             \
            CEU_THREADS_MUTEX_UNLOCK(&_ceu_app->threads_mutex);
#else
#   define CEU_ATOMIC(f) f
#endif

#ifdef CEU_NEWS_POOL
#ifndef _CEU_POOL_H
#define _CEU_POOL_H

#include "ceu_types.h"

/* TODO: all "int" here, should evaluate the correct unsigned type */

typedef struct {
    byte**  queue;
                    /* queue is in the next offset to distinguish dynamic(NULL)
                       from static pools(any-address) */
    int     size;
    int     free;
    int     index;
    int     unit;
    byte*   mem;
} tceu_pool;

#define CEU_POOL_DCL(name, type, size) \
    type*     name##_queue[size];      \
    type      name##_mem[size];        \
    tceu_pool name;

void ceu_pool_init (tceu_pool* pool, int size, int unit, byte** queue, byte* mem);
byte* ceu_pool_alloc (tceu_pool* pool);
void ceu_pool_free (tceu_pool* pool, byte* val);

#endif

/*
 * Ceu pool.c is based on Contiki and TinyOS pools:
 * https://github.com/contiki-os/contiki/blob/master/core/lib/memb.c
 * https://github.com/tinyos/tinyos-main/blob/master/tos/system/PoolP.nc
 */
#ifndef _CEU_POOL_C
#define _CEU_POOL_C

#include <stdlib.h>


void ceu_pool_init (tceu_pool* pool, int size, int unit, byte** queue, byte* mem)
{
    int i;
    pool->size  = size;
    pool->free  = size;
    pool->index = 0;
    pool->unit  = unit;
    pool->queue = queue;
    pool->mem   = mem;
    for (i=0; i<size; i++) {
        queue[i] = &mem[i*unit];
    }
}

byte* ceu_pool_alloc (tceu_pool* pool) {
    byte* ret;

    if (pool->free == 0) {
        return NULL;
    }

    pool->free--;
    ret = pool->queue[pool->index];
    pool->queue[pool->index++] = NULL;
    if (pool->index == pool->size) {
        pool->index = 0;
    }
    return ret;
}

void ceu_pool_free (tceu_pool* pool, byte* val) {
    int empty = pool->index + pool->free;
    if (empty >= pool->size) {
        empty -= pool->size;
    }
    pool->queue[empty] = val;
    pool->free++;
}

/*
int ceu_pool_inside (tceu_pool* pool, byte* val) {
    return ((byte*)val >= pool->mem)
        && ((byte*)val < pool->mem+(pool->size*pool->unit));
}
*/

#endif

#endif

#ifdef CEU_VECTOR
#ifndef _CEU_VECTOR_H
#define _CEU_VECTOR_H

#ifndef _CEU_OS_H
#define _CEU_OS_H

#include <stddef.h>
#include "ceu_types.h"

#ifdef CEU_DEBUG
#include <assert.h>
#endif

#if defined(CEU_OS) && defined(__AVR)
#error Understand this again!
#include "Arduino.h"
#define CEU_ISR
#define CEU_ISR_ON()  interrupts()
#define CEU_ISR_OFF() noInterrupts()
#else
#define CEU_ISR_ON()
#define CEU_ISR_OFF()
#endif

#if defined(CEU_OS_KERNEL) || defined(CEU_OS_APP)
#define CEU_OS
#endif

#if defined(CEU_ORGS_NEWS) || defined(CEU_ADTS_NEWS)
#define CEU_NEWS
#endif
#if defined(CEU_ORGS_NEWS_POOL) || defined(CEU_ADTS_NEWS_POOL)
#define CEU_NEWS_POOL
#endif
#if defined(CEU_ORGS_AWAIT) || defined(CEU_ADTS_AWAIT)
#define CEU_ORGS_OR_ADTS_AWAIT
#endif

#ifdef CEU_OS

    /* TODO: all should be configurable */
    #define CEU_EXTS
    #define CEU_WCLOCKS
    #define CEU_ASYNCS
    #define CEU_RET
    #define CEU_CLEAR
    #define CEU_STACK_CLEAR
#ifndef __AVR
#endif
    #define CEU_INTS
    #define CEU_ORGS
    /*#define CEU_PSES*/ /* TODO: never tried */
    #define CEU_NEWS
    #define CEU_NEWS_POOL
    #define CEU_ORGS_NEWS
    #define CEU_ORGS_NEWS_MALLOC
    #define CEU_ORGS_NEWS_POOL
    #define CEU_ADTS_NEWS
    #define CEU_ADTS_NEWS_MALLOC
    #define CEU_ADTS_NEWS_POOL
    #define CEU_ORGS_AWAIT
    #define CEU_ADTS_AWAIT
    #define CEU_ORGS_OR_ADTS_AWAIT
/*
    #define CEU_THREADS
*/

#ifdef __AVR
    #define CEU_QUEUE_MAX 256
#else
    #define CEU_QUEUE_MAX 65536
#endif

    #define CEU_IN__NONE          0
    #define CEU_IN__ORG         255
    #define CEU_IN__ORG_PSED    254
    #define CEU_IN__CLEAR       253
    #define CEU_IN__ok_killed   252
    #define CEU_IN__INIT        251     /* HIGHER EXTERNAL */
    #define CEU_IN__ASYNC       250
    #define CEU_IN__THREAD      249
    #define CEU_IN__WCLOCK      248
    #define CEU_IN_OS_START     247
    #define CEU_IN_OS_STOP      246
    #define CEU_IN_OS_DT        245
    #define CEU_IN_OS_INTERRUPT 244
#ifdef CEU_TIMEMACHINE
    #define CEU_IN__WCLOCK_     243
    #define CEU_IN              243
#else
    #define CEU_IN              242
#endif

    #define CEU_IN_higher       CEU_IN__INIT  /* _INIT = HIGHER EXTERNAL */
    #define CEU_IN_lower        128     /* TODO: not checked from up and down */

    typedef s8 tceu_nlbl;   /* TODO: to small!! */

#endif /* CEU_OS */

#ifdef CEU_OS_APP

    #define ceu_out_log(mode,str) \
        ((__typeof__(ceu_sys_log)*)((_ceu_app)->sys_vec[CEU_SYS_LOG]))(mode,str)

    #define ceu_out_assert(v) \
        ((__typeof__(ceu_sys_assert)*)((_ceu_app)->sys_vec[CEU_SYS_ASSERT]))(v)

    #define ceu_out_assert_msg_ex(v,msg,file,line)       \
        {                                                \
            int __ceu_v = v;                             \
            if ((!(__ceu_v)) && ((msg)!=NULL)) {         \
                ceu_out_log(0, (long)"[");               \
                ceu_out_log(0, (long)(file));            \
                ceu_out_log(0, (long)":");               \
                ceu_out_log(2, (line));                  \
                ceu_out_log(0, (long)"] ");              \
                ceu_out_log(0, (long)"runtime error: "); \
                ceu_out_log(0, (long)(msg));             \
                ceu_out_log(0, (long)"\n");              \
            }                                            \
            ((__typeof__(ceu_sys_assert)*)((_ceu_app)->sys_vec[CEU_SYS_ASSERT]))(__ceu_v); \
        }
    #define ceu_out_assert_msg(v,msg) ceu_out_assert_msg_ex((v),(msg),__FILE__,__LINE__)

    #define ceu_out_realloc(ptr, size) \
        ((__typeof__(ceu_sys_realloc)*)((_ceu_app)->sys_vec[CEU_SYS_REALLOC]))(ptr,size)

    #define ceu_out_req() \
        ((__typeof__(ceu_sys_req)*)((_ceu_app)->sys_vec[CEU_SYS_REQ]))()

    #define ceu_out_load(addr) \
        ((__typeof__(ceu_sys_load)*)((_ceu_app)->sys_vec[CEU_SYS_LOAD]))(addr)

#ifdef CEU_ISR
    #define ceu_out_isr(n,f) \
        ((__typeof__(ceu_sys_isr)*)((_ceu_app)->sys_vec[CEU_SYS_ISR]))(n,f,_ceu_app)
#endif

    #define ceu_out_org_init(app,org,n,lbl,cls,isDyn,parent_org,parent_trl) \
        ((__typeof__(ceu_sys_org_init)*)((app)->sys_vec[CEU_SYS_ORG]))(org,n,lbl,cls,isDyn,parent_org,parent_trl)
    #define ceu_out_start(app) \
        ((__typeof__(ceu_sys_start)*)((_ceu_app)->sys_vec[CEU_SYS_START]))(app)
    #define ceu_out_link(app1,evt1 , app2,evt2) \
        ((__typeof__(ceu_sys_link)*)((_ceu_app)->sys_vec[CEU_SYS_LINK]))(app1,evt1,app2,evt2)

    #define ceu_out_emit(app,id,sz,buf) \
        ((__typeof__(ceu_sys_emit)*)((app)->sys_vec[CEU_SYS_EMIT]))(app,id,sz,buf)

    #define ceu_out_call(app,id,param) \
        ((__typeof__(ceu_sys_call)*)((app)->sys_vec[CEU_SYS_CALL]))(app,id,param)

#ifdef CEU_WCLOCKS
    #define ceu_out_wclock(app,dt,set,get) \
        ((__typeof__(ceu_sys_wclock)*)((app)->sys_vec[CEU_SYS_WCLOCK]))(app,dt,set,get)
#ifdef CEU_TIMEMACHINE
    #error TIMEMACHINE
#endif
#endif

    #define ceu_out_go(app,evt,evtp) \
        ((__typeof__(ceu_sys_go)*)((app)->sys_vec[CEU_SYS_GO]))(app,evt,evtp)

#else /* ! CEU_OS_APP (!CEU_OS||CEU_OS_KERNEL) */

    #ifndef ceu_out_assert
        #error "Missing definition for macro \"ceu_out_assert\"."
    #endif

    #ifndef ceu_out_log
        #error "Missing definition for macro \"ceu_out_log\"."
    #endif

    #define ceu_out_assert_msg_ex(v,msg,file,line)          \
        {                                                   \
            int __ceu_v = v;                                \
            if ((!(__ceu_v)) && ((msg)!=NULL)) {            \
                ceu_out_log(0, (long)"[");                  \
                ceu_out_log(0, (long)(file));               \
                ceu_out_log(0, (long)":");                  \
                ceu_out_log(2, line);                       \
                ceu_out_log(0, (long)"] ");                 \
                ceu_out_log(0, (long)"runtime error: ");    \
                ceu_out_log(0, (long)(msg));                \
                ceu_out_log(0, (long)"\n");                 \
            }                                               \
            ceu_out_assert(__ceu_v);                        \
        }
    #define ceu_out_assert_msg(v,msg) ceu_out_assert_msg_ex((v),(msg),__FILE__,__LINE__)

    #define ceu_out_realloc(ptr,size) \
            ceu_sys_realloc(ptr,size)
    #define ceu_out_req() \
            ceu_sys_req()
    #define ceu_out_org_init(app,org,n,lbl,cls,isDyn,parent_org,parent_trl) \
            ceu_sys_org_init(org,n,lbl,cls,isDyn,parent_org,parent_trl)

#ifdef CEU_WCLOCKS
    #define ceu_out_wclock(app,dt,set,get) \
            ceu_sys_wclock(app,dt,set,get)
#ifdef CEU_TIMEMACHINE
    #define ceu_out_wclock_(app,dt,set,get) \
            ceu_sys_wclock_(app,dt,set,get)
#endif
#endif
    #define ceu_out_go(app,evt,evtp) \
            ceu_sys_go(app,evt,evtp)
    #define ceu_out_go_stk(app,evt,evtp,stk) \
            ceu_sys_go_stk(app,evt,evtp,stk)

#endif /* ! CEU_OS_APP (!CEU_OS||CEU_OS_KERNEL) */

#ifdef CEU_STACK_CLEAR
#define ceu_in_emit(app,id,n,buf) \
    ceu_out_go_stk(app,id,buf,&stk_)
#else
#define ceu_in_emit(app,id,n,buf) \
    ceu_out_go_stk(app,id,buf,NULL)
#endif

#ifdef CEU_THREADS
/* TODO: app */
#include "ceu_threads.h"
#endif

#ifdef CEU_LUA
#include <stdio.h>      /* BUFSIZ */
#include <string.h>     /* strcpy */
#if defined(__ANDROID__) || defined(CEU_OS)
    #include "lua.h"
    #include "lauxlib.h"
    #include "lualib.h"
#else
    #include <lua5.1/lua.h>
    #include <lua5.1/lauxlib.h>
    #include <lua5.1/lualib.h>
#endif

#ifdef CEU_OS_APP
    #define ceu_luaL_newstate(set) { \
        set = ceu_out_call(_ceu_app, CEU_OUT_LUA_NEW, NULL); \
    }

    #define ceu_luaL_openlibs(l) { \
        lua_State* p = l;          \
        ceu_out_call(_ceu_app, CEU_OUT_LUAL_OPENLIBS, &p); \
    }

    #define ceu_lua_atpanic(l, f) {     \
    }

    #define ceu_luaL_loadstring(set, l, str) {  \
        tceu__lua_State___char_ p = { l, str }; \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUAL_LOADSTRING, &p); \
    }

    #define ceu_lua_pushnumber(l, v) {      \
        tceu__lua_State___int p = { l, v }; \
        ceu_out_call(_ceu_app, CEU_OUT_LUA_PUSHNUMBER, &p); \
    }

    #define ceu_lua_pushstring(l, v) {      \
        tceu__lua_State___char_ p = { l, v }; \
        ceu_out_call(_ceu_app, CEU_OUT_LUA_PUSHSTRING, &p); \
    }

    #define ceu_lua_pushlightuserdata(l, v) {   \
        tceu__lua_State___void_ p = { l, v };     \
        ceu_out_call(_ceu_app, CEU_OUT_LUA_PUSHLIGHTUSERDATA, &p); \
    }

    #define ceu_lua_pcall(set,l,nargs,nrets,err) {                  \
        tceu__lua_State___int__int__int p = { l, nargs, nrets, err }; \
        ceu_out_call(_ceu_app, CEU_OUT_LUA_PCALL, &p); \
    }

    #define ceu_lua_isnumber(set, l, idx) {     \
        tceu__lua_State___int p = { l, idx };   \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUA_ISNUMBER, &p); \
    }

    #define ceu_lua_tonumber(set, l, idx) {     \
        tceu__lua_State___int p = { l, idx };   \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUA_TONUMBER, &p); \
    }

    #define ceu_lua_isboolean(set, l, idx) {    \
        tceu__lua_State___int p = { l, idx };   \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUA_ISBOOLEAN, &p); \
    }

    #define ceu_lua_toboolean(set, l, idx) {    \
        tceu__lua_State___int p = { l, idx };   \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUA_TOBOOLEAN, &p); \
    }

    #define ceu_lua_pop(l, n) {             \
        tceu__lua_State___int p = { l, n }; \
        ceu_out_call(_ceu_app, CEU_OUT_LUA_POP, &p); \
    }

    #define ceu_lua_isstring(set, l, idx) {     \
        tceu__lua_State___int p = { l, idx };   \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUA_ISSTRING, &p); \
    }

    #define ceu_lua_tostring(set, l, idx) {     \
        tceu__lua_State___int p = { l, idx };   \
        set = ceu_out_call(_ceu_app, CEU_OUT_LUA_TOSTRING, &p); \
    }

    #define ceu_lua_islightuserdata(set, l, idx) {  \
        tceu__lua_State___int p = { l, idx };       \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUA_ISLIGHTUSERDATA, &p); \
    }

    #define ceu_lua_touserdata(set, l, idx) {   \
        tceu__lua_State___int p = { l, idx };   \
        set = ceu_out_call(_ceu_app, CEU_OUT_LUA_TOUSERDATA, &p); \
    }

    #define ceu_lua_error(l) {                          \
        lua_State** p = &l;                             \
        ceu_out_call(_ceu_app, CEU_OUT_LUA_ERROR, &p);  \
    }

    #define ceu_lua_objlen(set, l, idx) {                       \
        tceu__lua_State___int p = { l, idx };                   \
        set = ceu_out_call(_ceu_app, CEU_OUT_LUA_OBJLEN, &p);   \
    }

#else
    #define ceu_luaL_newstate(set)               set = luaL_newstate()
    #define ceu_luaL_openlibs(l)                 luaL_openlibs(l)
    #define ceu_lua_atpanic(l,f)                 lua_atpanic(l,f)
    #define ceu_luaL_loadstring(set,l,str)       set = luaL_loadstring(l,str)
    #define ceu_lua_pushnumber(l,v)              lua_pushnumber(l,v)
    #define ceu_lua_pushstring(l,v)              lua_pushstring(l,v)
    #define ceu_lua_pushlightuserdata(l,v)       lua_pushlightuserdata(l,v)
    #define ceu_lua_pcall(set,l,nargs,nrets,err) set = lua_pcall(l,nargs,nrets,err)
    #define ceu_lua_isnumber(set,l,idx)          set = lua_isnumber(l,idx)
    #define ceu_lua_tonumber(set,l,idx)          set = lua_tonumber(l,idx)
    #define ceu_lua_isboolean(set,l,idx)         set = lua_isboolean(l,idx)
    #define ceu_lua_toboolean(set,l,idx)         set = lua_toboolean(l,idx)
    #define ceu_lua_pop(l,n)                     lua_pop(l,n)
    #define ceu_lua_isstring(set,l,idx)          set = lua_isstring(l,idx)
    #define ceu_lua_tostring(set,l,idx)          set = lua_tostring(l,idx)
    #define ceu_lua_islightuserdata(set,l,idx)   set = lua_islightuserdata(l,idx)
    #define ceu_lua_touserdata(set,l,idx)        set = lua_touserdata(l,idx)
    #define ceu_lua_error(l)                     lua_error(l)
    #define ceu_lua_objlen(set,l,idx)            set = lua_objlen(l,idx)
#endif
#endif

typedef u8 tceu_nevt;   /* max number of events */
                        /* TODO: should "u8" be fixed? */

typedef u8 tceu_ntrl;   /* max number of trails per class */
                        /* TODO: should "u8" be fixed? */

#ifdef CEU_STACK_CLEAR
typedef u16 tceu_nstk;  /* max size of internal stack in bytes */
                        /* TODO: should "u16" be fixed? */
#endif

#ifdef __cplusplus
#define CEU_WCLOCK_INACTIVE 0x7fffffffL     /* TODO */
#else
#define CEU_WCLOCK_INACTIVE INT32_MAX
#endif
#define CEU_WCLOCK_EXPIRED (CEU_WCLOCK_INACTIVE-1)

/* TCEU_TRL */

struct tceu_org;
typedef union tceu_trl {
    tceu_nevt evt;

    /* normal await // IN__CLEAR */
    struct {                    /* TODO(ram): bitfields */
        tceu_nevt evt1;
        tceu_nlbl lbl;
        u8        seqno;        /* TODO(ram): 2 bits is enough */
#ifdef CEU_INTS                 /* R-9: size of trails for internal events */
#ifdef CEU_ORGS
        void*     evto;
#endif
#endif
    };

    /* IN__ORG */
#ifdef CEU_ORGS
    struct {                    /* TODO(ram): bad for alignment */
        tceu_nevt evt3;
        struct tceu_org* org;
    };
#endif

    /* _ok_killed */
#ifdef CEU_ORGS_OR_ADTS_AWAIT
    struct {
        tceu_nevt evt4;
        tceu_nlbl lbl4;
#ifdef CEU_ORGS_AWAIT
#ifdef CEU_ADTS_AWAIT
        u8        is_org;
#endif
#endif
        void*     org_or_adt;
    };
#endif
} tceu_trl;

/* TCEU_EVT */

typedef struct tceu_evt {
    tceu_nevt id;
    void*     param;
#if defined(CEU_ORGS) && defined(CEU_INTS)
    void*     org;      /* emitting org */
#endif
} tceu_evt;

/* TCEU_ORG */

struct tceu_pool_orgs;
typedef struct tceu_org
{
#ifdef CEU_ORGS
    struct tceu_org* nxt; /* first field because of free list for orgs/adts */
    struct tceu_org* prv;
    struct tceu_org* parent_org;
    tceu_ntrl parent_trl;
#endif

#if defined(CEU_ORGS) || defined(CEU_OS)
    tceu_ntrl n;            /* number of trails (TODO(ram): opt, metadata) */
#endif

#ifdef CEU_ORGS

#ifdef CEU_IFCS
    tceu_ncls cls;          /* class id */
#endif
    u8 isAlive: 1;          /* Three purposes:
                             * - avoids double free
                             * - required by "watching o" to avoid awaiting a
                             *      dead org
                             * - required by "Do T" to avoid awaiting a dead 
                             *      org
                             */
#if defined(CEU_ORGS_NEWS) || defined(CEU_ORGS_AWAIT)
#endif
#ifdef CEU_ORGS_NEWS
    u8 isDyn: 1;            /* created w/ new or spawn? */
#endif
#ifdef CEU_ORGS_NEWS_POOL
    struct tceu_pool_orgs* pool;
#endif

#ifdef CEU_ORGS_AWAIT
    int ret;
#endif

#endif  /* CEU_ORGS */

    tceu_trl trls[0];       /* first trail */

} tceu_org;

/* TCEU_POOL_ORGS , TCEU_POOL_ADTS */

#if defined(CEU_ORGS_NEWS_POOL) || defined(CEU_ADTS_NEWS_POOL)
#include "ceu_pool.h"
#endif

#ifdef CEU_ORGS_NEWS
typedef struct tceu_pool_orgs {
    tceu_org* parent_org;
    tceu_ntrl parent_trl;
#ifdef CEU_ORGS_NEWS_POOL
    tceu_pool pool;
#endif
} tceu_pool_orgs;
#endif

#ifdef CEU_ADTS_NEWS
typedef struct {
    void* root;
#ifdef CEU_ADTS_NEWS_POOL
    void* pool;
#endif
} tceu_pool_adts;
#endif

/* TCEU_KILL */

#ifdef CEU_ORGS_OR_ADTS_AWAIT
typedef struct tceu_kill {
    void*     org_or_adt;
    int       ret;
    tceu_ntrl t1;
    tceu_ntrl t2;
} tceu_kill;
#endif

/* TCEU_LST */

#ifdef CEU_DEBUG
typedef struct tceu_lst {
#ifdef CEU_ORGS
    void*     org;
#endif
    tceu_trl* trl;
    tceu_nlbl lbl;
} tceu_lst;

#endif

/* TCEU_STK */

#ifdef CEU_STACK_CLEAR
typedef struct tceu_stk {
    struct tceu_stk* down;
    tceu_org*   org;
    tceu_ntrl   trl1;
    tceu_ntrl   trl2;
    char        is_alive;
} tceu_stk;
#else
typedef void tceu_stk;
#endif

/* TCEU_APP */

typedef struct tceu_app {
    /* global seqno: incremented on every reaction
     * awaiting trails matches only if trl->seqno < seqno,
     * i.e., previously awaiting the event
     */
    u8 seqno:          2;
#if defined(CEU_RET) || defined(CEU_OS)
    u8 isAlive:        1;
#endif
#ifdef CEU_ASYNCS
    u8 pendingAsyncs:  1;
#endif
#if defined(CEU_ORGS_NEWS_MALLOC) && defined(CEU_ORGS_AWAIT)
    u8 dont_emit_kill: 1;
#endif

#ifdef CEU_OS
    struct tceu_app* nxt;
#endif

#if defined(CEU_RET) || defined(CEU_ORGS_AWAIT)
    int ret;
#endif

#ifdef CEU_ORGS_NEWS_MALLOC
    tceu_org* tofree;
#endif

#ifdef CEU_WCLOCKS
    s32         wclk_late;
    s32         wclk_min_set;   /* used to set */
    s32         wclk_min_cmp;   /* used to compare */
                                /* cmp<-set every reaction */
#ifdef CEU_TIMEMACHINE
    s32         wclk_late_;
    s32         wclk_min_set_;
    s32         wclk_min_cmp_;
#endif
#endif

#ifndef CEU_OS
#ifdef CEU_DEBUG
    tceu_lst    lst; /* segfault printf */
#endif
#endif

#ifdef CEU_THREADS
    CEU_THREADS_MUTEX_T threads_mutex;
    /*CEU_THREADS_COND_T  threads_cond;*/
    u8                  threads_n;          /* number of running threads */
        /* TODO: u8? */
#endif
#if defined(CEU_LUA) || defined(CEU_OS)
#ifdef CEU_LUA
    lua_State*  lua;    /* TODO: move to data? */
#else
    void*       lua;
#endif
#endif

    void        (*code)  (struct tceu_app*,tceu_evt*,tceu_org*,tceu_trl*,tceu_stk*);
    void        (*init)  (struct tceu_app*);
#ifdef CEU_OS
    void*       (*calls) (struct tceu_app*,tceu_nevt,void*);
    void**      sys_vec;
    void*       addr;
#ifdef CEU_OS_LUAIFC
    char*       luaifc;
#endif
#endif
    tceu_org*   data;
} tceu_app;

#ifdef CEU_OS
typedef void (*tceu_init)   (tceu_app* app);
typedef void (*tceu_export) (uint* size, tceu_init** init
#ifdef CEU_OS_LUAIFC
                            , char** luaifc
#endif
);
#endif

/* TCEU_THREADS_P */

#ifdef CEU_THREADS
typedef struct {
    tceu_app* app;
    tceu_org* org;
    s8*       st; /* thread state:
                   * 0=ini (sync  spawns)
                   * 1=cpy (async copies)
                   * 2=lck (sync  locks)
                   * 3=end (sync/async terminates)
                   */
} tceu_threads_p;
#endif

#ifdef CEU_PSES
void ceu_pause (tceu_trl* trl, tceu_trl* trlF, int psed);
#endif

int  ceu_go_all    (tceu_app* app);

#ifdef CEU_WCLOCKS
int       ceu_sys_wclock (tceu_app* app, s32 dt, s32* set, s32* get);
#endif
void      ceu_sys_go     (tceu_app* app, int evt, void* evtp);

#ifdef CEU_OS

/* TCEU_LINK */

typedef struct tceu_lnk {
    tceu_app* src_app;
    tceu_nevt src_evt;
    tceu_app* dst_app;
    tceu_nevt dst_evt;
    struct tceu_lnk* nxt;
} tceu_lnk;

/* TCEU_QUEUE */

typedef struct {
    tceu_app* app;
    tceu_nevt evt;
#if CEU_QUEUE_MAX == 256
    s8        sz;
#else
    s16       sz;   /* signed because of fill */
#endif
    byte      buf[0];
} tceu_queue;

#ifdef CEU_ISR
typedef void(*tceu_isr_f)(tceu_app* app, tceu_org* org);
#endif

void ceu_os_init      (void);
int  ceu_os_scheduler (int(*dt)());
tceu_queue* ceu_sys_queue_nxt (void);
void        ceu_sys_queue_rem (void);

void      ceu_sys_assert    (int v);
void      ceu_sys_log       (int mode, long str);
void*     ceu_sys_realloc   (void* ptr, size_t size);
int       ceu_sys_req       (void);
tceu_app* ceu_sys_load      (void* addr);
#ifdef CEU_ISR
int       ceu_sys_isr       (int n, tceu_isr_f f, tceu_app* app);
#endif
void      ceu_sys_org_init  (tceu_org* org, int n, int lbl, int cls, int isDyn,
                             tceu_org* parent_org, tceu_ntrl parent_trl);
void      ceu_sys_start     (tceu_app* app);
int       ceu_sys_link      (tceu_app* src_app, tceu_nevt src_evt, tceu_app* dst_app, tceu_nevt dst_evt);
int       ceu_sys_unlink    (tceu_app* src_app, tceu_nevt src_evt, tceu_app* dst_app, tceu_nevt dst_evt);
int       ceu_sys_emit      (tceu_app* app, tceu_nevt evt, int sz, void* param);
void*     ceu_sys_call      (tceu_app* app, tceu_nevt evt, void* param);

enum {
    CEU_SYS_ASSERT = 0,
    CEU_SYS_LOG,
    CEU_SYS_REALLOC,
    CEU_SYS_REQ,
    CEU_SYS_LOAD,
#ifdef CEU_ISR
    CEU_SYS_ISR,
#endif
#ifdef CEU_CLEAR
    CEU_SYS_CLEAR,
#endif
    CEU_SYS_STACK_PUSH,
#ifdef CEU_ORGS
    CEU_SYS_STACK_CLEAR_ORG,
#endif
    CEU_SYS_ORG,
#ifdef CEU_ORGS
    CEU_SYS_ORG_TRAIL,
    CEU_SYS_ORG_SPAWN,
#endif
    CEU_SYS_START,
    CEU_SYS_LINK,
    CEU_SYS_UNLINK,
    CEU_SYS_EMIT,
    CEU_SYS_CALL,
#ifdef CEU_WCLOCKS
    CEU_SYS_WCLOCK,
#endif
    CEU_SYS_GO,
    CEU_SYS_MAX
};

/* SYS_VECTOR
 */
extern void* CEU_SYS_VEC[CEU_SYS_MAX];

#endif  /* CEU_OS */

#endif  /* _CEU_OS_H */


typedef struct {
    int   max;
    int   nxt;
    int   unit;
    byte* mem;
} tceu_vector;

#define CEU_VECTOR_DCL(name, type, max)  \
    type        name##_mem[max+1];       \
    tceu_vector name;
                /* [STRING] max+1: extra space for '\0' */

#define ceu_vector_getlen(vec) ((vec)->nxt)
#define ceu_vector_getmax(vec) ((vec)->max > 0 ? (vec)->max : 0)

void  ceu_vector_init   (tceu_vector* vector, int max, int unit, byte* mem);
int   ceu_vector_setlen (tceu_vector* vector, int len);
byte* ceu_vector_geti   (tceu_vector* vector, int idx);
int   ceu_vector_seti   (tceu_vector* vector, int idx, byte* v);
int   ceu_vector_push   (tceu_vector* vector, byte* v);
int   ceu_vector_concat (tceu_vector* to, tceu_vector* fr);
int   ceu_vector_concat_buffer (tceu_vector* to, const char* fr, int n);
char* ceu_vector_tochar (tceu_vector* vector);

#if 0
byte* ceu_pool_alloc (tceu_pool* pool);
void ceu_pool_free (tceu_pool* pool, byte* val);
#endif
#endif

#ifndef _CEU_VECTOR_C
#define _CEU_VECTOR_C



void ceu_vector_init (tceu_vector* vector, int max, int unit, byte* mem) {
    vector->nxt  = 0;
    vector->max  = max;
    vector->unit = unit;
    vector->mem  = (max==0) ? NULL : mem;

    /* [STRING] */
    if (vector->mem != NULL) {
        vector->mem[0] = '\0';
    }
}

#ifdef CEU_VECTOR_MALLOC
static void* ceu_vector_resize (tceu_vector* vector, int n) {
    ceu_out_assert_msg(vector->max <= 0, "bug found");

    if (n == 0) {
        /* free */
        if (vector->mem != NULL) {
            vector->max = 0;
            ceu_out_realloc(vector->mem, 0);
            vector->mem = NULL;
        }
    } else {
        /* TODO: Java does the same? */
        n = (n*3/2) + 1;
        if (n < 10) {
            n = 10;
        }

        vector->max = -n;
        vector->mem = (byte*)ceu_out_realloc(vector->mem, n*vector->unit + 1);
                                                        /* [STRING] +1 */
    }

    return vector->mem;
}
#endif

/* can only decrease vector->nxt */
int ceu_vector_setlen (tceu_vector* vector, int nxt) {
    if (nxt > vector->nxt) {
        return 0;
    } else {
        vector->nxt = nxt;

        /* [STRING] */
        if (vector->mem != NULL) {
            vector->mem[nxt*vector->unit] = '\0';
        }

#ifdef CEU_VECTOR_MALLOC
        /* shrink malloc'ed arrays */
        if (vector->max <= 0) {
            if (ceu_vector_resize(vector,nxt)==NULL && nxt>0) {
                return 0;
            }
        }
#endif

        return 1;
    }
}

/* can only get within idx < vector->nxt */
byte* ceu_vector_geti (tceu_vector* vector, int idx) {
    if (idx >= vector->nxt) {
        return NULL;
    } else {
        return &vector->mem[idx*vector->unit];
    }
}

/* can only set within idx < vector->nxt */
int ceu_vector_seti (tceu_vector* vector, int idx, byte* v) {
    if (idx >= vector->nxt) {
        return 0;
    } else {
        memcpy(&vector->mem[idx*vector->unit], v, vector->unit);
        return 1;
    }
}

/* can only push within nxt < vector->max */
int ceu_vector_push (tceu_vector* vector, byte* v) {
#ifdef CEU_VECTOR_MALLOC
    /* grow malloc'ed arrays */
    if (vector->max <= 0) {
        while (vector->nxt >= -vector->max) {
            if (ceu_vector_resize(vector,vector->nxt+1) == NULL) {
                return 0;
            }
        }
    }
#endif
#ifdef CEU_VECTOR_MALLOC
#ifdef CEU_VECTOR_POOL
    else
#endif
#endif
#ifdef CEU_VECTOR_POOL
    if (vector->nxt >= vector->max) {
        return 0;
    }
#endif

    memcpy(&vector->mem[vector->nxt*vector->unit], v, vector->unit);
    vector->nxt++;
    vector->mem[vector->nxt*vector->unit] = '\0';    /* [STRING] */
    return 1;
}

int ceu_vector_concat (tceu_vector* to, tceu_vector* fr) {
    if (to == fr) {
        return 0;
    } else {
        /* TODO: memcpy */
        int i;
        for (i=0; i<fr->nxt; i++) {
            byte* v = ceu_vector_geti(fr, i);
            if (v == NULL) {
                return 0;
            } else if (!ceu_vector_push(to,v)) {
                return 0;
            }
        }
    }
    return 1;
}

int ceu_vector_concat_buffer (tceu_vector* to, const char* fr, int n) {
    /* TODO: memcpy */
    int i;
    for (i=0; i<n; i++) {
        if (!ceu_vector_push(to,(byte*)&fr[i])) {
            return 0;
        }
    }
    return 1;
}

char* ceu_vector_tochar (tceu_vector* vector) {
    if (vector->mem == NULL) {
        return "";
    } else {
        return (char*)vector->mem;
    }
}

#endif

#endif

#ifdef CEU_IFCS
#include <stddef.h>
/* TODO: === direto? */
#define CEU_NCLS       (=== CEU_NCLS ===)
#endif

/* native code from the Main class */

#line 45 "garden.ceu"

  int seeds[4] = { -1, 0, 0, 0 };
#line 181 "garden.ceu"

  int plot_occupied[6] = { 0, 0, 0, 0, 0, 0 };
  int plot_x[6] = { 375, 643, 930, 310, 645, 977 };
  int plot_y[6] = { 525, 525, 525, 680, 680, 680 };
  int plot_layer[6] = { 1, 1, 1, 2, 2, 2 };
#line 851 "garden.ceu"

  int perch_x[] = { 330, 434, 545, 695, 834, 756 };
  int perch_y[] = { 200, 160, 150, 100, 109, 211 };
  int occupied[] = { 0, 0, 0, 0, 0, 0, };

/* goto labels */
enum {
    Main_Set_out_0 = 0,
    Delay_Awake_UPDATE_1 = 1,
    Class_Delay = 2,
    Garden_Awake__ok_killed_3 = 3,
    Class_Garden = 4,
    Konami_Awake_KEY_DOWN_5 = 5,
    Konami_Awake_KEY_DOWN_6 = 6,
    Konami_Awake_KEY_DOWN_7 = 7,
    Konami_Awake_KEY_DOWN_8 = 8,
    Konami_Awake_KEY_DOWN_9 = 9,
    Konami_Awake_KEY_DOWN_10 = 10,
    Konami_Awake_KEY_DOWN_11 = 11,
    Konami_Awake_KEY_DOWN_12 = 12,
    Konami_Awake_KEY_DOWN_13 = 13,
    Konami_Awake_KEY_DOWN_14 = 14,
    Class_Konami = 15,
    Growing_ParOr_sub_1_16 = 16,
    Growing_ParOr_sub_2_17 = 17,
    Growing_ParOr_out_18 = 18,
    Growing_Awake__ok_killed_19 = 19,
    Growing_Awake__ok_killed_20 = 20,
    Growing_Awake_go_water_21 = 21,
    Growing_Block__fin_22 = 22,
    Class_Growing = 23,
    Philodendron_ParOr_sub_1_24 = 24,
    Philodendron_ParOr_out_25 = 25,
    Philodendron_Awake_go_dig_26 = 26,
    Philodendron_ParOr_sub_1_27 = 27,
    Philodendron_ParOr_out_28 = 28,
    Philodendron_Awake_go_water_29 = 29,
    Philodendron_Awake_ok_30 = 30,
    Philodendron_Block__fin_31 = 31,
    Philodendron_Block__fin_32 = 32,
    Class_Philodendron = 33,
    Pitcher_ParOr_sub_1_34 = 34,
    Pitcher_ParOr_out_35 = 35,
    Pitcher_Awake_go_dig_36 = 36,
    Pitcher_ParOr_sub_1_37 = 37,
    Pitcher_ParOr_out_38 = 38,
    Pitcher_Awake_go_water_39 = 39,
    Pitcher_Awake_ok_40 = 40,
    Pitcher_Block__fin_41 = 41,
    Pitcher_Block__fin_42 = 42,
    Class_Pitcher = 43,
    Orchid_ParOr_sub_1_44 = 44,
    Orchid_ParOr_out_45 = 45,
    Orchid_Awake_go_dig_46 = 46,
    Orchid_ParOr_sub_1_47 = 47,
    Orchid_ParOr_out_48 = 48,
    Orchid_Awake_go_water_49 = 49,
    Orchid_Awake_ok_50 = 50,
    Orchid_Block__fin_51 = 51,
    Orchid_Block__fin_52 = 52,
    Class_Orchid = 53,
    Heliconia_ParOr_sub_1_54 = 54,
    Heliconia_ParOr_out_55 = 55,
    Heliconia_Awake_go_dig_56 = 56,
    Heliconia_ParOr_sub_1_57 = 57,
    Heliconia_ParOr_out_58 = 58,
    Heliconia_Awake_go_water_59 = 59,
    Heliconia_Awake_ok_60 = 60,
    Heliconia_Block__fin_61 = 61,
    Heliconia_Block__fin_62 = 62,
    Class_Heliconia = 63,
    BagActive_ParOr_sub_1_64 = 64,
    BagActive_ParOr_out_65 = 65,
    BagActive_Awake_MOUSE_UP_66 = 66,
    BagActive_Awake_MOUSE_MOVE_67 = 67,
    BagActive_Block__fin_68 = 68,
    Class_BagActive = 69,
    Bag_ParOr_sub_1_70 = 70,
    Bag_ParOr_out_71 = 71,
    Bag_Awake_MOUSE_MOVE_72 = 72,
    Bag_ParOr_sub_1_73 = 73,
    Bag_ParOr_out_74 = 74,
    Bag_Awake_MOUSE_UP_75 = 75,
    Bag_Awake_MOUSE_DOWN_76 = 76,
    Bag_Awake__ok_killed_77 = 77,
    Bag_Block__fin_78 = 78,
    Class_Bag = 79,
    WateringCanActive_ParOr_sub_1_80 = 80,
    WateringCanActive_ParOr_out_81 = 81,
    WateringCanActive_Awake_MOUSE_UP_82 = 82,
    WateringCanActive_Awake_MOUSE_MOVE_83 = 83,
    WateringCanActive_Block__fin_84 = 84,
    Class_WateringCanActive = 85,
    WateringCan_ParOr_sub_1_86 = 86,
    WateringCan_ParOr_out_87 = 87,
    WateringCan_Awake_MOUSE_MOVE_88 = 88,
    WateringCan_ParOr_sub_1_89 = 89,
    WateringCan_ParOr_out_90 = 90,
    WateringCan_Awake_MOUSE_UP_91 = 91,
    WateringCan_Awake_MOUSE_DOWN_92 = 92,
    WateringCan_Awake__ok_killed_93 = 93,
    WateringCan_Block__fin_94 = 94,
    Class_WateringCan = 95,
    ShovelActive_ParOr_sub_1_96 = 96,
    ShovelActive_ParOr_out_97 = 97,
    ShovelActive_Awake_MOUSE_UP_98 = 98,
    ShovelActive_Awake_MOUSE_MOVE_99 = 99,
    ShovelActive_Block__fin_100 = 100,
    Class_ShovelActive = 101,
    Shovel_ParOr_sub_1_102 = 102,
    Shovel_ParOr_out_103 = 103,
    Shovel_Awake_MOUSE_MOVE_104 = 104,
    Shovel_ParOr_sub_1_105 = 105,
    Shovel_ParOr_out_106 = 106,
    Shovel_Awake_MOUSE_UP_107 = 107,
    Shovel_Awake_MOUSE_DOWN_108 = 108,
    Shovel_Awake__ok_killed_109 = 109,
    Shovel_Block__fin_110 = 110,
    Class_Shovel = 111,
    Tween_Awake_UPDATE_112 = 112,
    Class_Tween = 113,
    Fly_Awake__ok_killed_114 = 114,
    Fly_Awake__ok_killed_115 = 115,
    Class_Fly = 116,
    Seed_ParOr_sub_1_117 = 117,
    Seed_ParOr_out_118 = 118,
    Seed_Awake__ok_killed_119 = 119,
    Seed_Awake_MOUSE_MOVE_120 = 120,
    Seed_Awake__ok_killed_121 = 121,
    Seed_Block__fin_122 = 122,
    Class_Seed = 123,
    Birb_ParOr_sub_1_124 = 124,
    Birb_ParOr_out_125 = 125,
    Birb_Awake_UPDATE_126 = 126,
    Birb_Awake__ok_killed_127 = 127,
    Birb_Awake__ok_killed_128 = 128,
    Birb_Block__fin_129 = 129,
    Birb_Awake__ok_killed_130 = 130,
    Birb_Block__fin_131 = 131,
    Birb_Block__fin_132 = 132,
    Class_Birb = 133,
    Main_ParEver_sub_1_134 = 134,
    Main_ParEver_sub_2_135 = 135,
    Main_ParEver_sub_3_136 = 136,
    Main_ParEver_sub_4_137 = 137,
    Main_ParEver_sub_5_138 = 138,
    Main_ParEver_out_139 = 139,
    Main_Awake_MOUSE_DOWN_140 = 140,
    Main_Awake_MOUSE_DOWN_141 = 141,
    Main_Awake_go_plant_142 = 142,
    Main_ParOr_sub_1_143 = 143,
    Main_ParOr_out_144 = 144,
    Main_Awake_MOUSE_OUT_145 = 145,
    Main_Awake_MOUSE_DOWN_146 = 146,
    Main_Awake__ok_killed_147 = 147,
    Main_Awake__ok_killed_148 = 148,
    Main_Awake__ok_killed_149 = 149,
    Main_Awake__ok_killed_150 = 150,
    Main_Awake__ok_killed_151 = 151,
    Main_Awake__ok_killed_152 = 152,
    Main_Awake_UPDATE_153 = 153,
    Main_Awake_UPDATE_154 = 154,
    Main_Awake_UPDATE_155 = 155,
    Main_Block__fin_156 = 156,
    Class_Main = 157,

};

typedef struct {
#ifdef CEU_IFCS
#ifdef CEU_OS_APP
#error remove from RAM!
#endif
    s8        ifcs_clss[CEU_NCLS][=== IFCS_NIFCS ===];
            /* Does "cls" implements "ifc?"
             * (I*) ifc = (I*) cls;     // returns null if not
             * TODO(ram): bitfield
             */

    u16       ifcs_flds[CEU_NCLS][=== IFCS_NFLDS ===];
    u16       ifcs_evts[CEU_NCLS][=== IFCS_NEVTS ===];
    void*     ifcs_funs[CEU_NCLS][=== IFCS_NFUNS ===];
#endif
} _tceu_app;

/* TODO: remove from RAM */
#ifdef CEU_IFCS
static _tceu_app _CEU_APP = {
#ifdef CEU_OS_APP
#error remove from RAM!
#endif
    {
=== IFCS_CLSS ===
    },
    {
=== IFCS_FLDS ===
    },
    {
=== IFCS_EVTS ===
    },
    {
=== IFCS_FUNS ===
    }
};
#endif



/**********************************************************************/

#ifndef CEU_OS_APP
#ifdef CEU_DEBUG
tceu_app* CEU_APP_SIG = NULL;
static void ceu_segfault (int sig_num) {
#ifdef CEU_ORGS
    printf("SEGFAULT on %p : %d\n", CEU_APP_SIG->lst.org, CEU_APP_SIG->lst.lbl);
#else
    printf("SEGFAULT on %d\n", CEU_APP_SIG->lst.lbl);
#endif
    exit(0);
}
#endif
#endif

#ifdef CEU_RUNTESTS
static void ceu_stack_clr () {
    int a[1000];
    memset(a, 0, sizeof(a));
}
#endif

/**********************************************************************/

#ifdef CEU_ORGS
static void _ceu_pre_1 (tceu_app* _ceu_app, tceu_org* __ceu_this) {
/* NODE: BlockI 3871 */
/* NODE: Stmts 3882 */

#line 50 "garden.ceu"
    {/* NODE: Dcl_var 3873 */
/* NODE: Set 3877 */

#line 50 "garden.ceu"
/* SET: ticks *//* NODE: NUMBER 87 */

#line 50 "garden.ceu"
    (((CEU_Delay*)__ceu_this)->ticks) = 100;/* NODE: Dcl_int 3880 */

#line 50 "garden.ceu"
    }}
static void _ceu_pre_2 (tceu_app* _ceu_app, tceu_org* __ceu_this) {
/* NODE: BlockI 3933 */
/* NODE: Stmts 3970 */

#line 66 "garden.ceu"
    {/* NODE: Dcl_var 3935 */
/* NODE: Set 3939 */

#line 66 "garden.ceu"
/* SET: score *//* NODE: NUMBER 120 */

#line 66 "garden.ceu"
    (((CEU_Garden*)__ceu_this)->score) = 0;/* NODE: Dcl_var 3941 */
/* NODE: Set 3945 */

#line 67 "garden.ceu"
/* SET: t0_plants *//* NODE: NUMBER 123 */

#line 67 "garden.ceu"
    (((CEU_Garden*)__ceu_this)->t0_plants) = 0;/* NODE: Dcl_var 3947 */
/* NODE: Set 3951 */

#line 68 "garden.ceu"
/* SET: t1_plants *//* NODE: NUMBER 126 */

#line 68 "garden.ceu"
    (((CEU_Garden*)__ceu_this)->t1_plants) = 0;/* NODE: Dcl_var 3953 */
/* NODE: Set 3957 */

#line 69 "garden.ceu"
/* SET: t2_plants *//* NODE: NUMBER 129 */

#line 69 "garden.ceu"
    (((CEU_Garden*)__ceu_this)->t2_plants) = 0;/* NODE: Dcl_var 3959 */
/* NODE: Set 3963 */

#line 70 "garden.ceu"
/* SET: t3_plants *//* NODE: NUMBER 132 */

#line 70 "garden.ceu"
    (((CEU_Garden*)__ceu_this)->t3_plants) = 0;/* NODE: Dcl_int 3964 */
/* NODE: Dcl_int 3966 */
/* NODE: Dcl_int 3968 */

#line 66 "garden.ceu"
    }}

#endif

#ifdef CEU_ORGS
static void _ceu_constr_155 (tceu_app* _ceu_app, tceu_org* __ceu_this, tceu_org* _ceu_org) {
/* NODE: Dcl_constr 155 */
/* NODE: Block 154 */

#line 77 "garden.ceu"
    {/* NODE: Stmts 153 */

#line 77 "garden.ceu"
    {/* NODE: Set 3982 */

#line 77 "garden.ceu"
/* SET: . *//* NODE: NUMBER 151 */

#line 77 "garden.ceu"
    (((*((CEU_Delay*)__ceu_this)).ticks)) = 60;
#line 77 "garden.ceu"
    }
#line 77 "garden.ceu"
/* CLEAR: Block (77) */
#line 77 "garden.ceu"
    if (0) {

#line 77 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
}
static void _ceu_constr_385 (tceu_app* _ceu_app, tceu_org* __ceu_this, tceu_org* _ceu_org) {
/* NODE: Dcl_constr 385 */
/* NODE: Block 384 */

#line 142 "garden.ceu"
    {/* NODE: Stmts 383 */

#line 142 "garden.ceu"
    {/* NODE: Set 4593 */

#line 142 "garden.ceu"
/* SET: . *//* NODE: Op2_+ 381 */

#line 142 "garden.ceu"
    (((*((CEU_Delay*)__ceu_this)).ticks)) = (((1200+d(400))+d(400))+d(400));
#line 142 "garden.ceu"
    }
#line 142 "garden.ceu"
/* CLEAR: Block (142) */
#line 142 "garden.ceu"
    if (0) {

#line 142 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
}
static void _ceu_constr_410 (tceu_app* _ceu_app, tceu_org* __ceu_this, tceu_org* _ceu_org) {
/* NODE: Dcl_constr 410 */
/* NODE: Block 409 */

#line 147 "garden.ceu"
    {/* NODE: Stmts 408 */

#line 147 "garden.ceu"
    {/* NODE: Set 4632 */

#line 147 "garden.ceu"
/* SET: . *//* NODE: Op2_+ 406 */

#line 147 "garden.ceu"
    (((*((CEU_Delay*)__ceu_this)).ticks)) = (((40+d(13))+d(13))+d(13));
#line 147 "garden.ceu"
    }
#line 147 "garden.ceu"
/* CLEAR: Block (147) */
#line 147 "garden.ceu"
    if (0) {

#line 147 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
}
static void _ceu_constr_600 (tceu_app* _ceu_app, tceu_org* __ceu_this, tceu_org* _ceu_org) {
/* NODE: Dcl_constr 600 */
/* NODE: Block 599 */

#line 210 "garden.ceu"
    {/* NODE: Stmts 598 */

#line 210 "garden.ceu"
    {/* NODE: Set 4803 */

#line 210 "garden.ceu"
/* SET: . *//* NODE: Op1_& 584 */

#line 210 "garden.ceu"
    (((*((CEU_Growing*)__ceu_this)).gensym)) = (((CEU_Philodendron*)_ceu_org)->gensym);/* NODE: Set 4804 */

#line 211 "garden.ceu"
/* SET: . *//* NODE: Var 588 */

#line 211 "garden.ceu"
    (((*((CEU_Growing*)__ceu_this)).x)) = (((CEU_Philodendron*)_ceu_org)->x);/* NODE: Set 4805 */

#line 212 "garden.ceu"
/* SET: . *//* NODE: Var 592 */

#line 212 "garden.ceu"
    (((*((CEU_Growing*)__ceu_this)).y)) = (((CEU_Philodendron*)_ceu_org)->y);/* NODE: Set 4806 */

#line 213 "garden.ceu"
/* SET: . *//* NODE: Var 596 */

#line 213 "garden.ceu"
    (((*((CEU_Growing*)__ceu_this)).layer)) = (((CEU_Philodendron*)_ceu_org)->layer);
#line 210 "garden.ceu"
    }
#line 210 "garden.ceu"
/* CLEAR: Block (210) */
#line 210 "garden.ceu"
    if (0) {

#line 210 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
}
static void _ceu_constr_787 (tceu_app* _ceu_app, tceu_org* __ceu_this, tceu_org* _ceu_org) {
/* NODE: Dcl_constr 787 */
/* NODE: Block 786 */

#line 268 "garden.ceu"
    {/* NODE: Stmts 785 */

#line 268 "garden.ceu"
    {/* NODE: Set 5039 */

#line 268 "garden.ceu"
/* SET: . *//* NODE: Op1_& 771 */

#line 268 "garden.ceu"
    (((*((CEU_Growing*)__ceu_this)).gensym)) = (((CEU_Pitcher*)_ceu_org)->gensym);/* NODE: Set 5040 */

#line 269 "garden.ceu"
/* SET: . *//* NODE: Var 775 */

#line 269 "garden.ceu"
    (((*((CEU_Growing*)__ceu_this)).x)) = (((CEU_Pitcher*)_ceu_org)->x);/* NODE: Set 5041 */

#line 270 "garden.ceu"
/* SET: . *//* NODE: Var 779 */

#line 270 "garden.ceu"
    (((*((CEU_Growing*)__ceu_this)).y)) = (((CEU_Pitcher*)_ceu_org)->y);/* NODE: Set 5042 */

#line 271 "garden.ceu"
/* SET: . *//* NODE: Var 783 */

#line 271 "garden.ceu"
    (((*((CEU_Growing*)__ceu_this)).layer)) = (((CEU_Pitcher*)_ceu_org)->layer);
#line 268 "garden.ceu"
    }
#line 268 "garden.ceu"
/* CLEAR: Block (268) */
#line 268 "garden.ceu"
    if (0) {

#line 268 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
}
static void _ceu_constr_968 (tceu_app* _ceu_app, tceu_org* __ceu_this, tceu_org* _ceu_org) {
/* NODE: Dcl_constr 968 */
/* NODE: Block 967 */

#line 325 "garden.ceu"
    {/* NODE: Stmts 966 */

#line 325 "garden.ceu"
    {/* NODE: Set 5275 */

#line 325 "garden.ceu"
/* SET: . *//* NODE: Op1_& 952 */

#line 325 "garden.ceu"
    (((*((CEU_Growing*)__ceu_this)).gensym)) = (((CEU_Orchid*)_ceu_org)->gensym);/* NODE: Set 5276 */

#line 326 "garden.ceu"
/* SET: . *//* NODE: Var 956 */

#line 326 "garden.ceu"
    (((*((CEU_Growing*)__ceu_this)).x)) = (((CEU_Orchid*)_ceu_org)->x);/* NODE: Set 5277 */

#line 327 "garden.ceu"
/* SET: . *//* NODE: Var 960 */

#line 327 "garden.ceu"
    (((*((CEU_Growing*)__ceu_this)).y)) = (((CEU_Orchid*)_ceu_org)->y);/* NODE: Set 5278 */

#line 328 "garden.ceu"
/* SET: . *//* NODE: Var 964 */

#line 328 "garden.ceu"
    (((*((CEU_Growing*)__ceu_this)).layer)) = (((CEU_Orchid*)_ceu_org)->layer);
#line 325 "garden.ceu"
    }
#line 325 "garden.ceu"
/* CLEAR: Block (325) */
#line 325 "garden.ceu"
    if (0) {

#line 325 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
}
static void _ceu_constr_1149 (tceu_app* _ceu_app, tceu_org* __ceu_this, tceu_org* _ceu_org) {
/* NODE: Dcl_constr 1149 */
/* NODE: Block 1148 */

#line 382 "garden.ceu"
    {/* NODE: Stmts 1147 */

#line 382 "garden.ceu"
    {/* NODE: Set 5511 */

#line 382 "garden.ceu"
/* SET: . *//* NODE: Op1_& 1133 */

#line 382 "garden.ceu"
    (((*((CEU_Growing*)__ceu_this)).gensym)) = (((CEU_Heliconia*)_ceu_org)->gensym);/* NODE: Set 5512 */

#line 383 "garden.ceu"
/* SET: . *//* NODE: Var 1137 */

#line 383 "garden.ceu"
    (((*((CEU_Growing*)__ceu_this)).x)) = (((CEU_Heliconia*)_ceu_org)->x);/* NODE: Set 5513 */

#line 384 "garden.ceu"
/* SET: . *//* NODE: Var 1141 */

#line 384 "garden.ceu"
    (((*((CEU_Growing*)__ceu_this)).y)) = (((CEU_Heliconia*)_ceu_org)->y);/* NODE: Set 5514 */

#line 385 "garden.ceu"
/* SET: . *//* NODE: Var 1145 */

#line 385 "garden.ceu"
    (((*((CEU_Growing*)__ceu_this)).layer)) = (((CEU_Heliconia*)_ceu_org)->layer);
#line 382 "garden.ceu"
    }
#line 382 "garden.ceu"
/* CLEAR: Block (382) */
#line 382 "garden.ceu"
    if (0) {

#line 382 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
}
static void _ceu_constr_1641 (tceu_app* _ceu_app, tceu_org* __ceu_this, tceu_org* _ceu_org) {
/* NODE: Dcl_constr 1641 */
/* NODE: Block 1640 */

#line 547 "garden.ceu"
    {/* NODE: Stmts 1639 */

#line 547 "garden.ceu"
    {/* NODE: Set 6016 */

#line 547 "garden.ceu"
/* SET: . *//* NODE: Var 1618 */

#line 547 "garden.ceu"
    (((*((CEU_BagActive*)__ceu_this)).id)) = (((CEU_Bag*)_ceu_org)->id);/* NODE: Set 6017 */

#line 548 "garden.ceu"
/* SET: . *//* NODE: Op1_& 1623 */

#line 548 "garden.ceu"
    (((*((CEU_BagActive*)__ceu_this)).x)) = (&((CEU_Bag*)_ceu_org)->x);/* NODE: Set 6018 */

#line 549 "garden.ceu"
/* SET: . *//* NODE: Op1_& 1628 */

#line 549 "garden.ceu"
    (((*((CEU_BagActive*)__ceu_this)).y)) = (&((CEU_Bag*)_ceu_org)->y);/* NODE: Set 6019 */

#line 550 "garden.ceu"
/* SET: . *//* NODE: Var 1632 */

#line 550 "garden.ceu"
    (((*((CEU_BagActive*)__ceu_this)).seed)) = (((CEU_Bag*)_ceu_org)->seed);/* NODE: Set 6020 */

#line 551 "garden.ceu"
/* SET: . *//* NODE: Op1_& 1637 */

#line 551 "garden.ceu"
    (((*((CEU_BagActive*)__ceu_this)).garden)) = (((CEU_Bag*)_ceu_org)->garden);
#line 547 "garden.ceu"
    }
#line 547 "garden.ceu"
/* CLEAR: Block (547) */
#line 547 "garden.ceu"
    if (0) {

#line 547 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
}
static void _ceu_constr_1953 (tceu_app* _ceu_app, tceu_org* __ceu_this, tceu_org* _ceu_org) {
/* NODE: Dcl_constr 1953 */
/* NODE: Block 1952 */

#line 630 "garden.ceu"
    {/* NODE: Stmts 1951 */

#line 630 "garden.ceu"
    {/* NODE: Set 6396 */

#line 630 "garden.ceu"
/* SET: . *//* NODE: Var 1934 */

#line 630 "garden.ceu"
    (((*((CEU_WateringCanActive*)__ceu_this)).id)) = (((CEU_WateringCan*)_ceu_org)->id);/* NODE: Set 6397 */

#line 631 "garden.ceu"
/* SET: . *//* NODE: Op1_& 1939 */

#line 631 "garden.ceu"
    (((*((CEU_WateringCanActive*)__ceu_this)).x)) = (&((CEU_WateringCan*)_ceu_org)->x);/* NODE: Set 6398 */

#line 632 "garden.ceu"
/* SET: . *//* NODE: Op1_& 1944 */

#line 632 "garden.ceu"
    (((*((CEU_WateringCanActive*)__ceu_this)).y)) = (&((CEU_WateringCan*)_ceu_org)->y);/* NODE: Set 6399 */

#line 633 "garden.ceu"
/* SET: . *//* NODE: Op1_& 1949 */

#line 633 "garden.ceu"
    (((*((CEU_WateringCanActive*)__ceu_this)).garden)) = (((CEU_WateringCan*)_ceu_org)->garden);
#line 630 "garden.ceu"
    }
#line 630 "garden.ceu"
/* CLEAR: Block (630) */
#line 630 "garden.ceu"
    if (0) {

#line 630 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
}
static void _ceu_constr_2295 (tceu_app* _ceu_app, tceu_org* __ceu_this, tceu_org* _ceu_org) {
/* NODE: Dcl_constr 2295 */
/* NODE: Block 2294 */

#line 718 "garden.ceu"
    {/* NODE: Stmts 2293 */

#line 718 "garden.ceu"
    {/* NODE: Set 6775 */

#line 718 "garden.ceu"
/* SET: . *//* NODE: Var 2276 */

#line 718 "garden.ceu"
    (((*((CEU_ShovelActive*)__ceu_this)).id)) = (((CEU_Shovel*)_ceu_org)->id);/* NODE: Set 6776 */

#line 719 "garden.ceu"
/* SET: . *//* NODE: Op1_& 2281 */

#line 719 "garden.ceu"
    (((*((CEU_ShovelActive*)__ceu_this)).x)) = (&((CEU_Shovel*)_ceu_org)->x);/* NODE: Set 6777 */

#line 720 "garden.ceu"
/* SET: . *//* NODE: Op1_& 2286 */

#line 720 "garden.ceu"
    (((*((CEU_ShovelActive*)__ceu_this)).y)) = (&((CEU_Shovel*)_ceu_org)->y);/* NODE: Set 6778 */

#line 721 "garden.ceu"
/* SET: . *//* NODE: Op1_& 2291 */

#line 721 "garden.ceu"
    (((*((CEU_ShovelActive*)__ceu_this)).garden)) = (((CEU_Shovel*)_ceu_org)->garden);
#line 718 "garden.ceu"
    }
#line 718 "garden.ceu"
/* CLEAR: Block (718) */
#line 718 "garden.ceu"
    if (0) {

#line 718 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
}
static void _ceu_constr_2511 (tceu_app* _ceu_app, tceu_org* __ceu_this, tceu_org* _ceu_org) {
/* NODE: Dcl_constr 2511 */
/* NODE: Block 2510 */

#line 775 "garden.ceu"
    {/* NODE: Stmts 2509 */

#line 775 "garden.ceu"
    {/* NODE: Set 6955 */

#line 775 "garden.ceu"
/* SET: . *//* NODE: Var 2485 */

#line 775 "garden.ceu"
    (((*((CEU_Tween*)__ceu_this)).target_x)) = (((CEU_Fly*)_ceu_org)->intermediate_x);/* NODE: Set 6956 */

#line 776 "garden.ceu"
/* SET: . *//* NODE: Var 2489 */

#line 776 "garden.ceu"
    (((*((CEU_Tween*)__ceu_this)).target_y)) = (((CEU_Fly*)_ceu_org)->intermediate_y);/* NODE: Set 6957 */

#line 777 "garden.ceu"
/* SET: . *//* NODE: Op1_& 2494 */

#line 777 "garden.ceu"
    (((*((CEU_Tween*)__ceu_this)).x)) = (((CEU_Fly*)_ceu_org)->x);/* NODE: Set 6958 */

#line 778 "garden.ceu"
/* SET: . *//* NODE: Op1_& 2499 */

#line 778 "garden.ceu"
    (((*((CEU_Tween*)__ceu_this)).y)) = (((CEU_Fly*)_ceu_org)->y);/* NODE: Set 6959 */

#line 779 "garden.ceu"
/* SET: . *//* NODE: Var 2503 */

#line 779 "garden.ceu"
    (((*((CEU_Tween*)__ceu_this)).id)) = (((CEU_Fly*)_ceu_org)->id);/* NODE: Set 6960 */

#line 780 "garden.ceu"
/* SET: . *//* NODE: Var 2507 */

#line 780 "garden.ceu"
    (((*((CEU_Tween*)__ceu_this)).speed)) = (((CEU_Fly*)_ceu_org)->speed);
#line 775 "garden.ceu"
    }
#line 775 "garden.ceu"
/* CLEAR: Block (775) */
#line 775 "garden.ceu"
    if (0) {

#line 775 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
}
static void _ceu_constr_2541 (tceu_app* _ceu_app, tceu_org* __ceu_this, tceu_org* _ceu_org) {
/* NODE: Dcl_constr 2541 */
/* NODE: Block 2540 */

#line 783 "garden.ceu"
    {/* NODE: Stmts 2539 */

#line 783 "garden.ceu"
    {/* NODE: Set 6995 */

#line 783 "garden.ceu"
/* SET: . *//* NODE: Var 2515 */

#line 783 "garden.ceu"
    (((*((CEU_Tween*)__ceu_this)).target_x)) = (((CEU_Fly*)_ceu_org)->target_x);/* NODE: Set 6996 */

#line 784 "garden.ceu"
/* SET: . *//* NODE: Var 2519 */

#line 784 "garden.ceu"
    (((*((CEU_Tween*)__ceu_this)).target_y)) = (((CEU_Fly*)_ceu_org)->target_y);/* NODE: Set 6997 */

#line 785 "garden.ceu"
/* SET: . *//* NODE: Op1_& 2524 */

#line 785 "garden.ceu"
    (((*((CEU_Tween*)__ceu_this)).x)) = (((CEU_Fly*)_ceu_org)->x);/* NODE: Set 6998 */

#line 786 "garden.ceu"
/* SET: . *//* NODE: Op1_& 2529 */

#line 786 "garden.ceu"
    (((*((CEU_Tween*)__ceu_this)).y)) = (((CEU_Fly*)_ceu_org)->y);/* NODE: Set 6999 */

#line 787 "garden.ceu"
/* SET: . *//* NODE: Var 2533 */

#line 787 "garden.ceu"
    (((*((CEU_Tween*)__ceu_this)).id)) = (((CEU_Fly*)_ceu_org)->id);/* NODE: Set 7000 */

#line 788 "garden.ceu"
/* SET: . *//* NODE: Var 2537 */

#line 788 "garden.ceu"
    (((*((CEU_Tween*)__ceu_this)).speed)) = (((CEU_Fly*)_ceu_org)->speed);
#line 783 "garden.ceu"
    }
#line 783 "garden.ceu"
/* CLEAR: Block (783) */
#line 783 "garden.ceu"
    if (0) {

#line 783 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
}
static void _ceu_constr_2642 (tceu_app* _ceu_app, tceu_org* __ceu_this, tceu_org* _ceu_org) {
/* NODE: Dcl_constr 2642 */
/* NODE: Block 2641 */

#line 818 "garden.ceu"
    {/* NODE: Stmts 2640 */

#line 818 "garden.ceu"
    {/* NODE: Set 7079 */

#line 818 "garden.ceu"
/* SET: . *//* NODE: Var 2616 */

#line 818 "garden.ceu"
    (((*((CEU_Tween*)__ceu_this)).target_x)) = (((CEU_Seed*)_ceu_org)->x);/* NODE: Set 7080 */

#line 819 "garden.ceu"
/* SET: . *//* NODE: NUMBER 2620 */

#line 819 "garden.ceu"
    (((*((CEU_Tween*)__ceu_this)).target_y)) = 1000;/* NODE: Set 7081 */

#line 820 "garden.ceu"
/* SET: . *//* NODE: Op1_& 2625 */

#line 820 "garden.ceu"
    (((*((CEU_Tween*)__ceu_this)).x)) = (&((CEU_Seed*)_ceu_org)->x);/* NODE: Set 7082 */

#line 821 "garden.ceu"
/* SET: . *//* NODE: Op1_& 2630 */

#line 821 "garden.ceu"
    (((*((CEU_Tween*)__ceu_this)).y)) = (&((CEU_Seed*)_ceu_org)->y);/* NODE: Set 7083 */

#line 822 "garden.ceu"
/* SET: . *//* NODE: Var 2634 */

#line 822 "garden.ceu"
    (((*((CEU_Tween*)__ceu_this)).id)) = (((CEU_Seed*)_ceu_org)->id);/* NODE: Set 7084 */

#line 823 "garden.ceu"
/* SET: . *//* NODE: NUMBER 2638 */

#line 823 "garden.ceu"
    (((*((CEU_Tween*)__ceu_this)).speed)) = 2.0;
#line 818 "garden.ceu"
    }
#line 818 "garden.ceu"
/* CLEAR: Block (818) */
#line 818 "garden.ceu"
    if (0) {

#line 818 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
}
static void _ceu_constr_2719 (tceu_app* _ceu_app, tceu_org* __ceu_this, tceu_org* _ceu_org) {
/* NODE: Dcl_constr 2719 */
/* NODE: Block 2718 */

#line 838 "garden.ceu"
    {/* NODE: Stmts 2717 */

#line 838 "garden.ceu"
    {/* NODE: Set 7177 */

#line 838 "garden.ceu"
/* SET: . *//* NODE: Op2_+ 2693 */

#line 838 "garden.ceu"
    (((*((CEU_Tween*)__ceu_this)).target_x)) = (215+(((((CEU_Seed*)_ceu_org)->tier)+2)*135));/* NODE: Set 7178 */

#line 839 "garden.ceu"
/* SET: . *//* NODE: NUMBER 2697 */

#line 839 "garden.ceu"
    (((*((CEU_Tween*)__ceu_this)).target_y)) = 800;/* NODE: Set 7179 */

#line 840 "garden.ceu"
/* SET: . *//* NODE: Op1_& 2702 */

#line 840 "garden.ceu"
    (((*((CEU_Tween*)__ceu_this)).x)) = (&((CEU_Seed*)_ceu_org)->x);/* NODE: Set 7180 */

#line 841 "garden.ceu"
/* SET: . *//* NODE: Op1_& 2707 */

#line 841 "garden.ceu"
    (((*((CEU_Tween*)__ceu_this)).y)) = (&((CEU_Seed*)_ceu_org)->y);/* NODE: Set 7181 */

#line 842 "garden.ceu"
/* SET: . *//* NODE: Var 2711 */

#line 842 "garden.ceu"
    (((*((CEU_Tween*)__ceu_this)).id)) = (((CEU_Seed*)_ceu_org)->id);/* NODE: Set 7182 */

#line 843 "garden.ceu"
/* SET: . *//* NODE: NUMBER 2715 */

#line 843 "garden.ceu"
    (((*((CEU_Tween*)__ceu_this)).speed)) = 10.0;
#line 838 "garden.ceu"
    }
#line 838 "garden.ceu"
/* CLEAR: Block (838) */
#line 838 "garden.ceu"
    if (0) {

#line 838 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
}
static void _ceu_constr_2868 (tceu_app* _ceu_app, tceu_org* __ceu_this, tceu_org* _ceu_org) {
/* NODE: Dcl_constr 2868 */
/* NODE: Block 2867 */

#line 890 "garden.ceu"
    {/* NODE: Stmts 2866 */

#line 890 "garden.ceu"
    {/* NODE: Set 7320 */

#line 890 "garden.ceu"
/* SET: . *//* NODE: Op2_idx 2844 */

#line 890 "garden.ceu"
    (((*((CEU_Fly*)__ceu_this)).target_x)) = perch_x[(((CEU_Birb*)_ceu_org)->target_perch_12)];/* NODE: Set 7321 */

#line 891 "garden.ceu"
/* SET: . *//* NODE: Op2_idx 2850 */

#line 891 "garden.ceu"
    (((*((CEU_Fly*)__ceu_this)).target_y)) = perch_y[(((CEU_Birb*)_ceu_org)->target_perch_12)];/* NODE: Set 7322 */

#line 892 "garden.ceu"
/* SET: . *//* NODE: Op1_& 2855 */

#line 892 "garden.ceu"
    (((*((CEU_Fly*)__ceu_this)).x)) = (&((CEU_Birb*)_ceu_org)->x);/* NODE: Set 7323 */

#line 893 "garden.ceu"
/* SET: . *//* NODE: Op1_& 2860 */

#line 893 "garden.ceu"
    (((*((CEU_Fly*)__ceu_this)).y)) = (&((CEU_Birb*)_ceu_org)->y);/* NODE: Set 7324 */

#line 894 "garden.ceu"
/* SET: . *//* NODE: Var 2864 */

#line 894 "garden.ceu"
    (((*((CEU_Fly*)__ceu_this)).id)) = (((CEU_Birb*)_ceu_org)->id);
#line 890 "garden.ceu"
    }
#line 890 "garden.ceu"
/* CLEAR: Block (890) */
#line 890 "garden.ceu"
    if (0) {

#line 890 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
}
static void _ceu_constr_2942 (tceu_app* _ceu_app, tceu_org* __ceu_this, tceu_org* _ceu_org) {
/* NODE: Dcl_constr 2942 */
/* NODE: Block 2941 */

#line 911 "garden.ceu"
    {/* NODE: Stmts 2940 */

#line 911 "garden.ceu"
    {/* NODE: Set 7366 */

#line 911 "garden.ceu"
/* SET: . *//* NODE: Op2_+ 2938 */

#line 911 "garden.ceu"
    (((*((CEU_Delay*)__ceu_this)).ticks)) = ((d(60)+d(60))+d(60));
#line 911 "garden.ceu"
    }
#line 911 "garden.ceu"
/* CLEAR: Block (911) */
#line 911 "garden.ceu"
    if (0) {

#line 911 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
}
static void _ceu_constr_2981 (tceu_app* _ceu_app, tceu_org* __ceu_this, tceu_org* _ceu_org) {
/* NODE: Dcl_constr 2981 */
/* NODE: Block 2980 */

#line 919 "garden.ceu"
    {/* NODE: Stmts 2979 */

#line 919 "garden.ceu"
    {/* NODE: Set 7398 */

#line 919 "garden.ceu"
/* SET: . *//* NODE: Op1_& 2965 */

#line 919 "garden.ceu"
    (((*((CEU_Seed*)__ceu_this)).gensym)) = (((CEU_Birb*)_ceu_org)->gensym);/* NODE: Set 7399 */

#line 920 "garden.ceu"
/* SET: . *//* NODE: Var 2969 */

#line 920 "garden.ceu"
    (((*((CEU_Seed*)__ceu_this)).x)) = (((CEU_Birb*)_ceu_org)->x);/* NODE: Set 7400 */

#line 921 "garden.ceu"
/* SET: . *//* NODE: Var 2973 */

#line 921 "garden.ceu"
    (((*((CEU_Seed*)__ceu_this)).y)) = (((CEU_Birb*)_ceu_org)->y);/* NODE: Set 7401 */

#line 922 "garden.ceu"
/* SET: . *//* NODE: Var 2977 */

#line 922 "garden.ceu"
    (((*((CEU_Seed*)__ceu_this)).tier)) = (((CEU_Birb*)_ceu_org)->tier);
#line 919 "garden.ceu"
    }
#line 919 "garden.ceu"
/* CLEAR: Block (919) */
#line 919 "garden.ceu"
    if (0) {

#line 919 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
}
static void _ceu_constr_3019 (tceu_app* _ceu_app, tceu_org* __ceu_this, tceu_org* _ceu_org) {
/* NODE: Dcl_constr 3019 */
/* NODE: Block 3018 */

#line 927 "garden.ceu"
    {/* NODE: Stmts 3017 */

#line 927 "garden.ceu"
    {/* NODE: Set 7409 */

#line 927 "garden.ceu"
/* SET: . *//* NODE: Op2_call 2991 */

#line 927 "garden.ceu"
    (((*((CEU_Fly*)__ceu_this)).target_x)) = d(1280);/* NODE: Set 7410 */

#line 928 "garden.ceu"
/* SET: . *//* NODE: Op2_* 3001 */

#line 928 "garden.ceu"
    (((*((CEU_Fly*)__ceu_this)).target_y)) = ((-1)*d(100));/* NODE: Set 7411 */

#line 929 "garden.ceu"
/* SET: . *//* NODE: Op1_& 3006 */

#line 929 "garden.ceu"
    (((*((CEU_Fly*)__ceu_this)).x)) = (&((CEU_Birb*)_ceu_org)->x);/* NODE: Set 7412 */

#line 930 "garden.ceu"
/* SET: . *//* NODE: Op1_& 3011 */

#line 930 "garden.ceu"
    (((*((CEU_Fly*)__ceu_this)).y)) = (&((CEU_Birb*)_ceu_org)->y);/* NODE: Set 7413 */

#line 931 "garden.ceu"
/* SET: . *//* NODE: Var 3015 */

#line 931 "garden.ceu"
    (((*((CEU_Fly*)__ceu_this)).id)) = (((CEU_Birb*)_ceu_org)->id);
#line 927 "garden.ceu"
    }
#line 927 "garden.ceu"
/* CLEAR: Block (927) */
#line 927 "garden.ceu"
    if (0) {

#line 927 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
}
static void _ceu_constr_8356 (tceu_app* _ceu_app, tceu_org* __ceu_this, tceu_org* _ceu_org) {
/* NODE: Dcl_constr 8356 */
/* NODE: Block 8355 */

#line 939 "garden.ceu"
    {/* NODE: Stmts 8354 */

#line 939 "garden.ceu"
    {
#line 939 "garden.ceu"
    }
#line 939 "garden.ceu"
/* CLEAR: Block (939) */
#line 939 "garden.ceu"
    if (0) {

#line 939 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
}
static void _ceu_constr_3166 (tceu_app* _ceu_app, tceu_org* __ceu_this, tceu_org* _ceu_org) {
/* NODE: Dcl_constr 3166 */
/* NODE: Block 3165 */

#line 971 "garden.ceu"
    {/* NODE: Stmts 3164 */

#line 971 "garden.ceu"
    {/* NODE: Set 7642 */

#line 971 "garden.ceu"
/* SET: . *//* NODE: Op1_& 3153 */

#line 971 "garden.ceu"
    (((*((CEU_Philodendron*)__ceu_this)).gensym)) = (&((CEU_Main*)_ceu_org)->gensym);/* NODE: Set 7643 */

#line 972 "garden.ceu"
/* SET: . *//* NODE: Op1_& 3158 */

#line 972 "garden.ceu"
    (((*((CEU_Philodendron*)__ceu_this)).garden)) = (&((CEU_Main*)_ceu_org)->garden);/* NODE: Set 7644 */

#line 973 "garden.ceu"
/* SET: . *//* NODE: Var 3162 */

#line 973 "garden.ceu"
    (((*((CEU_Philodendron*)__ceu_this)).plot)) = (((CEU_Main*)_ceu_org)->plot_12);
#line 971 "garden.ceu"
    }
#line 971 "garden.ceu"
/* CLEAR: Block (971) */
#line 971 "garden.ceu"
    if (0) {

#line 971 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
}
static void _ceu_constr_3195 (tceu_app* _ceu_app, tceu_org* __ceu_this, tceu_org* _ceu_org) {
/* NODE: Dcl_constr 3195 */
/* NODE: Block 3194 */

#line 977 "garden.ceu"
    {/* NODE: Stmts 3193 */

#line 977 "garden.ceu"
    {/* NODE: Set 7646 */

#line 977 "garden.ceu"
/* SET: . *//* NODE: Op1_& 3182 */

#line 977 "garden.ceu"
    (((*((CEU_Pitcher*)__ceu_this)).gensym)) = (&((CEU_Main*)_ceu_org)->gensym);/* NODE: Set 7647 */

#line 978 "garden.ceu"
/* SET: . *//* NODE: Op1_& 3187 */

#line 978 "garden.ceu"
    (((*((CEU_Pitcher*)__ceu_this)).garden)) = (&((CEU_Main*)_ceu_org)->garden);/* NODE: Set 7648 */

#line 979 "garden.ceu"
/* SET: . *//* NODE: Var 3191 */

#line 979 "garden.ceu"
    (((*((CEU_Pitcher*)__ceu_this)).plot)) = (((CEU_Main*)_ceu_org)->plot_12);
#line 977 "garden.ceu"
    }
#line 977 "garden.ceu"
/* CLEAR: Block (977) */
#line 977 "garden.ceu"
    if (0) {

#line 977 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
}
static void _ceu_constr_3240 (tceu_app* _ceu_app, tceu_org* __ceu_this, tceu_org* _ceu_org) {
/* NODE: Dcl_constr 3240 */
/* NODE: Block 3239 */

#line 985 "garden.ceu"
    {/* NODE: Stmts 3238 */

#line 985 "garden.ceu"
    {/* NODE: Set 7651 */

#line 985 "garden.ceu"
/* SET: . *//* NODE: Op1_& 3227 */

#line 985 "garden.ceu"
    (((*((CEU_Orchid*)__ceu_this)).gensym)) = (&((CEU_Main*)_ceu_org)->gensym);/* NODE: Set 7652 */

#line 986 "garden.ceu"
/* SET: . *//* NODE: Op1_& 3232 */

#line 986 "garden.ceu"
    (((*((CEU_Orchid*)__ceu_this)).garden)) = (&((CEU_Main*)_ceu_org)->garden);/* NODE: Set 7653 */

#line 987 "garden.ceu"
/* SET: . *//* NODE: Var 3236 */

#line 987 "garden.ceu"
    (((*((CEU_Orchid*)__ceu_this)).plot)) = (((CEU_Main*)_ceu_org)->plot_12);
#line 985 "garden.ceu"
    }
#line 985 "garden.ceu"
/* CLEAR: Block (985) */
#line 985 "garden.ceu"
    if (0) {

#line 985 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
}
static void _ceu_constr_3285 (tceu_app* _ceu_app, tceu_org* __ceu_this, tceu_org* _ceu_org) {
/* NODE: Dcl_constr 3285 */
/* NODE: Block 3284 */

#line 993 "garden.ceu"
    {/* NODE: Stmts 3283 */

#line 993 "garden.ceu"
    {/* NODE: Set 7656 */

#line 993 "garden.ceu"
/* SET: . *//* NODE: Op1_& 3272 */

#line 993 "garden.ceu"
    (((*((CEU_Heliconia*)__ceu_this)).gensym)) = (&((CEU_Main*)_ceu_org)->gensym);/* NODE: Set 7657 */

#line 994 "garden.ceu"
/* SET: . *//* NODE: Op1_& 3277 */

#line 994 "garden.ceu"
    (((*((CEU_Heliconia*)__ceu_this)).garden)) = (&((CEU_Main*)_ceu_org)->garden);/* NODE: Set 7658 */

#line 995 "garden.ceu"
/* SET: . *//* NODE: Var 3281 */

#line 995 "garden.ceu"
    (((*((CEU_Heliconia*)__ceu_this)).plot)) = (((CEU_Main*)_ceu_org)->plot_12);
#line 993 "garden.ceu"
    }
#line 993 "garden.ceu"
/* CLEAR: Block (993) */
#line 993 "garden.ceu"
    if (0) {

#line 993 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
}
static void _ceu_constr_3373 (tceu_app* _ceu_app, tceu_org* __ceu_this, tceu_org* _ceu_org) {
/* NODE: Dcl_constr 3373 */
/* NODE: Block 3372 */

#line 1013 "garden.ceu"
    {/* NODE: Stmts 3371 */

#line 1013 "garden.ceu"
    {/* NODE: Set 7757 */

#line 1013 "garden.ceu"
/* SET: . *//* NODE: Op1_& 3356 */

#line 1013 "garden.ceu"
    (((*((CEU_Shovel*)__ceu_this)).gensym)) = (&((CEU_Main*)_ceu_org)->gensym);/* NODE: Set 7758 */

#line 1014 "garden.ceu"
/* SET: . *//* NODE: Var 3360 */

#line 1014 "garden.ceu"
    (((*((CEU_Shovel*)__ceu_this)).x)) = (((CEU_Main*)_ceu_org)->x_13);/* NODE: Set 7759 */

#line 1015 "garden.ceu"
/* SET: . *//* NODE: Var 3364 */

#line 1015 "garden.ceu"
    (((*((CEU_Shovel*)__ceu_this)).y)) = (((CEU_Main*)_ceu_org)->y_14);/* NODE: Set 7760 */

#line 1016 "garden.ceu"
/* SET: . *//* NODE: Op1_& 3369 */

#line 1016 "garden.ceu"
    (((*((CEU_Shovel*)__ceu_this)).garden)) = (&((CEU_Main*)_ceu_org)->garden);
#line 1013 "garden.ceu"
    }
#line 1013 "garden.ceu"
/* CLEAR: Block (1013) */
#line 1013 "garden.ceu"
    if (0) {

#line 1013 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
}
static void _ceu_constr_3416 (tceu_app* _ceu_app, tceu_org* __ceu_this, tceu_org* _ceu_org) {
/* NODE: Dcl_constr 3416 */
/* NODE: Block 3415 */

#line 1020 "garden.ceu"
    {/* NODE: Stmts 3414 */

#line 1020 "garden.ceu"
    {/* NODE: Set 7795 */

#line 1020 "garden.ceu"
/* SET: . *//* NODE: Op1_& 3399 */

#line 1020 "garden.ceu"
    (((*((CEU_WateringCan*)__ceu_this)).gensym)) = (&((CEU_Main*)_ceu_org)->gensym);/* NODE: Set 7796 */

#line 1021 "garden.ceu"
/* SET: . *//* NODE: Var 3403 */

#line 1021 "garden.ceu"
    (((*((CEU_WateringCan*)__ceu_this)).x)) = (((CEU_Main*)_ceu_org)->x_13);/* NODE: Set 7797 */

#line 1022 "garden.ceu"
/* SET: . *//* NODE: Var 3407 */

#line 1022 "garden.ceu"
    (((*((CEU_WateringCan*)__ceu_this)).y)) = (((CEU_Main*)_ceu_org)->y_14);/* NODE: Set 7798 */

#line 1023 "garden.ceu"
/* SET: . *//* NODE: Op1_& 3412 */

#line 1023 "garden.ceu"
    (((*((CEU_WateringCan*)__ceu_this)).garden)) = (&((CEU_Main*)_ceu_org)->garden);
#line 1020 "garden.ceu"
    }
#line 1020 "garden.ceu"
/* CLEAR: Block (1020) */
#line 1020 "garden.ceu"
    if (0) {

#line 1020 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
}
static void _ceu_constr_3463 (tceu_app* _ceu_app, tceu_org* __ceu_this, tceu_org* _ceu_org) {
/* NODE: Dcl_constr 3463 */
/* NODE: Block 3462 */

#line 1027 "garden.ceu"
    {/* NODE: Stmts 3461 */

#line 1027 "garden.ceu"
    {/* NODE: Set 7833 */

#line 1027 "garden.ceu"
/* SET: . *//* NODE: Op1_& 3442 */

#line 1027 "garden.ceu"
    (((*((CEU_Bag*)__ceu_this)).gensym)) = (&((CEU_Main*)_ceu_org)->gensym);/* NODE: Set 7834 */

#line 1028 "garden.ceu"
/* SET: . *//* NODE: Var 3446 */

#line 1028 "garden.ceu"
    (((*((CEU_Bag*)__ceu_this)).x)) = (((CEU_Main*)_ceu_org)->x_13);/* NODE: Set 7835 */

#line 1029 "garden.ceu"
/* SET: . *//* NODE: Var 3450 */

#line 1029 "garden.ceu"
    (((*((CEU_Bag*)__ceu_this)).y)) = (((CEU_Main*)_ceu_org)->y_14);/* NODE: Set 7836 */

#line 1030 "garden.ceu"
/* SET: . *//* NODE: Op1_& 3455 */

#line 1030 "garden.ceu"
    (((*((CEU_Bag*)__ceu_this)).garden)) = (&((CEU_Main*)_ceu_org)->garden);/* NODE: Set 7837 */

#line 1031 "garden.ceu"
/* SET: . *//* NODE: NUMBER 3459 */

#line 1031 "garden.ceu"
    (((*((CEU_Bag*)__ceu_this)).seed)) = 9;
#line 1027 "garden.ceu"
    }
#line 1027 "garden.ceu"
/* CLEAR: Block (1027) */
#line 1027 "garden.ceu"
    if (0) {

#line 1027 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
}
static void _ceu_constr_3515 (tceu_app* _ceu_app, tceu_org* __ceu_this, tceu_org* _ceu_org) {
/* NODE: Dcl_constr 3515 */
/* NODE: Block 3514 */

#line 1036 "garden.ceu"
    {/* NODE: Stmts 3513 */

#line 1036 "garden.ceu"
    {/* NODE: Set 7874 */

#line 1036 "garden.ceu"
/* SET: . *//* NODE: Op1_& 3494 */

#line 1036 "garden.ceu"
    (((*((CEU_Bag*)__ceu_this)).gensym)) = (&((CEU_Main*)_ceu_org)->gensym);/* NODE: Set 7875 */

#line 1037 "garden.ceu"
/* SET: . *//* NODE: Var 3498 */

#line 1037 "garden.ceu"
    (((*((CEU_Bag*)__ceu_this)).x)) = (((CEU_Main*)_ceu_org)->x_13);/* NODE: Set 7876 */

#line 1038 "garden.ceu"
/* SET: . *//* NODE: Var 3502 */

#line 1038 "garden.ceu"
    (((*((CEU_Bag*)__ceu_this)).y)) = (((CEU_Main*)_ceu_org)->y_14);/* NODE: Set 7877 */

#line 1039 "garden.ceu"
/* SET: . *//* NODE: Op1_& 3507 */

#line 1039 "garden.ceu"
    (((*((CEU_Bag*)__ceu_this)).garden)) = (&((CEU_Main*)_ceu_org)->garden);/* NODE: Set 7878 */

#line 1040 "garden.ceu"
/* SET: . *//* NODE: NUMBER 3511 */

#line 1040 "garden.ceu"
    (((*((CEU_Bag*)__ceu_this)).seed)) = 12;
#line 1036 "garden.ceu"
    }
#line 1036 "garden.ceu"
/* CLEAR: Block (1036) */
#line 1036 "garden.ceu"
    if (0) {

#line 1036 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
}
static void _ceu_constr_3570 (tceu_app* _ceu_app, tceu_org* __ceu_this, tceu_org* _ceu_org) {
/* NODE: Dcl_constr 3570 */
/* NODE: Block 3569 */

#line 1046 "garden.ceu"
    {/* NODE: Stmts 3568 */

#line 1046 "garden.ceu"
    {/* NODE: Set 7915 */

#line 1046 "garden.ceu"
/* SET: . *//* NODE: Op1_& 3549 */

#line 1046 "garden.ceu"
    (((*((CEU_Bag*)__ceu_this)).gensym)) = (&((CEU_Main*)_ceu_org)->gensym);/* NODE: Set 7916 */

#line 1047 "garden.ceu"
/* SET: . *//* NODE: Var 3553 */

#line 1047 "garden.ceu"
    (((*((CEU_Bag*)__ceu_this)).x)) = (((CEU_Main*)_ceu_org)->x_13);/* NODE: Set 7917 */

#line 1048 "garden.ceu"
/* SET: . *//* NODE: Var 3557 */

#line 1048 "garden.ceu"
    (((*((CEU_Bag*)__ceu_this)).y)) = (((CEU_Main*)_ceu_org)->y_14);/* NODE: Set 7918 */

#line 1049 "garden.ceu"
/* SET: . *//* NODE: Op1_& 3562 */

#line 1049 "garden.ceu"
    (((*((CEU_Bag*)__ceu_this)).garden)) = (&((CEU_Main*)_ceu_org)->garden);/* NODE: Set 7919 */

#line 1050 "garden.ceu"
/* SET: . *//* NODE: NUMBER 3566 */

#line 1050 "garden.ceu"
    (((*((CEU_Bag*)__ceu_this)).seed)) = 10;
#line 1046 "garden.ceu"
    }
#line 1046 "garden.ceu"
/* CLEAR: Block (1046) */
#line 1046 "garden.ceu"
    if (0) {

#line 1046 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
}
static void _ceu_constr_3625 (tceu_app* _ceu_app, tceu_org* __ceu_this, tceu_org* _ceu_org) {
/* NODE: Dcl_constr 3625 */
/* NODE: Block 3624 */

#line 1056 "garden.ceu"
    {/* NODE: Stmts 3623 */

#line 1056 "garden.ceu"
    {/* NODE: Set 7956 */

#line 1056 "garden.ceu"
/* SET: . *//* NODE: Op1_& 3604 */

#line 1056 "garden.ceu"
    (((*((CEU_Bag*)__ceu_this)).gensym)) = (&((CEU_Main*)_ceu_org)->gensym);/* NODE: Set 7957 */

#line 1057 "garden.ceu"
/* SET: . *//* NODE: Var 3608 */

#line 1057 "garden.ceu"
    (((*((CEU_Bag*)__ceu_this)).x)) = (((CEU_Main*)_ceu_org)->x_13);/* NODE: Set 7958 */

#line 1058 "garden.ceu"
/* SET: . *//* NODE: Var 3612 */

#line 1058 "garden.ceu"
    (((*((CEU_Bag*)__ceu_this)).y)) = (((CEU_Main*)_ceu_org)->y_14);/* NODE: Set 7959 */

#line 1059 "garden.ceu"
/* SET: . *//* NODE: Op1_& 3617 */

#line 1059 "garden.ceu"
    (((*((CEU_Bag*)__ceu_this)).garden)) = (&((CEU_Main*)_ceu_org)->garden);/* NODE: Set 7960 */

#line 1060 "garden.ceu"
/* SET: . *//* NODE: NUMBER 3621 */

#line 1060 "garden.ceu"
    (((*((CEU_Bag*)__ceu_this)).seed)) = 11;
#line 1056 "garden.ceu"
    }
#line 1056 "garden.ceu"
/* CLEAR: Block (1056) */
#line 1056 "garden.ceu"
    if (0) {

#line 1056 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
}
static void _ceu_constr_3684 (tceu_app* _ceu_app, tceu_org* __ceu_this, tceu_org* _ceu_org) {
/* NODE: Dcl_constr 3684 */
/* NODE: Block 3683 */

#line 1072 "garden.ceu"
    {/* NODE: Stmts 3682 */

#line 1072 "garden.ceu"
    {/* NODE: Set 8021 */

#line 1072 "garden.ceu"
/* SET: . *//* NODE: Op1_& 3666 */

#line 1072 "garden.ceu"
    (((*((CEU_Birb*)__ceu_this)).gensym)) = (&((CEU_Main*)_ceu_org)->gensym);/* NODE: Set 8022 */

#line 1073 "garden.ceu"
/* SET: . *//* NODE: Op1_& 3671 */

#line 1073 "garden.ceu"
    (((*((CEU_Birb*)__ceu_this)).birb_count)) = (&((CEU_Main*)_ceu_org)->birb_count);/* NODE: Set 8023 */

#line 1074 "garden.ceu"
/* SET: . *//* NODE: Op1_& 3676 */

#line 1074 "garden.ceu"
    (((*((CEU_Birb*)__ceu_this)).seeds)) = (&((CEU_Main*)_ceu_org)->seeds);/* NODE: Set 8024 */

#line 1075 "garden.ceu"
/* SET: . *//* NODE: NUMBER 3680 */

#line 1075 "garden.ceu"
    (((*((CEU_Birb*)__ceu_this)).tier)) = 1;
#line 1072 "garden.ceu"
    }
#line 1072 "garden.ceu"
/* CLEAR: Block (1072) */
#line 1072 "garden.ceu"
    if (0) {

#line 1072 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
}
static void _ceu_constr_3734 (tceu_app* _ceu_app, tceu_org* __ceu_this, tceu_org* _ceu_org) {
/* NODE: Dcl_constr 3734 */
/* NODE: Block 3733 */

#line 1084 "garden.ceu"
    {/* NODE: Stmts 3732 */

#line 1084 "garden.ceu"
    {/* NODE: Set 8058 */

#line 1084 "garden.ceu"
/* SET: . *//* NODE: Op1_& 3716 */

#line 1084 "garden.ceu"
    (((*((CEU_Birb*)__ceu_this)).gensym)) = (&((CEU_Main*)_ceu_org)->gensym);/* NODE: Set 8059 */

#line 1085 "garden.ceu"
/* SET: . *//* NODE: Op1_& 3721 */

#line 1085 "garden.ceu"
    (((*((CEU_Birb*)__ceu_this)).birb_count)) = (&((CEU_Main*)_ceu_org)->birb_count);/* NODE: Set 8060 */

#line 1086 "garden.ceu"
/* SET: . *//* NODE: Op1_& 3726 */

#line 1086 "garden.ceu"
    (((*((CEU_Birb*)__ceu_this)).seeds)) = (&((CEU_Main*)_ceu_org)->seeds);/* NODE: Set 8061 */

#line 1087 "garden.ceu"
/* SET: . *//* NODE: NUMBER 3730 */

#line 1087 "garden.ceu"
    (((*((CEU_Birb*)__ceu_this)).tier)) = 2;
#line 1084 "garden.ceu"
    }
#line 1084 "garden.ceu"
/* CLEAR: Block (1084) */
#line 1084 "garden.ceu"
    if (0) {

#line 1084 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
}
static void _ceu_constr_3784 (tceu_app* _ceu_app, tceu_org* __ceu_this, tceu_org* _ceu_org) {
/* NODE: Dcl_constr 3784 */
/* NODE: Block 3783 */

#line 1096 "garden.ceu"
    {/* NODE: Stmts 3782 */

#line 1096 "garden.ceu"
    {/* NODE: Set 8095 */

#line 1096 "garden.ceu"
/* SET: . *//* NODE: Op1_& 3766 */

#line 1096 "garden.ceu"
    (((*((CEU_Birb*)__ceu_this)).gensym)) = (&((CEU_Main*)_ceu_org)->gensym);/* NODE: Set 8096 */

#line 1097 "garden.ceu"
/* SET: . *//* NODE: Op1_& 3771 */

#line 1097 "garden.ceu"
    (((*((CEU_Birb*)__ceu_this)).birb_count)) = (&((CEU_Main*)_ceu_org)->birb_count);/* NODE: Set 8097 */

#line 1098 "garden.ceu"
/* SET: . *//* NODE: Op1_& 3776 */

#line 1098 "garden.ceu"
    (((*((CEU_Birb*)__ceu_this)).seeds)) = (&((CEU_Main*)_ceu_org)->seeds);/* NODE: Set 8098 */

#line 1099 "garden.ceu"
/* SET: . *//* NODE: NUMBER 3780 */

#line 1099 "garden.ceu"
    (((*((CEU_Birb*)__ceu_this)).tier)) = 3;
#line 1096 "garden.ceu"
    }
#line 1096 "garden.ceu"
/* CLEAR: Block (1096) */
#line 1096 "garden.ceu"
    if (0) {

#line 1096 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
}

#endif

#ifdef CEU_THREADS
/* THREADS_C */

#endif

/* FUNCTIONS_C */


#ifdef CEU_OS_APP
static void* ceu_app_calls (tceu_app* _ceu_app, tceu_nevt evt, void* param) {
    switch (evt) {
        /* STUBS */
        
        /*
        case CEU_IN_XXX:
            return CEU_Main_XXX(param);
        */
        default:;
#ifdef CEU_DEBUG
        ceu_out_log(0, (long)"invalid call\n");
#endif
    }
    return NULL;
}
#endif

static void ceu_app_go (tceu_app* _ceu_app, tceu_evt* _ceu_evt, tceu_org* _ceu_org, tceu_trl* _ceu_trl,
                        tceu_stk* _ceu_stk)
{
    tceu_nlbl _ceu_lbl = _ceu_trl->lbl;

#ifdef CEU_GOTO
_CEU_GOTO_:
#endif

#ifdef CEU_DEBUG
#ifndef CEU_OS_APP
#ifdef CEU_ORGS
    _ceu_app->lst.org = _ceu_org;
#endif
    _ceu_app->lst.trl = _ceu_trl;
    _ceu_app->lst.lbl = _ceu_lbl;
#endif
#ifdef CEU_DEBUG_TRAILS
#ifndef CEU_OS_APP
printf("OK : lbl=%d : org=%p\n", _ceu_lbl, _ceu_org);
#endif
#endif
#endif

#ifdef CEU_RUNTESTS
    ceu_stack_clr();
#endif

    switch (_ceu_lbl) {
        /* NODE: Root 3810 */
/* NODE: Dcl_cls 0 */

#line 1 "garden.ceu"
case Class_Main:;/* NODE: Block 8100 */

#line 1 "garden.ceu"
    {/* NODE: Stmts 8099 */

#line 1 "garden.ceu"
    {/* NODE: Block 3816 */

#line 1 "garden.ceu"
    {
#line 1 "garden.ceu"
    #ifdef CEU_RET

#line 1 "garden.ceu"
    int __ceu__ret_0;

#line 1 "garden.ceu"
    #endif
/* NODE: Stmts 3815 */

#line 1 "garden.ceu"
    {/* NODE: Dcl_var 3812 */
/* NODE: SetBlock 3814 */
/* NODE: Block 3808 */

#line 1 "garden.ceu"
    {/* NODE: Stmts 3807 */

#line 1 "garden.ceu"
    {/* NODE: Stmts 3804 */

#line 1 "garden.ceu"
    {/* NODE: Block 3797 */

#line 1 "garden.ceu"
    /*  FINALIZE */
_ceu_org->trls[ 12 ].evt = CEU_IN__CLEAR;
_ceu_org->trls[ 12 ].lbl = Main_Block__fin_156;

#line 1 "garden.ceu"
    {
#line 1 "garden.ceu"
    (((CEU_Main*)_ceu_org)->_top_pool).parent_org = _ceu_org;
(((CEU_Main*)_ceu_org)->_top_pool).parent_trl = 0;
#ifdef CEU_ORGS_NEWS_POOL
(((CEU_Main*)_ceu_org)->_top_pool).pool.queue = NULL;            /* dynamic pool */
#endif

#line 1 "garden.ceu"
    #ifdef CEU_ORGS
_ceu_org->trls[ 0 ].evt = CEU_IN__ORG;
_ceu_org->trls[ 0 ].org = NULL;
#endif

#line 1 "garden.ceu"
    ((CEU_Main*)_ceu_org)->birbs.parent_org = _ceu_org;
((CEU_Main*)_ceu_org)->birbs.parent_trl = 1;

#line 1 "garden.ceu"
    ceu_pool_init(&((CEU_Main*)_ceu_org)->birbs.pool,5,sizeof(CEU_Birb),
              (byte**)&((CEU_Main*)_ceu_org)->birbs_queue, (byte*)&((CEU_Main*)_ceu_org)->birbs_mem);

#line 1 "garden.ceu"
    #ifdef CEU_ORGS
_ceu_org->trls[ 1 ].evt = CEU_IN__ORG;
_ceu_org->trls[ 1 ].org = NULL;
#endif

#line 1 "garden.ceu"
    ((CEU_Main*)_ceu_org)->seeds.parent_org = _ceu_org;
((CEU_Main*)_ceu_org)->seeds.parent_trl = 2;

#line 1 "garden.ceu"
    ceu_pool_init(&((CEU_Main*)_ceu_org)->seeds.pool,5,sizeof(CEU_Seed),
              (byte**)&((CEU_Main*)_ceu_org)->seeds_queue, (byte*)&((CEU_Main*)_ceu_org)->seeds_mem);

#line 1 "garden.ceu"
    #ifdef CEU_ORGS
_ceu_org->trls[ 2 ].evt = CEU_IN__ORG;
_ceu_org->trls[ 2 ].org = NULL;
#endif

#line 1 "garden.ceu"
    #ifdef CEU_ORGS
_ceu_org->trls[ 3 ].evt = CEU_IN__ORG;
_ceu_org->trls[ 3 ].org = NULL;
#endif

#line 1 "garden.ceu"
    _ceu_trl = &_ceu_org->trls[ 4 ];
/* NODE: Stmts 3795 */

#line 1 "garden.ceu"
    {/* NODE: Dcl_pool 8102 */
/* NODE: Stmts 3821 */

#line 1 "garden.ceu"
    {/* NODE: Dcl_ext 3820 */

#line 1 "garden.ceu"
    }/* NODE: Stmts 3825 */

#line 2 "garden.ceu"
    {/* NODE: Dcl_ext 3824 */

#line 2 "garden.ceu"
    }/* NODE: Stmts 3828 */

#line 3 "garden.ceu"
    {/* NODE: Dcl_ext 3827 */

#line 3 "garden.ceu"
    }/* NODE: Stmts 3830 */

#line 4 "garden.ceu"
    {/* NODE: Dcl_ext 3829 */

#line 4 "garden.ceu"
    }/* NODE: Stmts 3832 */

#line 5 "garden.ceu"
    {/* NODE: Dcl_ext 3831 */

#line 5 "garden.ceu"
    }/* NODE: Stmts 3834 */

#line 6 "garden.ceu"
    {/* NODE: Dcl_ext 3833 */

#line 6 "garden.ceu"
    }/* NODE: Stmts 3837 */

#line 7 "garden.ceu"
    {/* NODE: Dcl_ext 3836 */

#line 7 "garden.ceu"
    }/* NODE: Stmts 3839 */

#line 8 "garden.ceu"
    {/* NODE: Dcl_ext 3838 */

#line 8 "garden.ceu"
    }/* NODE: Stmts 3841 */

#line 34 "garden.ceu"
    {/* NODE: Dcl_ext 3840 */

#line 34 "garden.ceu"
    }/* NODE: Stmts 3845 */

#line 35 "garden.ceu"
    {/* NODE: Dcl_ext 3844 */

#line 35 "garden.ceu"
    }/* NODE: Stmts 3847 */

#line 36 "garden.ceu"
    {/* NODE: Dcl_ext 3846 */

#line 36 "garden.ceu"
    }/* NODE: Stmts 3849 */

#line 37 "garden.ceu"
    {/* NODE: Dcl_ext 3848 */

#line 37 "garden.ceu"
    }/* NODE: Stmts 3851 */

#line 38 "garden.ceu"
    {/* NODE: Dcl_ext 3850 */

#line 38 "garden.ceu"
    }/* NODE: Stmts 3853 */

#line 39 "garden.ceu"
    {/* NODE: Dcl_ext 3852 */

#line 39 "garden.ceu"
    }/* NODE: Stmts 3855 */

#line 40 "garden.ceu"
    {/* NODE: Dcl_ext 3854 */

#line 40 "garden.ceu"
    }/* NODE: Stmts 3857 */

#line 41 "garden.ceu"
    {/* NODE: Dcl_ext 3856 */

#line 41 "garden.ceu"
    }/* NODE: Stmts 3862 */

#line 43 "garden.ceu"
    {/* NODE: Dcl_var 3859 */
/* NODE: Set 3863 */

#line 43 "garden.ceu"
/* SET: gensym *//* NODE: NUMBER 83 */

#line 43 "garden.ceu"
    (((CEU_Main*)_ceu_org)->gensym) = 1;
#line 43 "garden.ceu"
    }/* NODE: Host 85 */
/* NODE: Stmts 3925 */

#line 49 "garden.ceu"
    {
#line 49 "garden.ceu"
    }/* NODE: Stmts 4013 */

#line 65 "garden.ceu"
    {
#line 65 "garden.ceu"
    }/* NODE: Stmts 4540 */

#line 83 "garden.ceu"
    {
#line 83 "garden.ceu"
    }/* NODE: Stmts 4704 */

#line 118 "garden.ceu"
    {
#line 118 "garden.ceu"
    }/* NODE: Host 521 */
/* NODE: Stmts 4940 */

#line 188 "garden.ceu"
    {
#line 188 "garden.ceu"
    }/* NODE: Stmts 5176 */

#line 246 "garden.ceu"
    {
#line 246 "garden.ceu"
    }/* NODE: Stmts 5412 */

#line 303 "garden.ceu"
    {
#line 303 "garden.ceu"
    }/* NODE: Stmts 5648 */

#line 360 "garden.ceu"
    {
#line 360 "garden.ceu"
    }/* NODE: Stmts 5832 */

#line 450 "garden.ceu"
    {
#line 450 "garden.ceu"
    }/* NODE: Stmts 6052 */

#line 518 "garden.ceu"
    {
#line 518 "garden.ceu"
    }/* NODE: Stmts 6215 */

#line 558 "garden.ceu"
    {
#line 558 "garden.ceu"
    }/* NODE: Stmts 6431 */

#line 602 "garden.ceu"
    {
#line 602 "garden.ceu"
    }/* NODE: Stmts 6594 */

#line 640 "garden.ceu"
    {
#line 640 "garden.ceu"
    }/* NODE: Stmts 6810 */

#line 690 "garden.ceu"
    {
#line 690 "garden.ceu"
    }/* NODE: Stmts 6901 */

#line 728 "garden.ceu"
    {
#line 728 "garden.ceu"
    }/* NODE: Stmts 7032 */

#line 763 "garden.ceu"
    {
#line 763 "garden.ceu"
    }/* NODE: Stmts 7214 */

#line 793 "garden.ceu"
    {
#line 793 "garden.ceu"
    }/* NODE: Host 2743 */
/* NODE: Stmts 7444 */

#line 857 "garden.ceu"
    {
#line 857 "garden.ceu"
    }/* NODE: Stmts 7449 */

#line 935 "garden.ceu"
    {/* NODE: Dcl_var 7446 */
/* NODE: Set 7450 */

#line 935 "garden.ceu"
/* SET: birb_count *//* NODE: NUMBER 3025 */

#line 935 "garden.ceu"
    (((CEU_Main*)_ceu_org)->birb_count) = 0;
#line 935 "garden.ceu"
    }/* NODE: Stmts 7454 */

#line 936 "garden.ceu"
    {/* NODE: Dcl_pool 7453 */

#line 936 "garden.ceu"
    }/* NODE: Stmts 7458 */

#line 937 "garden.ceu"
    {/* NODE: Dcl_pool 7457 */

#line 937 "garden.ceu"
    }/* NODE: Stmts 7461 */

#line 939 "garden.ceu"
    {/* NODE: Dcl_var 7460 */

#line 939 "garden.ceu"
/* start org: garden */
#line 939 "garden.ceu"
        /* resets org memory and starts org.trail[0]=Class_XXX */
    /* TODO: BUG: _ceu_org is not necessarily the parent for pool allocations */
    ceu_out_org_init(_ceu_app, ((tceu_org*) &(((CEU_Main*)_ceu_org)->garden)),3,Class_Garden,
                     2,
                     0,
                     _ceu_org,3);
/* TODO: currently idx is always "1" for all interfaces access because pools 
 * are all together there. When we have separate trls for pools, we'll have to 
 * indirectly access the offset in the interface. */

#line 939 "garden.ceu"
        _ceu_pre_2(_ceu_app, ((tceu_org*) &(((CEU_Main*)_ceu_org)->garden)));

#line 939 "garden.ceu"
        _ceu_constr_8356(_ceu_app, ((tceu_org*) &(((CEU_Main*)_ceu_org)->garden)), _ceu_org);

#line 939 "garden.ceu"
    {
#ifdef CEU_STACK_CLEAR
    tceu_stk stk_ = { _ceu_stk, _ceu_org, 4, 11, 1 };
    ceu_app_go(_ceu_app,NULL,
               ((tceu_org*) &(((CEU_Main*)_ceu_org)->garden)), &((tceu_org*) &(((CEU_Main*)_ceu_org)->garden))->trls[0],
               &stk_);
    if (!stk_.is_alive) {
        return;
    }
#else
    ceu_app_go(_ceu_app,NULL,
               ((tceu_org*) &(((CEU_Main*)_ceu_org)->garden)), &((tceu_org*) &(((CEU_Main*)_ceu_org)->garden))->trls[0],
               NULL);
#endif

#line 939 "garden.ceu"
    }

#line 939 "garden.ceu"
    }/* NODE: ParEver 3794 */

#line 941 "garden.ceu"
/* ParEver: spawn subs */
#line 941 "garden.ceu"
    {
#ifdef CEU_STACK_CLEAR
    tceu_stk stk_ = { _ceu_stk, _ceu_org, 4, 11, 1 };
#endif

#line 941 "garden.ceu"
        _ceu_org->trls[ 4 ].lbl = Main_ParEver_sub_1_134;
    ceu_app_go(_ceu_app,NULL,_ceu_org,
               &_ceu_org->trls[ 4 ],
#ifdef CEU_STACK_CLEAR
               &stk_
#else
               NULL
#endif
              );

#ifdef CEU_STACK_CLEAR
    if (!stk_.is_alive) {
        return;
    }
#endif

#line 941 "garden.ceu"
        _ceu_org->trls[ 5 ].lbl = Main_ParEver_sub_2_135;
    ceu_app_go(_ceu_app,NULL,_ceu_org,
               &_ceu_org->trls[ 5 ],
#ifdef CEU_STACK_CLEAR
               &stk_
#else
               NULL
#endif
              );

#ifdef CEU_STACK_CLEAR
    if (!stk_.is_alive) {
        return;
    }
#endif

#line 941 "garden.ceu"
        _ceu_org->trls[ 6 ].lbl = Main_ParEver_sub_3_136;
    ceu_app_go(_ceu_app,NULL,_ceu_org,
               &_ceu_org->trls[ 6 ],
#ifdef CEU_STACK_CLEAR
               &stk_
#else
               NULL
#endif
              );

#ifdef CEU_STACK_CLEAR
    if (!stk_.is_alive) {
        return;
    }
#endif

#line 941 "garden.ceu"
        _ceu_org->trls[ 9 ].lbl = Main_ParEver_sub_4_137;
    ceu_app_go(_ceu_app,NULL,_ceu_org,
               &_ceu_org->trls[ 9 ],
#ifdef CEU_STACK_CLEAR
               &stk_
#else
               NULL
#endif
              );

#ifdef CEU_STACK_CLEAR
    if (!stk_.is_alive) {
        return;
    }
#endif

#line 941 "garden.ceu"
        _ceu_org->trls[ 10 ].lbl = Main_ParEver_sub_5_138;
    ceu_app_go(_ceu_app,NULL,_ceu_org,
               &_ceu_org->trls[ 10 ],
#ifdef CEU_STACK_CLEAR
               &stk_
#else
               NULL
#endif
              );

#ifdef CEU_STACK_CLEAR
    if (!stk_.is_alive) {
        return;
    }
#endif

#line 941 "garden.ceu"
        _ceu_trl = &_ceu_org->trls[ 11 ];

#line 941 "garden.ceu"
    }
/* NODE: Block 3793 */

#line 1092 "garden.ceu"
    {/* NODE: Stmts 3792 */

#line 1092 "garden.ceu"
    {/* NODE: Block 8065 */

#line 1092 "garden.ceu"
    {/* NODE: Stmts 8064 */

#line 1092 "garden.ceu"
    {/* NODE: Stmts 8063 */

#line 1092 "garden.ceu"
    {
#line 1092 "garden.ceu"
    }/* NODE: Loop 8062 */

#line 1092 "garden.ceu"
    for (;;) {
/* NODE: Block 3790 */

#line 1093 "garden.ceu"
    {/* NODE: Stmts 3789 */

#line 1093 "garden.ceu"
    {/* NODE: Stmts 8092 */

#line 1093 "garden.ceu"
    {/* NODE: Nothing 8066 */
/* NODE: Await 3745 */

#line 1093 "garden.ceu"
    _CEU_NO_3745_:
if (0) { goto _CEU_NO_3745_; /* avoids "not used" warning */ }

#line 1093 "garden.ceu"
    _ceu_trl->evt = CEU_IN_UPDATE;
_ceu_trl->lbl = Main_Awake_UPDATE_155;
_ceu_trl->seqno = _ceu_app->seqno;

#line 1093 "garden.ceu"
    return;

case Main_Awake_UPDATE_155:;

#line 1093 "garden.ceu"
    #ifdef CEU_DEBUG_TRAILS
#ifndef CEU_OS
printf("\tOK!\n");
#endif
#endif
/* NODE: Nothing 8436 */
/* NODE: Nothing 8437 */

#line 1093 "garden.ceu"
    }/* NODE: If 8094 */

#line 1094 "garden.ceu"
    if (((((((((CEU_Main*)_ceu_org)->garden).score))>(((CEU_Main*)_ceu_org)->birb_count))&&((((((CEU_Main*)_ceu_org)->garden).t2_plants))>0))&&(d(60)==0))) {
/* NODE: Block 3787 */

#line 1095 "garden.ceu"
    {/* NODE: Stmts 3786 */

#line 1095 "garden.ceu"
    {/* NODE: Spawn 3785 */

#line 1095 "garden.ceu"
    /*{*/
    tceu_org* __ceu_new_3785;

#line 1095 "garden.ceu"
        __ceu_new_3785 = (tceu_org*) ceu_pool_alloc(&(((CEU_Main*)_ceu_org)->birbs).pool);

#line 1095 "garden.ceu"
        if (__ceu_new_3785 != NULL) {

#line 1095 "garden.ceu"
    #ifdef CEU_ORGS_NEWS_POOL
        __ceu_new_3785->pool = &(((CEU_Main*)_ceu_org)->birbs);
#endif

#line 1095 "garden.ceu"
/* start org: dyn */
#line 1095 "garden.ceu"
        /* resets org memory and starts org.trail[0]=Class_XXX */
    /* TODO: BUG: _ceu_org is not necessarily the parent for pool allocations */
    ceu_out_org_init(_ceu_app, ((tceu_org*) &(*((CEU_Birb*)__ceu_new_3785))),7,Class_Birb,
                     18,
                     1,
                     (((CEU_Main*)_ceu_org)->birbs).parent_org,(((CEU_Main*)_ceu_org)->birbs).parent_trl);
/* TODO: currently idx is always "1" for all interfaces access because pools 
 * are all together there. When we have separate trls for pools, we'll have to 
 * indirectly access the offset in the interface. */

#line 1095 "garden.ceu"
        _ceu_constr_3784(_ceu_app, ((tceu_org*) &(*((CEU_Birb*)__ceu_new_3785))), _ceu_org);

#line 1095 "garden.ceu"
    {
#ifdef CEU_STACK_CLEAR
    tceu_stk stk_ = { _ceu_stk, _ceu_org, 11, 11, 1 };
    ceu_app_go(_ceu_app,NULL,
               ((tceu_org*) &(*((CEU_Birb*)__ceu_new_3785))), &((tceu_org*) &(*((CEU_Birb*)__ceu_new_3785)))->trls[0],
               &stk_);
    if (!stk_.is_alive) {
        return;
    }
#else
    ceu_app_go(_ceu_app,NULL,
               ((tceu_org*) &(*((CEU_Birb*)__ceu_new_3785))), &((tceu_org*) &(*((CEU_Birb*)__ceu_new_3785)))->trls[0],
               NULL);
#endif

#line 1095 "garden.ceu"
    }

#line 1095 "garden.ceu"
        }
/*}*/

#line 1095 "garden.ceu"
    }
#line 1095 "garden.ceu"
/* CLEAR: Block (1095) */
#line 1095 "garden.ceu"
    if (0) {

#line 1095 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
} else {
/* NODE: Nothing 8093 */
}

#line 1093 "garden.ceu"
    }
#line 1093 "garden.ceu"
/* CLEAR: Block (1093) */
#line 1093 "garden.ceu"
    if (0) {

#line 1093 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 1092 "garden.ceu"
    }

#line 1092 "garden.ceu"
    }
#line 1092 "garden.ceu"
/* CLEAR: Block (1092) */
#line 1092 "garden.ceu"
    if (0) {

#line 1092 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 1092 "garden.ceu"
    }
#line 1092 "garden.ceu"
/* CLEAR: Block (1092) */
#line 1092 "garden.ceu"
    if (0) {

#line 1092 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 941 "garden.ceu"
case Main_ParEver_sub_5_138:;/* NODE: Block 3743 */

#line 1080 "garden.ceu"
    {/* NODE: Stmts 3742 */

#line 1080 "garden.ceu"
    {/* NODE: Block 8028 */

#line 1080 "garden.ceu"
    {/* NODE: Stmts 8027 */

#line 1080 "garden.ceu"
    {/* NODE: Stmts 8026 */

#line 1080 "garden.ceu"
    {
#line 1080 "garden.ceu"
    }/* NODE: Loop 8025 */

#line 1080 "garden.ceu"
    for (;;) {
/* NODE: Block 3740 */

#line 1081 "garden.ceu"
    {/* NODE: Stmts 3739 */

#line 1081 "garden.ceu"
    {/* NODE: Stmts 8055 */

#line 1081 "garden.ceu"
    {/* NODE: Nothing 8029 */
/* NODE: Await 3695 */

#line 1081 "garden.ceu"
    _CEU_NO_3695_:
if (0) { goto _CEU_NO_3695_; /* avoids "not used" warning */ }

#line 1081 "garden.ceu"
    _ceu_trl->evt = CEU_IN_UPDATE;
_ceu_trl->lbl = Main_Awake_UPDATE_154;
_ceu_trl->seqno = _ceu_app->seqno;

#line 1081 "garden.ceu"
    return;

case Main_Awake_UPDATE_154:;

#line 1081 "garden.ceu"
    #ifdef CEU_DEBUG_TRAILS
#ifndef CEU_OS
printf("\tOK!\n");
#endif
#endif
/* NODE: Nothing 8428 */
/* NODE: Nothing 8429 */

#line 1081 "garden.ceu"
    }/* NODE: If 8057 */

#line 1082 "garden.ceu"
    if (((((((((CEU_Main*)_ceu_org)->garden).score))>(((CEU_Main*)_ceu_org)->birb_count))&&((((((CEU_Main*)_ceu_org)->garden).t1_plants))>0))&&(d(60)==0))) {
/* NODE: Block 3737 */

#line 1083 "garden.ceu"
    {/* NODE: Stmts 3736 */

#line 1083 "garden.ceu"
    {/* NODE: Spawn 3735 */

#line 1083 "garden.ceu"
    /*{*/
    tceu_org* __ceu_new_3735;

#line 1083 "garden.ceu"
        __ceu_new_3735 = (tceu_org*) ceu_pool_alloc(&(((CEU_Main*)_ceu_org)->birbs).pool);

#line 1083 "garden.ceu"
        if (__ceu_new_3735 != NULL) {

#line 1083 "garden.ceu"
    #ifdef CEU_ORGS_NEWS_POOL
        __ceu_new_3735->pool = &(((CEU_Main*)_ceu_org)->birbs);
#endif

#line 1083 "garden.ceu"
/* start org: dyn */
#line 1083 "garden.ceu"
        /* resets org memory and starts org.trail[0]=Class_XXX */
    /* TODO: BUG: _ceu_org is not necessarily the parent for pool allocations */
    ceu_out_org_init(_ceu_app, ((tceu_org*) &(*((CEU_Birb*)__ceu_new_3735))),7,Class_Birb,
                     18,
                     1,
                     (((CEU_Main*)_ceu_org)->birbs).parent_org,(((CEU_Main*)_ceu_org)->birbs).parent_trl);
/* TODO: currently idx is always "1" for all interfaces access because pools 
 * are all together there. When we have separate trls for pools, we'll have to 
 * indirectly access the offset in the interface. */

#line 1083 "garden.ceu"
        _ceu_constr_3734(_ceu_app, ((tceu_org*) &(*((CEU_Birb*)__ceu_new_3735))), _ceu_org);

#line 1083 "garden.ceu"
    {
#ifdef CEU_STACK_CLEAR
    tceu_stk stk_ = { _ceu_stk, _ceu_org, 10, 10, 1 };
    ceu_app_go(_ceu_app,NULL,
               ((tceu_org*) &(*((CEU_Birb*)__ceu_new_3735))), &((tceu_org*) &(*((CEU_Birb*)__ceu_new_3735)))->trls[0],
               &stk_);
    if (!stk_.is_alive) {
        return;
    }
#else
    ceu_app_go(_ceu_app,NULL,
               ((tceu_org*) &(*((CEU_Birb*)__ceu_new_3735))), &((tceu_org*) &(*((CEU_Birb*)__ceu_new_3735)))->trls[0],
               NULL);
#endif

#line 1083 "garden.ceu"
    }

#line 1083 "garden.ceu"
        }
/*}*/

#line 1083 "garden.ceu"
    }
#line 1083 "garden.ceu"
/* CLEAR: Block (1083) */
#line 1083 "garden.ceu"
    if (0) {

#line 1083 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
} else {
/* NODE: Nothing 8056 */
}

#line 1081 "garden.ceu"
    }
#line 1081 "garden.ceu"
/* CLEAR: Block (1081) */
#line 1081 "garden.ceu"
    if (0) {

#line 1081 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 1080 "garden.ceu"
    }

#line 1080 "garden.ceu"
    }
#line 1080 "garden.ceu"
/* CLEAR: Block (1080) */
#line 1080 "garden.ceu"
    if (0) {

#line 1080 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 1080 "garden.ceu"
    }
#line 1080 "garden.ceu"
/* CLEAR: Block (1080) */
#line 1080 "garden.ceu"
    if (0) {

#line 1080 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 941 "garden.ceu"
case Main_ParEver_sub_4_137:;/* NODE: Block 3693 */

#line 1068 "garden.ceu"
    {/* NODE: Stmts 3692 */

#line 1068 "garden.ceu"
    {/* NODE: Block 7991 */

#line 1068 "garden.ceu"
    {/* NODE: Stmts 7990 */

#line 1068 "garden.ceu"
    {/* NODE: Stmts 7989 */

#line 1068 "garden.ceu"
    {
#line 1068 "garden.ceu"
    }/* NODE: Loop 7988 */

#line 1068 "garden.ceu"
    for (;;) {
/* NODE: Block 3690 */

#line 1069 "garden.ceu"
    {/* NODE: Stmts 3689 */

#line 1069 "garden.ceu"
    {/* NODE: Stmts 8018 */

#line 1069 "garden.ceu"
    {/* NODE: Nothing 7992 */
/* NODE: Await 3645 */

#line 1069 "garden.ceu"
    _CEU_NO_3645_:
if (0) { goto _CEU_NO_3645_; /* avoids "not used" warning */ }

#line 1069 "garden.ceu"
    _ceu_trl->evt = CEU_IN_UPDATE;
_ceu_trl->lbl = Main_Awake_UPDATE_153;
_ceu_trl->seqno = _ceu_app->seqno;

#line 1069 "garden.ceu"
    return;

case Main_Awake_UPDATE_153:;

#line 1069 "garden.ceu"
    #ifdef CEU_DEBUG_TRAILS
#ifndef CEU_OS
printf("\tOK!\n");
#endif
#endif
/* NODE: Nothing 8420 */
/* NODE: Nothing 8421 */

#line 1069 "garden.ceu"
    }/* NODE: If 8020 */

#line 1070 "garden.ceu"
    if (((((((((CEU_Main*)_ceu_org)->garden).score))>(((CEU_Main*)_ceu_org)->birb_count))&&((((((CEU_Main*)_ceu_org)->garden).t0_plants))>0))&&(d(60)==0))) {
/* NODE: Block 3687 */

#line 1071 "garden.ceu"
    {/* NODE: Stmts 3686 */

#line 1071 "garden.ceu"
    {/* NODE: Spawn 3685 */

#line 1071 "garden.ceu"
    /*{*/
    tceu_org* __ceu_new_3685;

#line 1071 "garden.ceu"
        __ceu_new_3685 = (tceu_org*) ceu_pool_alloc(&(((CEU_Main*)_ceu_org)->birbs).pool);

#line 1071 "garden.ceu"
        if (__ceu_new_3685 != NULL) {

#line 1071 "garden.ceu"
    #ifdef CEU_ORGS_NEWS_POOL
        __ceu_new_3685->pool = &(((CEU_Main*)_ceu_org)->birbs);
#endif

#line 1071 "garden.ceu"
/* start org: dyn */
#line 1071 "garden.ceu"
        /* resets org memory and starts org.trail[0]=Class_XXX */
    /* TODO: BUG: _ceu_org is not necessarily the parent for pool allocations */
    ceu_out_org_init(_ceu_app, ((tceu_org*) &(*((CEU_Birb*)__ceu_new_3685))),7,Class_Birb,
                     18,
                     1,
                     (((CEU_Main*)_ceu_org)->birbs).parent_org,(((CEU_Main*)_ceu_org)->birbs).parent_trl);
/* TODO: currently idx is always "1" for all interfaces access because pools 
 * are all together there. When we have separate trls for pools, we'll have to 
 * indirectly access the offset in the interface. */

#line 1071 "garden.ceu"
        _ceu_constr_3684(_ceu_app, ((tceu_org*) &(*((CEU_Birb*)__ceu_new_3685))), _ceu_org);

#line 1071 "garden.ceu"
    {
#ifdef CEU_STACK_CLEAR
    tceu_stk stk_ = { _ceu_stk, _ceu_org, 9, 9, 1 };
    ceu_app_go(_ceu_app,NULL,
               ((tceu_org*) &(*((CEU_Birb*)__ceu_new_3685))), &((tceu_org*) &(*((CEU_Birb*)__ceu_new_3685)))->trls[0],
               &stk_);
    if (!stk_.is_alive) {
        return;
    }
#else
    ceu_app_go(_ceu_app,NULL,
               ((tceu_org*) &(*((CEU_Birb*)__ceu_new_3685))), &((tceu_org*) &(*((CEU_Birb*)__ceu_new_3685)))->trls[0],
               NULL);
#endif

#line 1071 "garden.ceu"
    }

#line 1071 "garden.ceu"
        }
/*}*/

#line 1071 "garden.ceu"
    }
#line 1071 "garden.ceu"
/* CLEAR: Block (1071) */
#line 1071 "garden.ceu"
    if (0) {

#line 1071 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
} else {
/* NODE: Nothing 8019 */
}

#line 1069 "garden.ceu"
    }
#line 1069 "garden.ceu"
/* CLEAR: Block (1069) */
#line 1069 "garden.ceu"
    if (0) {

#line 1069 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 1068 "garden.ceu"
    }

#line 1068 "garden.ceu"
    }
#line 1068 "garden.ceu"
/* CLEAR: Block (1068) */
#line 1068 "garden.ceu"
    if (0) {

#line 1068 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 1068 "garden.ceu"
    }
#line 1068 "garden.ceu"
/* CLEAR: Block (1068) */
#line 1068 "garden.ceu"
    if (0) {

#line 1068 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 941 "garden.ceu"
case Main_ParEver_sub_3_136:;/* NODE: Block 3643 */

#line 1003 "garden.ceu"
    {/* NODE: Stmts 3642 */

#line 1003 "garden.ceu"
    {/* NODE: Block 7664 */

#line 1003 "garden.ceu"
    {/* NODE: Stmts 7663 */

#line 1003 "garden.ceu"
    {/* NODE: Stmts 7662 */

#line 1003 "garden.ceu"
    {
#line 1003 "garden.ceu"
    }/* NODE: Loop 7661 */

#line 1003 "garden.ceu"
    for (;;) {
/* NODE: Block 3640 */

#line 1004 "garden.ceu"
    {/* NODE: Stmts 3639 */

#line 1004 "garden.ceu"
    {/* NODE: CallStmt 3318 */

#line 1004 "garden.ceu"
    printf("top of tool loop\n");/* NODE: ParOr 3638 */

#line 1005 "garden.ceu"
/* ParOr: spawn subs */
#line 1005 "garden.ceu"
    {
#ifdef CEU_STACK_CLEAR
    tceu_stk stk_ = { _ceu_stk, _ceu_org, 6, 8, 1 };
#endif

#line 1005 "garden.ceu"
        _ceu_org->trls[ 6 ].lbl = Main_ParOr_sub_1_143;
    ceu_app_go(_ceu_app,NULL,_ceu_org,
               &_ceu_org->trls[ 6 ],
#ifdef CEU_STACK_CLEAR
               &stk_
#else
               NULL
#endif
              );

#ifdef CEU_STACK_CLEAR
    if (!stk_.is_alive) {
        return;
    }
#endif

#line 1005 "garden.ceu"
        _ceu_trl = &_ceu_org->trls[ 7 ];

#line 1005 "garden.ceu"
    }
/* NODE: Block 3637 */

#line 1008 "garden.ceu"
    {/* NODE: Stmts 3636 */

#line 1008 "garden.ceu"
    {/* NODE: Stmts 7696 */

#line 1008 "garden.ceu"
    {/* NODE: Dcl_var 7693 */
/* NODE: Dcl_var 7695 */

#line 1008 "garden.ceu"
    }/* NODE: Stmts 7736 */

#line 1009 "garden.ceu"
    {/* NODE: Nothing 7698 */
/* NODE: Set 7697 */

#line 1009 "garden.ceu"
/* SET: table: 0xf864d0 *//* NODE: Await 3329 */

#line 1009 "garden.ceu"
    _CEU_NO_3329_:
if (0) { goto _CEU_NO_3329_; /* avoids "not used" warning */ }

#line 1009 "garden.ceu"
    _ceu_trl->evt = CEU_IN_MOUSE_DOWN;
_ceu_trl->lbl = Main_Awake_MOUSE_DOWN_146;
_ceu_trl->seqno = _ceu_app->seqno;

#line 1009 "garden.ceu"
    return;

case Main_Awake_MOUSE_DOWN_146:;

#line 1009 "garden.ceu"
    #ifdef CEU_DEBUG_TRAILS
#ifndef CEU_OS
printf("\tOK!\n");
#endif
#endif

#line 1009 "garden.ceu"
    {

#line 1009 "garden.ceu"
        tceu__int__int** __ceu_casted = (tceu__int__int**) _ceu_evt->param;

#line 1009 "garden.ceu"
        (((CEU_Main*)_ceu_org)->x_13) = ((*(__ceu_casted))->_1);
}

#line 1009 "garden.ceu"
    {

#line 1009 "garden.ceu"
        tceu__int__int** __ceu_casted = (tceu__int__int**) _ceu_evt->param;

#line 1009 "garden.ceu"
        (((CEU_Main*)_ceu_org)->y_14) = ((*(__ceu_casted))->_2);
}
/* NODE: Nothing 8378 */
/* NODE: Nothing 8379 */

#line 1009 "garden.ceu"
    }/* NODE: If 7742 */

#line 1010 "garden.ceu"
    if (((((CEU_Main*)_ceu_org)->y_14)>=800)) {
/* NODE: Block 3634 */

#line 1011 "garden.ceu"
    {/* NODE: Stmts 3633 */

#line 1011 "garden.ceu"
    {/* NODE: If 7749 */

#line 1011 "garden.ceu"
    if ((((((CEU_Main*)_ceu_org)->x_13)>((215+(0*135))-50))&&((((CEU_Main*)_ceu_org)->x_13)<((215+(0*135))+50)))) {
/* NODE: Block 3376 */

#line 1012 "garden.ceu"
    {/* NODE: Stmts 3375 */

#line 1012 "garden.ceu"
    {/* NODE: Do 7756 */
/* NODE: Block 7755 */

#line 1012 "garden.ceu"
    {
#line 1012 "garden.ceu"
    #ifdef CEU_ORGS
_ceu_org->trls[ 7 ].evt = CEU_IN__ORG;
_ceu_org->trls[ 7 ].org = NULL;
#endif

#line 1012 "garden.ceu"
    _ceu_trl = &_ceu_org->trls[ 8 ];
/* NODE: Stmts 7754 */

#line 1012 "garden.ceu"
    {/* NODE: Dcl_var 7753 */

#line 1012 "garden.ceu"
/* start org: _org_3374 */
#line 1012 "garden.ceu"
        /* resets org memory and starts org.trail[0]=Class_XXX */
    /* TODO: BUG: _ceu_org is not necessarily the parent for pool allocations */
    ceu_out_org_init(_ceu_app, ((tceu_org*) &(((CEU_Main*)_ceu_org)->_org_3374_15)),5,Class_Shovel,
                     14,
                     0,
                     _ceu_org,7);
/* TODO: currently idx is always "1" for all interfaces access because pools 
 * are all together there. When we have separate trls for pools, we'll have to 
 * indirectly access the offset in the interface. */

#line 1012 "garden.ceu"
        _ceu_constr_3373(_ceu_app, ((tceu_org*) &(((CEU_Main*)_ceu_org)->_org_3374_15)), _ceu_org);

#line 1012 "garden.ceu"
    {
#ifdef CEU_STACK_CLEAR
    tceu_stk stk_ = { _ceu_stk, _ceu_org, 8, 8, 1 };
    ceu_app_go(_ceu_app,NULL,
               ((tceu_org*) &(((CEU_Main*)_ceu_org)->_org_3374_15)), &((tceu_org*) &(((CEU_Main*)_ceu_org)->_org_3374_15))->trls[0],
               &stk_);
    if (!stk_.is_alive) {
        return;
    }
#else
    ceu_app_go(_ceu_app,NULL,
               ((tceu_org*) &(((CEU_Main*)_ceu_org)->_org_3374_15)), &((tceu_org*) &(((CEU_Main*)_ceu_org)->_org_3374_15))->trls[0],
               NULL);
#endif

#line 1012 "garden.ceu"
    }
/* NODE: Stmts 7787 */

#line 1012 "garden.ceu"
    {/* NODE: Nothing 7761 */
/* NODE: Nothing 8384 */
/* NODE: Nothing 8385 */
/* NODE: Stmts 7786 */

#line 1012 "garden.ceu"
    {/* NODE: If 7785 */

#line 1012 "garden.ceu"
    if ((!(((*((tceu_org*)(&((CEU_Main*)_ceu_org)->_org_3374_15))).isAlive)))) {
/* NODE: Block 7782 */

#line 1012 "garden.ceu"
    {/* NODE: Stmts 7781 */

#line 1012 "garden.ceu"
    {/* NODE: Nothing 7765 */

#line 1012 "garden.ceu"
    }
#line 1012 "garden.ceu"
/* CLEAR: Block (1012) */
#line 1012 "garden.ceu"
    if (0) {

#line 1012 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
} else {
/* NODE: Block 7784 */

#line 1012 "garden.ceu"
    {/* NODE: Stmts 7783 */

#line 1012 "garden.ceu"
    {/* NODE: Await 7764 */

#line 1012 "garden.ceu"
    _CEU_NO_7764_:
if (0) { goto _CEU_NO_7764_; /* avoids "not used" warning */ }

#line 1012 "garden.ceu"
    _ceu_trl->evt = CEU_IN__ok_killed;
_ceu_trl->lbl = Main_Awake__ok_killed_147;
_ceu_trl->seqno = _ceu_app->seqno;

#line 1012 "garden.ceu"
    #ifdef CEU_ORGS_AWAIT
#ifdef CEU_ADTS_AWAIT
_ceu_trl->is_org = 1;
#endif
#endif
_ceu_trl->org_or_adt = (void*)(&((CEU_Main*)_ceu_org)->_org_3374_15);

#line 1012 "garden.ceu"
    return;

case Main_Awake__ok_killed_147:;

#line 1012 "garden.ceu"
    #ifdef CEU_DEBUG_TRAILS
#ifndef CEU_OS
printf("\tOK!\n");
#endif
#endif

#line 1012 "garden.ceu"
    }
#line 1012 "garden.ceu"
/* CLEAR: Block (1012) */
#line 1012 "garden.ceu"
    if (0) {

#line 1012 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
}

#line 1012 "garden.ceu"
    }
#line 1012 "garden.ceu"
    }
#line 1012 "garden.ceu"
    }
#line 1012 "garden.ceu"
/* CLEAR: Block (1012) */
#line 1012 "garden.ceu"
    {
    /* Reuse current stack frame.
     * We know that CLEAR will not abort anything and return normally.
     * Just save the previous "is_alive", call CLEAR, and restore it.
     */
#ifdef CEU_STACK_CLEAR
    int __ceu_old = _ceu_stk->is_alive;
    _ceu_stk->is_alive = 1;
#endif
    tceu_evt evt;
             evt.id = CEU_IN__CLEAR;
    ceu_sys_go_ex(_ceu_app, &evt,
                  _ceu_stk,
                  _ceu_org,
                  7,
                  9);
#ifdef CEU_STACK_CLEAR
    _ceu_stk->is_alive = __ceu_old;
    ceu_sys_stack_clear(_ceu_stk, _ceu_org,
                        7,8);
#endif
}

#line 1012 "garden.ceu"
    #ifdef CEU_ORGS_AWAIT
/* signal ok_killed */
{
    tceu_kill ps = { _ceu_org, _ceu_org->ret, 7,8 };
    tceu_evt evt_;
             evt_.id = CEU_IN__ok_killed;
             evt_.param = &ps;
    ceu_sys_go_ex(_ceu_app, &evt_, _ceu_stk,
                  _ceu_app->data, 0, _ceu_app->data->n);
}
#endif

#line 1012 "garden.ceu"
    if (0) {

#line 1012 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 1012 "garden.ceu"
    }
#line 1012 "garden.ceu"
/* CLEAR: Block (1012) */
#line 1012 "garden.ceu"
    if (0) {

#line 1012 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
} else {
/* NODE: If 7748 */

#line 1018 "garden.ceu"
    if ((((((CEU_Main*)_ceu_org)->x_13)>((215+(1*135))-50))&&((((CEU_Main*)_ceu_org)->x_13)<((215+(1*135))+50)))) {
/* NODE: Block 3419 */

#line 1019 "garden.ceu"
    {/* NODE: Stmts 3418 */

#line 1019 "garden.ceu"
    {/* NODE: Do 7794 */
/* NODE: Block 7793 */

#line 1019 "garden.ceu"
    {
#line 1019 "garden.ceu"
    #ifdef CEU_ORGS
_ceu_org->trls[ 7 ].evt = CEU_IN__ORG;
_ceu_org->trls[ 7 ].org = NULL;
#endif

#line 1019 "garden.ceu"
    _ceu_trl = &_ceu_org->trls[ 8 ];
/* NODE: Stmts 7792 */

#line 1019 "garden.ceu"
    {/* NODE: Dcl_var 7791 */

#line 1019 "garden.ceu"
/* start org: _org_3417 */
#line 1019 "garden.ceu"
        /* resets org memory and starts org.trail[0]=Class_XXX */
    /* TODO: BUG: _ceu_org is not necessarily the parent for pool allocations */
    ceu_out_org_init(_ceu_app, ((tceu_org*) &(((CEU_Main*)_ceu_org)->_org_3417_16)),5,Class_WateringCan,
                     12,
                     0,
                     _ceu_org,7);
/* TODO: currently idx is always "1" for all interfaces access because pools 
 * are all together there. When we have separate trls for pools, we'll have to 
 * indirectly access the offset in the interface. */

#line 1019 "garden.ceu"
        _ceu_constr_3416(_ceu_app, ((tceu_org*) &(((CEU_Main*)_ceu_org)->_org_3417_16)), _ceu_org);

#line 1019 "garden.ceu"
    {
#ifdef CEU_STACK_CLEAR
    tceu_stk stk_ = { _ceu_stk, _ceu_org, 8, 8, 1 };
    ceu_app_go(_ceu_app,NULL,
               ((tceu_org*) &(((CEU_Main*)_ceu_org)->_org_3417_16)), &((tceu_org*) &(((CEU_Main*)_ceu_org)->_org_3417_16))->trls[0],
               &stk_);
    if (!stk_.is_alive) {
        return;
    }
#else
    ceu_app_go(_ceu_app,NULL,
               ((tceu_org*) &(((CEU_Main*)_ceu_org)->_org_3417_16)), &((tceu_org*) &(((CEU_Main*)_ceu_org)->_org_3417_16))->trls[0],
               NULL);
#endif

#line 1019 "garden.ceu"
    }
/* NODE: Stmts 7825 */

#line 1019 "garden.ceu"
    {/* NODE: Nothing 7799 */
/* NODE: Nothing 8390 */
/* NODE: Nothing 8391 */
/* NODE: Stmts 7824 */

#line 1019 "garden.ceu"
    {/* NODE: If 7823 */

#line 1019 "garden.ceu"
    if ((!(((*((tceu_org*)(&((CEU_Main*)_ceu_org)->_org_3417_16))).isAlive)))) {
/* NODE: Block 7820 */

#line 1019 "garden.ceu"
    {/* NODE: Stmts 7819 */

#line 1019 "garden.ceu"
    {/* NODE: Nothing 7803 */

#line 1019 "garden.ceu"
    }
#line 1019 "garden.ceu"
/* CLEAR: Block (1019) */
#line 1019 "garden.ceu"
    if (0) {

#line 1019 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
} else {
/* NODE: Block 7822 */

#line 1019 "garden.ceu"
    {/* NODE: Stmts 7821 */

#line 1019 "garden.ceu"
    {/* NODE: Await 7802 */

#line 1019 "garden.ceu"
    _CEU_NO_7802_:
if (0) { goto _CEU_NO_7802_; /* avoids "not used" warning */ }

#line 1019 "garden.ceu"
    _ceu_trl->evt = CEU_IN__ok_killed;
_ceu_trl->lbl = Main_Awake__ok_killed_148;
_ceu_trl->seqno = _ceu_app->seqno;

#line 1019 "garden.ceu"
    #ifdef CEU_ORGS_AWAIT
#ifdef CEU_ADTS_AWAIT
_ceu_trl->is_org = 1;
#endif
#endif
_ceu_trl->org_or_adt = (void*)(&((CEU_Main*)_ceu_org)->_org_3417_16);

#line 1019 "garden.ceu"
    return;

case Main_Awake__ok_killed_148:;

#line 1019 "garden.ceu"
    #ifdef CEU_DEBUG_TRAILS
#ifndef CEU_OS
printf("\tOK!\n");
#endif
#endif

#line 1019 "garden.ceu"
    }
#line 1019 "garden.ceu"
/* CLEAR: Block (1019) */
#line 1019 "garden.ceu"
    if (0) {

#line 1019 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
}

#line 1019 "garden.ceu"
    }
#line 1019 "garden.ceu"
    }
#line 1019 "garden.ceu"
    }
#line 1019 "garden.ceu"
/* CLEAR: Block (1019) */
#line 1019 "garden.ceu"
    {
    /* Reuse current stack frame.
     * We know that CLEAR will not abort anything and return normally.
     * Just save the previous "is_alive", call CLEAR, and restore it.
     */
#ifdef CEU_STACK_CLEAR
    int __ceu_old = _ceu_stk->is_alive;
    _ceu_stk->is_alive = 1;
#endif
    tceu_evt evt;
             evt.id = CEU_IN__CLEAR;
    ceu_sys_go_ex(_ceu_app, &evt,
                  _ceu_stk,
                  _ceu_org,
                  7,
                  9);
#ifdef CEU_STACK_CLEAR
    _ceu_stk->is_alive = __ceu_old;
    ceu_sys_stack_clear(_ceu_stk, _ceu_org,
                        7,8);
#endif
}

#line 1019 "garden.ceu"
    #ifdef CEU_ORGS_AWAIT
/* signal ok_killed */
{
    tceu_kill ps = { _ceu_org, _ceu_org->ret, 7,8 };
    tceu_evt evt_;
             evt_.id = CEU_IN__ok_killed;
             evt_.param = &ps;
    ceu_sys_go_ex(_ceu_app, &evt_, _ceu_stk,
                  _ceu_app->data, 0, _ceu_app->data->n);
}
#endif

#line 1019 "garden.ceu"
    if (0) {

#line 1019 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 1019 "garden.ceu"
    }
#line 1019 "garden.ceu"
/* CLEAR: Block (1019) */
#line 1019 "garden.ceu"
    if (0) {

#line 1019 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
} else {
/* NODE: If 7747 */

#line 1025 "garden.ceu"
    if ((((((CEU_Main*)_ceu_org)->x_13)>((215+(2*135))-50))&&((((CEU_Main*)_ceu_org)->x_13)<((215+(2*135))+50)))) {
/* NODE: Block 3466 */

#line 1026 "garden.ceu"
    {/* NODE: Stmts 3465 */

#line 1026 "garden.ceu"
    {/* NODE: Do 7832 */
/* NODE: Block 7831 */

#line 1026 "garden.ceu"
    {
#line 1026 "garden.ceu"
    #ifdef CEU_ORGS
_ceu_org->trls[ 7 ].evt = CEU_IN__ORG;
_ceu_org->trls[ 7 ].org = NULL;
#endif

#line 1026 "garden.ceu"
    _ceu_trl = &_ceu_org->trls[ 8 ];
/* NODE: Stmts 7830 */

#line 1026 "garden.ceu"
    {/* NODE: Dcl_var 7829 */

#line 1026 "garden.ceu"
/* start org: _org_3464 */
#line 1026 "garden.ceu"
        /* resets org memory and starts org.trail[0]=Class_XXX */
    /* TODO: BUG: _ceu_org is not necessarily the parent for pool allocations */
    ceu_out_org_init(_ceu_app, ((tceu_org*) &(((CEU_Main*)_ceu_org)->_org_3464_17)),5,Class_Bag,
                     10,
                     0,
                     _ceu_org,7);
/* TODO: currently idx is always "1" for all interfaces access because pools 
 * are all together there. When we have separate trls for pools, we'll have to 
 * indirectly access the offset in the interface. */

#line 1026 "garden.ceu"
        _ceu_constr_3463(_ceu_app, ((tceu_org*) &(((CEU_Main*)_ceu_org)->_org_3464_17)), _ceu_org);

#line 1026 "garden.ceu"
    {
#ifdef CEU_STACK_CLEAR
    tceu_stk stk_ = { _ceu_stk, _ceu_org, 8, 8, 1 };
    ceu_app_go(_ceu_app,NULL,
               ((tceu_org*) &(((CEU_Main*)_ceu_org)->_org_3464_17)), &((tceu_org*) &(((CEU_Main*)_ceu_org)->_org_3464_17))->trls[0],
               &stk_);
    if (!stk_.is_alive) {
        return;
    }
#else
    ceu_app_go(_ceu_app,NULL,
               ((tceu_org*) &(((CEU_Main*)_ceu_org)->_org_3464_17)), &((tceu_org*) &(((CEU_Main*)_ceu_org)->_org_3464_17))->trls[0],
               NULL);
#endif

#line 1026 "garden.ceu"
    }
/* NODE: Stmts 7864 */

#line 1026 "garden.ceu"
    {/* NODE: Nothing 7838 */
/* NODE: Nothing 8397 */
/* NODE: Nothing 8398 */
/* NODE: Stmts 7863 */

#line 1026 "garden.ceu"
    {/* NODE: If 7862 */

#line 1026 "garden.ceu"
    if ((!(((*((tceu_org*)(&((CEU_Main*)_ceu_org)->_org_3464_17))).isAlive)))) {
/* NODE: Block 7859 */

#line 1026 "garden.ceu"
    {/* NODE: Stmts 7858 */

#line 1026 "garden.ceu"
    {/* NODE: Nothing 7842 */

#line 1026 "garden.ceu"
    }
#line 1026 "garden.ceu"
/* CLEAR: Block (1026) */
#line 1026 "garden.ceu"
    if (0) {

#line 1026 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
} else {
/* NODE: Block 7861 */

#line 1026 "garden.ceu"
    {/* NODE: Stmts 7860 */

#line 1026 "garden.ceu"
    {/* NODE: Await 7841 */

#line 1026 "garden.ceu"
    _CEU_NO_7841_:
if (0) { goto _CEU_NO_7841_; /* avoids "not used" warning */ }

#line 1026 "garden.ceu"
    _ceu_trl->evt = CEU_IN__ok_killed;
_ceu_trl->lbl = Main_Awake__ok_killed_149;
_ceu_trl->seqno = _ceu_app->seqno;

#line 1026 "garden.ceu"
    #ifdef CEU_ORGS_AWAIT
#ifdef CEU_ADTS_AWAIT
_ceu_trl->is_org = 1;
#endif
#endif
_ceu_trl->org_or_adt = (void*)(&((CEU_Main*)_ceu_org)->_org_3464_17);

#line 1026 "garden.ceu"
    return;

case Main_Awake__ok_killed_149:;

#line 1026 "garden.ceu"
    #ifdef CEU_DEBUG_TRAILS
#ifndef CEU_OS
printf("\tOK!\n");
#endif
#endif

#line 1026 "garden.ceu"
    }
#line 1026 "garden.ceu"
/* CLEAR: Block (1026) */
#line 1026 "garden.ceu"
    if (0) {

#line 1026 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
}

#line 1026 "garden.ceu"
    }
#line 1026 "garden.ceu"
    }
#line 1026 "garden.ceu"
    }
#line 1026 "garden.ceu"
/* CLEAR: Block (1026) */
#line 1026 "garden.ceu"
    {
    /* Reuse current stack frame.
     * We know that CLEAR will not abort anything and return normally.
     * Just save the previous "is_alive", call CLEAR, and restore it.
     */
#ifdef CEU_STACK_CLEAR
    int __ceu_old = _ceu_stk->is_alive;
    _ceu_stk->is_alive = 1;
#endif
    tceu_evt evt;
             evt.id = CEU_IN__CLEAR;
    ceu_sys_go_ex(_ceu_app, &evt,
                  _ceu_stk,
                  _ceu_org,
                  7,
                  9);
#ifdef CEU_STACK_CLEAR
    _ceu_stk->is_alive = __ceu_old;
    ceu_sys_stack_clear(_ceu_stk, _ceu_org,
                        7,8);
#endif
}

#line 1026 "garden.ceu"
    #ifdef CEU_ORGS_AWAIT
/* signal ok_killed */
{
    tceu_kill ps = { _ceu_org, _ceu_org->ret, 7,8 };
    tceu_evt evt_;
             evt_.id = CEU_IN__ok_killed;
             evt_.param = &ps;
    ceu_sys_go_ex(_ceu_app, &evt_, _ceu_stk,
                  _ceu_app->data, 0, _ceu_app->data->n);
}
#endif

#line 1026 "garden.ceu"
    if (0) {

#line 1026 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 1026 "garden.ceu"
    }
#line 1026 "garden.ceu"
/* CLEAR: Block (1026) */
#line 1026 "garden.ceu"
    if (0) {

#line 1026 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
} else {
/* NODE: If 7746 */

#line 1033 "garden.ceu"
    if ((((((CEU_Main*)_ceu_org)->x_13)>((215+(3*135))-50))&&((((CEU_Main*)_ceu_org)->x_13)<((215+(3*135))+50)))) {
/* NODE: Block 3521 */

#line 1034 "garden.ceu"
    {/* NODE: Stmts 3520 */

#line 1034 "garden.ceu"
    {/* NODE: If 7866 */

#line 1034 "garden.ceu"
    if ((seeds[1]>0)) {
/* NODE: Block 3518 */

#line 1035 "garden.ceu"
    {/* NODE: Stmts 3517 */

#line 1035 "garden.ceu"
    {/* NODE: Do 7873 */
/* NODE: Block 7872 */

#line 1035 "garden.ceu"
    {
#line 1035 "garden.ceu"
    #ifdef CEU_ORGS
_ceu_org->trls[ 7 ].evt = CEU_IN__ORG;
_ceu_org->trls[ 7 ].org = NULL;
#endif

#line 1035 "garden.ceu"
    _ceu_trl = &_ceu_org->trls[ 8 ];
/* NODE: Stmts 7871 */

#line 1035 "garden.ceu"
    {/* NODE: Dcl_var 7870 */

#line 1035 "garden.ceu"
/* start org: _org_3516 */
#line 1035 "garden.ceu"
        /* resets org memory and starts org.trail[0]=Class_XXX */
    /* TODO: BUG: _ceu_org is not necessarily the parent for pool allocations */
    ceu_out_org_init(_ceu_app, ((tceu_org*) &(((CEU_Main*)_ceu_org)->_org_3516_18)),5,Class_Bag,
                     10,
                     0,
                     _ceu_org,7);
/* TODO: currently idx is always "1" for all interfaces access because pools 
 * are all together there. When we have separate trls for pools, we'll have to 
 * indirectly access the offset in the interface. */

#line 1035 "garden.ceu"
        _ceu_constr_3515(_ceu_app, ((tceu_org*) &(((CEU_Main*)_ceu_org)->_org_3516_18)), _ceu_org);

#line 1035 "garden.ceu"
    {
#ifdef CEU_STACK_CLEAR
    tceu_stk stk_ = { _ceu_stk, _ceu_org, 8, 8, 1 };
    ceu_app_go(_ceu_app,NULL,
               ((tceu_org*) &(((CEU_Main*)_ceu_org)->_org_3516_18)), &((tceu_org*) &(((CEU_Main*)_ceu_org)->_org_3516_18))->trls[0],
               &stk_);
    if (!stk_.is_alive) {
        return;
    }
#else
    ceu_app_go(_ceu_app,NULL,
               ((tceu_org*) &(((CEU_Main*)_ceu_org)->_org_3516_18)), &((tceu_org*) &(((CEU_Main*)_ceu_org)->_org_3516_18))->trls[0],
               NULL);
#endif

#line 1035 "garden.ceu"
    }
/* NODE: Stmts 7905 */

#line 1035 "garden.ceu"
    {/* NODE: Nothing 7879 */
/* NODE: Nothing 8404 */
/* NODE: Nothing 8405 */
/* NODE: Stmts 7904 */

#line 1035 "garden.ceu"
    {/* NODE: If 7903 */

#line 1035 "garden.ceu"
    if ((!(((*((tceu_org*)(&((CEU_Main*)_ceu_org)->_org_3516_18))).isAlive)))) {
/* NODE: Block 7900 */

#line 1035 "garden.ceu"
    {/* NODE: Stmts 7899 */

#line 1035 "garden.ceu"
    {/* NODE: Nothing 7883 */

#line 1035 "garden.ceu"
    }
#line 1035 "garden.ceu"
/* CLEAR: Block (1035) */
#line 1035 "garden.ceu"
    if (0) {

#line 1035 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
} else {
/* NODE: Block 7902 */

#line 1035 "garden.ceu"
    {/* NODE: Stmts 7901 */

#line 1035 "garden.ceu"
    {/* NODE: Await 7882 */

#line 1035 "garden.ceu"
    _CEU_NO_7882_:
if (0) { goto _CEU_NO_7882_; /* avoids "not used" warning */ }

#line 1035 "garden.ceu"
    _ceu_trl->evt = CEU_IN__ok_killed;
_ceu_trl->lbl = Main_Awake__ok_killed_150;
_ceu_trl->seqno = _ceu_app->seqno;

#line 1035 "garden.ceu"
    #ifdef CEU_ORGS_AWAIT
#ifdef CEU_ADTS_AWAIT
_ceu_trl->is_org = 1;
#endif
#endif
_ceu_trl->org_or_adt = (void*)(&((CEU_Main*)_ceu_org)->_org_3516_18);

#line 1035 "garden.ceu"
    return;

case Main_Awake__ok_killed_150:;

#line 1035 "garden.ceu"
    #ifdef CEU_DEBUG_TRAILS
#ifndef CEU_OS
printf("\tOK!\n");
#endif
#endif

#line 1035 "garden.ceu"
    }
#line 1035 "garden.ceu"
/* CLEAR: Block (1035) */
#line 1035 "garden.ceu"
    if (0) {

#line 1035 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
}

#line 1035 "garden.ceu"
    }
#line 1035 "garden.ceu"
    }
#line 1035 "garden.ceu"
    }
#line 1035 "garden.ceu"
/* CLEAR: Block (1035) */
#line 1035 "garden.ceu"
    {
    /* Reuse current stack frame.
     * We know that CLEAR will not abort anything and return normally.
     * Just save the previous "is_alive", call CLEAR, and restore it.
     */
#ifdef CEU_STACK_CLEAR
    int __ceu_old = _ceu_stk->is_alive;
    _ceu_stk->is_alive = 1;
#endif
    tceu_evt evt;
             evt.id = CEU_IN__CLEAR;
    ceu_sys_go_ex(_ceu_app, &evt,
                  _ceu_stk,
                  _ceu_org,
                  7,
                  9);
#ifdef CEU_STACK_CLEAR
    _ceu_stk->is_alive = __ceu_old;
    ceu_sys_stack_clear(_ceu_stk, _ceu_org,
                        7,8);
#endif
}

#line 1035 "garden.ceu"
    #ifdef CEU_ORGS_AWAIT
/* signal ok_killed */
{
    tceu_kill ps = { _ceu_org, _ceu_org->ret, 7,8 };
    tceu_evt evt_;
             evt_.id = CEU_IN__ok_killed;
             evt_.param = &ps;
    ceu_sys_go_ex(_ceu_app, &evt_, _ceu_stk,
                  _ceu_app->data, 0, _ceu_app->data->n);
}
#endif

#line 1035 "garden.ceu"
    if (0) {

#line 1035 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 1035 "garden.ceu"
    }
#line 1035 "garden.ceu"
/* CLEAR: Block (1035) */
#line 1035 "garden.ceu"
    if (0) {

#line 1035 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
} else {
/* NODE: Nothing 7865 */
}

#line 1034 "garden.ceu"
    }
#line 1034 "garden.ceu"
/* CLEAR: Block (1034) */
#line 1034 "garden.ceu"
    if (0) {

#line 1034 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
} else {
/* NODE: If 7745 */

#line 1043 "garden.ceu"
    if ((((((CEU_Main*)_ceu_org)->x_13)>((215+(4*135))-50))&&((((CEU_Main*)_ceu_org)->x_13)<((215+(4*135))+50)))) {
/* NODE: Block 3576 */

#line 1044 "garden.ceu"
    {/* NODE: Stmts 3575 */

#line 1044 "garden.ceu"
    {/* NODE: If 7907 */

#line 1044 "garden.ceu"
    if ((seeds[2]>0)) {
/* NODE: Block 3573 */

#line 1045 "garden.ceu"
    {/* NODE: Stmts 3572 */

#line 1045 "garden.ceu"
    {/* NODE: Do 7914 */
/* NODE: Block 7913 */

#line 1045 "garden.ceu"
    {
#line 1045 "garden.ceu"
    #ifdef CEU_ORGS
_ceu_org->trls[ 7 ].evt = CEU_IN__ORG;
_ceu_org->trls[ 7 ].org = NULL;
#endif

#line 1045 "garden.ceu"
    _ceu_trl = &_ceu_org->trls[ 8 ];
/* NODE: Stmts 7912 */

#line 1045 "garden.ceu"
    {/* NODE: Dcl_var 7911 */

#line 1045 "garden.ceu"
/* start org: _org_3571 */
#line 1045 "garden.ceu"
        /* resets org memory and starts org.trail[0]=Class_XXX */
    /* TODO: BUG: _ceu_org is not necessarily the parent for pool allocations */
    ceu_out_org_init(_ceu_app, ((tceu_org*) &(((CEU_Main*)_ceu_org)->_org_3571_19)),5,Class_Bag,
                     10,
                     0,
                     _ceu_org,7);
/* TODO: currently idx is always "1" for all interfaces access because pools 
 * are all together there. When we have separate trls for pools, we'll have to 
 * indirectly access the offset in the interface. */

#line 1045 "garden.ceu"
        _ceu_constr_3570(_ceu_app, ((tceu_org*) &(((CEU_Main*)_ceu_org)->_org_3571_19)), _ceu_org);

#line 1045 "garden.ceu"
    {
#ifdef CEU_STACK_CLEAR
    tceu_stk stk_ = { _ceu_stk, _ceu_org, 8, 8, 1 };
    ceu_app_go(_ceu_app,NULL,
               ((tceu_org*) &(((CEU_Main*)_ceu_org)->_org_3571_19)), &((tceu_org*) &(((CEU_Main*)_ceu_org)->_org_3571_19))->trls[0],
               &stk_);
    if (!stk_.is_alive) {
        return;
    }
#else
    ceu_app_go(_ceu_app,NULL,
               ((tceu_org*) &(((CEU_Main*)_ceu_org)->_org_3571_19)), &((tceu_org*) &(((CEU_Main*)_ceu_org)->_org_3571_19))->trls[0],
               NULL);
#endif

#line 1045 "garden.ceu"
    }
/* NODE: Stmts 7946 */

#line 1045 "garden.ceu"
    {/* NODE: Nothing 7920 */
/* NODE: Nothing 8411 */
/* NODE: Nothing 8412 */
/* NODE: Stmts 7945 */

#line 1045 "garden.ceu"
    {/* NODE: If 7944 */

#line 1045 "garden.ceu"
    if ((!(((*((tceu_org*)(&((CEU_Main*)_ceu_org)->_org_3571_19))).isAlive)))) {
/* NODE: Block 7941 */

#line 1045 "garden.ceu"
    {/* NODE: Stmts 7940 */

#line 1045 "garden.ceu"
    {/* NODE: Nothing 7924 */

#line 1045 "garden.ceu"
    }
#line 1045 "garden.ceu"
/* CLEAR: Block (1045) */
#line 1045 "garden.ceu"
    if (0) {

#line 1045 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
} else {
/* NODE: Block 7943 */

#line 1045 "garden.ceu"
    {/* NODE: Stmts 7942 */

#line 1045 "garden.ceu"
    {/* NODE: Await 7923 */

#line 1045 "garden.ceu"
    _CEU_NO_7923_:
if (0) { goto _CEU_NO_7923_; /* avoids "not used" warning */ }

#line 1045 "garden.ceu"
    _ceu_trl->evt = CEU_IN__ok_killed;
_ceu_trl->lbl = Main_Awake__ok_killed_151;
_ceu_trl->seqno = _ceu_app->seqno;

#line 1045 "garden.ceu"
    #ifdef CEU_ORGS_AWAIT
#ifdef CEU_ADTS_AWAIT
_ceu_trl->is_org = 1;
#endif
#endif
_ceu_trl->org_or_adt = (void*)(&((CEU_Main*)_ceu_org)->_org_3571_19);

#line 1045 "garden.ceu"
    return;

case Main_Awake__ok_killed_151:;

#line 1045 "garden.ceu"
    #ifdef CEU_DEBUG_TRAILS
#ifndef CEU_OS
printf("\tOK!\n");
#endif
#endif

#line 1045 "garden.ceu"
    }
#line 1045 "garden.ceu"
/* CLEAR: Block (1045) */
#line 1045 "garden.ceu"
    if (0) {

#line 1045 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
}

#line 1045 "garden.ceu"
    }
#line 1045 "garden.ceu"
    }
#line 1045 "garden.ceu"
    }
#line 1045 "garden.ceu"
/* CLEAR: Block (1045) */
#line 1045 "garden.ceu"
    {
    /* Reuse current stack frame.
     * We know that CLEAR will not abort anything and return normally.
     * Just save the previous "is_alive", call CLEAR, and restore it.
     */
#ifdef CEU_STACK_CLEAR
    int __ceu_old = _ceu_stk->is_alive;
    _ceu_stk->is_alive = 1;
#endif
    tceu_evt evt;
             evt.id = CEU_IN__CLEAR;
    ceu_sys_go_ex(_ceu_app, &evt,
                  _ceu_stk,
                  _ceu_org,
                  7,
                  9);
#ifdef CEU_STACK_CLEAR
    _ceu_stk->is_alive = __ceu_old;
    ceu_sys_stack_clear(_ceu_stk, _ceu_org,
                        7,8);
#endif
}

#line 1045 "garden.ceu"
    #ifdef CEU_ORGS_AWAIT
/* signal ok_killed */
{
    tceu_kill ps = { _ceu_org, _ceu_org->ret, 7,8 };
    tceu_evt evt_;
             evt_.id = CEU_IN__ok_killed;
             evt_.param = &ps;
    ceu_sys_go_ex(_ceu_app, &evt_, _ceu_stk,
                  _ceu_app->data, 0, _ceu_app->data->n);
}
#endif

#line 1045 "garden.ceu"
    if (0) {

#line 1045 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 1045 "garden.ceu"
    }
#line 1045 "garden.ceu"
/* CLEAR: Block (1045) */
#line 1045 "garden.ceu"
    if (0) {

#line 1045 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
} else {
/* NODE: Nothing 7906 */
}

#line 1044 "garden.ceu"
    }
#line 1044 "garden.ceu"
/* CLEAR: Block (1044) */
#line 1044 "garden.ceu"
    if (0) {

#line 1044 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
} else {
/* NODE: If 7744 */

#line 1053 "garden.ceu"
    if ((((((CEU_Main*)_ceu_org)->x_13)>((215+(5*135))-50))&&((((CEU_Main*)_ceu_org)->x_13)<((215+(5*135))+50)))) {
/* NODE: Block 3631 */

#line 1054 "garden.ceu"
    {/* NODE: Stmts 3630 */

#line 1054 "garden.ceu"
    {/* NODE: If 7948 */

#line 1054 "garden.ceu"
    if ((seeds[3]>0)) {
/* NODE: Block 3628 */

#line 1055 "garden.ceu"
    {/* NODE: Stmts 3627 */

#line 1055 "garden.ceu"
    {/* NODE: Do 7955 */
/* NODE: Block 7954 */

#line 1055 "garden.ceu"
    {
#line 1055 "garden.ceu"
    #ifdef CEU_ORGS
_ceu_org->trls[ 7 ].evt = CEU_IN__ORG;
_ceu_org->trls[ 7 ].org = NULL;
#endif

#line 1055 "garden.ceu"
    _ceu_trl = &_ceu_org->trls[ 8 ];
/* NODE: Stmts 7953 */

#line 1055 "garden.ceu"
    {/* NODE: Dcl_var 7952 */

#line 1055 "garden.ceu"
/* start org: _org_3626 */
#line 1055 "garden.ceu"
        /* resets org memory and starts org.trail[0]=Class_XXX */
    /* TODO: BUG: _ceu_org is not necessarily the parent for pool allocations */
    ceu_out_org_init(_ceu_app, ((tceu_org*) &(((CEU_Main*)_ceu_org)->_org_3626_20)),5,Class_Bag,
                     10,
                     0,
                     _ceu_org,7);
/* TODO: currently idx is always "1" for all interfaces access because pools 
 * are all together there. When we have separate trls for pools, we'll have to 
 * indirectly access the offset in the interface. */

#line 1055 "garden.ceu"
        _ceu_constr_3625(_ceu_app, ((tceu_org*) &(((CEU_Main*)_ceu_org)->_org_3626_20)), _ceu_org);

#line 1055 "garden.ceu"
    {
#ifdef CEU_STACK_CLEAR
    tceu_stk stk_ = { _ceu_stk, _ceu_org, 8, 8, 1 };
    ceu_app_go(_ceu_app,NULL,
               ((tceu_org*) &(((CEU_Main*)_ceu_org)->_org_3626_20)), &((tceu_org*) &(((CEU_Main*)_ceu_org)->_org_3626_20))->trls[0],
               &stk_);
    if (!stk_.is_alive) {
        return;
    }
#else
    ceu_app_go(_ceu_app,NULL,
               ((tceu_org*) &(((CEU_Main*)_ceu_org)->_org_3626_20)), &((tceu_org*) &(((CEU_Main*)_ceu_org)->_org_3626_20))->trls[0],
               NULL);
#endif

#line 1055 "garden.ceu"
    }
/* NODE: Stmts 7987 */

#line 1055 "garden.ceu"
    {/* NODE: Nothing 7961 */
/* NODE: Nothing 8418 */
/* NODE: Nothing 8419 */
/* NODE: Stmts 7986 */

#line 1055 "garden.ceu"
    {/* NODE: If 7985 */

#line 1055 "garden.ceu"
    if ((!(((*((tceu_org*)(&((CEU_Main*)_ceu_org)->_org_3626_20))).isAlive)))) {
/* NODE: Block 7982 */

#line 1055 "garden.ceu"
    {/* NODE: Stmts 7981 */

#line 1055 "garden.ceu"
    {/* NODE: Nothing 7965 */

#line 1055 "garden.ceu"
    }
#line 1055 "garden.ceu"
/* CLEAR: Block (1055) */
#line 1055 "garden.ceu"
    if (0) {

#line 1055 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
} else {
/* NODE: Block 7984 */

#line 1055 "garden.ceu"
    {/* NODE: Stmts 7983 */

#line 1055 "garden.ceu"
    {/* NODE: Await 7964 */

#line 1055 "garden.ceu"
    _CEU_NO_7964_:
if (0) { goto _CEU_NO_7964_; /* avoids "not used" warning */ }

#line 1055 "garden.ceu"
    _ceu_trl->evt = CEU_IN__ok_killed;
_ceu_trl->lbl = Main_Awake__ok_killed_152;
_ceu_trl->seqno = _ceu_app->seqno;

#line 1055 "garden.ceu"
    #ifdef CEU_ORGS_AWAIT
#ifdef CEU_ADTS_AWAIT
_ceu_trl->is_org = 1;
#endif
#endif
_ceu_trl->org_or_adt = (void*)(&((CEU_Main*)_ceu_org)->_org_3626_20);

#line 1055 "garden.ceu"
    return;

case Main_Awake__ok_killed_152:;

#line 1055 "garden.ceu"
    #ifdef CEU_DEBUG_TRAILS
#ifndef CEU_OS
printf("\tOK!\n");
#endif
#endif

#line 1055 "garden.ceu"
    }
#line 1055 "garden.ceu"
/* CLEAR: Block (1055) */
#line 1055 "garden.ceu"
    if (0) {

#line 1055 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
}

#line 1055 "garden.ceu"
    }
#line 1055 "garden.ceu"
    }
#line 1055 "garden.ceu"
    }
#line 1055 "garden.ceu"
/* CLEAR: Block (1055) */
#line 1055 "garden.ceu"
    {
    /* Reuse current stack frame.
     * We know that CLEAR will not abort anything and return normally.
     * Just save the previous "is_alive", call CLEAR, and restore it.
     */
#ifdef CEU_STACK_CLEAR
    int __ceu_old = _ceu_stk->is_alive;
    _ceu_stk->is_alive = 1;
#endif
    tceu_evt evt;
             evt.id = CEU_IN__CLEAR;
    ceu_sys_go_ex(_ceu_app, &evt,
                  _ceu_stk,
                  _ceu_org,
                  7,
                  9);
#ifdef CEU_STACK_CLEAR
    _ceu_stk->is_alive = __ceu_old;
    ceu_sys_stack_clear(_ceu_stk, _ceu_org,
                        7,8);
#endif
}

#line 1055 "garden.ceu"
    #ifdef CEU_ORGS_AWAIT
/* signal ok_killed */
{
    tceu_kill ps = { _ceu_org, _ceu_org->ret, 7,8 };
    tceu_evt evt_;
             evt_.id = CEU_IN__ok_killed;
             evt_.param = &ps;
    ceu_sys_go_ex(_ceu_app, &evt_, _ceu_stk,
                  _ceu_app->data, 0, _ceu_app->data->n);
}
#endif

#line 1055 "garden.ceu"
    if (0) {

#line 1055 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 1055 "garden.ceu"
    }
#line 1055 "garden.ceu"
/* CLEAR: Block (1055) */
#line 1055 "garden.ceu"
    if (0) {

#line 1055 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
} else {
/* NODE: Nothing 7947 */
}

#line 1054 "garden.ceu"
    }
#line 1054 "garden.ceu"
/* CLEAR: Block (1054) */
#line 1054 "garden.ceu"
    if (0) {

#line 1054 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
} else {
/* NODE: Nothing 7743 */
}
}
}
}
}
}

#line 1011 "garden.ceu"
    }
#line 1011 "garden.ceu"
/* CLEAR: Block (1011) */
#line 1011 "garden.ceu"
    if (0) {

#line 1011 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
} else {
/* NODE: Nothing 7741 */
}

#line 1008 "garden.ceu"
    }
#line 1008 "garden.ceu"
/* CLEAR: Block (1008) */
#line 1008 "garden.ceu"
    if (0) {

#line 1008 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 1005 "garden.ceu"
/* PAROR JOIN */
#line 1005 "garden.ceu"
    _ceu_lbl = Main_ParOr_out_144;
goto _CEU_GOTO_;

#line 1005 "garden.ceu"
case Main_ParOr_sub_1_143:;/* NODE: Block 3322 */

#line 1006 "garden.ceu"
    {/* NODE: Stmts 3321 */

#line 1006 "garden.ceu"
    {/* NODE: Stmts 7691 */

#line 1006 "garden.ceu"
    {/* NODE: Nothing 7665 */
/* NODE: Await 3320 */

#line 1006 "garden.ceu"
    _CEU_NO_3320_:
if (0) { goto _CEU_NO_3320_; /* avoids "not used" warning */ }

#line 1006 "garden.ceu"
    _ceu_trl->evt = CEU_IN_MOUSE_OUT;
_ceu_trl->lbl = Main_Awake_MOUSE_OUT_145;
_ceu_trl->seqno = _ceu_app->seqno;

#line 1006 "garden.ceu"
    return;

case Main_Awake_MOUSE_OUT_145:;

#line 1006 "garden.ceu"
    #ifdef CEU_DEBUG_TRAILS
#ifndef CEU_OS
printf("\tOK!\n");
#endif
#endif
/* NODE: Nothing 8376 */
/* NODE: Nothing 8377 */

#line 1006 "garden.ceu"
    }
#line 1006 "garden.ceu"
    }
#line 1006 "garden.ceu"
/* CLEAR: Block (1006) */
#line 1006 "garden.ceu"
    if (0) {

#line 1006 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 1005 "garden.ceu"
/* PAROR JOIN */
#line 1005 "garden.ceu"
    _ceu_lbl = Main_ParOr_out_144;
goto _CEU_GOTO_;

#line 1005 "garden.ceu"
case Main_ParOr_out_144:;
#line 1005 "garden.ceu"
/* CLEAR: ParOr (1005) */
#line 1005 "garden.ceu"
    {
    /* Reuse current stack frame.
     * We know that CLEAR will not abort anything and return normally.
     * Just save the previous "is_alive", call CLEAR, and restore it.
     */
#ifdef CEU_STACK_CLEAR
    int __ceu_old = _ceu_stk->is_alive;
    _ceu_stk->is_alive = 1;
#endif
    tceu_evt evt;
             evt.id = CEU_IN__CLEAR;
    ceu_sys_go_ex(_ceu_app, &evt,
                  _ceu_stk,
                  _ceu_org,
                  6,
                  9);
#ifdef CEU_STACK_CLEAR
    _ceu_stk->is_alive = __ceu_old;
    ceu_sys_stack_clear(_ceu_stk, _ceu_org,
                        6,8);
#endif
}

#line 1005 "garden.ceu"
    #ifdef CEU_ORGS_AWAIT
/* signal ok_killed */
{
    tceu_kill ps = { _ceu_org, _ceu_org->ret, 6,8 };
    tceu_evt evt_;
             evt_.id = CEU_IN__ok_killed;
             evt_.param = &ps;
    ceu_sys_go_ex(_ceu_app, &evt_, _ceu_stk,
                  _ceu_app->data, 0, _ceu_app->data->n);
}
#endif

#line 1004 "garden.ceu"
    }
#line 1004 "garden.ceu"
/* CLEAR: Block (1004) */
#line 1004 "garden.ceu"
    if (0) {

#line 1004 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 1003 "garden.ceu"
    }

#line 1003 "garden.ceu"
    }
#line 1003 "garden.ceu"
/* CLEAR: Block (1003) */
#line 1003 "garden.ceu"
    if (0) {

#line 1003 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 1003 "garden.ceu"
    }
#line 1003 "garden.ceu"
/* CLEAR: Block (1003) */
#line 1003 "garden.ceu"
    if (0) {

#line 1003 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 941 "garden.ceu"
case Main_ParEver_sub_2_135:;/* NODE: Block 3313 */

#line 963 "garden.ceu"
    {/* NODE: Stmts 3312 */

#line 963 "garden.ceu"
    {/* NODE: Block 7583 */

#line 963 "garden.ceu"
    {/* NODE: Stmts 7582 */

#line 963 "garden.ceu"
    {/* NODE: Stmts 7581 */

#line 963 "garden.ceu"
    {
#line 963 "garden.ceu"
    }/* NODE: Loop 7580 */

#line 963 "garden.ceu"
    for (;;) {
/* NODE: Block 3310 */

#line 964 "garden.ceu"
    {/* NODE: Stmts 3309 */

#line 964 "garden.ceu"
    {/* NODE: Stmts 7588 */

#line 964 "garden.ceu"
    {/* NODE: Dcl_var 7585 */
/* NODE: Dcl_var 7587 */

#line 964 "garden.ceu"
    }/* NODE: Stmts 7632 */

#line 965 "garden.ceu"
    {/* NODE: Nothing 7590 */
/* NODE: Set 7589 */

#line 965 "garden.ceu"
/* SET: table: 0xf77650 *//* NODE: Await 3133 */

#line 965 "garden.ceu"
    _CEU_NO_3133_:
if (0) { goto _CEU_NO_3133_; /* avoids "not used" warning */ }

#line 965 "garden.ceu"
    _ceu_trl->evt = 2;
_ceu_trl->lbl = Main_Awake_go_plant_142;
_ceu_trl->seqno = _ceu_app->seqno;

#line 965 "garden.ceu"
    #ifdef CEU_ORGS
_ceu_trl->evto  = (&((CEU_Main*)_ceu_org)->garden);
#endif

#line 965 "garden.ceu"
    return;

case Main_Awake_go_plant_142:;

#line 965 "garden.ceu"
    #ifdef CEU_DEBUG_TRAILS
#ifndef CEU_OS
printf("\tOK!\n");
#endif
#endif

#line 965 "garden.ceu"
    {

#line 965 "garden.ceu"
        tceu__int__int* __ceu_casted = (tceu__int__int*) _ceu_evt->param;

#line 965 "garden.ceu"
        (((CEU_Main*)_ceu_org)->seed_11) = ((__ceu_casted)->_1);
}

#line 965 "garden.ceu"
    {

#line 965 "garden.ceu"
        tceu__int__int* __ceu_casted = (tceu__int__int*) _ceu_evt->param;

#line 965 "garden.ceu"
        (((CEU_Main*)_ceu_org)->plot_12) = ((__ceu_casted)->_2);
}
/* NODE: Nothing 8362 */
/* NODE: Nothing 8363 */

#line 965 "garden.ceu"
    }/* NODE: If 3308 */

#line 966 "garden.ceu"
    if (plot_occupied[(((CEU_Main*)_ceu_org)->plot_12)]) {
/* NODE: Block 3146 */

#line 967 "garden.ceu"
    {/* NODE: Stmts 3145 */

#line 967 "garden.ceu"
    {/* NODE: CallStmt 3144 */

#line 967 "garden.ceu"
    printf("cannot plant %d in plot %d\n",(((CEU_Main*)_ceu_org)->seed_11),(((CEU_Main*)_ceu_org)->plot_12));
#line 967 "garden.ceu"
    }
#line 967 "garden.ceu"
/* CLEAR: Block (967) */
#line 967 "garden.ceu"
    if (0) {

#line 967 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
} else {
/* NODE: Block 3307 */

#line 969 "garden.ceu"
    {/* NODE: Stmts 3306 */

#line 969 "garden.ceu"
    {/* NODE: If 7641 */

#line 969 "garden.ceu"
    if (((((CEU_Main*)_ceu_org)->seed_11)==9)) {
/* NODE: Block 3169 */

#line 970 "garden.ceu"
    {/* NODE: Stmts 3168 */

#line 970 "garden.ceu"
    {/* NODE: Spawn 3167 */

#line 970 "garden.ceu"
    /*{*/
    tceu_org* __ceu_new_3167;

#line 970 "garden.ceu"
        __ceu_new_3167 = (tceu_org*) ceu_out_realloc(NULL, sizeof(CEU_Philodendron));

#line 970 "garden.ceu"
        if (__ceu_new_3167 != NULL) {

#line 970 "garden.ceu"
    #ifdef CEU_ORGS_NEWS_POOL
        __ceu_new_3167->pool = &(((CEU_Main*)_ceu_org)->_top_pool);
#endif

#line 970 "garden.ceu"
/* start org: dyn */
#line 970 "garden.ceu"
        /* resets org memory and starts org.trail[0]=Class_XXX */
    /* TODO: BUG: _ceu_org is not necessarily the parent for pool allocations */
    ceu_out_org_init(_ceu_app, ((tceu_org*) &(*((CEU_Philodendron*)__ceu_new_3167))),6,Class_Philodendron,
                     5,
                     1,
                     (((CEU_Main*)_ceu_org)->_top_pool).parent_org,(((CEU_Main*)_ceu_org)->_top_pool).parent_trl);
/* TODO: currently idx is always "1" for all interfaces access because pools 
 * are all together there. When we have separate trls for pools, we'll have to 
 * indirectly access the offset in the interface. */

#line 970 "garden.ceu"
        _ceu_constr_3166(_ceu_app, ((tceu_org*) &(*((CEU_Philodendron*)__ceu_new_3167))), _ceu_org);

#line 970 "garden.ceu"
    {
#ifdef CEU_STACK_CLEAR
    tceu_stk stk_ = { _ceu_stk, _ceu_org, 5, 5, 1 };
    ceu_app_go(_ceu_app,NULL,
               ((tceu_org*) &(*((CEU_Philodendron*)__ceu_new_3167))), &((tceu_org*) &(*((CEU_Philodendron*)__ceu_new_3167)))->trls[0],
               &stk_);
    if (!stk_.is_alive) {
        return;
    }
#else
    ceu_app_go(_ceu_app,NULL,
               ((tceu_org*) &(*((CEU_Philodendron*)__ceu_new_3167))), &((tceu_org*) &(*((CEU_Philodendron*)__ceu_new_3167)))->trls[0],
               NULL);
#endif

#line 970 "garden.ceu"
    }

#line 970 "garden.ceu"
        }
/*}*/

#line 970 "garden.ceu"
    }
#line 970 "garden.ceu"
/* CLEAR: Block (970) */
#line 970 "garden.ceu"
    if (0) {

#line 970 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
} else {
/* NODE: If 7640 */

#line 975 "garden.ceu"
    if ((((((CEU_Main*)_ceu_org)->seed_11)==12)&&(seeds[1]>0))) {
/* NODE: Block 3214 */

#line 976 "garden.ceu"
    {/* NODE: Stmts 3213 */

#line 976 "garden.ceu"
    {/* NODE: Spawn 3196 */

#line 976 "garden.ceu"
    /*{*/
    tceu_org* __ceu_new_3196;

#line 976 "garden.ceu"
        __ceu_new_3196 = (tceu_org*) ceu_out_realloc(NULL, sizeof(CEU_Pitcher));

#line 976 "garden.ceu"
        if (__ceu_new_3196 != NULL) {

#line 976 "garden.ceu"
    #ifdef CEU_ORGS_NEWS_POOL
        __ceu_new_3196->pool = &(((CEU_Main*)_ceu_org)->_top_pool);
#endif

#line 976 "garden.ceu"
/* start org: dyn */
#line 976 "garden.ceu"
        /* resets org memory and starts org.trail[0]=Class_XXX */
    /* TODO: BUG: _ceu_org is not necessarily the parent for pool allocations */
    ceu_out_org_init(_ceu_app, ((tceu_org*) &(*((CEU_Pitcher*)__ceu_new_3196))),6,Class_Pitcher,
                     6,
                     1,
                     (((CEU_Main*)_ceu_org)->_top_pool).parent_org,(((CEU_Main*)_ceu_org)->_top_pool).parent_trl);
/* TODO: currently idx is always "1" for all interfaces access because pools 
 * are all together there. When we have separate trls for pools, we'll have to 
 * indirectly access the offset in the interface. */

#line 976 "garden.ceu"
        _ceu_constr_3195(_ceu_app, ((tceu_org*) &(*((CEU_Pitcher*)__ceu_new_3196))), _ceu_org);

#line 976 "garden.ceu"
    {
#ifdef CEU_STACK_CLEAR
    tceu_stk stk_ = { _ceu_stk, _ceu_org, 5, 5, 1 };
    ceu_app_go(_ceu_app,NULL,
               ((tceu_org*) &(*((CEU_Pitcher*)__ceu_new_3196))), &((tceu_org*) &(*((CEU_Pitcher*)__ceu_new_3196)))->trls[0],
               &stk_);
    if (!stk_.is_alive) {
        return;
    }
#else
    ceu_app_go(_ceu_app,NULL,
               ((tceu_org*) &(*((CEU_Pitcher*)__ceu_new_3196))), &((tceu_org*) &(*((CEU_Pitcher*)__ceu_new_3196)))->trls[0],
               NULL);
#endif

#line 976 "garden.ceu"
    }

#line 976 "garden.ceu"
        }
/*}*/
/* NODE: Set 7650 */

#line 981 "garden.ceu"
/* SET: idx *//* NODE: Op2_- 3204 */

#line 981 "garden.ceu"
    seeds[1] = (seeds[1]-1);/* NODE: EmitExt 3212 */

#line 982 "garden.ceu"
        {

#line 982 "garden.ceu"
    tceu__int__int __ceu_ps_3212;
{
    tceu__int__int __ceu_ps_3212_ =
        { 1,seeds[1] };
    __ceu_ps_3212 = __ceu_ps_3212_;
}

#line 982 "garden.ceu"
    
#if defined(ceu_out_emit_SET_COUNT)
    ceu_out_emit_SET_COUNT((&__ceu_ps_3212))

#elif defined(ceu_out_emit)
    (ceu_out_emit(_ceu_app, CEU_OUT_SET_COUNT, sizeof(tceu__int__int), (void*)(&__ceu_ps_3212)))

#else
    #error ceu_out_emit_* is not defined
#endif
;
#line 982 "garden.ceu"
        }

#line 976 "garden.ceu"
    }
#line 976 "garden.ceu"
/* CLEAR: Block (976) */
#line 976 "garden.ceu"
    if (0) {

#line 976 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
} else {
/* NODE: If 7639 */

#line 983 "garden.ceu"
    if ((((((CEU_Main*)_ceu_org)->seed_11)==10)&&(seeds[2]>0))) {
/* NODE: Block 3259 */

#line 984 "garden.ceu"
    {/* NODE: Stmts 3258 */

#line 984 "garden.ceu"
    {/* NODE: Spawn 3241 */

#line 984 "garden.ceu"
    /*{*/
    tceu_org* __ceu_new_3241;

#line 984 "garden.ceu"
        __ceu_new_3241 = (tceu_org*) ceu_out_realloc(NULL, sizeof(CEU_Orchid));

#line 984 "garden.ceu"
        if (__ceu_new_3241 != NULL) {

#line 984 "garden.ceu"
    #ifdef CEU_ORGS_NEWS_POOL
        __ceu_new_3241->pool = &(((CEU_Main*)_ceu_org)->_top_pool);
#endif

#line 984 "garden.ceu"
/* start org: dyn */
#line 984 "garden.ceu"
        /* resets org memory and starts org.trail[0]=Class_XXX */
    /* TODO: BUG: _ceu_org is not necessarily the parent for pool allocations */
    ceu_out_org_init(_ceu_app, ((tceu_org*) &(*((CEU_Orchid*)__ceu_new_3241))),6,Class_Orchid,
                     7,
                     1,
                     (((CEU_Main*)_ceu_org)->_top_pool).parent_org,(((CEU_Main*)_ceu_org)->_top_pool).parent_trl);
/* TODO: currently idx is always "1" for all interfaces access because pools 
 * are all together there. When we have separate trls for pools, we'll have to 
 * indirectly access the offset in the interface. */

#line 984 "garden.ceu"
        _ceu_constr_3240(_ceu_app, ((tceu_org*) &(*((CEU_Orchid*)__ceu_new_3241))), _ceu_org);

#line 984 "garden.ceu"
    {
#ifdef CEU_STACK_CLEAR
    tceu_stk stk_ = { _ceu_stk, _ceu_org, 5, 5, 1 };
    ceu_app_go(_ceu_app,NULL,
               ((tceu_org*) &(*((CEU_Orchid*)__ceu_new_3241))), &((tceu_org*) &(*((CEU_Orchid*)__ceu_new_3241)))->trls[0],
               &stk_);
    if (!stk_.is_alive) {
        return;
    }
#else
    ceu_app_go(_ceu_app,NULL,
               ((tceu_org*) &(*((CEU_Orchid*)__ceu_new_3241))), &((tceu_org*) &(*((CEU_Orchid*)__ceu_new_3241)))->trls[0],
               NULL);
#endif

#line 984 "garden.ceu"
    }

#line 984 "garden.ceu"
        }
/*}*/
/* NODE: Set 7655 */

#line 989 "garden.ceu"
/* SET: idx *//* NODE: Op2_- 3249 */

#line 989 "garden.ceu"
    seeds[2] = (seeds[2]-1);/* NODE: EmitExt 3257 */

#line 990 "garden.ceu"
        {

#line 990 "garden.ceu"
    tceu__int__int __ceu_ps_3257;
{
    tceu__int__int __ceu_ps_3257_ =
        { 2,seeds[2] };
    __ceu_ps_3257 = __ceu_ps_3257_;
}

#line 990 "garden.ceu"
    
#if defined(ceu_out_emit_SET_COUNT)
    ceu_out_emit_SET_COUNT((&__ceu_ps_3257))

#elif defined(ceu_out_emit)
    (ceu_out_emit(_ceu_app, CEU_OUT_SET_COUNT, sizeof(tceu__int__int), (void*)(&__ceu_ps_3257)))

#else
    #error ceu_out_emit_* is not defined
#endif
;
#line 990 "garden.ceu"
        }

#line 984 "garden.ceu"
    }
#line 984 "garden.ceu"
/* CLEAR: Block (984) */
#line 984 "garden.ceu"
    if (0) {

#line 984 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
} else {
/* NODE: If 7638 */

#line 991 "garden.ceu"
    if ((((((CEU_Main*)_ceu_org)->seed_11)==11)&&(seeds[3]>0))) {
/* NODE: Block 3304 */

#line 992 "garden.ceu"
    {/* NODE: Stmts 3303 */

#line 992 "garden.ceu"
    {/* NODE: Spawn 3286 */

#line 992 "garden.ceu"
    /*{*/
    tceu_org* __ceu_new_3286;

#line 992 "garden.ceu"
        __ceu_new_3286 = (tceu_org*) ceu_out_realloc(NULL, sizeof(CEU_Heliconia));

#line 992 "garden.ceu"
        if (__ceu_new_3286 != NULL) {

#line 992 "garden.ceu"
    #ifdef CEU_ORGS_NEWS_POOL
        __ceu_new_3286->pool = &(((CEU_Main*)_ceu_org)->_top_pool);
#endif

#line 992 "garden.ceu"
/* start org: dyn */
#line 992 "garden.ceu"
        /* resets org memory and starts org.trail[0]=Class_XXX */
    /* TODO: BUG: _ceu_org is not necessarily the parent for pool allocations */
    ceu_out_org_init(_ceu_app, ((tceu_org*) &(*((CEU_Heliconia*)__ceu_new_3286))),6,Class_Heliconia,
                     8,
                     1,
                     (((CEU_Main*)_ceu_org)->_top_pool).parent_org,(((CEU_Main*)_ceu_org)->_top_pool).parent_trl);
/* TODO: currently idx is always "1" for all interfaces access because pools 
 * are all together there. When we have separate trls for pools, we'll have to 
 * indirectly access the offset in the interface. */

#line 992 "garden.ceu"
        _ceu_constr_3285(_ceu_app, ((tceu_org*) &(*((CEU_Heliconia*)__ceu_new_3286))), _ceu_org);

#line 992 "garden.ceu"
    {
#ifdef CEU_STACK_CLEAR
    tceu_stk stk_ = { _ceu_stk, _ceu_org, 5, 5, 1 };
    ceu_app_go(_ceu_app,NULL,
               ((tceu_org*) &(*((CEU_Heliconia*)__ceu_new_3286))), &((tceu_org*) &(*((CEU_Heliconia*)__ceu_new_3286)))->trls[0],
               &stk_);
    if (!stk_.is_alive) {
        return;
    }
#else
    ceu_app_go(_ceu_app,NULL,
               ((tceu_org*) &(*((CEU_Heliconia*)__ceu_new_3286))), &((tceu_org*) &(*((CEU_Heliconia*)__ceu_new_3286)))->trls[0],
               NULL);
#endif

#line 992 "garden.ceu"
    }

#line 992 "garden.ceu"
        }
/*}*/
/* NODE: Set 7660 */

#line 997 "garden.ceu"
/* SET: idx *//* NODE: Op2_- 3294 */

#line 997 "garden.ceu"
    seeds[3] = (seeds[3]-1);/* NODE: EmitExt 3302 */

#line 998 "garden.ceu"
        {

#line 998 "garden.ceu"
    tceu__int__int __ceu_ps_3302;
{
    tceu__int__int __ceu_ps_3302_ =
        { 3,seeds[3] };
    __ceu_ps_3302 = __ceu_ps_3302_;
}

#line 998 "garden.ceu"
    
#if defined(ceu_out_emit_SET_COUNT)
    ceu_out_emit_SET_COUNT((&__ceu_ps_3302))

#elif defined(ceu_out_emit)
    (ceu_out_emit(_ceu_app, CEU_OUT_SET_COUNT, sizeof(tceu__int__int), (void*)(&__ceu_ps_3302)))

#else
    #error ceu_out_emit_* is not defined
#endif
;
#line 998 "garden.ceu"
        }

#line 992 "garden.ceu"
    }
#line 992 "garden.ceu"
/* CLEAR: Block (992) */
#line 992 "garden.ceu"
    if (0) {

#line 992 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
} else {
/* NODE: Nothing 7637 */
}
}
}
}

#line 969 "garden.ceu"
    }
#line 969 "garden.ceu"
/* CLEAR: Block (969) */
#line 969 "garden.ceu"
    if (0) {

#line 969 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
}

#line 964 "garden.ceu"
    }
#line 964 "garden.ceu"
/* CLEAR: Block (964) */
#line 964 "garden.ceu"
    if (0) {

#line 964 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 963 "garden.ceu"
    }

#line 963 "garden.ceu"
    }
#line 963 "garden.ceu"
/* CLEAR: Block (963) */
#line 963 "garden.ceu"
    if (0) {

#line 963 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 963 "garden.ceu"
    }
#line 963 "garden.ceu"
/* CLEAR: Block (963) */
#line 963 "garden.ceu"
    if (0) {

#line 963 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 941 "garden.ceu"
case Main_ParEver_sub_1_134:;/* NODE: Block 3125 */

#line 942 "garden.ceu"
    {/* NODE: Stmts 3124 */

#line 942 "garden.ceu"
    {/* NODE: Block 7465 */

#line 942 "garden.ceu"
    {/* NODE: Stmts 7464 */

#line 942 "garden.ceu"
    {/* NODE: Stmts 7463 */

#line 942 "garden.ceu"
    {
#line 942 "garden.ceu"
    }/* NODE: Loop 7462 */

#line 942 "garden.ceu"
    for (;;) {
/* NODE: Block 3122 */

#line 943 "garden.ceu"
    {/* NODE: Stmts 3121 */

#line 943 "garden.ceu"
    {/* NODE: Block 7469 */

#line 943 "garden.ceu"
    {/* NODE: Stmts 7468 */

#line 943 "garden.ceu"
    {/* NODE: Stmts 7467 */

#line 943 "garden.ceu"
    {
#line 943 "garden.ceu"
    }/* NODE: Loop 7466 */

#line 943 "garden.ceu"
    for (;;) {
/* NODE: Block 3073 */

#line 944 "garden.ceu"
    {
#line 944 "garden.ceu"
    int __ceu_x_7;

#line 944 "garden.ceu"
    int __ceu_y_8;
/* NODE: Stmts 3072 */

#line 944 "garden.ceu"
    {/* NODE: Stmts 7472 */

#line 944 "garden.ceu"
    {/* NODE: Dcl_var 7471 */

#line 944 "garden.ceu"
    }/* NODE: Stmts 7475 */

#line 945 "garden.ceu"
    {/* NODE: Dcl_var 7474 */

#line 945 "garden.ceu"
    }/* NODE: Stmts 7515 */

#line 946 "garden.ceu"
    {/* NODE: Nothing 7477 */
/* NODE: Set 7476 */

#line 946 "garden.ceu"
/* SET: table: 0xf709b0 *//* NODE: Await 3043 */

#line 946 "garden.ceu"
    _CEU_NO_3043_:
if (0) { goto _CEU_NO_3043_; /* avoids "not used" warning */ }

#line 946 "garden.ceu"
    _ceu_trl->evt = CEU_IN_MOUSE_DOWN;
_ceu_trl->lbl = Main_Awake_MOUSE_DOWN_140;
_ceu_trl->seqno = _ceu_app->seqno;

#line 946 "garden.ceu"
    return;

case Main_Awake_MOUSE_DOWN_140:;

#line 946 "garden.ceu"
    #ifdef CEU_DEBUG_TRAILS
#ifndef CEU_OS
printf("\tOK!\n");
#endif
#endif

#line 946 "garden.ceu"
    {

#line 946 "garden.ceu"
        tceu__int__int** __ceu_casted = (tceu__int__int**) _ceu_evt->param;

#line 946 "garden.ceu"
        (__ceu_x_7) = ((*(__ceu_casted))->_1);
}

#line 946 "garden.ceu"
    {

#line 946 "garden.ceu"
        tceu__int__int** __ceu_casted = (tceu__int__int**) _ceu_evt->param;

#line 946 "garden.ceu"
        (__ceu_y_8) = ((*(__ceu_casted))->_2);
}
/* NODE: Nothing 8357 */
/* NODE: Nothing 8358 */

#line 946 "garden.ceu"
    }/* NODE: If 7521 */

#line 947 "garden.ceu"
    if (((((__ceu_y_8)>800)&&((__ceu_x_7)>((215+(6*135))-50)))&&((__ceu_x_7)<((215+(6*135))+50)))) {
/* NODE: Block 3070 */

#line 948 "garden.ceu"
    {/* NODE: Stmts 3069 */

#line 948 "garden.ceu"
    {/* NODE: Break 3068 */

#line 948 "garden.ceu"
    break;
#line 948 "garden.ceu"
    }
#line 948 "garden.ceu"
/* CLEAR: Block (948) */
#line 948 "garden.ceu"
    if (0) {

#line 948 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
} else {
/* NODE: Nothing 7520 */
}

#line 944 "garden.ceu"
    }
#line 944 "garden.ceu"
/* CLEAR: Block (944) */
#line 944 "garden.ceu"
    if (0) {

#line 944 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 943 "garden.ceu"
    }

#line 943 "garden.ceu"
/* CLEAR: Loop (943) */
#line 943 "garden.ceu"
    }
#line 943 "garden.ceu"
/* CLEAR: Block (943) */
#line 943 "garden.ceu"
    if (0) {

#line 943 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
/* NODE: EmitExt 3077 */

#line 951 "garden.ceu"
        {

#line 951 "garden.ceu"
    tceu__int __ceu_ps_3077;
{
    tceu__int __ceu_ps_3077_ =
        { 1 };
    __ceu_ps_3077 = __ceu_ps_3077_;
}

#line 951 "garden.ceu"
    
#if defined(ceu_out_emit_SET_MUTED)
    ceu_out_emit_SET_MUTED((&__ceu_ps_3077))

#elif defined(ceu_out_emit)
    (ceu_out_emit(_ceu_app, CEU_OUT_SET_MUTED, sizeof(tceu__int), (void*)(&__ceu_ps_3077)))

#else
    #error ceu_out_emit_* is not defined
#endif
;
#line 951 "garden.ceu"
        }
/* NODE: Block 7526 */

#line 952 "garden.ceu"
    {/* NODE: Stmts 7525 */

#line 952 "garden.ceu"
    {/* NODE: Stmts 7524 */

#line 952 "garden.ceu"
    {
#line 952 "garden.ceu"
    }/* NODE: Loop 7523 */

#line 952 "garden.ceu"
    for (;;) {
/* NODE: Block 3116 */

#line 953 "garden.ceu"
    {
#line 953 "garden.ceu"
    int __ceu_x_9;

#line 953 "garden.ceu"
    int __ceu_y_10;
/* NODE: Stmts 3115 */

#line 953 "garden.ceu"
    {/* NODE: Stmts 7529 */

#line 953 "garden.ceu"
    {/* NODE: Dcl_var 7528 */

#line 953 "garden.ceu"
    }/* NODE: Stmts 7532 */

#line 954 "garden.ceu"
    {/* NODE: Dcl_var 7531 */

#line 954 "garden.ceu"
    }/* NODE: Stmts 7572 */

#line 955 "garden.ceu"
    {/* NODE: Nothing 7534 */
/* NODE: Set 7533 */

#line 955 "garden.ceu"
/* SET: table: 0xf73e40 *//* NODE: Await 3086 */

#line 955 "garden.ceu"
    _CEU_NO_3086_:
if (0) { goto _CEU_NO_3086_; /* avoids "not used" warning */ }

#line 955 "garden.ceu"
    _ceu_trl->evt = CEU_IN_MOUSE_DOWN;
_ceu_trl->lbl = Main_Awake_MOUSE_DOWN_141;
_ceu_trl->seqno = _ceu_app->seqno;

#line 955 "garden.ceu"
    return;

case Main_Awake_MOUSE_DOWN_141:;

#line 955 "garden.ceu"
    #ifdef CEU_DEBUG_TRAILS
#ifndef CEU_OS
printf("\tOK!\n");
#endif
#endif

#line 955 "garden.ceu"
    {

#line 955 "garden.ceu"
        tceu__int__int** __ceu_casted = (tceu__int__int**) _ceu_evt->param;

#line 955 "garden.ceu"
        (__ceu_x_9) = ((*(__ceu_casted))->_1);
}

#line 955 "garden.ceu"
    {

#line 955 "garden.ceu"
        tceu__int__int** __ceu_casted = (tceu__int__int**) _ceu_evt->param;

#line 955 "garden.ceu"
        (__ceu_y_10) = ((*(__ceu_casted))->_2);
}
/* NODE: Nothing 8359 */
/* NODE: Nothing 8360 */

#line 955 "garden.ceu"
    }/* NODE: If 7578 */

#line 956 "garden.ceu"
    if (((((__ceu_y_10)>800)&&((__ceu_x_9)>((215+(6*135))-50)))&&((__ceu_x_9)<((215+(6*135))+50)))) {
/* NODE: Block 3113 */

#line 957 "garden.ceu"
    {/* NODE: Stmts 3112 */

#line 957 "garden.ceu"
    {/* NODE: Break 3111 */

#line 957 "garden.ceu"
    break;
#line 957 "garden.ceu"
    }
#line 957 "garden.ceu"
/* CLEAR: Block (957) */
#line 957 "garden.ceu"
    if (0) {

#line 957 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
} else {
/* NODE: Nothing 7577 */
}

#line 953 "garden.ceu"
    }
#line 953 "garden.ceu"
/* CLEAR: Block (953) */
#line 953 "garden.ceu"
    if (0) {

#line 953 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 952 "garden.ceu"
    }

#line 952 "garden.ceu"
/* CLEAR: Loop (952) */
#line 952 "garden.ceu"
    }
#line 952 "garden.ceu"
/* CLEAR: Block (952) */
#line 952 "garden.ceu"
    if (0) {

#line 952 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
/* NODE: EmitExt 3120 */

#line 960 "garden.ceu"
        {

#line 960 "garden.ceu"
    tceu__int __ceu_ps_3120;
{
    tceu__int __ceu_ps_3120_ =
        { 0 };
    __ceu_ps_3120 = __ceu_ps_3120_;
}

#line 960 "garden.ceu"
    
#if defined(ceu_out_emit_SET_MUTED)
    ceu_out_emit_SET_MUTED((&__ceu_ps_3120))

#elif defined(ceu_out_emit)
    (ceu_out_emit(_ceu_app, CEU_OUT_SET_MUTED, sizeof(tceu__int), (void*)(&__ceu_ps_3120)))

#else
    #error ceu_out_emit_* is not defined
#endif
;
#line 960 "garden.ceu"
        }

#line 943 "garden.ceu"
    }
#line 943 "garden.ceu"
/* CLEAR: Block (943) */
#line 943 "garden.ceu"
    if (0) {

#line 943 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 942 "garden.ceu"
    }

#line 942 "garden.ceu"
    }
#line 942 "garden.ceu"
/* CLEAR: Block (942) */
#line 942 "garden.ceu"
    if (0) {

#line 942 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 942 "garden.ceu"
    }
#line 942 "garden.ceu"
/* CLEAR: Block (942) */
#line 942 "garden.ceu"
    if (0) {

#line 942 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 1 "garden.ceu"
    }
#line 1 "garden.ceu"
/* CLEAR: Block (1) */
#line 1 "garden.ceu"
    if (0) {

#line 1 "garden.ceu"
case Main_Block__fin_156:;
#line 1 "garden.ceu"
    return;
#line 1 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 1 "garden.ceu"
    }
#line 1 "garden.ceu"
    }
#line 1 "garden.ceu"
/* CLEAR: Block (1) */
#line 1 "garden.ceu"
    if (0) {

#line 1 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 1 "garden.ceu"
    return;
#line 1 "garden.ceu"
    }
#line 1 "garden.ceu"
/* CLEAR: Block (1) */
#line 1 "garden.ceu"
    if (0) {

#line 1 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 1 "garden.ceu"
    }
#line 1 "garden.ceu"
/* CLEAR: Block (1) */
#line 1 "garden.ceu"
    if (0) {

#line 1 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
/* NODE: Dcl_cls 1 */

#line 49 "garden.ceu"
case Class_Delay:;/* NODE: Block 3923 */

#line 49 "garden.ceu"
    {/* NODE: Stmts 3922 */

#line 49 "garden.ceu"
    {/* NODE: Block 3869 */

#line 49 "garden.ceu"
    {/* NODE: Stmts 3924 */

#line 49 "garden.ceu"
    {/* NODE: Block 117 */

#line 53 "garden.ceu"
    {/* NODE: Stmts 116 */

#line 53 "garden.ceu"
    {/* NODE: Stmts 3887 */

#line 53 "garden.ceu"
    {/* NODE: Dcl_var 3884 */
/* NODE: Set 3888 */

#line 53 "garden.ceu"
/* SET: ticker *//* NODE: NUMBER 93 */

#line 53 "garden.ceu"
    (((CEU_Delay*)_ceu_org)->ticker) = 0;
#line 53 "garden.ceu"
    }/* NODE: Block 3892 */

#line 54 "garden.ceu"
    {/* NODE: Stmts 3891 */

#line 54 "garden.ceu"
    {/* NODE: Stmts 3890 */

#line 54 "garden.ceu"
    {
#line 54 "garden.ceu"
    }/* NODE: Loop 3889 */

#line 54 "garden.ceu"
    for (;;) {
/* NODE: Block 112 */

#line 55 "garden.ceu"
    {/* NODE: Stmts 111 */

#line 55 "garden.ceu"
    {/* NODE: Stmts 3919 */

#line 55 "garden.ceu"
    {/* NODE: Nothing 3893 */
/* NODE: Await 96 */

#line 55 "garden.ceu"
    _CEU_NO_96_:
if (0) { goto _CEU_NO_96_; /* avoids "not used" warning */ }

#line 55 "garden.ceu"
    _ceu_trl->evt = CEU_IN_UPDATE;
_ceu_trl->lbl = Delay_Awake_UPDATE_1;
_ceu_trl->seqno = _ceu_app->seqno;

#line 55 "garden.ceu"
    return;

case Delay_Awake_UPDATE_1:;

#line 55 "garden.ceu"
    #ifdef CEU_DEBUG_TRAILS
#ifndef CEU_OS
printf("\tOK!\n");
#endif
#endif
/* NODE: Nothing 8107 */
/* NODE: Nothing 8108 */

#line 55 "garden.ceu"
    }/* NODE: If 110 */

#line 56 "garden.ceu"
    if (((((CEU_Delay*)_ceu_org)->ticker)<(((CEU_Delay*)_ceu_org)->ticks))) {
/* NODE: Block 106 */

#line 57 "garden.ceu"
    {/* NODE: Stmts 105 */

#line 57 "garden.ceu"
    {/* NODE: Set 3920 */

#line 57 "garden.ceu"
/* SET: ticker *//* NODE: Op2_+ 103 */

#line 57 "garden.ceu"
    (((CEU_Delay*)_ceu_org)->ticker) = ((((CEU_Delay*)_ceu_org)->ticker)+1);
#line 57 "garden.ceu"
    }
#line 57 "garden.ceu"
/* CLEAR: Block (57) */
#line 57 "garden.ceu"
    if (0) {

#line 57 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
} else {
/* NODE: Block 109 */

#line 59 "garden.ceu"
    {/* NODE: Stmts 108 */

#line 59 "garden.ceu"
    {/* NODE: Break 107 */

#line 59 "garden.ceu"
    break;
#line 59 "garden.ceu"
    }
#line 59 "garden.ceu"
/* CLEAR: Block (59) */
#line 59 "garden.ceu"
    if (0) {

#line 59 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
}

#line 55 "garden.ceu"
    }
#line 55 "garden.ceu"
/* CLEAR: Block (55) */
#line 55 "garden.ceu"
    if (0) {

#line 55 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 54 "garden.ceu"
    }

#line 54 "garden.ceu"
/* CLEAR: Loop (54) */
#line 54 "garden.ceu"
    }
#line 54 "garden.ceu"
/* CLEAR: Block (54) */
#line 54 "garden.ceu"
    if (0) {

#line 54 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
/* NODE: EmitInt 115 */

#line 62 "garden.ceu"
    {
#ifdef CEU_STACK_CLEAR
    tceu_stk stk_ = { _ceu_stk, _ceu_org, 0, 0, 1 };
#endif

#line 62 "garden.ceu"
        /* trigger the event */
    tceu_evt evt;
    evt.id = 1;
#ifdef CEU_ORGS
#line 62 "garden.ceu"
    evt.org = (tceu_org*) _ceu_org;
#endif

#line 62 "garden.ceu"
        ceu_sys_go_ex(_ceu_app, &evt,
#ifdef CEU_STACK_CLEAR
                  &stk_,
#else
                  NULL,
#endif
                  _ceu_app->data, 0,
#ifdef CEU_ORGS
                  _ceu_app->data->n
#else
                  CEU_NTRAILS
#endif
    );

#ifdef CEU_STACK_CLEAR
    if (!stk_.is_alive) {
        return;
    }
#endif
}

#line 53 "garden.ceu"
    }
#line 53 "garden.ceu"
/* CLEAR: Block (53) */
#line 53 "garden.ceu"
    if (0) {

#line 53 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 49 "garden.ceu"
    }
#line 49 "garden.ceu"
/* CLEAR: Block (49) */
#line 49 "garden.ceu"
    if (0) {

#line 49 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 49 "garden.ceu"
    }
#line 49 "garden.ceu"
/* CLEAR: Block (49) */
#line 49 "garden.ceu"
    if (0) {

#line 49 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 49 "garden.ceu"
    ceu_sys_org_free(_ceu_app, _ceu_org);
#ifdef CEU_ORGS_AWAIT
{
    /* signal ok_killed */
#ifdef CEU_STACK_CLEAR
    tceu_stk stk_ = *_ceu_stk;
             stk_.is_alive = 1;
             stk_.down = _ceu_stk;
#endif
    tceu_kill ps = { _ceu_org, _ceu_org->ret, 0, (tceu_ntrl)(_ceu_org->n-1) };
    tceu_evt evt_;
             evt_.id = CEU_IN__ok_killed;
             evt_.param = &ps;
    ceu_sys_go_ex(_ceu_app, &evt_,
#ifdef CEU_STACK_CLEAR
                  &stk_,
#else
                  NULL,
#endif
                  _ceu_app->data, 0, _ceu_app->data->n);
}
#endif

#line 49 "garden.ceu"
    return;/* NODE: Dcl_cls 2 */

#line 65 "garden.ceu"
case Class_Garden:;/* NODE: Block 4011 */

#line 65 "garden.ceu"
    {/* NODE: Stmts 4010 */

#line 65 "garden.ceu"
    {/* NODE: Block 3931 */

#line 65 "garden.ceu"
    {/* NODE: Stmts 4012 */

#line 65 "garden.ceu"
    {/* NODE: Block 171 */

#line 75 "garden.ceu"
    {/* NODE: Stmts 170 */

#line 75 "garden.ceu"
    {/* NODE: Block 3974 */

#line 75 "garden.ceu"
    {/* NODE: Stmts 3973 */

#line 75 "garden.ceu"
    {/* NODE: Stmts 3972 */

#line 75 "garden.ceu"
    {
#line 75 "garden.ceu"
    }/* NODE: Loop 3971 */

#line 75 "garden.ceu"
    for (;;) {
/* NODE: Block 168 */

#line 76 "garden.ceu"
    {/* NODE: Stmts 167 */

#line 76 "garden.ceu"
    {/* NODE: Do 3981 */
/* NODE: Block 3980 */

#line 76 "garden.ceu"
    {
#line 76 "garden.ceu"
    #ifdef CEU_ORGS
_ceu_org->trls[ 0 ].evt = CEU_IN__ORG;
_ceu_org->trls[ 0 ].org = NULL;
#endif

#line 76 "garden.ceu"
    _ceu_trl = &_ceu_org->trls[ 1 ];
/* NODE: Stmts 3979 */

#line 76 "garden.ceu"
    {/* NODE: Dcl_var 3978 */

#line 76 "garden.ceu"
/* start org: _org_156 */
#line 76 "garden.ceu"
        /* resets org memory and starts org.trail[0]=Class_XXX */
    /* TODO: BUG: _ceu_org is not necessarily the parent for pool allocations */
    ceu_out_org_init(_ceu_app, ((tceu_org*) &(((CEU_Garden*)_ceu_org)->_org_156_11)),2,Class_Delay,
                     1,
                     0,
                     _ceu_org,0);
/* TODO: currently idx is always "1" for all interfaces access because pools 
 * are all together there. When we have separate trls for pools, we'll have to 
 * indirectly access the offset in the interface. */

#line 76 "garden.ceu"
        _ceu_pre_1(_ceu_app, ((tceu_org*) &(((CEU_Garden*)_ceu_org)->_org_156_11)));

#line 76 "garden.ceu"
        _ceu_constr_155(_ceu_app, ((tceu_org*) &(((CEU_Garden*)_ceu_org)->_org_156_11)), _ceu_org);

#line 76 "garden.ceu"
    {
#ifdef CEU_STACK_CLEAR
    tceu_stk stk_ = { _ceu_stk, _ceu_org, 1, 1, 1 };
    ceu_app_go(_ceu_app,NULL,
               ((tceu_org*) &(((CEU_Garden*)_ceu_org)->_org_156_11)), &((tceu_org*) &(((CEU_Garden*)_ceu_org)->_org_156_11))->trls[0],
               &stk_);
    if (!stk_.is_alive) {
        return;
    }
#else
    ceu_app_go(_ceu_app,NULL,
               ((tceu_org*) &(((CEU_Garden*)_ceu_org)->_org_156_11)), &((tceu_org*) &(((CEU_Garden*)_ceu_org)->_org_156_11))->trls[0],
               NULL);
#endif

#line 76 "garden.ceu"
    }
/* NODE: Stmts 4009 */

#line 76 "garden.ceu"
    {/* NODE: Nothing 3983 */
/* NODE: Nothing 8110 */
/* NODE: Nothing 8111 */
/* NODE: Stmts 4008 */

#line 76 "garden.ceu"
    {/* NODE: If 4007 */

#line 76 "garden.ceu"
    if ((!(((*((tceu_org*)(&((CEU_Garden*)_ceu_org)->_org_156_11))).isAlive)))) {
/* NODE: Block 4004 */

#line 76 "garden.ceu"
    {/* NODE: Stmts 4003 */

#line 76 "garden.ceu"
    {/* NODE: Nothing 3987 */

#line 76 "garden.ceu"
    }
#line 76 "garden.ceu"
/* CLEAR: Block (76) */
#line 76 "garden.ceu"
    if (0) {

#line 76 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
} else {
/* NODE: Block 4006 */

#line 76 "garden.ceu"
    {/* NODE: Stmts 4005 */

#line 76 "garden.ceu"
    {/* NODE: Await 3986 */

#line 76 "garden.ceu"
    _CEU_NO_3986_:
if (0) { goto _CEU_NO_3986_; /* avoids "not used" warning */ }

#line 76 "garden.ceu"
    _ceu_trl->evt = CEU_IN__ok_killed;
_ceu_trl->lbl = Garden_Awake__ok_killed_3;
_ceu_trl->seqno = _ceu_app->seqno;

#line 76 "garden.ceu"
    #ifdef CEU_ORGS_AWAIT
#ifdef CEU_ADTS_AWAIT
_ceu_trl->is_org = 1;
#endif
#endif
_ceu_trl->org_or_adt = (void*)(&((CEU_Garden*)_ceu_org)->_org_156_11);

#line 76 "garden.ceu"
    return;

case Garden_Awake__ok_killed_3:;

#line 76 "garden.ceu"
    #ifdef CEU_DEBUG_TRAILS
#ifndef CEU_OS
printf("\tOK!\n");
#endif
#endif

#line 76 "garden.ceu"
    }
#line 76 "garden.ceu"
/* CLEAR: Block (76) */
#line 76 "garden.ceu"
    if (0) {

#line 76 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
}

#line 76 "garden.ceu"
    }
#line 76 "garden.ceu"
    }
#line 76 "garden.ceu"
    }
#line 76 "garden.ceu"
/* CLEAR: Block (76) */
#line 76 "garden.ceu"
    {
    /* Reuse current stack frame.
     * We know that CLEAR will not abort anything and return normally.
     * Just save the previous "is_alive", call CLEAR, and restore it.
     */
#ifdef CEU_STACK_CLEAR
    int __ceu_old = _ceu_stk->is_alive;
    _ceu_stk->is_alive = 1;
#endif
    tceu_evt evt;
             evt.id = CEU_IN__CLEAR;
    ceu_sys_go_ex(_ceu_app, &evt,
                  _ceu_stk,
                  _ceu_org,
                  0,
                  2);
#ifdef CEU_STACK_CLEAR
    _ceu_stk->is_alive = __ceu_old;
    ceu_sys_stack_clear(_ceu_stk, _ceu_org,
                        0,1);
#endif
}

#line 76 "garden.ceu"
    #ifdef CEU_ORGS_AWAIT
/* signal ok_killed */
{
    tceu_kill ps = { _ceu_org, _ceu_org->ret, 0,1 };
    tceu_evt evt_;
             evt_.id = CEU_IN__ok_killed;
             evt_.param = &ps;
    ceu_sys_go_ex(_ceu_app, &evt_, _ceu_stk,
                  _ceu_app->data, 0, _ceu_app->data->n);
}
#endif

#line 76 "garden.ceu"
    if (0) {

#line 76 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
/* NODE: CallStmt 166 */

#line 79 "garden.ceu"
    printf("score = %f, (%d, %d, %d, %d)\n",(((CEU_Garden*)_ceu_org)->score),(((CEU_Garden*)_ceu_org)->t0_plants),(((CEU_Garden*)_ceu_org)->t1_plants),(((CEU_Garden*)_ceu_org)->t2_plants),(((CEU_Garden*)_ceu_org)->t3_plants));
#line 76 "garden.ceu"
    }
#line 76 "garden.ceu"
/* CLEAR: Block (76) */
#line 76 "garden.ceu"
    if (0) {

#line 76 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 75 "garden.ceu"
    }

#line 75 "garden.ceu"
    }
#line 75 "garden.ceu"
/* CLEAR: Block (75) */
#line 75 "garden.ceu"
    if (0) {

#line 75 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 75 "garden.ceu"
    }
#line 75 "garden.ceu"
/* CLEAR: Block (75) */
#line 75 "garden.ceu"
    if (0) {

#line 75 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 65 "garden.ceu"
    }
#line 65 "garden.ceu"
/* CLEAR: Block (65) */
#line 65 "garden.ceu"
    if (0) {

#line 65 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 65 "garden.ceu"
    }
#line 65 "garden.ceu"
/* CLEAR: Block (65) */
#line 65 "garden.ceu"
    if (0) {

#line 65 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 65 "garden.ceu"
    ceu_sys_org_free(_ceu_app, _ceu_org);
#ifdef CEU_ORGS_AWAIT
{
    /* signal ok_killed */
#ifdef CEU_STACK_CLEAR
    tceu_stk stk_ = *_ceu_stk;
             stk_.is_alive = 1;
             stk_.down = _ceu_stk;
#endif
    tceu_kill ps = { _ceu_org, _ceu_org->ret, 0, (tceu_ntrl)(_ceu_org->n-1) };
    tceu_evt evt_;
             evt_.id = CEU_IN__ok_killed;
             evt_.param = &ps;
    ceu_sys_go_ex(_ceu_app, &evt_,
#ifdef CEU_STACK_CLEAR
                  &stk_,
#else
                  NULL,
#endif
                  _ceu_app->data, 0, _ceu_app->data->n);
}
#endif

#line 65 "garden.ceu"
    return;/* NODE: Dcl_cls 3 */

#line 83 "garden.ceu"
case Class_Konami:;/* NODE: Block 4538 */

#line 83 "garden.ceu"
    {/* NODE: Stmts 4537 */

#line 83 "garden.ceu"
    {/* NODE: Block 4019 */

#line 83 "garden.ceu"
    {/* NODE: Stmts 4539 */

#line 83 "garden.ceu"
    {/* NODE: Block 293 */

#line 86 "garden.ceu"
    {/* NODE: Stmts 292 */

#line 86 "garden.ceu"
    {/* NODE: Block 4030 */

#line 86 "garden.ceu"
    {/* NODE: Stmts 4029 */

#line 86 "garden.ceu"
    {/* NODE: Stmts 4028 */

#line 86 "garden.ceu"
    {
#line 86 "garden.ceu"
    }/* NODE: Loop 4027 */

#line 86 "garden.ceu"
    for (;;) {
/* NODE: Block 288 */

#line 87 "garden.ceu"
    {
#line 87 "garden.ceu"
    int __ceu_which_4;
/* NODE: Stmts 287 */

#line 87 "garden.ceu"
    {/* NODE: Stmts 4035 */

#line 87 "garden.ceu"
    {/* NODE: Dcl_var 4032 */
/* NODE: Stmts 4076 */

#line 87 "garden.ceu"
    {/* NODE: Nothing 4038 */
/* NODE: Set 4037 */

#line 87 "garden.ceu"
/* SET: table: 0x8f8a20 *//* NODE: Await 178 */

#line 87 "garden.ceu"
    _CEU_NO_178_:
if (0) { goto _CEU_NO_178_; /* avoids "not used" warning */ }

#line 87 "garden.ceu"
    _ceu_trl->evt = CEU_IN_KEY_DOWN;
_ceu_trl->lbl = Konami_Awake_KEY_DOWN_5;
_ceu_trl->seqno = _ceu_app->seqno;

#line 87 "garden.ceu"
    return;

case Konami_Awake_KEY_DOWN_5:;

#line 87 "garden.ceu"
    #ifdef CEU_DEBUG_TRAILS
#ifndef CEU_OS
printf("\tOK!\n");
#endif
#endif

#line 87 "garden.ceu"
    {

#line 87 "garden.ceu"
        tceu__int** __ceu_casted = (tceu__int**) _ceu_evt->param;

#line 87 "garden.ceu"
        (__ceu_which_4) = ((*(__ceu_casted))->_1);
}
/* NODE: Nothing 8112 */
/* NODE: Nothing 8113 */

#line 87 "garden.ceu"
    }
#line 87 "garden.ceu"
    }/* NODE: If 4082 */

#line 88 "garden.ceu"
    if (((__ceu_which_4)!=38)) {
/* NODE: Block 185 */

#line 88 "garden.ceu"
    {/* NODE: Stmts 184 */

#line 88 "garden.ceu"
    {/* NODE: Nothing 4083 */

#line 88 "garden.ceu"
    }
#line 88 "garden.ceu"
/* CLEAR: Block (88) */
#line 88 "garden.ceu"
    if (0) {

#line 88 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
} else {
/* NODE: Block 4535 */

#line 86 "garden.ceu"
    {/* NODE: Stmts 4534 */

#line 88 "garden.ceu"
    {/* NODE: Stmts 4124 */

#line 89 "garden.ceu"
    {/* NODE: Nothing 4086 */
/* NODE: Set 4085 */

#line 89 "garden.ceu"
/* SET: table: 0xe941a0 *//* NODE: Await 189 */

#line 89 "garden.ceu"
    _CEU_NO_189_:
if (0) { goto _CEU_NO_189_; /* avoids "not used" warning */ }

#line 89 "garden.ceu"
    _ceu_trl->evt = CEU_IN_KEY_DOWN;
_ceu_trl->lbl = Konami_Awake_KEY_DOWN_6;
_ceu_trl->seqno = _ceu_app->seqno;

#line 89 "garden.ceu"
    return;

case Konami_Awake_KEY_DOWN_6:;

#line 89 "garden.ceu"
    #ifdef CEU_DEBUG_TRAILS
#ifndef CEU_OS
printf("\tOK!\n");
#endif
#endif

#line 89 "garden.ceu"
    {

#line 89 "garden.ceu"
        tceu__int** __ceu_casted = (tceu__int**) _ceu_evt->param;

#line 89 "garden.ceu"
        (__ceu_which_4) = ((*(__ceu_casted))->_1);
}
/* NODE: Nothing 8114 */
/* NODE: Nothing 8115 */

#line 89 "garden.ceu"
    }/* NODE: If 4130 */

#line 90 "garden.ceu"
    if (((__ceu_which_4)!=38)) {
/* NODE: Block 196 */

#line 90 "garden.ceu"
    {/* NODE: Stmts 195 */

#line 90 "garden.ceu"
    {/* NODE: Nothing 4131 */

#line 90 "garden.ceu"
    }
#line 90 "garden.ceu"
/* CLEAR: Block (90) */
#line 90 "garden.ceu"
    if (0) {

#line 90 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
} else {
/* NODE: Block 4533 */

#line 86 "garden.ceu"
    {/* NODE: Stmts 4532 */

#line 90 "garden.ceu"
    {/* NODE: Stmts 4172 */

#line 91 "garden.ceu"
    {/* NODE: Nothing 4134 */
/* NODE: Set 4133 */

#line 91 "garden.ceu"
/* SET: table: 0xe94ed0 *//* NODE: Await 200 */

#line 91 "garden.ceu"
    _CEU_NO_200_:
if (0) { goto _CEU_NO_200_; /* avoids "not used" warning */ }

#line 91 "garden.ceu"
    _ceu_trl->evt = CEU_IN_KEY_DOWN;
_ceu_trl->lbl = Konami_Awake_KEY_DOWN_7;
_ceu_trl->seqno = _ceu_app->seqno;

#line 91 "garden.ceu"
    return;

case Konami_Awake_KEY_DOWN_7:;

#line 91 "garden.ceu"
    #ifdef CEU_DEBUG_TRAILS
#ifndef CEU_OS
printf("\tOK!\n");
#endif
#endif

#line 91 "garden.ceu"
    {

#line 91 "garden.ceu"
        tceu__int** __ceu_casted = (tceu__int**) _ceu_evt->param;

#line 91 "garden.ceu"
        (__ceu_which_4) = ((*(__ceu_casted))->_1);
}
/* NODE: Nothing 8116 */
/* NODE: Nothing 8117 */

#line 91 "garden.ceu"
    }/* NODE: If 4178 */

#line 92 "garden.ceu"
    if (((__ceu_which_4)!=40)) {
/* NODE: Block 207 */

#line 92 "garden.ceu"
    {/* NODE: Stmts 206 */

#line 92 "garden.ceu"
    {/* NODE: Nothing 4179 */

#line 92 "garden.ceu"
    }
#line 92 "garden.ceu"
/* CLEAR: Block (92) */
#line 92 "garden.ceu"
    if (0) {

#line 92 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
} else {
/* NODE: Block 4531 */

#line 86 "garden.ceu"
    {/* NODE: Stmts 4530 */

#line 92 "garden.ceu"
    {/* NODE: Stmts 4220 */

#line 93 "garden.ceu"
    {/* NODE: Nothing 4182 */
/* NODE: Set 4181 */

#line 93 "garden.ceu"
/* SET: table: 0xe1b520 *//* NODE: Await 211 */

#line 93 "garden.ceu"
    _CEU_NO_211_:
if (0) { goto _CEU_NO_211_; /* avoids "not used" warning */ }

#line 93 "garden.ceu"
    _ceu_trl->evt = CEU_IN_KEY_DOWN;
_ceu_trl->lbl = Konami_Awake_KEY_DOWN_8;
_ceu_trl->seqno = _ceu_app->seqno;

#line 93 "garden.ceu"
    return;

case Konami_Awake_KEY_DOWN_8:;

#line 93 "garden.ceu"
    #ifdef CEU_DEBUG_TRAILS
#ifndef CEU_OS
printf("\tOK!\n");
#endif
#endif

#line 93 "garden.ceu"
    {

#line 93 "garden.ceu"
        tceu__int** __ceu_casted = (tceu__int**) _ceu_evt->param;

#line 93 "garden.ceu"
        (__ceu_which_4) = ((*(__ceu_casted))->_1);
}
/* NODE: Nothing 8118 */
/* NODE: Nothing 8119 */

#line 93 "garden.ceu"
    }/* NODE: If 4226 */

#line 94 "garden.ceu"
    if (((__ceu_which_4)!=40)) {
/* NODE: Block 218 */

#line 94 "garden.ceu"
    {/* NODE: Stmts 217 */

#line 94 "garden.ceu"
    {/* NODE: Nothing 4227 */

#line 94 "garden.ceu"
    }
#line 94 "garden.ceu"
/* CLEAR: Block (94) */
#line 94 "garden.ceu"
    if (0) {

#line 94 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
} else {
/* NODE: Block 4529 */

#line 86 "garden.ceu"
    {/* NODE: Stmts 4528 */

#line 94 "garden.ceu"
    {/* NODE: Stmts 4268 */

#line 95 "garden.ceu"
    {/* NODE: Nothing 4230 */
/* NODE: Set 4229 */

#line 95 "garden.ceu"
/* SET: table: 0xe1c220 *//* NODE: Await 222 */

#line 95 "garden.ceu"
    _CEU_NO_222_:
if (0) { goto _CEU_NO_222_; /* avoids "not used" warning */ }

#line 95 "garden.ceu"
    _ceu_trl->evt = CEU_IN_KEY_DOWN;
_ceu_trl->lbl = Konami_Awake_KEY_DOWN_9;
_ceu_trl->seqno = _ceu_app->seqno;

#line 95 "garden.ceu"
    return;

case Konami_Awake_KEY_DOWN_9:;

#line 95 "garden.ceu"
    #ifdef CEU_DEBUG_TRAILS
#ifndef CEU_OS
printf("\tOK!\n");
#endif
#endif

#line 95 "garden.ceu"
    {

#line 95 "garden.ceu"
        tceu__int** __ceu_casted = (tceu__int**) _ceu_evt->param;

#line 95 "garden.ceu"
        (__ceu_which_4) = ((*(__ceu_casted))->_1);
}
/* NODE: Nothing 8120 */
/* NODE: Nothing 8121 */

#line 95 "garden.ceu"
    }/* NODE: If 4274 */

#line 96 "garden.ceu"
    if (((__ceu_which_4)!=37)) {
/* NODE: Block 229 */

#line 96 "garden.ceu"
    {/* NODE: Stmts 228 */

#line 96 "garden.ceu"
    {/* NODE: Nothing 4275 */

#line 96 "garden.ceu"
    }
#line 96 "garden.ceu"
/* CLEAR: Block (96) */
#line 96 "garden.ceu"
    if (0) {

#line 96 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
} else {
/* NODE: Block 4527 */

#line 86 "garden.ceu"
    {/* NODE: Stmts 4526 */

#line 96 "garden.ceu"
    {/* NODE: Stmts 4316 */

#line 97 "garden.ceu"
    {/* NODE: Nothing 4278 */
/* NODE: Set 4277 */

#line 97 "garden.ceu"
/* SET: table: 0xea00f0 *//* NODE: Await 233 */

#line 97 "garden.ceu"
    _CEU_NO_233_:
if (0) { goto _CEU_NO_233_; /* avoids "not used" warning */ }

#line 97 "garden.ceu"
    _ceu_trl->evt = CEU_IN_KEY_DOWN;
_ceu_trl->lbl = Konami_Awake_KEY_DOWN_10;
_ceu_trl->seqno = _ceu_app->seqno;

#line 97 "garden.ceu"
    return;

case Konami_Awake_KEY_DOWN_10:;

#line 97 "garden.ceu"
    #ifdef CEU_DEBUG_TRAILS
#ifndef CEU_OS
printf("\tOK!\n");
#endif
#endif

#line 97 "garden.ceu"
    {

#line 97 "garden.ceu"
        tceu__int** __ceu_casted = (tceu__int**) _ceu_evt->param;

#line 97 "garden.ceu"
        (__ceu_which_4) = ((*(__ceu_casted))->_1);
}
/* NODE: Nothing 8122 */
/* NODE: Nothing 8123 */

#line 97 "garden.ceu"
    }/* NODE: If 4322 */

#line 98 "garden.ceu"
    if (((__ceu_which_4)!=39)) {
/* NODE: Block 240 */

#line 98 "garden.ceu"
    {/* NODE: Stmts 239 */

#line 98 "garden.ceu"
    {/* NODE: Nothing 4323 */

#line 98 "garden.ceu"
    }
#line 98 "garden.ceu"
/* CLEAR: Block (98) */
#line 98 "garden.ceu"
    if (0) {

#line 98 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
} else {
/* NODE: Block 4525 */

#line 86 "garden.ceu"
    {/* NODE: Stmts 4524 */

#line 98 "garden.ceu"
    {/* NODE: Stmts 4364 */

#line 99 "garden.ceu"
    {/* NODE: Nothing 4326 */
/* NODE: Set 4325 */

#line 99 "garden.ceu"
/* SET: table: 0xea0df0 *//* NODE: Await 244 */

#line 99 "garden.ceu"
    _CEU_NO_244_:
if (0) { goto _CEU_NO_244_; /* avoids "not used" warning */ }

#line 99 "garden.ceu"
    _ceu_trl->evt = CEU_IN_KEY_DOWN;
_ceu_trl->lbl = Konami_Awake_KEY_DOWN_11;
_ceu_trl->seqno = _ceu_app->seqno;

#line 99 "garden.ceu"
    return;

case Konami_Awake_KEY_DOWN_11:;

#line 99 "garden.ceu"
    #ifdef CEU_DEBUG_TRAILS
#ifndef CEU_OS
printf("\tOK!\n");
#endif
#endif

#line 99 "garden.ceu"
    {

#line 99 "garden.ceu"
        tceu__int** __ceu_casted = (tceu__int**) _ceu_evt->param;

#line 99 "garden.ceu"
        (__ceu_which_4) = ((*(__ceu_casted))->_1);
}
/* NODE: Nothing 8124 */
/* NODE: Nothing 8125 */

#line 99 "garden.ceu"
    }/* NODE: If 4370 */

#line 100 "garden.ceu"
    if (((__ceu_which_4)!=37)) {
/* NODE: Block 251 */

#line 100 "garden.ceu"
    {/* NODE: Stmts 250 */

#line 100 "garden.ceu"
    {/* NODE: Nothing 4371 */

#line 100 "garden.ceu"
    }
#line 100 "garden.ceu"
/* CLEAR: Block (100) */
#line 100 "garden.ceu"
    if (0) {

#line 100 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
} else {
/* NODE: Block 4523 */

#line 86 "garden.ceu"
    {/* NODE: Stmts 4522 */

#line 100 "garden.ceu"
    {/* NODE: Stmts 4412 */

#line 101 "garden.ceu"
    {/* NODE: Nothing 4374 */
/* NODE: Set 4373 */

#line 101 "garden.ceu"
/* SET: table: 0xe4da10 *//* NODE: Await 255 */

#line 101 "garden.ceu"
    _CEU_NO_255_:
if (0) { goto _CEU_NO_255_; /* avoids "not used" warning */ }

#line 101 "garden.ceu"
    _ceu_trl->evt = CEU_IN_KEY_DOWN;
_ceu_trl->lbl = Konami_Awake_KEY_DOWN_12;
_ceu_trl->seqno = _ceu_app->seqno;

#line 101 "garden.ceu"
    return;

case Konami_Awake_KEY_DOWN_12:;

#line 101 "garden.ceu"
    #ifdef CEU_DEBUG_TRAILS
#ifndef CEU_OS
printf("\tOK!\n");
#endif
#endif

#line 101 "garden.ceu"
    {

#line 101 "garden.ceu"
        tceu__int** __ceu_casted = (tceu__int**) _ceu_evt->param;

#line 101 "garden.ceu"
        (__ceu_which_4) = ((*(__ceu_casted))->_1);
}
/* NODE: Nothing 8126 */
/* NODE: Nothing 8127 */

#line 101 "garden.ceu"
    }/* NODE: If 4418 */

#line 102 "garden.ceu"
    if (((__ceu_which_4)!=39)) {
/* NODE: Block 262 */

#line 102 "garden.ceu"
    {/* NODE: Stmts 261 */

#line 102 "garden.ceu"
    {/* NODE: Nothing 4419 */

#line 102 "garden.ceu"
    }
#line 102 "garden.ceu"
/* CLEAR: Block (102) */
#line 102 "garden.ceu"
    if (0) {

#line 102 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
} else {
/* NODE: Block 4521 */

#line 86 "garden.ceu"
    {/* NODE: Stmts 4520 */

#line 102 "garden.ceu"
    {/* NODE: Stmts 4460 */

#line 103 "garden.ceu"
    {/* NODE: Nothing 4422 */
/* NODE: Set 4421 */

#line 103 "garden.ceu"
/* SET: table: 0xe4e710 *//* NODE: Await 266 */

#line 103 "garden.ceu"
    _CEU_NO_266_:
if (0) { goto _CEU_NO_266_; /* avoids "not used" warning */ }

#line 103 "garden.ceu"
    _ceu_trl->evt = CEU_IN_KEY_DOWN;
_ceu_trl->lbl = Konami_Awake_KEY_DOWN_13;
_ceu_trl->seqno = _ceu_app->seqno;

#line 103 "garden.ceu"
    return;

case Konami_Awake_KEY_DOWN_13:;

#line 103 "garden.ceu"
    #ifdef CEU_DEBUG_TRAILS
#ifndef CEU_OS
printf("\tOK!\n");
#endif
#endif

#line 103 "garden.ceu"
    {

#line 103 "garden.ceu"
        tceu__int** __ceu_casted = (tceu__int**) _ceu_evt->param;

#line 103 "garden.ceu"
        (__ceu_which_4) = ((*(__ceu_casted))->_1);
}
/* NODE: Nothing 8128 */
/* NODE: Nothing 8129 */

#line 103 "garden.ceu"
    }/* NODE: If 4466 */

#line 104 "garden.ceu"
    if (((__ceu_which_4)!=66)) {
/* NODE: Block 273 */

#line 104 "garden.ceu"
    {/* NODE: Stmts 272 */

#line 104 "garden.ceu"
    {/* NODE: Nothing 4467 */

#line 104 "garden.ceu"
    }
#line 104 "garden.ceu"
/* CLEAR: Block (104) */
#line 104 "garden.ceu"
    if (0) {

#line 104 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
} else {
/* NODE: Block 4519 */

#line 86 "garden.ceu"
    {/* NODE: Stmts 4518 */

#line 104 "garden.ceu"
    {/* NODE: Stmts 4508 */

#line 105 "garden.ceu"
    {/* NODE: Nothing 4470 */
/* NODE: Set 4469 */

#line 105 "garden.ceu"
/* SET: table: 0xea1b80 *//* NODE: Await 277 */

#line 105 "garden.ceu"
    _CEU_NO_277_:
if (0) { goto _CEU_NO_277_; /* avoids "not used" warning */ }

#line 105 "garden.ceu"
    _ceu_trl->evt = CEU_IN_KEY_DOWN;
_ceu_trl->lbl = Konami_Awake_KEY_DOWN_14;
_ceu_trl->seqno = _ceu_app->seqno;

#line 105 "garden.ceu"
    return;

case Konami_Awake_KEY_DOWN_14:;

#line 105 "garden.ceu"
    #ifdef CEU_DEBUG_TRAILS
#ifndef CEU_OS
printf("\tOK!\n");
#endif
#endif

#line 105 "garden.ceu"
    {

#line 105 "garden.ceu"
        tceu__int** __ceu_casted = (tceu__int**) _ceu_evt->param;

#line 105 "garden.ceu"
        (__ceu_which_4) = ((*(__ceu_casted))->_1);
}
/* NODE: Nothing 8130 */
/* NODE: Nothing 8131 */

#line 105 "garden.ceu"
    }/* NODE: If 4514 */

#line 106 "garden.ceu"
    if (((__ceu_which_4)!=65)) {
/* NODE: Block 284 */

#line 106 "garden.ceu"
    {/* NODE: Stmts 283 */

#line 106 "garden.ceu"
    {/* NODE: Nothing 4515 */

#line 106 "garden.ceu"
    }
#line 106 "garden.ceu"
/* CLEAR: Block (106) */
#line 106 "garden.ceu"
    if (0) {

#line 106 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
} else {
/* NODE: Block 4517 */

#line 86 "garden.ceu"
    {/* NODE: Stmts 4516 */

#line 106 "garden.ceu"
    {/* NODE: Break 286 */

#line 107 "garden.ceu"
    break;
#line 106 "garden.ceu"
    }
#line 86 "garden.ceu"
/* CLEAR: Block (86) */
#line 86 "garden.ceu"
    if (0) {

#line 86 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
}

#line 104 "garden.ceu"
    }
#line 86 "garden.ceu"
/* CLEAR: Block (86) */
#line 86 "garden.ceu"
    if (0) {

#line 86 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
}

#line 102 "garden.ceu"
    }
#line 86 "garden.ceu"
/* CLEAR: Block (86) */
#line 86 "garden.ceu"
    if (0) {

#line 86 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
}

#line 100 "garden.ceu"
    }
#line 86 "garden.ceu"
/* CLEAR: Block (86) */
#line 86 "garden.ceu"
    if (0) {

#line 86 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
}

#line 98 "garden.ceu"
    }
#line 86 "garden.ceu"
/* CLEAR: Block (86) */
#line 86 "garden.ceu"
    if (0) {

#line 86 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
}

#line 96 "garden.ceu"
    }
#line 86 "garden.ceu"
/* CLEAR: Block (86) */
#line 86 "garden.ceu"
    if (0) {

#line 86 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
}

#line 94 "garden.ceu"
    }
#line 86 "garden.ceu"
/* CLEAR: Block (86) */
#line 86 "garden.ceu"
    if (0) {

#line 86 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
}

#line 92 "garden.ceu"
    }
#line 86 "garden.ceu"
/* CLEAR: Block (86) */
#line 86 "garden.ceu"
    if (0) {

#line 86 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
}

#line 90 "garden.ceu"
    }
#line 86 "garden.ceu"
/* CLEAR: Block (86) */
#line 86 "garden.ceu"
    if (0) {

#line 86 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
}

#line 88 "garden.ceu"
    }
#line 86 "garden.ceu"
/* CLEAR: Block (86) */
#line 86 "garden.ceu"
    if (0) {

#line 86 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
}

#line 87 "garden.ceu"
    }
#line 87 "garden.ceu"
/* CLEAR: Block (87) */
#line 87 "garden.ceu"
    if (0) {

#line 87 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 86 "garden.ceu"
    }

#line 86 "garden.ceu"
/* CLEAR: Loop (86) */
#line 86 "garden.ceu"
    }
#line 86 "garden.ceu"
/* CLEAR: Block (86) */
#line 86 "garden.ceu"
    if (0) {

#line 86 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
/* NODE: EmitInt 291 */

#line 109 "garden.ceu"
    {
#ifdef CEU_STACK_CLEAR
    tceu_stk stk_ = { _ceu_stk, _ceu_org, 0, 0, 1 };
#endif

#line 109 "garden.ceu"
        /* trigger the event */
    tceu_evt evt;
    evt.id = 1;
#ifdef CEU_ORGS
#line 109 "garden.ceu"
    evt.org = (tceu_org*) _ceu_org;
#endif

#line 109 "garden.ceu"
        ceu_sys_go_ex(_ceu_app, &evt,
#ifdef CEU_STACK_CLEAR
                  &stk_,
#else
                  NULL,
#endif
                  _ceu_app->data, 0,
#ifdef CEU_ORGS
                  _ceu_app->data->n
#else
                  CEU_NTRAILS
#endif
    );

#ifdef CEU_STACK_CLEAR
    if (!stk_.is_alive) {
        return;
    }
#endif
}

#line 86 "garden.ceu"
    }
#line 86 "garden.ceu"
/* CLEAR: Block (86) */
#line 86 "garden.ceu"
    if (0) {

#line 86 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 83 "garden.ceu"
    }
#line 83 "garden.ceu"
/* CLEAR: Block (83) */
#line 83 "garden.ceu"
    if (0) {

#line 83 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 83 "garden.ceu"
    }
#line 83 "garden.ceu"
/* CLEAR: Block (83) */
#line 83 "garden.ceu"
    if (0) {

#line 83 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 83 "garden.ceu"
    ceu_sys_org_free(_ceu_app, _ceu_org);
#ifdef CEU_ORGS_AWAIT
{
    /* signal ok_killed */
#ifdef CEU_STACK_CLEAR
    tceu_stk stk_ = *_ceu_stk;
             stk_.is_alive = 1;
             stk_.down = _ceu_stk;
#endif
    tceu_kill ps = { _ceu_org, _ceu_org->ret, 0, (tceu_ntrl)(_ceu_org->n-1) };
    tceu_evt evt_;
             evt_.id = CEU_IN__ok_killed;
             evt_.param = &ps;
    ceu_sys_go_ex(_ceu_app, &evt_,
#ifdef CEU_STACK_CLEAR
                  &stk_,
#else
                  NULL,
#endif
                  _ceu_app->data, 0, _ceu_app->data->n);
}
#endif

#line 83 "garden.ceu"
    return;/* NODE: Dcl_cls 4 */

#line 118 "garden.ceu"
case Class_Growing:;/* NODE: Block 4702 */

#line 118 "garden.ceu"
    {/* NODE: Stmts 4701 */

#line 118 "garden.ceu"
    {/* NODE: Block 4546 */

#line 118 "garden.ceu"
    {/* NODE: Stmts 4703 */

#line 118 "garden.ceu"
    {/* NODE: Block 519 */

#line 126 "garden.ceu"
    /*  FINALIZE */
_ceu_org->trls[ 5 ].evt = CEU_IN__CLEAR;
_ceu_org->trls[ 5 ].lbl = Growing_Block__fin_22;

#line 126 "garden.ceu"
    ((CEU_Growing*)_ceu_org)->__fin_519_1 = 0;
#line 126 "garden.ceu"
    {/* NODE: Stmts 518 */

#line 126 "garden.ceu"
    {/* NODE: Stmts 4574 */

#line 126 "garden.ceu"
    {/* NODE: Dcl_var 4571 */
/* NODE: Set 4575 */

#line 126 "garden.ceu"
/* SET: id *//* NODE: Var 309 */

#line 126 "garden.ceu"
    (((CEU_Growing*)_ceu_org)->id) = (*((CEU_Growing*)_ceu_org)->gensym);
#line 126 "garden.ceu"
    }/* NODE: Set 4576 */

#line 127 "garden.ceu"
/* SET: gensym *//* NODE: Op2_+ 314 */

#line 127 "garden.ceu"
    (*((CEU_Growing*)_ceu_org)->gensym) = ((*((CEU_Growing*)_ceu_org)->gensym)+1);/* NODE: EmitExt 325 */

#line 128 "garden.ceu"
        {

#line 128 "garden.ceu"
    tceu__int__int__int__int__int __ceu_ps_325;
{
    tceu__int__int__int__int__int __ceu_ps_325_ =
        { (((CEU_Growing*)_ceu_org)->id),(((CEU_Growing*)_ceu_org)->x),((((CEU_Growing*)_ceu_org)->y)-60),2,(((CEU_Growing*)_ceu_org)->layer) };
    __ceu_ps_325 = __ceu_ps_325_;
}

#line 128 "garden.ceu"
    
#if defined(ceu_out_emit_NEW_SPRITE)
    ceu_out_emit_NEW_SPRITE((&__ceu_ps_325))

#elif defined(ceu_out_emit)
    (ceu_out_emit(_ceu_app, CEU_OUT_NEW_SPRITE, sizeof(tceu__int__int__int__int__int), (void*)(&__ceu_ps_325)))

#else
    #error ceu_out_emit_* is not defined
#endif
;
#line 128 "garden.ceu"
        }
/* NODE: Finalize 332 */

#line 129 "garden.ceu"
    ((CEU_Growing*)_ceu_org)->__fin_519_1 = 1;/* NODE: Stmts 4582 */

#line 132 "garden.ceu"
    {/* NODE: Dcl_var 4579 */
/* NODE: Set 4583 */

#line 132 "garden.ceu"
/* SET: water *//* NODE: NUMBER 334 */

#line 132 "garden.ceu"
    (((CEU_Growing*)_ceu_org)->water) = 10;
#line 132 "garden.ceu"
    }/* NODE: If 4585 */

#line 133 "garden.ceu"
    if (((((CEU_Growing*)_ceu_org)->water)>16)) {
/* NODE: Block 345 */

#line 134 "garden.ceu"
    {/* NODE: Stmts 344 */

#line 134 "garden.ceu"
    {/* NODE: EmitExt 343 */

#line 134 "garden.ceu"
        {

#line 134 "garden.ceu"
    tceu__int__int __ceu_ps_343;
{
    tceu__int__int __ceu_ps_343_ =
        { (((CEU_Growing*)_ceu_org)->id),0x00FFFF };
    __ceu_ps_343 = __ceu_ps_343_;
}

#line 134 "garden.ceu"
    
#if defined(ceu_out_emit_SET_SPRITE_TINT)
    ceu_out_emit_SET_SPRITE_TINT((&__ceu_ps_343))

#elif defined(ceu_out_emit)
    (ceu_out_emit(_ceu_app, CEU_OUT_SET_SPRITE_TINT, sizeof(tceu__int__int), (void*)(&__ceu_ps_343)))

#else
    #error ceu_out_emit_* is not defined
#endif
;
#line 134 "garden.ceu"
        }

#line 134 "garden.ceu"
    }
#line 134 "garden.ceu"
/* CLEAR: Block (134) */
#line 134 "garden.ceu"
    if (0) {

#line 134 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
} else {
/* NODE: If 4584 */

#line 135 "garden.ceu"
    if (((((CEU_Growing*)_ceu_org)->water)<8)) {
/* NODE: Block 355 */

#line 136 "garden.ceu"
    {/* NODE: Stmts 354 */

#line 136 "garden.ceu"
    {/* NODE: EmitExt 353 */

#line 136 "garden.ceu"
        {

#line 136 "garden.ceu"
    tceu__int__int __ceu_ps_353;
{
    tceu__int__int __ceu_ps_353_ =
        { (((CEU_Growing*)_ceu_org)->id),0xBBBB51 };
    __ceu_ps_353 = __ceu_ps_353_;
}

#line 136 "garden.ceu"
    
#if defined(ceu_out_emit_SET_SPRITE_TINT)
    ceu_out_emit_SET_SPRITE_TINT((&__ceu_ps_353))

#elif defined(ceu_out_emit)
    (ceu_out_emit(_ceu_app, CEU_OUT_SET_SPRITE_TINT, sizeof(tceu__int__int), (void*)(&__ceu_ps_353)))

#else
    #error ceu_out_emit_* is not defined
#endif
;
#line 136 "garden.ceu"
        }

#line 136 "garden.ceu"
    }
#line 136 "garden.ceu"
/* CLEAR: Block (136) */
#line 136 "garden.ceu"
    if (0) {

#line 136 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
} else {
/* NODE: Block 362 */

#line 138 "garden.ceu"
    {/* NODE: Stmts 361 */

#line 138 "garden.ceu"
    {/* NODE: EmitExt 360 */

#line 138 "garden.ceu"
        {

#line 138 "garden.ceu"
    tceu__int__int __ceu_ps_360;
{
    tceu__int__int __ceu_ps_360_ =
        { (((CEU_Growing*)_ceu_org)->id),0x00FF00 };
    __ceu_ps_360 = __ceu_ps_360_;
}

#line 138 "garden.ceu"
    
#if defined(ceu_out_emit_SET_SPRITE_TINT)
    ceu_out_emit_SET_SPRITE_TINT((&__ceu_ps_360))

#elif defined(ceu_out_emit)
    (ceu_out_emit(_ceu_app, CEU_OUT_SET_SPRITE_TINT, sizeof(tceu__int__int), (void*)(&__ceu_ps_360)))

#else
    #error ceu_out_emit_* is not defined
#endif
;
#line 138 "garden.ceu"
        }

#line 138 "garden.ceu"
    }
#line 138 "garden.ceu"
/* CLEAR: Block (138) */
#line 138 "garden.ceu"
    if (0) {

#line 138 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
}
}
/* NODE: ParOr 508 */

#line 140 "garden.ceu"
/* ParOr: spawn subs */
#line 140 "garden.ceu"
    {
#ifdef CEU_STACK_CLEAR
    tceu_stk stk_ = { _ceu_stk, _ceu_org, 0, 4, 1 };
#endif

#line 140 "garden.ceu"
        _ceu_org->trls[ 0 ].lbl = Growing_ParOr_sub_1_16;
    ceu_app_go(_ceu_app,NULL,_ceu_org,
               &_ceu_org->trls[ 0 ],
#ifdef CEU_STACK_CLEAR
               &stk_
#else
               NULL
#endif
              );

#ifdef CEU_STACK_CLEAR
    if (!stk_.is_alive) {
        return;
    }
#endif

#line 140 "garden.ceu"
        _ceu_org->trls[ 2 ].lbl = Growing_ParOr_sub_2_17;
    ceu_app_go(_ceu_app,NULL,_ceu_org,
               &_ceu_org->trls[ 2 ],
#ifdef CEU_STACK_CLEAR
               &stk_
#else
               NULL
#endif
              );

#ifdef CEU_STACK_CLEAR
    if (!stk_.is_alive) {
        return;
    }
#endif

#line 140 "garden.ceu"
        _ceu_trl = &_ceu_org->trls[ 4 ];

#line 140 "garden.ceu"
    }
/* NODE: Block 507 */

#line 163 "garden.ceu"
    {/* NODE: Stmts 506 */

#line 163 "garden.ceu"
    {/* NODE: Block 4666 */

#line 163 "garden.ceu"
    {/* NODE: Stmts 4665 */

#line 163 "garden.ceu"
    {/* NODE: Stmts 4664 */

#line 163 "garden.ceu"
    {
#line 163 "garden.ceu"
    }/* NODE: Loop 4663 */

#line 163 "garden.ceu"
    for (;;) {
/* NODE: Block 504 */

#line 164 "garden.ceu"
    {/* NODE: Stmts 503 */

#line 164 "garden.ceu"
    {/* NODE: Stmts 4693 */

#line 164 "garden.ceu"
    {/* NODE: Nothing 4667 */
/* NODE: Await 460 */

#line 164 "garden.ceu"
    _CEU_NO_460_:
if (0) { goto _CEU_NO_460_; /* avoids "not used" warning */ }

#line 164 "garden.ceu"
    _ceu_trl->evt = 1;
_ceu_trl->lbl = Growing_Awake_go_water_21;
_ceu_trl->seqno = _ceu_app->seqno;

#line 164 "garden.ceu"
    #ifdef CEU_ORGS
_ceu_trl->evto  = _ceu_org;
#endif

#line 164 "garden.ceu"
    return;

case Growing_Awake_go_water_21:;

#line 164 "garden.ceu"
    #ifdef CEU_DEBUG_TRAILS
#ifndef CEU_OS
printf("\tOK!\n");
#endif
#endif
/* NODE: Nothing 8138 */
/* NODE: Nothing 8139 */

#line 164 "garden.ceu"
    }/* NODE: Set 4694 */

#line 165 "garden.ceu"
/* SET: water *//* NODE: Op2_+ 464 */

#line 165 "garden.ceu"
    (((CEU_Growing*)_ceu_org)->water) = ((((CEU_Growing*)_ceu_org)->water)+3);/* NODE: If 4696 */

#line 166 "garden.ceu"
    if (((((CEU_Growing*)_ceu_org)->water)>20)) {
/* NODE: Block 473 */

#line 167 "garden.ceu"
    {/* NODE: Stmts 472 */

#line 167 "garden.ceu"
    {/* NODE: Set 4697 */

#line 167 "garden.ceu"
/* SET: water *//* NODE: NUMBER 470 */

#line 167 "garden.ceu"
    (((CEU_Growing*)_ceu_org)->water) = 20;
#line 167 "garden.ceu"
    }
#line 167 "garden.ceu"
/* CLEAR: Block (167) */
#line 167 "garden.ceu"
    if (0) {

#line 167 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
} else {
/* NODE: Nothing 4695 */
}
/* NODE: If 4699 */

#line 169 "garden.ceu"
    if (((((CEU_Growing*)_ceu_org)->water)>16)) {
/* NODE: Block 484 */

#line 170 "garden.ceu"
    {/* NODE: Stmts 483 */

#line 170 "garden.ceu"
    {/* NODE: EmitExt 482 */

#line 170 "garden.ceu"
        {

#line 170 "garden.ceu"
    tceu__int__int __ceu_ps_482;
{
    tceu__int__int __ceu_ps_482_ =
        { (((CEU_Growing*)_ceu_org)->id),0x00FFFF };
    __ceu_ps_482 = __ceu_ps_482_;
}

#line 170 "garden.ceu"
    
#if defined(ceu_out_emit_SET_SPRITE_TINT)
    ceu_out_emit_SET_SPRITE_TINT((&__ceu_ps_482))

#elif defined(ceu_out_emit)
    (ceu_out_emit(_ceu_app, CEU_OUT_SET_SPRITE_TINT, sizeof(tceu__int__int), (void*)(&__ceu_ps_482)))

#else
    #error ceu_out_emit_* is not defined
#endif
;
#line 170 "garden.ceu"
        }

#line 170 "garden.ceu"
    }
#line 170 "garden.ceu"
/* CLEAR: Block (170) */
#line 170 "garden.ceu"
    if (0) {

#line 170 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
} else {
/* NODE: If 4698 */

#line 171 "garden.ceu"
    if (((((CEU_Growing*)_ceu_org)->water)<8)) {
/* NODE: Block 494 */

#line 172 "garden.ceu"
    {/* NODE: Stmts 493 */

#line 172 "garden.ceu"
    {/* NODE: EmitExt 492 */

#line 172 "garden.ceu"
        {

#line 172 "garden.ceu"
    tceu__int__int __ceu_ps_492;
{
    tceu__int__int __ceu_ps_492_ =
        { (((CEU_Growing*)_ceu_org)->id),0xBBBB51 };
    __ceu_ps_492 = __ceu_ps_492_;
}

#line 172 "garden.ceu"
    
#if defined(ceu_out_emit_SET_SPRITE_TINT)
    ceu_out_emit_SET_SPRITE_TINT((&__ceu_ps_492))

#elif defined(ceu_out_emit)
    (ceu_out_emit(_ceu_app, CEU_OUT_SET_SPRITE_TINT, sizeof(tceu__int__int), (void*)(&__ceu_ps_492)))

#else
    #error ceu_out_emit_* is not defined
#endif
;
#line 172 "garden.ceu"
        }

#line 172 "garden.ceu"
    }
#line 172 "garden.ceu"
/* CLEAR: Block (172) */
#line 172 "garden.ceu"
    if (0) {

#line 172 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
} else {
/* NODE: Block 501 */

#line 174 "garden.ceu"
    {/* NODE: Stmts 500 */

#line 174 "garden.ceu"
    {/* NODE: EmitExt 499 */

#line 174 "garden.ceu"
        {

#line 174 "garden.ceu"
    tceu__int__int __ceu_ps_499;
{
    tceu__int__int __ceu_ps_499_ =
        { (((CEU_Growing*)_ceu_org)->id),0x00FF00 };
    __ceu_ps_499 = __ceu_ps_499_;
}

#line 174 "garden.ceu"
    
#if defined(ceu_out_emit_SET_SPRITE_TINT)
    ceu_out_emit_SET_SPRITE_TINT((&__ceu_ps_499))

#elif defined(ceu_out_emit)
    (ceu_out_emit(_ceu_app, CEU_OUT_SET_SPRITE_TINT, sizeof(tceu__int__int), (void*)(&__ceu_ps_499)))

#else
    #error ceu_out_emit_* is not defined
#endif
;
#line 174 "garden.ceu"
        }

#line 174 "garden.ceu"
    }
#line 174 "garden.ceu"
/* CLEAR: Block (174) */
#line 174 "garden.ceu"
    if (0) {

#line 174 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
}
}

#line 164 "garden.ceu"
    }
#line 164 "garden.ceu"
/* CLEAR: Block (164) */
#line 164 "garden.ceu"
    if (0) {

#line 164 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 163 "garden.ceu"
    }

#line 163 "garden.ceu"
    }
#line 163 "garden.ceu"
/* CLEAR: Block (163) */
#line 163 "garden.ceu"
    if (0) {

#line 163 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 163 "garden.ceu"
    }
#line 163 "garden.ceu"
/* CLEAR: Block (163) */
#line 163 "garden.ceu"
    if (0) {

#line 163 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 140 "garden.ceu"
case Growing_ParOr_sub_2_17:;/* NODE: Block 458 */

#line 145 "garden.ceu"
    {/* NODE: Stmts 457 */

#line 145 "garden.ceu"
    {/* NODE: Block 4624 */

#line 145 "garden.ceu"
    {/* NODE: Stmts 4623 */

#line 145 "garden.ceu"
    {/* NODE: Stmts 4622 */

#line 145 "garden.ceu"
    {
#line 145 "garden.ceu"
    }/* NODE: Loop 4621 */

#line 145 "garden.ceu"
    for (;;) {
/* NODE: Block 455 */

#line 146 "garden.ceu"
    {/* NODE: Stmts 454 */

#line 146 "garden.ceu"
    {/* NODE: Do 4631 */
/* NODE: Block 4630 */

#line 146 "garden.ceu"
    {
#line 146 "garden.ceu"
    #ifdef CEU_ORGS
_ceu_org->trls[ 2 ].evt = CEU_IN__ORG;
_ceu_org->trls[ 2 ].org = NULL;
#endif

#line 146 "garden.ceu"
    _ceu_trl = &_ceu_org->trls[ 3 ];
/* NODE: Stmts 4629 */

#line 146 "garden.ceu"
    {/* NODE: Dcl_var 4628 */

#line 146 "garden.ceu"
/* start org: _org_411 */
#line 146 "garden.ceu"
        /* resets org memory and starts org.trail[0]=Class_XXX */
    /* TODO: BUG: _ceu_org is not necessarily the parent for pool allocations */
    ceu_out_org_init(_ceu_app, ((tceu_org*) &(((CEU_Growing*)_ceu_org)->_org_411_12)),2,Class_Delay,
                     1,
                     0,
                     _ceu_org,2);
/* TODO: currently idx is always "1" for all interfaces access because pools 
 * are all together there. When we have separate trls for pools, we'll have to 
 * indirectly access the offset in the interface. */

#line 146 "garden.ceu"
        _ceu_pre_1(_ceu_app, ((tceu_org*) &(((CEU_Growing*)_ceu_org)->_org_411_12)));

#line 146 "garden.ceu"
        _ceu_constr_410(_ceu_app, ((tceu_org*) &(((CEU_Growing*)_ceu_org)->_org_411_12)), _ceu_org);

#line 146 "garden.ceu"
    {
#ifdef CEU_STACK_CLEAR
    tceu_stk stk_ = { _ceu_stk, _ceu_org, 3, 3, 1 };
    ceu_app_go(_ceu_app,NULL,
               ((tceu_org*) &(((CEU_Growing*)_ceu_org)->_org_411_12)), &((tceu_org*) &(((CEU_Growing*)_ceu_org)->_org_411_12))->trls[0],
               &stk_);
    if (!stk_.is_alive) {
        return;
    }
#else
    ceu_app_go(_ceu_app,NULL,
               ((tceu_org*) &(((CEU_Growing*)_ceu_org)->_org_411_12)), &((tceu_org*) &(((CEU_Growing*)_ceu_org)->_org_411_12))->trls[0],
               NULL);
#endif

#line 146 "garden.ceu"
    }
/* NODE: Stmts 4659 */

#line 146 "garden.ceu"
    {/* NODE: Nothing 4633 */
/* NODE: Nothing 8136 */
/* NODE: Nothing 8137 */
/* NODE: Stmts 4658 */

#line 146 "garden.ceu"
    {/* NODE: If 4657 */

#line 146 "garden.ceu"
    if ((!(((*((tceu_org*)(&((CEU_Growing*)_ceu_org)->_org_411_12))).isAlive)))) {
/* NODE: Block 4654 */

#line 146 "garden.ceu"
    {/* NODE: Stmts 4653 */

#line 146 "garden.ceu"
    {/* NODE: Nothing 4637 */

#line 146 "garden.ceu"
    }
#line 146 "garden.ceu"
/* CLEAR: Block (146) */
#line 146 "garden.ceu"
    if (0) {

#line 146 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
} else {
/* NODE: Block 4656 */

#line 146 "garden.ceu"
    {/* NODE: Stmts 4655 */

#line 146 "garden.ceu"
    {/* NODE: Await 4636 */

#line 146 "garden.ceu"
    _CEU_NO_4636_:
if (0) { goto _CEU_NO_4636_; /* avoids "not used" warning */ }

#line 146 "garden.ceu"
    _ceu_trl->evt = CEU_IN__ok_killed;
_ceu_trl->lbl = Growing_Awake__ok_killed_20;
_ceu_trl->seqno = _ceu_app->seqno;

#line 146 "garden.ceu"
    #ifdef CEU_ORGS_AWAIT
#ifdef CEU_ADTS_AWAIT
_ceu_trl->is_org = 1;
#endif
#endif
_ceu_trl->org_or_adt = (void*)(&((CEU_Growing*)_ceu_org)->_org_411_12);

#line 146 "garden.ceu"
    return;

case Growing_Awake__ok_killed_20:;

#line 146 "garden.ceu"
    #ifdef CEU_DEBUG_TRAILS
#ifndef CEU_OS
printf("\tOK!\n");
#endif
#endif

#line 146 "garden.ceu"
    }
#line 146 "garden.ceu"
/* CLEAR: Block (146) */
#line 146 "garden.ceu"
    if (0) {

#line 146 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
}

#line 146 "garden.ceu"
    }
#line 146 "garden.ceu"
    }
#line 146 "garden.ceu"
    }
#line 146 "garden.ceu"
/* CLEAR: Block (146) */
#line 146 "garden.ceu"
    {
    /* Reuse current stack frame.
     * We know that CLEAR will not abort anything and return normally.
     * Just save the previous "is_alive", call CLEAR, and restore it.
     */
#ifdef CEU_STACK_CLEAR
    int __ceu_old = _ceu_stk->is_alive;
    _ceu_stk->is_alive = 1;
#endif
    tceu_evt evt;
             evt.id = CEU_IN__CLEAR;
    ceu_sys_go_ex(_ceu_app, &evt,
                  _ceu_stk,
                  _ceu_org,
                  2,
                  4);
#ifdef CEU_STACK_CLEAR
    _ceu_stk->is_alive = __ceu_old;
    ceu_sys_stack_clear(_ceu_stk, _ceu_org,
                        2,3);
#endif
}

#line 146 "garden.ceu"
    #ifdef CEU_ORGS_AWAIT
/* signal ok_killed */
{
    tceu_kill ps = { _ceu_org, _ceu_org->ret, 2,3 };
    tceu_evt evt_;
             evt_.id = CEU_IN__ok_killed;
             evt_.param = &ps;
    ceu_sys_go_ex(_ceu_app, &evt_, _ceu_stk,
                  _ceu_app->data, 0, _ceu_app->data->n);
}
#endif

#line 146 "garden.ceu"
    if (0) {

#line 146 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
/* NODE: If 453 */

#line 149 "garden.ceu"
    if (((((CEU_Growing*)_ceu_org)->water)>0)) {
/* NODE: Block 449 */

#line 150 "garden.ceu"
    {/* NODE: Stmts 448 */

#line 150 "garden.ceu"
    {/* NODE: Set 4660 */

#line 150 "garden.ceu"
/* SET: water *//* NODE: Op2_- 418 */

#line 150 "garden.ceu"
    (((CEU_Growing*)_ceu_org)->water) = ((((CEU_Growing*)_ceu_org)->water)-1);/* NODE: If 4662 */

#line 151 "garden.ceu"
    if (((((CEU_Growing*)_ceu_org)->water)>16)) {
/* NODE: Block 429 */

#line 152 "garden.ceu"
    {/* NODE: Stmts 428 */

#line 152 "garden.ceu"
    {/* NODE: EmitExt 427 */

#line 152 "garden.ceu"
        {

#line 152 "garden.ceu"
    tceu__int__int __ceu_ps_427;
{
    tceu__int__int __ceu_ps_427_ =
        { (((CEU_Growing*)_ceu_org)->id),0x00FFFF };
    __ceu_ps_427 = __ceu_ps_427_;
}

#line 152 "garden.ceu"
    
#if defined(ceu_out_emit_SET_SPRITE_TINT)
    ceu_out_emit_SET_SPRITE_TINT((&__ceu_ps_427))

#elif defined(ceu_out_emit)
    (ceu_out_emit(_ceu_app, CEU_OUT_SET_SPRITE_TINT, sizeof(tceu__int__int), (void*)(&__ceu_ps_427)))

#else
    #error ceu_out_emit_* is not defined
#endif
;
#line 152 "garden.ceu"
        }

#line 152 "garden.ceu"
    }
#line 152 "garden.ceu"
/* CLEAR: Block (152) */
#line 152 "garden.ceu"
    if (0) {

#line 152 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
} else {
/* NODE: If 4661 */

#line 153 "garden.ceu"
    if (((((CEU_Growing*)_ceu_org)->water)<8)) {
/* NODE: Block 439 */

#line 154 "garden.ceu"
    {/* NODE: Stmts 438 */

#line 154 "garden.ceu"
    {/* NODE: EmitExt 437 */

#line 154 "garden.ceu"
        {

#line 154 "garden.ceu"
    tceu__int__int __ceu_ps_437;
{
    tceu__int__int __ceu_ps_437_ =
        { (((CEU_Growing*)_ceu_org)->id),0xBBBB51 };
    __ceu_ps_437 = __ceu_ps_437_;
}

#line 154 "garden.ceu"
    
#if defined(ceu_out_emit_SET_SPRITE_TINT)
    ceu_out_emit_SET_SPRITE_TINT((&__ceu_ps_437))

#elif defined(ceu_out_emit)
    (ceu_out_emit(_ceu_app, CEU_OUT_SET_SPRITE_TINT, sizeof(tceu__int__int), (void*)(&__ceu_ps_437)))

#else
    #error ceu_out_emit_* is not defined
#endif
;
#line 154 "garden.ceu"
        }

#line 154 "garden.ceu"
    }
#line 154 "garden.ceu"
/* CLEAR: Block (154) */
#line 154 "garden.ceu"
    if (0) {

#line 154 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
} else {
/* NODE: Block 446 */

#line 156 "garden.ceu"
    {/* NODE: Stmts 445 */

#line 156 "garden.ceu"
    {/* NODE: EmitExt 444 */

#line 156 "garden.ceu"
        {

#line 156 "garden.ceu"
    tceu__int__int __ceu_ps_444;
{
    tceu__int__int __ceu_ps_444_ =
        { (((CEU_Growing*)_ceu_org)->id),0x00FF00 };
    __ceu_ps_444 = __ceu_ps_444_;
}

#line 156 "garden.ceu"
    
#if defined(ceu_out_emit_SET_SPRITE_TINT)
    ceu_out_emit_SET_SPRITE_TINT((&__ceu_ps_444))

#elif defined(ceu_out_emit)
    (ceu_out_emit(_ceu_app, CEU_OUT_SET_SPRITE_TINT, sizeof(tceu__int__int), (void*)(&__ceu_ps_444)))

#else
    #error ceu_out_emit_* is not defined
#endif
;
#line 156 "garden.ceu"
        }

#line 156 "garden.ceu"
    }
#line 156 "garden.ceu"
/* CLEAR: Block (156) */
#line 156 "garden.ceu"
    if (0) {

#line 156 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
}
}

#line 150 "garden.ceu"
    }
#line 150 "garden.ceu"
/* CLEAR: Block (150) */
#line 150 "garden.ceu"
    if (0) {

#line 150 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
} else {
/* NODE: Block 452 */

#line 159 "garden.ceu"
    {/* NODE: Stmts 451 */

#line 159 "garden.ceu"
    {/* NODE: Break 450 */

#line 159 "garden.ceu"
    break;
#line 159 "garden.ceu"
    }
#line 159 "garden.ceu"
/* CLEAR: Block (159) */
#line 159 "garden.ceu"
    if (0) {

#line 159 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
}

#line 146 "garden.ceu"
    }
#line 146 "garden.ceu"
/* CLEAR: Block (146) */
#line 146 "garden.ceu"
    if (0) {

#line 146 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 145 "garden.ceu"
    }

#line 145 "garden.ceu"
/* CLEAR: Loop (145) */
#line 145 "garden.ceu"
    }
#line 145 "garden.ceu"
/* CLEAR: Block (145) */
#line 145 "garden.ceu"
    if (0) {

#line 145 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 145 "garden.ceu"
    }
#line 145 "garden.ceu"
/* CLEAR: Block (145) */
#line 145 "garden.ceu"
    if (0) {

#line 145 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 140 "garden.ceu"
/* PAROR JOIN */
#line 140 "garden.ceu"
    _ceu_lbl = Growing_ParOr_out_18;
goto _CEU_GOTO_;

#line 140 "garden.ceu"
case Growing_ParOr_sub_1_16:;/* NODE: Block 388 */

#line 141 "garden.ceu"
    {/* NODE: Stmts 387 */

#line 141 "garden.ceu"
    {/* NODE: Do 4592 */
/* NODE: Block 4591 */

#line 141 "garden.ceu"
    {
#line 141 "garden.ceu"
    #ifdef CEU_ORGS
_ceu_org->trls[ 0 ].evt = CEU_IN__ORG;
_ceu_org->trls[ 0 ].org = NULL;
#endif

#line 141 "garden.ceu"
    _ceu_trl = &_ceu_org->trls[ 1 ];
/* NODE: Stmts 4590 */

#line 141 "garden.ceu"
    {/* NODE: Dcl_var 4589 */

#line 141 "garden.ceu"
/* start org: _org_386 */
#line 141 "garden.ceu"
        /* resets org memory and starts org.trail[0]=Class_XXX */
    /* TODO: BUG: _ceu_org is not necessarily the parent for pool allocations */
    ceu_out_org_init(_ceu_app, ((tceu_org*) &(((CEU_Growing*)_ceu_org)->_org_386_11)),2,Class_Delay,
                     1,
                     0,
                     _ceu_org,0);
/* TODO: currently idx is always "1" for all interfaces access because pools 
 * are all together there. When we have separate trls for pools, we'll have to 
 * indirectly access the offset in the interface. */

#line 141 "garden.ceu"
        _ceu_pre_1(_ceu_app, ((tceu_org*) &(((CEU_Growing*)_ceu_org)->_org_386_11)));

#line 141 "garden.ceu"
        _ceu_constr_385(_ceu_app, ((tceu_org*) &(((CEU_Growing*)_ceu_org)->_org_386_11)), _ceu_org);

#line 141 "garden.ceu"
    {
#ifdef CEU_STACK_CLEAR
    tceu_stk stk_ = { _ceu_stk, _ceu_org, 1, 1, 1 };
    ceu_app_go(_ceu_app,NULL,
               ((tceu_org*) &(((CEU_Growing*)_ceu_org)->_org_386_11)), &((tceu_org*) &(((CEU_Growing*)_ceu_org)->_org_386_11))->trls[0],
               &stk_);
    if (!stk_.is_alive) {
        return;
    }
#else
    ceu_app_go(_ceu_app,NULL,
               ((tceu_org*) &(((CEU_Growing*)_ceu_org)->_org_386_11)), &((tceu_org*) &(((CEU_Growing*)_ceu_org)->_org_386_11))->trls[0],
               NULL);
#endif

#line 141 "garden.ceu"
    }
/* NODE: Stmts 4620 */

#line 141 "garden.ceu"
    {/* NODE: Nothing 4594 */
/* NODE: Nothing 8133 */
/* NODE: Nothing 8134 */
/* NODE: Stmts 4619 */

#line 141 "garden.ceu"
    {/* NODE: If 4618 */

#line 141 "garden.ceu"
    if ((!(((*((tceu_org*)(&((CEU_Growing*)_ceu_org)->_org_386_11))).isAlive)))) {
/* NODE: Block 4615 */

#line 141 "garden.ceu"
    {/* NODE: Stmts 4614 */

#line 141 "garden.ceu"
    {/* NODE: Nothing 4598 */

#line 141 "garden.ceu"
    }
#line 141 "garden.ceu"
/* CLEAR: Block (141) */
#line 141 "garden.ceu"
    if (0) {

#line 141 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
} else {
/* NODE: Block 4617 */

#line 141 "garden.ceu"
    {/* NODE: Stmts 4616 */

#line 141 "garden.ceu"
    {/* NODE: Await 4597 */

#line 141 "garden.ceu"
    _CEU_NO_4597_:
if (0) { goto _CEU_NO_4597_; /* avoids "not used" warning */ }

#line 141 "garden.ceu"
    _ceu_trl->evt = CEU_IN__ok_killed;
_ceu_trl->lbl = Growing_Awake__ok_killed_19;
_ceu_trl->seqno = _ceu_app->seqno;

#line 141 "garden.ceu"
    #ifdef CEU_ORGS_AWAIT
#ifdef CEU_ADTS_AWAIT
_ceu_trl->is_org = 1;
#endif
#endif
_ceu_trl->org_or_adt = (void*)(&((CEU_Growing*)_ceu_org)->_org_386_11);

#line 141 "garden.ceu"
    return;

case Growing_Awake__ok_killed_19:;

#line 141 "garden.ceu"
    #ifdef CEU_DEBUG_TRAILS
#ifndef CEU_OS
printf("\tOK!\n");
#endif
#endif

#line 141 "garden.ceu"
    }
#line 141 "garden.ceu"
/* CLEAR: Block (141) */
#line 141 "garden.ceu"
    if (0) {

#line 141 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
}

#line 141 "garden.ceu"
    }
#line 141 "garden.ceu"
    }
#line 141 "garden.ceu"
    }
#line 141 "garden.ceu"
/* CLEAR: Block (141) */
#line 141 "garden.ceu"
    {
    /* Reuse current stack frame.
     * We know that CLEAR will not abort anything and return normally.
     * Just save the previous "is_alive", call CLEAR, and restore it.
     */
#ifdef CEU_STACK_CLEAR
    int __ceu_old = _ceu_stk->is_alive;
    _ceu_stk->is_alive = 1;
#endif
    tceu_evt evt;
             evt.id = CEU_IN__CLEAR;
    ceu_sys_go_ex(_ceu_app, &evt,
                  _ceu_stk,
                  _ceu_org,
                  0,
                  2);
#ifdef CEU_STACK_CLEAR
    _ceu_stk->is_alive = __ceu_old;
    ceu_sys_stack_clear(_ceu_stk, _ceu_org,
                        0,1);
#endif
}

#line 141 "garden.ceu"
    #ifdef CEU_ORGS_AWAIT
/* signal ok_killed */
{
    tceu_kill ps = { _ceu_org, _ceu_org->ret, 0,1 };
    tceu_evt evt_;
             evt_.id = CEU_IN__ok_killed;
             evt_.param = &ps;
    ceu_sys_go_ex(_ceu_app, &evt_, _ceu_stk,
                  _ceu_app->data, 0, _ceu_app->data->n);
}
#endif

#line 141 "garden.ceu"
    if (0) {

#line 141 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 141 "garden.ceu"
    }
#line 141 "garden.ceu"
/* CLEAR: Block (141) */
#line 141 "garden.ceu"
    if (0) {

#line 141 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 140 "garden.ceu"
/* PAROR JOIN */
#line 140 "garden.ceu"
    _ceu_lbl = Growing_ParOr_out_18;
goto _CEU_GOTO_;

#line 140 "garden.ceu"
case Growing_ParOr_out_18:;
#line 140 "garden.ceu"
/* CLEAR: ParOr (140) */
#line 140 "garden.ceu"
    {
    /* Reuse current stack frame.
     * We know that CLEAR will not abort anything and return normally.
     * Just save the previous "is_alive", call CLEAR, and restore it.
     */
#ifdef CEU_STACK_CLEAR
    int __ceu_old = _ceu_stk->is_alive;
    _ceu_stk->is_alive = 1;
#endif
    tceu_evt evt;
             evt.id = CEU_IN__CLEAR;
    ceu_sys_go_ex(_ceu_app, &evt,
                  _ceu_stk,
                  _ceu_org,
                  0,
                  5);
#ifdef CEU_STACK_CLEAR
    _ceu_stk->is_alive = __ceu_old;
    ceu_sys_stack_clear(_ceu_stk, _ceu_org,
                        0,4);
#endif
}

#line 140 "garden.ceu"
    #ifdef CEU_ORGS_AWAIT
/* signal ok_killed */
{
    tceu_kill ps = { _ceu_org, _ceu_org->ret, 0,4 };
    tceu_evt evt_;
             evt_.id = CEU_IN__ok_killed;
             evt_.param = &ps;
    ceu_sys_go_ex(_ceu_app, &evt_, _ceu_stk,
                  _ceu_app->data, 0, _ceu_app->data->n);
}
#endif
/* NODE: EmitInt 517 */

#line 178 "garden.ceu"
    {
#ifdef CEU_STACK_CLEAR
    tceu_stk stk_ = { _ceu_stk, _ceu_org, 0, 4, 1 };
#endif

#line 178 "garden.ceu"
    tceu__bool __ceu_ps_517;
{
    tceu__bool __ceu_ps_517_ =
        { (((((CEU_Growing*)_ceu_org)->water)>=8)&&((((CEU_Growing*)_ceu_org)->water)<=16)) };
    __ceu_ps_517 = __ceu_ps_517_;
}

#line 178 "garden.ceu"
        /* trigger the event */
    tceu_evt evt;
    evt.id = 2;
#ifdef CEU_ORGS
#line 178 "garden.ceu"
    evt.org = (tceu_org*) _ceu_org;
#endif

#line 178 "garden.ceu"
        evt.param = (&__ceu_ps_517);

#line 178 "garden.ceu"
        ceu_sys_go_ex(_ceu_app, &evt,
#ifdef CEU_STACK_CLEAR
                  &stk_,
#else
                  NULL,
#endif
                  _ceu_app->data, 0,
#ifdef CEU_ORGS
                  _ceu_app->data->n
#else
                  CEU_NTRAILS
#endif
    );

#ifdef CEU_STACK_CLEAR
    if (!stk_.is_alive) {
        return;
    }
#endif
}

#line 126 "garden.ceu"
    }
#line 126 "garden.ceu"
/* CLEAR: Block (126) */
#line 126 "garden.ceu"
    {
    /* Reuse current stack frame.
     * We know that CLEAR will not abort anything and return normally.
     * Just save the previous "is_alive", call CLEAR, and restore it.
     */
#ifdef CEU_STACK_CLEAR
    int __ceu_old = _ceu_stk->is_alive;
    _ceu_stk->is_alive = 1;
#endif
    tceu_evt evt;
             evt.id = CEU_IN__CLEAR;
    ceu_sys_go_ex(_ceu_app, &evt,
                  _ceu_stk,
                  _ceu_org,
                  0,
                  6);
#ifdef CEU_STACK_CLEAR
    _ceu_stk->is_alive = __ceu_old;
    ceu_sys_stack_clear(_ceu_stk, _ceu_org,
                        0,5);
#endif
}

#line 126 "garden.ceu"
    #ifdef CEU_ORGS_AWAIT
/* signal ok_killed */
{
    tceu_kill ps = { _ceu_org, _ceu_org->ret, 0,5 };
    tceu_evt evt_;
             evt_.id = CEU_IN__ok_killed;
             evt_.param = &ps;
    ceu_sys_go_ex(_ceu_app, &evt_, _ceu_stk,
                  _ceu_app->data, 0, _ceu_app->data->n);
}
#endif

#line 126 "garden.ceu"
    if (0) {

#line 126 "garden.ceu"
case Growing_Block__fin_22:;
#line 126 "garden.ceu"
    if (((CEU_Growing*)_ceu_org)->__fin_519_1) {
    /* NODE: Finally 331 */
/* NODE: Block 330 */

#line 130 "garden.ceu"
    {/* NODE: Stmts 329 */

#line 130 "garden.ceu"
    {/* NODE: EmitExt 328 */

#line 130 "garden.ceu"
        {

#line 130 "garden.ceu"
    tceu__int __ceu_ps_328;
{
    tceu__int __ceu_ps_328_ =
        { (((CEU_Growing*)_ceu_org)->id) };
    __ceu_ps_328 = __ceu_ps_328_;
}

#line 130 "garden.ceu"
    
#if defined(ceu_out_emit_FREE_SPRITE)
    ceu_out_emit_FREE_SPRITE((&__ceu_ps_328))

#elif defined(ceu_out_emit)
    (ceu_out_emit(_ceu_app, CEU_OUT_FREE_SPRITE, sizeof(tceu__int), (void*)(&__ceu_ps_328)))

#else
    #error ceu_out_emit_* is not defined
#endif
;
#line 130 "garden.ceu"
        }

#line 130 "garden.ceu"
    }
#line 130 "garden.ceu"
/* CLEAR: Block (130) */
#line 130 "garden.ceu"
    if (0) {

#line 130 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
}

#line 126 "garden.ceu"
    return;
#line 126 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 118 "garden.ceu"
    }
#line 118 "garden.ceu"
/* CLEAR: Block (118) */
#line 118 "garden.ceu"
    if (0) {

#line 118 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 118 "garden.ceu"
    }
#line 118 "garden.ceu"
/* CLEAR: Block (118) */
#line 118 "garden.ceu"
    if (0) {

#line 118 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 118 "garden.ceu"
    ceu_sys_org_free(_ceu_app, _ceu_org);
#ifdef CEU_ORGS_AWAIT
{
    /* signal ok_killed */
#ifdef CEU_STACK_CLEAR
    tceu_stk stk_ = *_ceu_stk;
             stk_.is_alive = 1;
             stk_.down = _ceu_stk;
#endif
    tceu_kill ps = { _ceu_org, _ceu_org->ret, 0, (tceu_ntrl)(_ceu_org->n-1) };
    tceu_evt evt_;
             evt_.id = CEU_IN__ok_killed;
             evt_.param = &ps;
    ceu_sys_go_ex(_ceu_app, &evt_,
#ifdef CEU_STACK_CLEAR
                  &stk_,
#else
                  NULL,
#endif
                  _ceu_app->data, 0, _ceu_app->data->n);
}
#endif

#line 118 "garden.ceu"
    return;/* NODE: Dcl_cls 5 */

#line 188 "garden.ceu"
case Class_Philodendron:;/* NODE: Block 4938 */

#line 188 "garden.ceu"
    {/* NODE: Stmts 4937 */

#line 188 "garden.ceu"
    {/* NODE: Block 4710 */

#line 188 "garden.ceu"
    {/* NODE: Stmts 4939 */

#line 188 "garden.ceu"
    {/* NODE: Block 707 */

#line 193 "garden.ceu"
    /*  FINALIZE */
_ceu_org->trls[ 4 ].evt = CEU_IN__CLEAR;
_ceu_org->trls[ 4 ].lbl = Philodendron_Block__fin_32;

#line 193 "garden.ceu"
    ((CEU_Philodendron*)_ceu_org)->__fin_707_1 = 0;
#line 193 "garden.ceu"
    {/* NODE: Stmts 706 */

#line 193 "garden.ceu"
    {/* NODE: Set 4723 */

#line 193 "garden.ceu"
/* SET: idx *//* NODE: NUMBER 532 */

#line 193 "garden.ceu"
    plot_occupied[(((CEU_Philodendron*)_ceu_org)->plot)] = 1;/* NODE: Finalize 542 */

#line 194 "garden.ceu"
    ((CEU_Philodendron*)_ceu_org)->__fin_707_1 = 1;/* NODE: Stmts 4729 */

#line 197 "garden.ceu"
    {/* NODE: Dcl_var 4726 */
/* NODE: Set 4730 */

#line 197 "garden.ceu"
/* SET: x *//* NODE: Op2_idx 546 */

#line 197 "garden.ceu"
    (((CEU_Philodendron*)_ceu_org)->x) = plot_x[(((CEU_Philodendron*)_ceu_org)->plot)];
#line 197 "garden.ceu"
    }/* NODE: Stmts 4735 */

#line 198 "garden.ceu"
    {/* NODE: Dcl_var 4732 */
/* NODE: Set 4736 */

#line 198 "garden.ceu"
/* SET: y *//* NODE: Op2_idx 551 */

#line 198 "garden.ceu"
    (((CEU_Philodendron*)_ceu_org)->y) = plot_y[(((CEU_Philodendron*)_ceu_org)->plot)];
#line 198 "garden.ceu"
    }/* NODE: Stmts 4741 */

#line 199 "garden.ceu"
    {/* NODE: Dcl_var 4738 */
/* NODE: Set 4742 */

#line 199 "garden.ceu"
/* SET: layer *//* NODE: Op2_idx 556 */

#line 199 "garden.ceu"
    (((CEU_Philodendron*)_ceu_org)->layer) = plot_layer[(((CEU_Philodendron*)_ceu_org)->plot)];
#line 199 "garden.ceu"
    }/* NODE: ParOr 705 */

#line 200 "garden.ceu"
/* ParOr: spawn subs */
#line 200 "garden.ceu"
    {
#ifdef CEU_STACK_CLEAR
    tceu_stk stk_ = { _ceu_stk, _ceu_org, 0, 3, 1 };
#endif

#line 200 "garden.ceu"
        _ceu_org->trls[ 0 ].lbl = Philodendron_ParOr_sub_1_24;
    ceu_app_go(_ceu_app,NULL,_ceu_org,
               &_ceu_org->trls[ 0 ],
#ifdef CEU_STACK_CLEAR
               &stk_
#else
               NULL
#endif
              );

#ifdef CEU_STACK_CLEAR
    if (!stk_.is_alive) {
        return;
    }
#endif

#line 200 "garden.ceu"
        _ceu_trl = &_ceu_org->trls[ 1 ];

#line 200 "garden.ceu"
    }
/* NODE: Block 704 */

#line 209 "garden.ceu"
    {
#line 209 "garden.ceu"
    #ifdef CEU_ORGS
_ceu_org->trls[ 1 ].evt = CEU_IN__ORG;
_ceu_org->trls[ 1 ].org = NULL;
#endif

#line 209 "garden.ceu"
    _ceu_trl = &_ceu_org->trls[ 2 ];
/* NODE: Stmts 703 */

#line 209 "garden.ceu"
    {/* NODE: Dcl_var 601 */

#line 209 "garden.ceu"
/* start org: growing */
#line 209 "garden.ceu"
        /* resets org memory and starts org.trail[0]=Class_XXX */
    /* TODO: BUG: _ceu_org is not necessarily the parent for pool allocations */
    ceu_out_org_init(_ceu_app, ((tceu_org*) &(((CEU_Philodendron*)_ceu_org)->growing_10)),7,Class_Growing,
                     4,
                     0,
                     _ceu_org,1);
/* TODO: currently idx is always "1" for all interfaces access because pools 
 * are all together there. When we have separate trls for pools, we'll have to 
 * indirectly access the offset in the interface. */

#line 209 "garden.ceu"
        _ceu_constr_600(_ceu_app, ((tceu_org*) &(((CEU_Philodendron*)_ceu_org)->growing_10)), _ceu_org);

#line 209 "garden.ceu"
    {
#ifdef CEU_STACK_CLEAR
    tceu_stk stk_ = { _ceu_stk, _ceu_org, 2, 3, 1 };
    ceu_app_go(_ceu_app,NULL,
               ((tceu_org*) &(((CEU_Philodendron*)_ceu_org)->growing_10)), &((tceu_org*) &(((CEU_Philodendron*)_ceu_org)->growing_10))->trls[0],
               &stk_);
    if (!stk_.is_alive) {
        return;
    }
#else
    ceu_app_go(_ceu_app,NULL,
               ((tceu_org*) &(((CEU_Philodendron*)_ceu_org)->growing_10)), &((tceu_org*) &(((CEU_Philodendron*)_ceu_org)->growing_10))->trls[0],
               NULL);
#endif

#line 209 "garden.ceu"
    }
/* NODE: Stmts 4811 */

#line 215 "garden.ceu"
    {/* NODE: Dcl_var 4808 */
/* NODE: Set 4812 */

#line 215 "garden.ceu"
/* SET: survived *//* NODE: NUMBER 603 */

#line 215 "garden.ceu"
    (((CEU_Philodendron*)_ceu_org)->survived_11) = 0;
#line 215 "garden.ceu"
    }/* NODE: ParOr 637 */

#line 216 "garden.ceu"
/* ParOr: spawn subs */
#line 216 "garden.ceu"
    {
#ifdef CEU_STACK_CLEAR
    tceu_stk stk_ = { _ceu_stk, _ceu_org, 2, 3, 1 };
#endif

#line 216 "garden.ceu"
        _ceu_org->trls[ 2 ].lbl = Philodendron_ParOr_sub_1_27;
    ceu_app_go(_ceu_app,NULL,_ceu_org,
               &_ceu_org->trls[ 2 ],
#ifdef CEU_STACK_CLEAR
               &stk_
#else
               NULL
#endif
              );

#ifdef CEU_STACK_CLEAR
    if (!stk_.is_alive) {
        return;
    }
#endif

#line 216 "garden.ceu"
        _ceu_trl = &_ceu_org->trls[ 3 ];

#line 216 "garden.ceu"
    }
/* NODE: Block 636 */

#line 225 "garden.ceu"
    {/* NODE: Stmts 635 */

#line 225 "garden.ceu"
    {/* NODE: Stmts 4918 */

#line 225 "garden.ceu"
    {/* NODE: Nothing 4876 */
/* NODE: Set 4875 */

#line 225 "garden.ceu"
/* SET: table: 0x8fb3e0 *//* NODE: Await 633 */

#line 225 "garden.ceu"
    _CEU_NO_633_:
if (0) { goto _CEU_NO_633_; /* avoids "not used" warning */ }

#line 225 "garden.ceu"
    _ceu_trl->evt = 2;
_ceu_trl->lbl = Philodendron_Awake_ok_30;
_ceu_trl->seqno = _ceu_app->seqno;

#line 225 "garden.ceu"
    #ifdef CEU_ORGS
_ceu_trl->evto  = (&((CEU_Philodendron*)_ceu_org)->growing_10);
#endif

#line 225 "garden.ceu"
    return;

case Philodendron_Awake_ok_30:;

#line 225 "garden.ceu"
    #ifdef CEU_DEBUG_TRAILS
#ifndef CEU_OS
printf("\tOK!\n");
#endif
#endif

#line 225 "garden.ceu"
    {

#line 225 "garden.ceu"
        tceu__bool* __ceu_casted = (tceu__bool*) _ceu_evt->param;

#line 225 "garden.ceu"
        (((CEU_Philodendron*)_ceu_org)->survived_11) = ((__ceu_casted)->_1);
}
/* NODE: Nothing 8152 */
/* NODE: Nothing 8153 */

#line 225 "garden.ceu"
    }
#line 225 "garden.ceu"
    }
#line 225 "garden.ceu"
/* CLEAR: Block (225) */
#line 225 "garden.ceu"
    if (0) {

#line 225 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 216 "garden.ceu"
/* PAROR JOIN */
#line 216 "garden.ceu"
    _ceu_lbl = Philodendron_ParOr_out_28;
goto _CEU_GOTO_;

#line 216 "garden.ceu"
case Philodendron_ParOr_sub_1_27:;/* NODE: Block 629 */

#line 217 "garden.ceu"
    {/* NODE: Stmts 628 */

#line 217 "garden.ceu"
    {/* NODE: Block 4816 */

#line 217 "garden.ceu"
    {/* NODE: Stmts 4815 */

#line 217 "garden.ceu"
    {/* NODE: Stmts 4814 */

#line 217 "garden.ceu"
    {
#line 217 "garden.ceu"
    }/* NODE: Loop 4813 */

#line 217 "garden.ceu"
    for (;;) {
/* NODE: Block 626 */

#line 218 "garden.ceu"
    {
#line 218 "garden.ceu"
    int __ceu_incoming_plot_12;
/* NODE: Stmts 625 */

#line 218 "garden.ceu"
    {/* NODE: Stmts 4821 */

#line 218 "garden.ceu"
    {/* NODE: Dcl_var 4818 */
/* NODE: Stmts 4866 */

#line 218 "garden.ceu"
    {/* NODE: Nothing 4824 */
/* NODE: Set 4823 */

#line 218 "garden.ceu"
/* SET: table: 0xf42670 *//* NODE: Await 608 */

#line 218 "garden.ceu"
    _CEU_NO_608_:
if (0) { goto _CEU_NO_608_; /* avoids "not used" warning */ }

#line 218 "garden.ceu"
    _ceu_trl->evt = 3;
_ceu_trl->lbl = Philodendron_Awake_go_water_29;
_ceu_trl->seqno = _ceu_app->seqno;

#line 218 "garden.ceu"
    #ifdef CEU_ORGS
_ceu_trl->evto  = (((CEU_Philodendron*)_ceu_org)->garden);
#endif

#line 218 "garden.ceu"
    return;

case Philodendron_Awake_go_water_29:;

#line 218 "garden.ceu"
    #ifdef CEU_DEBUG_TRAILS
#ifndef CEU_OS
printf("\tOK!\n");
#endif
#endif

#line 218 "garden.ceu"
    {

#line 218 "garden.ceu"
        tceu__int* __ceu_casted = (tceu__int*) _ceu_evt->param;

#line 218 "garden.ceu"
        (__ceu_incoming_plot_12) = ((__ceu_casted)->_1);
}
/* NODE: Nothing 8148 */
/* NODE: Nothing 8149 */

#line 218 "garden.ceu"
    }
#line 218 "garden.ceu"
    }/* NODE: If 4872 */

#line 219 "garden.ceu"
    if (((__ceu_incoming_plot_12)==(((CEU_Philodendron*)_ceu_org)->plot))) {
/* NODE: Block 623 */

#line 220 "garden.ceu"
    {/* NODE: Stmts 622 */

#line 220 "garden.ceu"
    {/* NODE: CallStmt 618 */

#line 220 "garden.ceu"
    printf("watering the philodendron growing in %d\n",(((CEU_Philodendron*)_ceu_org)->plot));/* NODE: EmitInt 621 */

#line 221 "garden.ceu"
    {
#ifdef CEU_STACK_CLEAR
    tceu_stk stk_ = { _ceu_stk, _ceu_org, 2, 2, 1 };
#endif

#line 221 "garden.ceu"
        /* trigger the event */
    tceu_evt evt;
    evt.id = 1;
#ifdef CEU_ORGS
#line 221 "garden.ceu"
    evt.org = (tceu_org*) (&((CEU_Philodendron*)_ceu_org)->growing_10);
#endif

#line 221 "garden.ceu"
        ceu_sys_go_ex(_ceu_app, &evt,
#ifdef CEU_STACK_CLEAR
                  &stk_,
#else
                  NULL,
#endif
                  _ceu_app->data, 0,
#ifdef CEU_ORGS
                  _ceu_app->data->n
#else
                  CEU_NTRAILS
#endif
    );

#ifdef CEU_STACK_CLEAR
    if (!stk_.is_alive) {
        return;
    }
#endif
}

#line 220 "garden.ceu"
    }
#line 220 "garden.ceu"
/* CLEAR: Block (220) */
#line 220 "garden.ceu"
    if (0) {

#line 220 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
} else {
/* NODE: Nothing 4871 */
}

#line 218 "garden.ceu"
    }
#line 218 "garden.ceu"
/* CLEAR: Block (218) */
#line 218 "garden.ceu"
    if (0) {

#line 218 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 217 "garden.ceu"
    }

#line 217 "garden.ceu"
    }
#line 217 "garden.ceu"
/* CLEAR: Block (217) */
#line 217 "garden.ceu"
    if (0) {

#line 217 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 217 "garden.ceu"
    }
#line 217 "garden.ceu"
/* CLEAR: Block (217) */
#line 217 "garden.ceu"
    if (0) {

#line 217 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 216 "garden.ceu"
case Philodendron_ParOr_out_28:;
#line 216 "garden.ceu"
/* CLEAR: ParOr (216) */
#line 216 "garden.ceu"
    {
    /* Reuse current stack frame.
     * We know that CLEAR will not abort anything and return normally.
     * Just save the previous "is_alive", call CLEAR, and restore it.
     */
#ifdef CEU_STACK_CLEAR
    int __ceu_old = _ceu_stk->is_alive;
    _ceu_stk->is_alive = 1;
#endif
    tceu_evt evt;
             evt.id = CEU_IN__CLEAR;
    ceu_sys_go_ex(_ceu_app, &evt,
                  _ceu_stk,
                  _ceu_org,
                  2,
                  4);
#ifdef CEU_STACK_CLEAR
    _ceu_stk->is_alive = __ceu_old;
    ceu_sys_stack_clear(_ceu_stk, _ceu_org,
                        2,3);
#endif
}
/* NODE: If 4924 */

#line 227 "garden.ceu"
    if ((((CEU_Philodendron*)_ceu_org)->survived_11)) {
/* NODE: Block 701 */

#line 228 "garden.ceu"
    /*  FINALIZE */
_ceu_org->trls[ 3 ].evt = CEU_IN__CLEAR;
_ceu_org->trls[ 3 ].lbl = Philodendron_Block__fin_31;

#line 228 "garden.ceu"
    ((CEU_Philodendron*)_ceu_org)->__fin_701_1 = 0;
#line 228 "garden.ceu"
    ((CEU_Philodendron*)_ceu_org)->__fin_701_2 = 0;
#line 228 "garden.ceu"
    {/* NODE: Stmts 700 */

#line 228 "garden.ceu"
    {/* NODE: Set 4925 */

#line 228 "garden.ceu"
/* SET: . *//* NODE: Op2_+ 644 */

#line 228 "garden.ceu"
    (((*((CEU_Philodendron*)_ceu_org)->garden).t0_plants)) = ((((*((CEU_Philodendron*)_ceu_org)->garden).t0_plants))+1);/* NODE: Set 4926 */

#line 229 "garden.ceu"
/* SET: . *//* NODE: Op2_+ 651 */

#line 229 "garden.ceu"
    (((*((CEU_Philodendron*)_ceu_org)->garden).score)) = ((((*((CEU_Philodendron*)_ceu_org)->garden).score))+0.25);/* NODE: Finalize 670 */

#line 230 "garden.ceu"
    ((CEU_Philodendron*)_ceu_org)->__fin_701_2 = 1;/* NODE: Stmts 4933 */

#line 234 "garden.ceu"
    {/* NODE: Dcl_var 4930 */
/* NODE: Set 4934 */

#line 234 "garden.ceu"
/* SET: id *//* NODE: Var 672 */

#line 234 "garden.ceu"
    (((CEU_Philodendron*)_ceu_org)->id_13) = (*((CEU_Philodendron*)_ceu_org)->gensym);
#line 234 "garden.ceu"
    }/* NODE: Set 4935 */

#line 235 "garden.ceu"
/* SET: gensym *//* NODE: Op2_+ 677 */

#line 235 "garden.ceu"
    (*((CEU_Philodendron*)_ceu_org)->gensym) = ((*((CEU_Philodendron*)_ceu_org)->gensym)+1);/* NODE: EmitExt 686 */

#line 236 "garden.ceu"
        {

#line 236 "garden.ceu"
    tceu__int__int__int__int__int __ceu_ps_686;
{
    tceu__int__int__int__int__int __ceu_ps_686_ =
        { (((CEU_Philodendron*)_ceu_org)->id_13),(((CEU_Philodendron*)_ceu_org)->x),(((CEU_Philodendron*)_ceu_org)->y),9,(((CEU_Philodendron*)_ceu_org)->layer) };
    __ceu_ps_686 = __ceu_ps_686_;
}

#line 236 "garden.ceu"
    
#if defined(ceu_out_emit_NEW_SPRITE)
    ceu_out_emit_NEW_SPRITE((&__ceu_ps_686))

#elif defined(ceu_out_emit)
    (ceu_out_emit(_ceu_app, CEU_OUT_NEW_SPRITE, sizeof(tceu__int__int__int__int__int), (void*)(&__ceu_ps_686)))

#else
    #error ceu_out_emit_* is not defined
#endif
;
#line 236 "garden.ceu"
        }
/* NODE: Finalize 698 */

#line 237 "garden.ceu"
    ((CEU_Philodendron*)_ceu_org)->__fin_701_1 = 1;/* NODE: AwaitN 699 */

#line 241 "garden.ceu"
    return;
#line 228 "garden.ceu"
    }
#line 228 "garden.ceu"
/* CLEAR: Block (228) */
#line 228 "garden.ceu"
    if (0) {

#line 228 "garden.ceu"
case Philodendron_Block__fin_31:;
#line 228 "garden.ceu"
    if (((CEU_Philodendron*)_ceu_org)->__fin_701_1) {
    /* NODE: Finally 697 */
/* NODE: Block 696 */

#line 238 "garden.ceu"
    {/* NODE: Stmts 695 */

#line 238 "garden.ceu"
    {/* NODE: CallStmt 691 */

#line 238 "garden.ceu"
    printf("flouishing over\n");/* NODE: EmitExt 694 */

#line 239 "garden.ceu"
        {

#line 239 "garden.ceu"
    tceu__int __ceu_ps_694;
{
    tceu__int __ceu_ps_694_ =
        { (((CEU_Philodendron*)_ceu_org)->id_13) };
    __ceu_ps_694 = __ceu_ps_694_;
}

#line 239 "garden.ceu"
    
#if defined(ceu_out_emit_FREE_SPRITE)
    ceu_out_emit_FREE_SPRITE((&__ceu_ps_694))

#elif defined(ceu_out_emit)
    (ceu_out_emit(_ceu_app, CEU_OUT_FREE_SPRITE, sizeof(tceu__int), (void*)(&__ceu_ps_694)))

#else
    #error ceu_out_emit_* is not defined
#endif
;
#line 239 "garden.ceu"
        }

#line 238 "garden.ceu"
    }
#line 238 "garden.ceu"
/* CLEAR: Block (238) */
#line 238 "garden.ceu"
    if (0) {

#line 238 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
}

#line 228 "garden.ceu"
    if (((CEU_Philodendron*)_ceu_org)->__fin_701_2) {
    /* NODE: Finally 669 */
/* NODE: Block 668 */

#line 231 "garden.ceu"
    {/* NODE: Stmts 667 */

#line 231 "garden.ceu"
    {/* NODE: Set 4927 */

#line 231 "garden.ceu"
/* SET: . *//* NODE: Op2_- 658 */

#line 231 "garden.ceu"
    (((*((CEU_Philodendron*)_ceu_org)->garden).t0_plants)) = ((((*((CEU_Philodendron*)_ceu_org)->garden).t0_plants))-1);/* NODE: Set 4928 */

#line 232 "garden.ceu"
/* SET: . *//* NODE: Op2_- 665 */

#line 232 "garden.ceu"
    (((*((CEU_Philodendron*)_ceu_org)->garden).score)) = ((((*((CEU_Philodendron*)_ceu_org)->garden).score))-0.25);
#line 231 "garden.ceu"
    }
#line 231 "garden.ceu"
/* CLEAR: Block (231) */
#line 231 "garden.ceu"
    if (0) {

#line 231 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
}

#line 228 "garden.ceu"
    return;
#line 228 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
} else {
/* NODE: Nothing 4923 */
}

#line 209 "garden.ceu"
    }
#line 209 "garden.ceu"
/* CLEAR: Block (209) */
#line 209 "garden.ceu"
    {
    /* Reuse current stack frame.
     * We know that CLEAR will not abort anything and return normally.
     * Just save the previous "is_alive", call CLEAR, and restore it.
     */
#ifdef CEU_STACK_CLEAR
    int __ceu_old = _ceu_stk->is_alive;
    _ceu_stk->is_alive = 1;
#endif
    tceu_evt evt;
             evt.id = CEU_IN__CLEAR;
    ceu_sys_go_ex(_ceu_app, &evt,
                  _ceu_stk,
                  _ceu_org,
                  1,
                  4);
#ifdef CEU_STACK_CLEAR
    _ceu_stk->is_alive = __ceu_old;
    ceu_sys_stack_clear(_ceu_stk, _ceu_org,
                        1,3);
#endif
}

#line 209 "garden.ceu"
    #ifdef CEU_ORGS_AWAIT
/* signal ok_killed */
{
    tceu_kill ps = { _ceu_org, _ceu_org->ret, 1,3 };
    tceu_evt evt_;
             evt_.id = CEU_IN__ok_killed;
             evt_.param = &ps;
    ceu_sys_go_ex(_ceu_app, &evt_, _ceu_stk,
                  _ceu_app->data, 0, _ceu_app->data->n);
}
#endif

#line 209 "garden.ceu"
    if (0) {

#line 209 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 200 "garden.ceu"
/* PAROR JOIN */
#line 200 "garden.ceu"
    _ceu_lbl = Philodendron_ParOr_out_25;
goto _CEU_GOTO_;

#line 200 "garden.ceu"
case Philodendron_ParOr_sub_1_24:;/* NODE: Block 579 */

#line 201 "garden.ceu"
    {/* NODE: Stmts 578 */

#line 201 "garden.ceu"
    {/* NODE: Block 4746 */

#line 201 "garden.ceu"
    {/* NODE: Stmts 4745 */

#line 201 "garden.ceu"
    {/* NODE: Stmts 4744 */

#line 201 "garden.ceu"
    {
#line 201 "garden.ceu"
    }/* NODE: Loop 4743 */

#line 201 "garden.ceu"
    for (;;) {
/* NODE: Block 576 */

#line 202 "garden.ceu"
    {
#line 202 "garden.ceu"
    int __ceu_incoming_plot_9;
/* NODE: Stmts 575 */

#line 202 "garden.ceu"
    {/* NODE: Stmts 4751 */

#line 202 "garden.ceu"
    {/* NODE: Dcl_var 4748 */
/* NODE: Stmts 4796 */

#line 202 "garden.ceu"
    {/* NODE: Nothing 4754 */
/* NODE: Set 4753 */

#line 202 "garden.ceu"
/* SET: table: 0xf365c0 *//* NODE: Await 561 */

#line 202 "garden.ceu"
    _CEU_NO_561_:
if (0) { goto _CEU_NO_561_; /* avoids "not used" warning */ }

#line 202 "garden.ceu"
    _ceu_trl->evt = 1;
_ceu_trl->lbl = Philodendron_Awake_go_dig_26;
_ceu_trl->seqno = _ceu_app->seqno;

#line 202 "garden.ceu"
    #ifdef CEU_ORGS
_ceu_trl->evto  = (((CEU_Philodendron*)_ceu_org)->garden);
#endif

#line 202 "garden.ceu"
    return;

case Philodendron_Awake_go_dig_26:;

#line 202 "garden.ceu"
    #ifdef CEU_DEBUG_TRAILS
#ifndef CEU_OS
printf("\tOK!\n");
#endif
#endif

#line 202 "garden.ceu"
    {

#line 202 "garden.ceu"
        tceu__int* __ceu_casted = (tceu__int*) _ceu_evt->param;

#line 202 "garden.ceu"
        (__ceu_incoming_plot_9) = ((__ceu_casted)->_1);
}
/* NODE: Nothing 8141 */
/* NODE: Nothing 8142 */

#line 202 "garden.ceu"
    }
#line 202 "garden.ceu"
    }/* NODE: If 4802 */

#line 203 "garden.ceu"
    if (((__ceu_incoming_plot_9)==(((CEU_Philodendron*)_ceu_org)->plot))) {
/* NODE: Block 573 */

#line 204 "garden.ceu"
    {/* NODE: Stmts 572 */

#line 204 "garden.ceu"
    {/* NODE: CallStmt 570 */

#line 204 "garden.ceu"
    printf("Philodendron is dug up!\n");/* NODE: Break 571 */

#line 205 "garden.ceu"
    break;
#line 204 "garden.ceu"
    }
#line 204 "garden.ceu"
/* CLEAR: Block (204) */
#line 204 "garden.ceu"
    if (0) {

#line 204 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
} else {
/* NODE: Nothing 4801 */
}

#line 202 "garden.ceu"
    }
#line 202 "garden.ceu"
/* CLEAR: Block (202) */
#line 202 "garden.ceu"
    if (0) {

#line 202 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 201 "garden.ceu"
    }

#line 201 "garden.ceu"
/* CLEAR: Loop (201) */
#line 201 "garden.ceu"
    }
#line 201 "garden.ceu"
/* CLEAR: Block (201) */
#line 201 "garden.ceu"
    if (0) {

#line 201 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 201 "garden.ceu"
    }
#line 201 "garden.ceu"
/* CLEAR: Block (201) */
#line 201 "garden.ceu"
    if (0) {

#line 201 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 200 "garden.ceu"
/* PAROR JOIN */
#line 200 "garden.ceu"
    _ceu_lbl = Philodendron_ParOr_out_25;
goto _CEU_GOTO_;

#line 200 "garden.ceu"
case Philodendron_ParOr_out_25:;
#line 200 "garden.ceu"
/* CLEAR: ParOr (200) */
#line 200 "garden.ceu"
    {
    /* Reuse current stack frame.
     * We know that CLEAR will not abort anything and return normally.
     * Just save the previous "is_alive", call CLEAR, and restore it.
     */
#ifdef CEU_STACK_CLEAR
    int __ceu_old = _ceu_stk->is_alive;
    _ceu_stk->is_alive = 1;
#endif
    tceu_evt evt;
             evt.id = CEU_IN__CLEAR;
    ceu_sys_go_ex(_ceu_app, &evt,
                  _ceu_stk,
                  _ceu_org,
                  0,
                  4);
#ifdef CEU_STACK_CLEAR
    _ceu_stk->is_alive = __ceu_old;
    ceu_sys_stack_clear(_ceu_stk, _ceu_org,
                        0,3);
#endif
}

#line 200 "garden.ceu"
    #ifdef CEU_ORGS_AWAIT
/* signal ok_killed */
{
    tceu_kill ps = { _ceu_org, _ceu_org->ret, 0,3 };
    tceu_evt evt_;
             evt_.id = CEU_IN__ok_killed;
             evt_.param = &ps;
    ceu_sys_go_ex(_ceu_app, &evt_, _ceu_stk,
                  _ceu_app->data, 0, _ceu_app->data->n);
}
#endif

#line 193 "garden.ceu"
    }
#line 193 "garden.ceu"
/* CLEAR: Block (193) */
#line 193 "garden.ceu"
    {
    /* Reuse current stack frame.
     * We know that CLEAR will not abort anything and return normally.
     * Just save the previous "is_alive", call CLEAR, and restore it.
     */
#ifdef CEU_STACK_CLEAR
    int __ceu_old = _ceu_stk->is_alive;
    _ceu_stk->is_alive = 1;
#endif
    tceu_evt evt;
             evt.id = CEU_IN__CLEAR;
    ceu_sys_go_ex(_ceu_app, &evt,
                  _ceu_stk,
                  _ceu_org,
                  0,
                  5);
#ifdef CEU_STACK_CLEAR
    _ceu_stk->is_alive = __ceu_old;
    ceu_sys_stack_clear(_ceu_stk, _ceu_org,
                        0,4);
#endif
}

#line 193 "garden.ceu"
    #ifdef CEU_ORGS_AWAIT
/* signal ok_killed */
{
    tceu_kill ps = { _ceu_org, _ceu_org->ret, 0,4 };
    tceu_evt evt_;
             evt_.id = CEU_IN__ok_killed;
             evt_.param = &ps;
    ceu_sys_go_ex(_ceu_app, &evt_, _ceu_stk,
                  _ceu_app->data, 0, _ceu_app->data->n);
}
#endif

#line 193 "garden.ceu"
    if (0) {

#line 193 "garden.ceu"
case Philodendron_Block__fin_32:;
#line 193 "garden.ceu"
    if (((CEU_Philodendron*)_ceu_org)->__fin_707_1) {
    /* NODE: Finally 541 */
/* NODE: Block 540 */

#line 195 "garden.ceu"
    {/* NODE: Stmts 539 */

#line 195 "garden.ceu"
    {/* NODE: Set 4724 */

#line 195 "garden.ceu"
/* SET: idx *//* NODE: NUMBER 537 */

#line 195 "garden.ceu"
    plot_occupied[(((CEU_Philodendron*)_ceu_org)->plot)] = 0;
#line 195 "garden.ceu"
    }
#line 195 "garden.ceu"
/* CLEAR: Block (195) */
#line 195 "garden.ceu"
    if (0) {

#line 195 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
}

#line 193 "garden.ceu"
    return;
#line 193 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 188 "garden.ceu"
    }
#line 188 "garden.ceu"
/* CLEAR: Block (188) */
#line 188 "garden.ceu"
    if (0) {

#line 188 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 188 "garden.ceu"
    }
#line 188 "garden.ceu"
/* CLEAR: Block (188) */
#line 188 "garden.ceu"
    if (0) {

#line 188 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 188 "garden.ceu"
    ceu_sys_org_free(_ceu_app, _ceu_org);
#ifdef CEU_ORGS_AWAIT
{
    /* signal ok_killed */
#ifdef CEU_STACK_CLEAR
    tceu_stk stk_ = *_ceu_stk;
             stk_.is_alive = 1;
             stk_.down = _ceu_stk;
#endif
    tceu_kill ps = { _ceu_org, _ceu_org->ret, 0, (tceu_ntrl)(_ceu_org->n-1) };
    tceu_evt evt_;
             evt_.id = CEU_IN__ok_killed;
             evt_.param = &ps;
    ceu_sys_go_ex(_ceu_app, &evt_,
#ifdef CEU_STACK_CLEAR
                  &stk_,
#else
                  NULL,
#endif
                  _ceu_app->data, 0, _ceu_app->data->n);
}
#endif

#line 188 "garden.ceu"
    return;/* NODE: Dcl_cls 6 */

#line 246 "garden.ceu"
case Class_Pitcher:;/* NODE: Block 5174 */

#line 246 "garden.ceu"
    {/* NODE: Stmts 5173 */

#line 246 "garden.ceu"
    {/* NODE: Block 4946 */

#line 246 "garden.ceu"
    {/* NODE: Stmts 5175 */

#line 246 "garden.ceu"
    {/* NODE: Block 888 */

#line 251 "garden.ceu"
    /*  FINALIZE */
_ceu_org->trls[ 4 ].evt = CEU_IN__CLEAR;
_ceu_org->trls[ 4 ].lbl = Pitcher_Block__fin_42;

#line 251 "garden.ceu"
    ((CEU_Pitcher*)_ceu_org)->__fin_888_1 = 0;
#line 251 "garden.ceu"
    {/* NODE: Stmts 887 */

#line 251 "garden.ceu"
    {/* NODE: Set 4959 */

#line 251 "garden.ceu"
/* SET: idx *//* NODE: NUMBER 719 */

#line 251 "garden.ceu"
    plot_occupied[(((CEU_Pitcher*)_ceu_org)->plot)] = 1;/* NODE: Finalize 729 */

#line 252 "garden.ceu"
    ((CEU_Pitcher*)_ceu_org)->__fin_888_1 = 1;/* NODE: Stmts 4965 */

#line 255 "garden.ceu"
    {/* NODE: Dcl_var 4962 */
/* NODE: Set 4966 */

#line 255 "garden.ceu"
/* SET: x *//* NODE: Op2_idx 733 */

#line 255 "garden.ceu"
    (((CEU_Pitcher*)_ceu_org)->x) = plot_x[(((CEU_Pitcher*)_ceu_org)->plot)];
#line 255 "garden.ceu"
    }/* NODE: Stmts 4971 */

#line 256 "garden.ceu"
    {/* NODE: Dcl_var 4968 */
/* NODE: Set 4972 */

#line 256 "garden.ceu"
/* SET: y *//* NODE: Op2_idx 738 */

#line 256 "garden.ceu"
    (((CEU_Pitcher*)_ceu_org)->y) = plot_y[(((CEU_Pitcher*)_ceu_org)->plot)];
#line 256 "garden.ceu"
    }/* NODE: Stmts 4977 */

#line 257 "garden.ceu"
    {/* NODE: Dcl_var 4974 */
/* NODE: Set 4978 */

#line 257 "garden.ceu"
/* SET: layer *//* NODE: Op2_idx 743 */

#line 257 "garden.ceu"
    (((CEU_Pitcher*)_ceu_org)->layer) = plot_layer[(((CEU_Pitcher*)_ceu_org)->plot)];
#line 257 "garden.ceu"
    }/* NODE: ParOr 886 */

#line 258 "garden.ceu"
/* ParOr: spawn subs */
#line 258 "garden.ceu"
    {
#ifdef CEU_STACK_CLEAR
    tceu_stk stk_ = { _ceu_stk, _ceu_org, 0, 3, 1 };
#endif

#line 258 "garden.ceu"
        _ceu_org->trls[ 0 ].lbl = Pitcher_ParOr_sub_1_34;
    ceu_app_go(_ceu_app,NULL,_ceu_org,
               &_ceu_org->trls[ 0 ],
#ifdef CEU_STACK_CLEAR
               &stk_
#else
               NULL
#endif
              );

#ifdef CEU_STACK_CLEAR
    if (!stk_.is_alive) {
        return;
    }
#endif

#line 258 "garden.ceu"
        _ceu_trl = &_ceu_org->trls[ 1 ];

#line 258 "garden.ceu"
    }
/* NODE: Block 885 */

#line 267 "garden.ceu"
    {
#line 267 "garden.ceu"
    #ifdef CEU_ORGS
_ceu_org->trls[ 1 ].evt = CEU_IN__ORG;
_ceu_org->trls[ 1 ].org = NULL;
#endif

#line 267 "garden.ceu"
    _ceu_trl = &_ceu_org->trls[ 2 ];
/* NODE: Stmts 884 */

#line 267 "garden.ceu"
    {/* NODE: Dcl_var 788 */

#line 267 "garden.ceu"
/* start org: growing */
#line 267 "garden.ceu"
        /* resets org memory and starts org.trail[0]=Class_XXX */
    /* TODO: BUG: _ceu_org is not necessarily the parent for pool allocations */
    ceu_out_org_init(_ceu_app, ((tceu_org*) &(((CEU_Pitcher*)_ceu_org)->growing_10)),7,Class_Growing,
                     4,
                     0,
                     _ceu_org,1);
/* TODO: currently idx is always "1" for all interfaces access because pools 
 * are all together there. When we have separate trls for pools, we'll have to 
 * indirectly access the offset in the interface. */

#line 267 "garden.ceu"
        _ceu_constr_787(_ceu_app, ((tceu_org*) &(((CEU_Pitcher*)_ceu_org)->growing_10)), _ceu_org);

#line 267 "garden.ceu"
    {
#ifdef CEU_STACK_CLEAR
    tceu_stk stk_ = { _ceu_stk, _ceu_org, 2, 3, 1 };
    ceu_app_go(_ceu_app,NULL,
               ((tceu_org*) &(((CEU_Pitcher*)_ceu_org)->growing_10)), &((tceu_org*) &(((CEU_Pitcher*)_ceu_org)->growing_10))->trls[0],
               &stk_);
    if (!stk_.is_alive) {
        return;
    }
#else
    ceu_app_go(_ceu_app,NULL,
               ((tceu_org*) &(((CEU_Pitcher*)_ceu_org)->growing_10)), &((tceu_org*) &(((CEU_Pitcher*)_ceu_org)->growing_10))->trls[0],
               NULL);
#endif

#line 267 "garden.ceu"
    }
/* NODE: Stmts 5047 */

#line 273 "garden.ceu"
    {/* NODE: Dcl_var 5044 */
/* NODE: Set 5048 */

#line 273 "garden.ceu"
/* SET: survived *//* NODE: NUMBER 790 */

#line 273 "garden.ceu"
    (((CEU_Pitcher*)_ceu_org)->survived_11) = 0;
#line 273 "garden.ceu"
    }/* NODE: ParOr 818 */

#line 274 "garden.ceu"
/* ParOr: spawn subs */
#line 274 "garden.ceu"
    {
#ifdef CEU_STACK_CLEAR
    tceu_stk stk_ = { _ceu_stk, _ceu_org, 2, 3, 1 };
#endif

#line 274 "garden.ceu"
        _ceu_org->trls[ 2 ].lbl = Pitcher_ParOr_sub_1_37;
    ceu_app_go(_ceu_app,NULL,_ceu_org,
               &_ceu_org->trls[ 2 ],
#ifdef CEU_STACK_CLEAR
               &stk_
#else
               NULL
#endif
              );

#ifdef CEU_STACK_CLEAR
    if (!stk_.is_alive) {
        return;
    }
#endif

#line 274 "garden.ceu"
        _ceu_trl = &_ceu_org->trls[ 3 ];

#line 274 "garden.ceu"
    }
/* NODE: Block 817 */

#line 282 "garden.ceu"
    {/* NODE: Stmts 816 */

#line 282 "garden.ceu"
    {/* NODE: Stmts 5154 */

#line 282 "garden.ceu"
    {/* NODE: Nothing 5112 */
/* NODE: Set 5111 */

#line 282 "garden.ceu"
/* SET: table: 0xe46ec0 *//* NODE: Await 814 */

#line 282 "garden.ceu"
    _CEU_NO_814_:
if (0) { goto _CEU_NO_814_; /* avoids "not used" warning */ }

#line 282 "garden.ceu"
    _ceu_trl->evt = 2;
_ceu_trl->lbl = Pitcher_Awake_ok_40;
_ceu_trl->seqno = _ceu_app->seqno;

#line 282 "garden.ceu"
    #ifdef CEU_ORGS
_ceu_trl->evto  = (&((CEU_Pitcher*)_ceu_org)->growing_10);
#endif

#line 282 "garden.ceu"
    return;

case Pitcher_Awake_ok_40:;

#line 282 "garden.ceu"
    #ifdef CEU_DEBUG_TRAILS
#ifndef CEU_OS
printf("\tOK!\n");
#endif
#endif

#line 282 "garden.ceu"
    {

#line 282 "garden.ceu"
        tceu__bool* __ceu_casted = (tceu__bool*) _ceu_evt->param;

#line 282 "garden.ceu"
        (((CEU_Pitcher*)_ceu_org)->survived_11) = ((__ceu_casted)->_1);
}
/* NODE: Nothing 8174 */
/* NODE: Nothing 8175 */

#line 282 "garden.ceu"
    }
#line 282 "garden.ceu"
    }
#line 282 "garden.ceu"
/* CLEAR: Block (282) */
#line 282 "garden.ceu"
    if (0) {

#line 282 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 274 "garden.ceu"
/* PAROR JOIN */
#line 274 "garden.ceu"
    _ceu_lbl = Pitcher_ParOr_out_38;
goto _CEU_GOTO_;

#line 274 "garden.ceu"
case Pitcher_ParOr_sub_1_37:;/* NODE: Block 810 */

#line 275 "garden.ceu"
    {/* NODE: Stmts 809 */

#line 275 "garden.ceu"
    {/* NODE: Block 5052 */

#line 275 "garden.ceu"
    {/* NODE: Stmts 5051 */

#line 275 "garden.ceu"
    {/* NODE: Stmts 5050 */

#line 275 "garden.ceu"
    {
#line 275 "garden.ceu"
    }/* NODE: Loop 5049 */

#line 275 "garden.ceu"
    for (;;) {
/* NODE: Block 807 */

#line 276 "garden.ceu"
    {
#line 276 "garden.ceu"
    int __ceu_incoming_plot_12;
/* NODE: Stmts 806 */

#line 276 "garden.ceu"
    {/* NODE: Stmts 5057 */

#line 276 "garden.ceu"
    {/* NODE: Dcl_var 5054 */
/* NODE: Stmts 5102 */

#line 276 "garden.ceu"
    {/* NODE: Nothing 5060 */
/* NODE: Set 5059 */

#line 276 "garden.ceu"
/* SET: table: 0xf664d0 *//* NODE: Await 795 */

#line 276 "garden.ceu"
    _CEU_NO_795_:
if (0) { goto _CEU_NO_795_; /* avoids "not used" warning */ }

#line 276 "garden.ceu"
    _ceu_trl->evt = 3;
_ceu_trl->lbl = Pitcher_Awake_go_water_39;
_ceu_trl->seqno = _ceu_app->seqno;

#line 276 "garden.ceu"
    #ifdef CEU_ORGS
_ceu_trl->evto  = (((CEU_Pitcher*)_ceu_org)->garden);
#endif

#line 276 "garden.ceu"
    return;

case Pitcher_Awake_go_water_39:;

#line 276 "garden.ceu"
    #ifdef CEU_DEBUG_TRAILS
#ifndef CEU_OS
printf("\tOK!\n");
#endif
#endif

#line 276 "garden.ceu"
    {

#line 276 "garden.ceu"
        tceu__int* __ceu_casted = (tceu__int*) _ceu_evt->param;

#line 276 "garden.ceu"
        (__ceu_incoming_plot_12) = ((__ceu_casted)->_1);
}
/* NODE: Nothing 8170 */
/* NODE: Nothing 8171 */

#line 276 "garden.ceu"
    }
#line 276 "garden.ceu"
    }/* NODE: If 5108 */

#line 277 "garden.ceu"
    if (((__ceu_incoming_plot_12)==(((CEU_Pitcher*)_ceu_org)->plot))) {
/* NODE: Block 804 */

#line 278 "garden.ceu"
    {/* NODE: Stmts 803 */

#line 278 "garden.ceu"
    {/* NODE: EmitInt 802 */

#line 278 "garden.ceu"
    {
#ifdef CEU_STACK_CLEAR
    tceu_stk stk_ = { _ceu_stk, _ceu_org, 2, 2, 1 };
#endif

#line 278 "garden.ceu"
        /* trigger the event */
    tceu_evt evt;
    evt.id = 1;
#ifdef CEU_ORGS
#line 278 "garden.ceu"
    evt.org = (tceu_org*) (&((CEU_Pitcher*)_ceu_org)->growing_10);
#endif

#line 278 "garden.ceu"
        ceu_sys_go_ex(_ceu_app, &evt,
#ifdef CEU_STACK_CLEAR
                  &stk_,
#else
                  NULL,
#endif
                  _ceu_app->data, 0,
#ifdef CEU_ORGS
                  _ceu_app->data->n
#else
                  CEU_NTRAILS
#endif
    );

#ifdef CEU_STACK_CLEAR
    if (!stk_.is_alive) {
        return;
    }
#endif
}

#line 278 "garden.ceu"
    }
#line 278 "garden.ceu"
/* CLEAR: Block (278) */
#line 278 "garden.ceu"
    if (0) {

#line 278 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
} else {
/* NODE: Nothing 5107 */
}

#line 276 "garden.ceu"
    }
#line 276 "garden.ceu"
/* CLEAR: Block (276) */
#line 276 "garden.ceu"
    if (0) {

#line 276 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 275 "garden.ceu"
    }

#line 275 "garden.ceu"
    }
#line 275 "garden.ceu"
/* CLEAR: Block (275) */
#line 275 "garden.ceu"
    if (0) {

#line 275 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 275 "garden.ceu"
    }
#line 275 "garden.ceu"
/* CLEAR: Block (275) */
#line 275 "garden.ceu"
    if (0) {

#line 275 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 274 "garden.ceu"
case Pitcher_ParOr_out_38:;
#line 274 "garden.ceu"
/* CLEAR: ParOr (274) */
#line 274 "garden.ceu"
    {
    /* Reuse current stack frame.
     * We know that CLEAR will not abort anything and return normally.
     * Just save the previous "is_alive", call CLEAR, and restore it.
     */
#ifdef CEU_STACK_CLEAR
    int __ceu_old = _ceu_stk->is_alive;
    _ceu_stk->is_alive = 1;
#endif
    tceu_evt evt;
             evt.id = CEU_IN__CLEAR;
    ceu_sys_go_ex(_ceu_app, &evt,
                  _ceu_stk,
                  _ceu_org,
                  2,
                  4);
#ifdef CEU_STACK_CLEAR
    _ceu_stk->is_alive = __ceu_old;
    ceu_sys_stack_clear(_ceu_stk, _ceu_org,
                        2,3);
#endif
}
/* NODE: If 5160 */

#line 284 "garden.ceu"
    if ((((CEU_Pitcher*)_ceu_org)->survived_11)) {
/* NODE: Block 882 */

#line 285 "garden.ceu"
    /*  FINALIZE */
_ceu_org->trls[ 3 ].evt = CEU_IN__CLEAR;
_ceu_org->trls[ 3 ].lbl = Pitcher_Block__fin_41;

#line 285 "garden.ceu"
    ((CEU_Pitcher*)_ceu_org)->__fin_882_1 = 0;
#line 285 "garden.ceu"
    ((CEU_Pitcher*)_ceu_org)->__fin_882_2 = 0;
#line 285 "garden.ceu"
    {/* NODE: Stmts 881 */

#line 285 "garden.ceu"
    {/* NODE: Set 5161 */

#line 285 "garden.ceu"
/* SET: . *//* NODE: Op2_+ 825 */

#line 285 "garden.ceu"
    (((*((CEU_Pitcher*)_ceu_org)->garden).t1_plants)) = ((((*((CEU_Pitcher*)_ceu_org)->garden).t1_plants))+1);/* NODE: Set 5162 */

#line 286 "garden.ceu"
/* SET: . *//* NODE: Op2_+ 832 */

#line 286 "garden.ceu"
    (((*((CEU_Pitcher*)_ceu_org)->garden).score)) = ((((*((CEU_Pitcher*)_ceu_org)->garden).score))+0.5);/* NODE: Finalize 851 */

#line 287 "garden.ceu"
    ((CEU_Pitcher*)_ceu_org)->__fin_882_2 = 1;/* NODE: Stmts 5169 */

#line 291 "garden.ceu"
    {/* NODE: Dcl_var 5166 */
/* NODE: Set 5170 */

#line 291 "garden.ceu"
/* SET: id *//* NODE: Var 853 */

#line 291 "garden.ceu"
    (((CEU_Pitcher*)_ceu_org)->id_13) = (*((CEU_Pitcher*)_ceu_org)->gensym);
#line 291 "garden.ceu"
    }/* NODE: Set 5171 */

#line 292 "garden.ceu"
/* SET: gensym *//* NODE: Op2_+ 858 */

#line 292 "garden.ceu"
    (*((CEU_Pitcher*)_ceu_org)->gensym) = ((*((CEU_Pitcher*)_ceu_org)->gensym)+1);/* NODE: EmitExt 867 */

#line 293 "garden.ceu"
        {

#line 293 "garden.ceu"
    tceu__int__int__int__int__int __ceu_ps_867;
{
    tceu__int__int__int__int__int __ceu_ps_867_ =
        { (((CEU_Pitcher*)_ceu_org)->id_13),(((CEU_Pitcher*)_ceu_org)->x),(((CEU_Pitcher*)_ceu_org)->y),12,(((CEU_Pitcher*)_ceu_org)->layer) };
    __ceu_ps_867 = __ceu_ps_867_;
}

#line 293 "garden.ceu"
    
#if defined(ceu_out_emit_NEW_SPRITE)
    ceu_out_emit_NEW_SPRITE((&__ceu_ps_867))

#elif defined(ceu_out_emit)
    (ceu_out_emit(_ceu_app, CEU_OUT_NEW_SPRITE, sizeof(tceu__int__int__int__int__int), (void*)(&__ceu_ps_867)))

#else
    #error ceu_out_emit_* is not defined
#endif
;
#line 293 "garden.ceu"
        }
/* NODE: Finalize 879 */

#line 294 "garden.ceu"
    ((CEU_Pitcher*)_ceu_org)->__fin_882_1 = 1;/* NODE: AwaitN 880 */

#line 298 "garden.ceu"
    return;
#line 285 "garden.ceu"
    }
#line 285 "garden.ceu"
/* CLEAR: Block (285) */
#line 285 "garden.ceu"
    if (0) {

#line 285 "garden.ceu"
case Pitcher_Block__fin_41:;
#line 285 "garden.ceu"
    if (((CEU_Pitcher*)_ceu_org)->__fin_882_1) {
    /* NODE: Finally 878 */
/* NODE: Block 877 */

#line 295 "garden.ceu"
    {/* NODE: Stmts 876 */

#line 295 "garden.ceu"
    {/* NODE: CallStmt 872 */

#line 295 "garden.ceu"
    printf("flouishing over\n");/* NODE: EmitExt 875 */

#line 296 "garden.ceu"
        {

#line 296 "garden.ceu"
    tceu__int __ceu_ps_875;
{
    tceu__int __ceu_ps_875_ =
        { (((CEU_Pitcher*)_ceu_org)->id_13) };
    __ceu_ps_875 = __ceu_ps_875_;
}

#line 296 "garden.ceu"
    
#if defined(ceu_out_emit_FREE_SPRITE)
    ceu_out_emit_FREE_SPRITE((&__ceu_ps_875))

#elif defined(ceu_out_emit)
    (ceu_out_emit(_ceu_app, CEU_OUT_FREE_SPRITE, sizeof(tceu__int), (void*)(&__ceu_ps_875)))

#else
    #error ceu_out_emit_* is not defined
#endif
;
#line 296 "garden.ceu"
        }

#line 295 "garden.ceu"
    }
#line 295 "garden.ceu"
/* CLEAR: Block (295) */
#line 295 "garden.ceu"
    if (0) {

#line 295 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
}

#line 285 "garden.ceu"
    if (((CEU_Pitcher*)_ceu_org)->__fin_882_2) {
    /* NODE: Finally 850 */
/* NODE: Block 849 */

#line 288 "garden.ceu"
    {/* NODE: Stmts 848 */

#line 288 "garden.ceu"
    {/* NODE: Set 5163 */

#line 288 "garden.ceu"
/* SET: . *//* NODE: Op2_- 839 */

#line 288 "garden.ceu"
    (((*((CEU_Pitcher*)_ceu_org)->garden).t1_plants)) = ((((*((CEU_Pitcher*)_ceu_org)->garden).t1_plants))-1);/* NODE: Set 5164 */

#line 289 "garden.ceu"
/* SET: . *//* NODE: Op2_- 846 */

#line 289 "garden.ceu"
    (((*((CEU_Pitcher*)_ceu_org)->garden).score)) = ((((*((CEU_Pitcher*)_ceu_org)->garden).score))-0.5);
#line 288 "garden.ceu"
    }
#line 288 "garden.ceu"
/* CLEAR: Block (288) */
#line 288 "garden.ceu"
    if (0) {

#line 288 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
}

#line 285 "garden.ceu"
    return;
#line 285 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
} else {
/* NODE: Nothing 5159 */
}

#line 267 "garden.ceu"
    }
#line 267 "garden.ceu"
/* CLEAR: Block (267) */
#line 267 "garden.ceu"
    {
    /* Reuse current stack frame.
     * We know that CLEAR will not abort anything and return normally.
     * Just save the previous "is_alive", call CLEAR, and restore it.
     */
#ifdef CEU_STACK_CLEAR
    int __ceu_old = _ceu_stk->is_alive;
    _ceu_stk->is_alive = 1;
#endif
    tceu_evt evt;
             evt.id = CEU_IN__CLEAR;
    ceu_sys_go_ex(_ceu_app, &evt,
                  _ceu_stk,
                  _ceu_org,
                  1,
                  4);
#ifdef CEU_STACK_CLEAR
    _ceu_stk->is_alive = __ceu_old;
    ceu_sys_stack_clear(_ceu_stk, _ceu_org,
                        1,3);
#endif
}

#line 267 "garden.ceu"
    #ifdef CEU_ORGS_AWAIT
/* signal ok_killed */
{
    tceu_kill ps = { _ceu_org, _ceu_org->ret, 1,3 };
    tceu_evt evt_;
             evt_.id = CEU_IN__ok_killed;
             evt_.param = &ps;
    ceu_sys_go_ex(_ceu_app, &evt_, _ceu_stk,
                  _ceu_app->data, 0, _ceu_app->data->n);
}
#endif

#line 267 "garden.ceu"
    if (0) {

#line 267 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 258 "garden.ceu"
/* PAROR JOIN */
#line 258 "garden.ceu"
    _ceu_lbl = Pitcher_ParOr_out_35;
goto _CEU_GOTO_;

#line 258 "garden.ceu"
case Pitcher_ParOr_sub_1_34:;/* NODE: Block 766 */

#line 259 "garden.ceu"
    {/* NODE: Stmts 765 */

#line 259 "garden.ceu"
    {/* NODE: Block 4982 */

#line 259 "garden.ceu"
    {/* NODE: Stmts 4981 */

#line 259 "garden.ceu"
    {/* NODE: Stmts 4980 */

#line 259 "garden.ceu"
    {
#line 259 "garden.ceu"
    }/* NODE: Loop 4979 */

#line 259 "garden.ceu"
    for (;;) {
/* NODE: Block 763 */

#line 260 "garden.ceu"
    {
#line 260 "garden.ceu"
    int __ceu_incoming_plot_9;
/* NODE: Stmts 762 */

#line 260 "garden.ceu"
    {/* NODE: Stmts 4987 */

#line 260 "garden.ceu"
    {/* NODE: Dcl_var 4984 */
/* NODE: Stmts 5032 */

#line 260 "garden.ceu"
    {/* NODE: Nothing 4990 */
/* NODE: Set 4989 */

#line 260 "garden.ceu"
/* SET: table: 0xf5c9d0 *//* NODE: Await 748 */

#line 260 "garden.ceu"
    _CEU_NO_748_:
if (0) { goto _CEU_NO_748_; /* avoids "not used" warning */ }

#line 260 "garden.ceu"
    _ceu_trl->evt = 1;
_ceu_trl->lbl = Pitcher_Awake_go_dig_36;
_ceu_trl->seqno = _ceu_app->seqno;

#line 260 "garden.ceu"
    #ifdef CEU_ORGS
_ceu_trl->evto  = (((CEU_Pitcher*)_ceu_org)->garden);
#endif

#line 260 "garden.ceu"
    return;

case Pitcher_Awake_go_dig_36:;

#line 260 "garden.ceu"
    #ifdef CEU_DEBUG_TRAILS
#ifndef CEU_OS
printf("\tOK!\n");
#endif
#endif

#line 260 "garden.ceu"
    {

#line 260 "garden.ceu"
        tceu__int* __ceu_casted = (tceu__int*) _ceu_evt->param;

#line 260 "garden.ceu"
        (__ceu_incoming_plot_9) = ((__ceu_casted)->_1);
}
/* NODE: Nothing 8163 */
/* NODE: Nothing 8164 */

#line 260 "garden.ceu"
    }
#line 260 "garden.ceu"
    }/* NODE: If 5038 */

#line 261 "garden.ceu"
    if (((__ceu_incoming_plot_9)==(((CEU_Pitcher*)_ceu_org)->plot))) {
/* NODE: Block 760 */

#line 262 "garden.ceu"
    {/* NODE: Stmts 759 */

#line 262 "garden.ceu"
    {/* NODE: CallStmt 757 */

#line 262 "garden.ceu"
    printf("pitcher plant dug up\n");/* NODE: Break 758 */

#line 263 "garden.ceu"
    break;
#line 262 "garden.ceu"
    }
#line 262 "garden.ceu"
/* CLEAR: Block (262) */
#line 262 "garden.ceu"
    if (0) {

#line 262 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
} else {
/* NODE: Nothing 5037 */
}

#line 260 "garden.ceu"
    }
#line 260 "garden.ceu"
/* CLEAR: Block (260) */
#line 260 "garden.ceu"
    if (0) {

#line 260 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 259 "garden.ceu"
    }

#line 259 "garden.ceu"
/* CLEAR: Loop (259) */
#line 259 "garden.ceu"
    }
#line 259 "garden.ceu"
/* CLEAR: Block (259) */
#line 259 "garden.ceu"
    if (0) {

#line 259 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 259 "garden.ceu"
    }
#line 259 "garden.ceu"
/* CLEAR: Block (259) */
#line 259 "garden.ceu"
    if (0) {

#line 259 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 258 "garden.ceu"
/* PAROR JOIN */
#line 258 "garden.ceu"
    _ceu_lbl = Pitcher_ParOr_out_35;
goto _CEU_GOTO_;

#line 258 "garden.ceu"
case Pitcher_ParOr_out_35:;
#line 258 "garden.ceu"
/* CLEAR: ParOr (258) */
#line 258 "garden.ceu"
    {
    /* Reuse current stack frame.
     * We know that CLEAR will not abort anything and return normally.
     * Just save the previous "is_alive", call CLEAR, and restore it.
     */
#ifdef CEU_STACK_CLEAR
    int __ceu_old = _ceu_stk->is_alive;
    _ceu_stk->is_alive = 1;
#endif
    tceu_evt evt;
             evt.id = CEU_IN__CLEAR;
    ceu_sys_go_ex(_ceu_app, &evt,
                  _ceu_stk,
                  _ceu_org,
                  0,
                  4);
#ifdef CEU_STACK_CLEAR
    _ceu_stk->is_alive = __ceu_old;
    ceu_sys_stack_clear(_ceu_stk, _ceu_org,
                        0,3);
#endif
}

#line 258 "garden.ceu"
    #ifdef CEU_ORGS_AWAIT
/* signal ok_killed */
{
    tceu_kill ps = { _ceu_org, _ceu_org->ret, 0,3 };
    tceu_evt evt_;
             evt_.id = CEU_IN__ok_killed;
             evt_.param = &ps;
    ceu_sys_go_ex(_ceu_app, &evt_, _ceu_stk,
                  _ceu_app->data, 0, _ceu_app->data->n);
}
#endif

#line 251 "garden.ceu"
    }
#line 251 "garden.ceu"
/* CLEAR: Block (251) */
#line 251 "garden.ceu"
    {
    /* Reuse current stack frame.
     * We know that CLEAR will not abort anything and return normally.
     * Just save the previous "is_alive", call CLEAR, and restore it.
     */
#ifdef CEU_STACK_CLEAR
    int __ceu_old = _ceu_stk->is_alive;
    _ceu_stk->is_alive = 1;
#endif
    tceu_evt evt;
             evt.id = CEU_IN__CLEAR;
    ceu_sys_go_ex(_ceu_app, &evt,
                  _ceu_stk,
                  _ceu_org,
                  0,
                  5);
#ifdef CEU_STACK_CLEAR
    _ceu_stk->is_alive = __ceu_old;
    ceu_sys_stack_clear(_ceu_stk, _ceu_org,
                        0,4);
#endif
}

#line 251 "garden.ceu"
    #ifdef CEU_ORGS_AWAIT
/* signal ok_killed */
{
    tceu_kill ps = { _ceu_org, _ceu_org->ret, 0,4 };
    tceu_evt evt_;
             evt_.id = CEU_IN__ok_killed;
             evt_.param = &ps;
    ceu_sys_go_ex(_ceu_app, &evt_, _ceu_stk,
                  _ceu_app->data, 0, _ceu_app->data->n);
}
#endif

#line 251 "garden.ceu"
    if (0) {

#line 251 "garden.ceu"
case Pitcher_Block__fin_42:;
#line 251 "garden.ceu"
    if (((CEU_Pitcher*)_ceu_org)->__fin_888_1) {
    /* NODE: Finally 728 */
/* NODE: Block 727 */

#line 253 "garden.ceu"
    {/* NODE: Stmts 726 */

#line 253 "garden.ceu"
    {/* NODE: Set 4960 */

#line 253 "garden.ceu"
/* SET: idx *//* NODE: NUMBER 724 */

#line 253 "garden.ceu"
    plot_occupied[(((CEU_Pitcher*)_ceu_org)->plot)] = 0;
#line 253 "garden.ceu"
    }
#line 253 "garden.ceu"
/* CLEAR: Block (253) */
#line 253 "garden.ceu"
    if (0) {

#line 253 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
}

#line 251 "garden.ceu"
    return;
#line 251 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 246 "garden.ceu"
    }
#line 246 "garden.ceu"
/* CLEAR: Block (246) */
#line 246 "garden.ceu"
    if (0) {

#line 246 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 246 "garden.ceu"
    }
#line 246 "garden.ceu"
/* CLEAR: Block (246) */
#line 246 "garden.ceu"
    if (0) {

#line 246 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 246 "garden.ceu"
    ceu_sys_org_free(_ceu_app, _ceu_org);
#ifdef CEU_ORGS_AWAIT
{
    /* signal ok_killed */
#ifdef CEU_STACK_CLEAR
    tceu_stk stk_ = *_ceu_stk;
             stk_.is_alive = 1;
             stk_.down = _ceu_stk;
#endif
    tceu_kill ps = { _ceu_org, _ceu_org->ret, 0, (tceu_ntrl)(_ceu_org->n-1) };
    tceu_evt evt_;
             evt_.id = CEU_IN__ok_killed;
             evt_.param = &ps;
    ceu_sys_go_ex(_ceu_app, &evt_,
#ifdef CEU_STACK_CLEAR
                  &stk_,
#else
                  NULL,
#endif
                  _ceu_app->data, 0, _ceu_app->data->n);
}
#endif

#line 246 "garden.ceu"
    return;/* NODE: Dcl_cls 7 */

#line 303 "garden.ceu"
case Class_Orchid:;/* NODE: Block 5410 */

#line 303 "garden.ceu"
    {/* NODE: Stmts 5409 */

#line 303 "garden.ceu"
    {/* NODE: Block 5182 */

#line 303 "garden.ceu"
    {/* NODE: Stmts 5411 */

#line 303 "garden.ceu"
    {/* NODE: Block 1069 */

#line 308 "garden.ceu"
    /*  FINALIZE */
_ceu_org->trls[ 4 ].evt = CEU_IN__CLEAR;
_ceu_org->trls[ 4 ].lbl = Orchid_Block__fin_52;

#line 308 "garden.ceu"
    ((CEU_Orchid*)_ceu_org)->__fin_1069_1 = 0;
#line 308 "garden.ceu"
    {/* NODE: Stmts 1068 */

#line 308 "garden.ceu"
    {/* NODE: Set 5195 */

#line 308 "garden.ceu"
/* SET: idx *//* NODE: NUMBER 900 */

#line 308 "garden.ceu"
    plot_occupied[(((CEU_Orchid*)_ceu_org)->plot)] = 1;/* NODE: Finalize 910 */

#line 309 "garden.ceu"
    ((CEU_Orchid*)_ceu_org)->__fin_1069_1 = 1;/* NODE: Stmts 5201 */

#line 312 "garden.ceu"
    {/* NODE: Dcl_var 5198 */
/* NODE: Set 5202 */

#line 312 "garden.ceu"
/* SET: x *//* NODE: Op2_idx 914 */

#line 312 "garden.ceu"
    (((CEU_Orchid*)_ceu_org)->x) = plot_x[(((CEU_Orchid*)_ceu_org)->plot)];
#line 312 "garden.ceu"
    }/* NODE: Stmts 5207 */

#line 313 "garden.ceu"
    {/* NODE: Dcl_var 5204 */
/* NODE: Set 5208 */

#line 313 "garden.ceu"
/* SET: y *//* NODE: Op2_idx 919 */

#line 313 "garden.ceu"
    (((CEU_Orchid*)_ceu_org)->y) = plot_y[(((CEU_Orchid*)_ceu_org)->plot)];
#line 313 "garden.ceu"
    }/* NODE: Stmts 5213 */

#line 314 "garden.ceu"
    {/* NODE: Dcl_var 5210 */
/* NODE: Set 5214 */

#line 314 "garden.ceu"
/* SET: layer *//* NODE: Op2_idx 924 */

#line 314 "garden.ceu"
    (((CEU_Orchid*)_ceu_org)->layer) = plot_layer[(((CEU_Orchid*)_ceu_org)->plot)];
#line 314 "garden.ceu"
    }/* NODE: ParOr 1067 */

#line 315 "garden.ceu"
/* ParOr: spawn subs */
#line 315 "garden.ceu"
    {
#ifdef CEU_STACK_CLEAR
    tceu_stk stk_ = { _ceu_stk, _ceu_org, 0, 3, 1 };
#endif

#line 315 "garden.ceu"
        _ceu_org->trls[ 0 ].lbl = Orchid_ParOr_sub_1_44;
    ceu_app_go(_ceu_app,NULL,_ceu_org,
               &_ceu_org->trls[ 0 ],
#ifdef CEU_STACK_CLEAR
               &stk_
#else
               NULL
#endif
              );

#ifdef CEU_STACK_CLEAR
    if (!stk_.is_alive) {
        return;
    }
#endif

#line 315 "garden.ceu"
        _ceu_trl = &_ceu_org->trls[ 1 ];

#line 315 "garden.ceu"
    }
/* NODE: Block 1066 */

#line 324 "garden.ceu"
    {
#line 324 "garden.ceu"
    #ifdef CEU_ORGS
_ceu_org->trls[ 1 ].evt = CEU_IN__ORG;
_ceu_org->trls[ 1 ].org = NULL;
#endif

#line 324 "garden.ceu"
    _ceu_trl = &_ceu_org->trls[ 2 ];
/* NODE: Stmts 1065 */

#line 324 "garden.ceu"
    {/* NODE: Dcl_var 969 */

#line 324 "garden.ceu"
/* start org: growing */
#line 324 "garden.ceu"
        /* resets org memory and starts org.trail[0]=Class_XXX */
    /* TODO: BUG: _ceu_org is not necessarily the parent for pool allocations */
    ceu_out_org_init(_ceu_app, ((tceu_org*) &(((CEU_Orchid*)_ceu_org)->growing_10)),7,Class_Growing,
                     4,
                     0,
                     _ceu_org,1);
/* TODO: currently idx is always "1" for all interfaces access because pools 
 * are all together there. When we have separate trls for pools, we'll have to 
 * indirectly access the offset in the interface. */

#line 324 "garden.ceu"
        _ceu_constr_968(_ceu_app, ((tceu_org*) &(((CEU_Orchid*)_ceu_org)->growing_10)), _ceu_org);

#line 324 "garden.ceu"
    {
#ifdef CEU_STACK_CLEAR
    tceu_stk stk_ = { _ceu_stk, _ceu_org, 2, 3, 1 };
    ceu_app_go(_ceu_app,NULL,
               ((tceu_org*) &(((CEU_Orchid*)_ceu_org)->growing_10)), &((tceu_org*) &(((CEU_Orchid*)_ceu_org)->growing_10))->trls[0],
               &stk_);
    if (!stk_.is_alive) {
        return;
    }
#else
    ceu_app_go(_ceu_app,NULL,
               ((tceu_org*) &(((CEU_Orchid*)_ceu_org)->growing_10)), &((tceu_org*) &(((CEU_Orchid*)_ceu_org)->growing_10))->trls[0],
               NULL);
#endif

#line 324 "garden.ceu"
    }
/* NODE: Stmts 5283 */

#line 330 "garden.ceu"
    {/* NODE: Dcl_var 5280 */
/* NODE: Set 5284 */

#line 330 "garden.ceu"
/* SET: survived *//* NODE: NUMBER 971 */

#line 330 "garden.ceu"
    (((CEU_Orchid*)_ceu_org)->survived_11) = 0;
#line 330 "garden.ceu"
    }/* NODE: ParOr 999 */

#line 331 "garden.ceu"
/* ParOr: spawn subs */
#line 331 "garden.ceu"
    {
#ifdef CEU_STACK_CLEAR
    tceu_stk stk_ = { _ceu_stk, _ceu_org, 2, 3, 1 };
#endif

#line 331 "garden.ceu"
        _ceu_org->trls[ 2 ].lbl = Orchid_ParOr_sub_1_47;
    ceu_app_go(_ceu_app,NULL,_ceu_org,
               &_ceu_org->trls[ 2 ],
#ifdef CEU_STACK_CLEAR
               &stk_
#else
               NULL
#endif
              );

#ifdef CEU_STACK_CLEAR
    if (!stk_.is_alive) {
        return;
    }
#endif

#line 331 "garden.ceu"
        _ceu_trl = &_ceu_org->trls[ 3 ];

#line 331 "garden.ceu"
    }
/* NODE: Block 998 */

#line 339 "garden.ceu"
    {/* NODE: Stmts 997 */

#line 339 "garden.ceu"
    {/* NODE: Stmts 5390 */

#line 339 "garden.ceu"
    {/* NODE: Nothing 5348 */
/* NODE: Set 5347 */

#line 339 "garden.ceu"
/* SET: table: 0xe5f7d0 *//* NODE: Await 995 */

#line 339 "garden.ceu"
    _CEU_NO_995_:
if (0) { goto _CEU_NO_995_; /* avoids "not used" warning */ }

#line 339 "garden.ceu"
    _ceu_trl->evt = 2;
_ceu_trl->lbl = Orchid_Awake_ok_50;
_ceu_trl->seqno = _ceu_app->seqno;

#line 339 "garden.ceu"
    #ifdef CEU_ORGS
_ceu_trl->evto  = (&((CEU_Orchid*)_ceu_org)->growing_10);
#endif

#line 339 "garden.ceu"
    return;

case Orchid_Awake_ok_50:;

#line 339 "garden.ceu"
    #ifdef CEU_DEBUG_TRAILS
#ifndef CEU_OS
printf("\tOK!\n");
#endif
#endif

#line 339 "garden.ceu"
    {

#line 339 "garden.ceu"
        tceu__bool* __ceu_casted = (tceu__bool*) _ceu_evt->param;

#line 339 "garden.ceu"
        (((CEU_Orchid*)_ceu_org)->survived_11) = ((__ceu_casted)->_1);
}
/* NODE: Nothing 8196 */
/* NODE: Nothing 8197 */

#line 339 "garden.ceu"
    }
#line 339 "garden.ceu"
    }
#line 339 "garden.ceu"
/* CLEAR: Block (339) */
#line 339 "garden.ceu"
    if (0) {

#line 339 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 331 "garden.ceu"
/* PAROR JOIN */
#line 331 "garden.ceu"
    _ceu_lbl = Orchid_ParOr_out_48;
goto _CEU_GOTO_;

#line 331 "garden.ceu"
case Orchid_ParOr_sub_1_47:;/* NODE: Block 991 */

#line 332 "garden.ceu"
    {/* NODE: Stmts 990 */

#line 332 "garden.ceu"
    {/* NODE: Block 5288 */

#line 332 "garden.ceu"
    {/* NODE: Stmts 5287 */

#line 332 "garden.ceu"
    {/* NODE: Stmts 5286 */

#line 332 "garden.ceu"
    {
#line 332 "garden.ceu"
    }/* NODE: Loop 5285 */

#line 332 "garden.ceu"
    for (;;) {
/* NODE: Block 988 */

#line 333 "garden.ceu"
    {
#line 333 "garden.ceu"
    int __ceu_incoming_plot_12;
/* NODE: Stmts 987 */

#line 333 "garden.ceu"
    {/* NODE: Stmts 5293 */

#line 333 "garden.ceu"
    {/* NODE: Dcl_var 5290 */
/* NODE: Stmts 5338 */

#line 333 "garden.ceu"
    {/* NODE: Nothing 5296 */
/* NODE: Set 5295 */

#line 333 "garden.ceu"
/* SET: table: 0xf8ac80 *//* NODE: Await 976 */

#line 333 "garden.ceu"
    _CEU_NO_976_:
if (0) { goto _CEU_NO_976_; /* avoids "not used" warning */ }

#line 333 "garden.ceu"
    _ceu_trl->evt = 3;
_ceu_trl->lbl = Orchid_Awake_go_water_49;
_ceu_trl->seqno = _ceu_app->seqno;

#line 333 "garden.ceu"
    #ifdef CEU_ORGS
_ceu_trl->evto  = (((CEU_Orchid*)_ceu_org)->garden);
#endif

#line 333 "garden.ceu"
    return;

case Orchid_Awake_go_water_49:;

#line 333 "garden.ceu"
    #ifdef CEU_DEBUG_TRAILS
#ifndef CEU_OS
printf("\tOK!\n");
#endif
#endif

#line 333 "garden.ceu"
    {

#line 333 "garden.ceu"
        tceu__int* __ceu_casted = (tceu__int*) _ceu_evt->param;

#line 333 "garden.ceu"
        (__ceu_incoming_plot_12) = ((__ceu_casted)->_1);
}
/* NODE: Nothing 8192 */
/* NODE: Nothing 8193 */

#line 333 "garden.ceu"
    }
#line 333 "garden.ceu"
    }/* NODE: If 5344 */

#line 334 "garden.ceu"
    if (((__ceu_incoming_plot_12)==(((CEU_Orchid*)_ceu_org)->plot))) {
/* NODE: Block 985 */

#line 335 "garden.ceu"
    {/* NODE: Stmts 984 */

#line 335 "garden.ceu"
    {/* NODE: EmitInt 983 */

#line 335 "garden.ceu"
    {
#ifdef CEU_STACK_CLEAR
    tceu_stk stk_ = { _ceu_stk, _ceu_org, 2, 2, 1 };
#endif

#line 335 "garden.ceu"
        /* trigger the event */
    tceu_evt evt;
    evt.id = 1;
#ifdef CEU_ORGS
#line 335 "garden.ceu"
    evt.org = (tceu_org*) (&((CEU_Orchid*)_ceu_org)->growing_10);
#endif

#line 335 "garden.ceu"
        ceu_sys_go_ex(_ceu_app, &evt,
#ifdef CEU_STACK_CLEAR
                  &stk_,
#else
                  NULL,
#endif
                  _ceu_app->data, 0,
#ifdef CEU_ORGS
                  _ceu_app->data->n
#else
                  CEU_NTRAILS
#endif
    );

#ifdef CEU_STACK_CLEAR
    if (!stk_.is_alive) {
        return;
    }
#endif
}

#line 335 "garden.ceu"
    }
#line 335 "garden.ceu"
/* CLEAR: Block (335) */
#line 335 "garden.ceu"
    if (0) {

#line 335 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
} else {
/* NODE: Nothing 5343 */
}

#line 333 "garden.ceu"
    }
#line 333 "garden.ceu"
/* CLEAR: Block (333) */
#line 333 "garden.ceu"
    if (0) {

#line 333 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 332 "garden.ceu"
    }

#line 332 "garden.ceu"
    }
#line 332 "garden.ceu"
/* CLEAR: Block (332) */
#line 332 "garden.ceu"
    if (0) {

#line 332 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 332 "garden.ceu"
    }
#line 332 "garden.ceu"
/* CLEAR: Block (332) */
#line 332 "garden.ceu"
    if (0) {

#line 332 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 331 "garden.ceu"
case Orchid_ParOr_out_48:;
#line 331 "garden.ceu"
/* CLEAR: ParOr (331) */
#line 331 "garden.ceu"
    {
    /* Reuse current stack frame.
     * We know that CLEAR will not abort anything and return normally.
     * Just save the previous "is_alive", call CLEAR, and restore it.
     */
#ifdef CEU_STACK_CLEAR
    int __ceu_old = _ceu_stk->is_alive;
    _ceu_stk->is_alive = 1;
#endif
    tceu_evt evt;
             evt.id = CEU_IN__CLEAR;
    ceu_sys_go_ex(_ceu_app, &evt,
                  _ceu_stk,
                  _ceu_org,
                  2,
                  4);
#ifdef CEU_STACK_CLEAR
    _ceu_stk->is_alive = __ceu_old;
    ceu_sys_stack_clear(_ceu_stk, _ceu_org,
                        2,3);
#endif
}
/* NODE: If 5396 */

#line 341 "garden.ceu"
    if ((((CEU_Orchid*)_ceu_org)->survived_11)) {
/* NODE: Block 1063 */

#line 342 "garden.ceu"
    /*  FINALIZE */
_ceu_org->trls[ 3 ].evt = CEU_IN__CLEAR;
_ceu_org->trls[ 3 ].lbl = Orchid_Block__fin_51;

#line 342 "garden.ceu"
    ((CEU_Orchid*)_ceu_org)->__fin_1063_1 = 0;
#line 342 "garden.ceu"
    ((CEU_Orchid*)_ceu_org)->__fin_1063_2 = 0;
#line 342 "garden.ceu"
    {/* NODE: Stmts 1062 */

#line 342 "garden.ceu"
    {/* NODE: Set 5397 */

#line 342 "garden.ceu"
/* SET: . *//* NODE: Op2_+ 1006 */

#line 342 "garden.ceu"
    (((*((CEU_Orchid*)_ceu_org)->garden).t2_plants)) = ((((*((CEU_Orchid*)_ceu_org)->garden).t2_plants))+1);/* NODE: Set 5398 */

#line 343 "garden.ceu"
/* SET: . *//* NODE: Op2_+ 1013 */

#line 343 "garden.ceu"
    (((*((CEU_Orchid*)_ceu_org)->garden).score)) = ((((*((CEU_Orchid*)_ceu_org)->garden).score))+1.0);/* NODE: Finalize 1032 */

#line 344 "garden.ceu"
    ((CEU_Orchid*)_ceu_org)->__fin_1063_2 = 1;/* NODE: Stmts 5405 */

#line 348 "garden.ceu"
    {/* NODE: Dcl_var 5402 */
/* NODE: Set 5406 */

#line 348 "garden.ceu"
/* SET: id *//* NODE: Var 1034 */

#line 348 "garden.ceu"
    (((CEU_Orchid*)_ceu_org)->id_13) = (*((CEU_Orchid*)_ceu_org)->gensym);
#line 348 "garden.ceu"
    }/* NODE: Set 5407 */

#line 349 "garden.ceu"
/* SET: gensym *//* NODE: Op2_+ 1039 */

#line 349 "garden.ceu"
    (*((CEU_Orchid*)_ceu_org)->gensym) = ((*((CEU_Orchid*)_ceu_org)->gensym)+1);/* NODE: EmitExt 1048 */

#line 350 "garden.ceu"
        {

#line 350 "garden.ceu"
    tceu__int__int__int__int__int __ceu_ps_1048;
{
    tceu__int__int__int__int__int __ceu_ps_1048_ =
        { (((CEU_Orchid*)_ceu_org)->id_13),(((CEU_Orchid*)_ceu_org)->x),(((CEU_Orchid*)_ceu_org)->y),10,(((CEU_Orchid*)_ceu_org)->layer) };
    __ceu_ps_1048 = __ceu_ps_1048_;
}

#line 350 "garden.ceu"
    
#if defined(ceu_out_emit_NEW_SPRITE)
    ceu_out_emit_NEW_SPRITE((&__ceu_ps_1048))

#elif defined(ceu_out_emit)
    (ceu_out_emit(_ceu_app, CEU_OUT_NEW_SPRITE, sizeof(tceu__int__int__int__int__int), (void*)(&__ceu_ps_1048)))

#else
    #error ceu_out_emit_* is not defined
#endif
;
#line 350 "garden.ceu"
        }
/* NODE: Finalize 1060 */

#line 351 "garden.ceu"
    ((CEU_Orchid*)_ceu_org)->__fin_1063_1 = 1;/* NODE: AwaitN 1061 */

#line 355 "garden.ceu"
    return;
#line 342 "garden.ceu"
    }
#line 342 "garden.ceu"
/* CLEAR: Block (342) */
#line 342 "garden.ceu"
    if (0) {

#line 342 "garden.ceu"
case Orchid_Block__fin_51:;
#line 342 "garden.ceu"
    if (((CEU_Orchid*)_ceu_org)->__fin_1063_1) {
    /* NODE: Finally 1059 */
/* NODE: Block 1058 */

#line 352 "garden.ceu"
    {/* NODE: Stmts 1057 */

#line 352 "garden.ceu"
    {/* NODE: CallStmt 1053 */

#line 352 "garden.ceu"
    printf("flouishing over\n");/* NODE: EmitExt 1056 */

#line 353 "garden.ceu"
        {

#line 353 "garden.ceu"
    tceu__int __ceu_ps_1056;
{
    tceu__int __ceu_ps_1056_ =
        { (((CEU_Orchid*)_ceu_org)->id_13) };
    __ceu_ps_1056 = __ceu_ps_1056_;
}

#line 353 "garden.ceu"
    
#if defined(ceu_out_emit_FREE_SPRITE)
    ceu_out_emit_FREE_SPRITE((&__ceu_ps_1056))

#elif defined(ceu_out_emit)
    (ceu_out_emit(_ceu_app, CEU_OUT_FREE_SPRITE, sizeof(tceu__int), (void*)(&__ceu_ps_1056)))

#else
    #error ceu_out_emit_* is not defined
#endif
;
#line 353 "garden.ceu"
        }

#line 352 "garden.ceu"
    }
#line 352 "garden.ceu"
/* CLEAR: Block (352) */
#line 352 "garden.ceu"
    if (0) {

#line 352 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
}

#line 342 "garden.ceu"
    if (((CEU_Orchid*)_ceu_org)->__fin_1063_2) {
    /* NODE: Finally 1031 */
/* NODE: Block 1030 */

#line 345 "garden.ceu"
    {/* NODE: Stmts 1029 */

#line 345 "garden.ceu"
    {/* NODE: Set 5399 */

#line 345 "garden.ceu"
/* SET: . *//* NODE: Op2_- 1020 */

#line 345 "garden.ceu"
    (((*((CEU_Orchid*)_ceu_org)->garden).t2_plants)) = ((((*((CEU_Orchid*)_ceu_org)->garden).t2_plants))-1);/* NODE: Set 5400 */

#line 346 "garden.ceu"
/* SET: . *//* NODE: Op2_- 1027 */

#line 346 "garden.ceu"
    (((*((CEU_Orchid*)_ceu_org)->garden).score)) = ((((*((CEU_Orchid*)_ceu_org)->garden).score))-1.0);
#line 345 "garden.ceu"
    }
#line 345 "garden.ceu"
/* CLEAR: Block (345) */
#line 345 "garden.ceu"
    if (0) {

#line 345 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
}

#line 342 "garden.ceu"
    return;
#line 342 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
} else {
/* NODE: Nothing 5395 */
}

#line 324 "garden.ceu"
    }
#line 324 "garden.ceu"
/* CLEAR: Block (324) */
#line 324 "garden.ceu"
    {
    /* Reuse current stack frame.
     * We know that CLEAR will not abort anything and return normally.
     * Just save the previous "is_alive", call CLEAR, and restore it.
     */
#ifdef CEU_STACK_CLEAR
    int __ceu_old = _ceu_stk->is_alive;
    _ceu_stk->is_alive = 1;
#endif
    tceu_evt evt;
             evt.id = CEU_IN__CLEAR;
    ceu_sys_go_ex(_ceu_app, &evt,
                  _ceu_stk,
                  _ceu_org,
                  1,
                  4);
#ifdef CEU_STACK_CLEAR
    _ceu_stk->is_alive = __ceu_old;
    ceu_sys_stack_clear(_ceu_stk, _ceu_org,
                        1,3);
#endif
}

#line 324 "garden.ceu"
    #ifdef CEU_ORGS_AWAIT
/* signal ok_killed */
{
    tceu_kill ps = { _ceu_org, _ceu_org->ret, 1,3 };
    tceu_evt evt_;
             evt_.id = CEU_IN__ok_killed;
             evt_.param = &ps;
    ceu_sys_go_ex(_ceu_app, &evt_, _ceu_stk,
                  _ceu_app->data, 0, _ceu_app->data->n);
}
#endif

#line 324 "garden.ceu"
    if (0) {

#line 324 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 315 "garden.ceu"
/* PAROR JOIN */
#line 315 "garden.ceu"
    _ceu_lbl = Orchid_ParOr_out_45;
goto _CEU_GOTO_;

#line 315 "garden.ceu"
case Orchid_ParOr_sub_1_44:;/* NODE: Block 947 */

#line 316 "garden.ceu"
    {/* NODE: Stmts 946 */

#line 316 "garden.ceu"
    {/* NODE: Block 5218 */

#line 316 "garden.ceu"
    {/* NODE: Stmts 5217 */

#line 316 "garden.ceu"
    {/* NODE: Stmts 5216 */

#line 316 "garden.ceu"
    {
#line 316 "garden.ceu"
    }/* NODE: Loop 5215 */

#line 316 "garden.ceu"
    for (;;) {
/* NODE: Block 944 */

#line 317 "garden.ceu"
    {
#line 317 "garden.ceu"
    int __ceu_incoming_plot_9;
/* NODE: Stmts 943 */

#line 317 "garden.ceu"
    {/* NODE: Stmts 5223 */

#line 317 "garden.ceu"
    {/* NODE: Dcl_var 5220 */
/* NODE: Stmts 5268 */

#line 317 "garden.ceu"
    {/* NODE: Nothing 5226 */
/* NODE: Set 5225 */

#line 317 "garden.ceu"
/* SET: table: 0xf7f8c0 *//* NODE: Await 929 */

#line 317 "garden.ceu"
    _CEU_NO_929_:
if (0) { goto _CEU_NO_929_; /* avoids "not used" warning */ }

#line 317 "garden.ceu"
    _ceu_trl->evt = 1;
_ceu_trl->lbl = Orchid_Awake_go_dig_46;
_ceu_trl->seqno = _ceu_app->seqno;

#line 317 "garden.ceu"
    #ifdef CEU_ORGS
_ceu_trl->evto  = (((CEU_Orchid*)_ceu_org)->garden);
#endif

#line 317 "garden.ceu"
    return;

case Orchid_Awake_go_dig_46:;

#line 317 "garden.ceu"
    #ifdef CEU_DEBUG_TRAILS
#ifndef CEU_OS
printf("\tOK!\n");
#endif
#endif

#line 317 "garden.ceu"
    {

#line 317 "garden.ceu"
        tceu__int* __ceu_casted = (tceu__int*) _ceu_evt->param;

#line 317 "garden.ceu"
        (__ceu_incoming_plot_9) = ((__ceu_casted)->_1);
}
/* NODE: Nothing 8185 */
/* NODE: Nothing 8186 */

#line 317 "garden.ceu"
    }
#line 317 "garden.ceu"
    }/* NODE: If 5274 */

#line 318 "garden.ceu"
    if (((__ceu_incoming_plot_9)==(((CEU_Orchid*)_ceu_org)->plot))) {
/* NODE: Block 941 */

#line 319 "garden.ceu"
    {/* NODE: Stmts 940 */

#line 319 "garden.ceu"
    {/* NODE: CallStmt 938 */

#line 319 "garden.ceu"
    printf("orchid dug up\n");/* NODE: Break 939 */

#line 320 "garden.ceu"
    break;
#line 319 "garden.ceu"
    }
#line 319 "garden.ceu"
/* CLEAR: Block (319) */
#line 319 "garden.ceu"
    if (0) {

#line 319 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
} else {
/* NODE: Nothing 5273 */
}

#line 317 "garden.ceu"
    }
#line 317 "garden.ceu"
/* CLEAR: Block (317) */
#line 317 "garden.ceu"
    if (0) {

#line 317 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 316 "garden.ceu"
    }

#line 316 "garden.ceu"
/* CLEAR: Loop (316) */
#line 316 "garden.ceu"
    }
#line 316 "garden.ceu"
/* CLEAR: Block (316) */
#line 316 "garden.ceu"
    if (0) {

#line 316 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 316 "garden.ceu"
    }
#line 316 "garden.ceu"
/* CLEAR: Block (316) */
#line 316 "garden.ceu"
    if (0) {

#line 316 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 315 "garden.ceu"
/* PAROR JOIN */
#line 315 "garden.ceu"
    _ceu_lbl = Orchid_ParOr_out_45;
goto _CEU_GOTO_;

#line 315 "garden.ceu"
case Orchid_ParOr_out_45:;
#line 315 "garden.ceu"
/* CLEAR: ParOr (315) */
#line 315 "garden.ceu"
    {
    /* Reuse current stack frame.
     * We know that CLEAR will not abort anything and return normally.
     * Just save the previous "is_alive", call CLEAR, and restore it.
     */
#ifdef CEU_STACK_CLEAR
    int __ceu_old = _ceu_stk->is_alive;
    _ceu_stk->is_alive = 1;
#endif
    tceu_evt evt;
             evt.id = CEU_IN__CLEAR;
    ceu_sys_go_ex(_ceu_app, &evt,
                  _ceu_stk,
                  _ceu_org,
                  0,
                  4);
#ifdef CEU_STACK_CLEAR
    _ceu_stk->is_alive = __ceu_old;
    ceu_sys_stack_clear(_ceu_stk, _ceu_org,
                        0,3);
#endif
}

#line 315 "garden.ceu"
    #ifdef CEU_ORGS_AWAIT
/* signal ok_killed */
{
    tceu_kill ps = { _ceu_org, _ceu_org->ret, 0,3 };
    tceu_evt evt_;
             evt_.id = CEU_IN__ok_killed;
             evt_.param = &ps;
    ceu_sys_go_ex(_ceu_app, &evt_, _ceu_stk,
                  _ceu_app->data, 0, _ceu_app->data->n);
}
#endif

#line 308 "garden.ceu"
    }
#line 308 "garden.ceu"
/* CLEAR: Block (308) */
#line 308 "garden.ceu"
    {
    /* Reuse current stack frame.
     * We know that CLEAR will not abort anything and return normally.
     * Just save the previous "is_alive", call CLEAR, and restore it.
     */
#ifdef CEU_STACK_CLEAR
    int __ceu_old = _ceu_stk->is_alive;
    _ceu_stk->is_alive = 1;
#endif
    tceu_evt evt;
             evt.id = CEU_IN__CLEAR;
    ceu_sys_go_ex(_ceu_app, &evt,
                  _ceu_stk,
                  _ceu_org,
                  0,
                  5);
#ifdef CEU_STACK_CLEAR
    _ceu_stk->is_alive = __ceu_old;
    ceu_sys_stack_clear(_ceu_stk, _ceu_org,
                        0,4);
#endif
}

#line 308 "garden.ceu"
    #ifdef CEU_ORGS_AWAIT
/* signal ok_killed */
{
    tceu_kill ps = { _ceu_org, _ceu_org->ret, 0,4 };
    tceu_evt evt_;
             evt_.id = CEU_IN__ok_killed;
             evt_.param = &ps;
    ceu_sys_go_ex(_ceu_app, &evt_, _ceu_stk,
                  _ceu_app->data, 0, _ceu_app->data->n);
}
#endif

#line 308 "garden.ceu"
    if (0) {

#line 308 "garden.ceu"
case Orchid_Block__fin_52:;
#line 308 "garden.ceu"
    if (((CEU_Orchid*)_ceu_org)->__fin_1069_1) {
    /* NODE: Finally 909 */
/* NODE: Block 908 */

#line 310 "garden.ceu"
    {/* NODE: Stmts 907 */

#line 310 "garden.ceu"
    {/* NODE: Set 5196 */

#line 310 "garden.ceu"
/* SET: idx *//* NODE: NUMBER 905 */

#line 310 "garden.ceu"
    plot_occupied[(((CEU_Orchid*)_ceu_org)->plot)] = 0;
#line 310 "garden.ceu"
    }
#line 310 "garden.ceu"
/* CLEAR: Block (310) */
#line 310 "garden.ceu"
    if (0) {

#line 310 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
}

#line 308 "garden.ceu"
    return;
#line 308 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 303 "garden.ceu"
    }
#line 303 "garden.ceu"
/* CLEAR: Block (303) */
#line 303 "garden.ceu"
    if (0) {

#line 303 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 303 "garden.ceu"
    }
#line 303 "garden.ceu"
/* CLEAR: Block (303) */
#line 303 "garden.ceu"
    if (0) {

#line 303 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 303 "garden.ceu"
    ceu_sys_org_free(_ceu_app, _ceu_org);
#ifdef CEU_ORGS_AWAIT
{
    /* signal ok_killed */
#ifdef CEU_STACK_CLEAR
    tceu_stk stk_ = *_ceu_stk;
             stk_.is_alive = 1;
             stk_.down = _ceu_stk;
#endif
    tceu_kill ps = { _ceu_org, _ceu_org->ret, 0, (tceu_ntrl)(_ceu_org->n-1) };
    tceu_evt evt_;
             evt_.id = CEU_IN__ok_killed;
             evt_.param = &ps;
    ceu_sys_go_ex(_ceu_app, &evt_,
#ifdef CEU_STACK_CLEAR
                  &stk_,
#else
                  NULL,
#endif
                  _ceu_app->data, 0, _ceu_app->data->n);
}
#endif

#line 303 "garden.ceu"
    return;/* NODE: Dcl_cls 8 */

#line 360 "garden.ceu"
case Class_Heliconia:;/* NODE: Block 5646 */

#line 360 "garden.ceu"
    {/* NODE: Stmts 5645 */

#line 360 "garden.ceu"
    {/* NODE: Block 5418 */

#line 360 "garden.ceu"
    {/* NODE: Stmts 5647 */

#line 360 "garden.ceu"
    {/* NODE: Block 1250 */

#line 365 "garden.ceu"
    /*  FINALIZE */
_ceu_org->trls[ 4 ].evt = CEU_IN__CLEAR;
_ceu_org->trls[ 4 ].lbl = Heliconia_Block__fin_62;

#line 365 "garden.ceu"
    ((CEU_Heliconia*)_ceu_org)->__fin_1250_1 = 0;
#line 365 "garden.ceu"
    {/* NODE: Stmts 1249 */

#line 365 "garden.ceu"
    {/* NODE: Set 5431 */

#line 365 "garden.ceu"
/* SET: idx *//* NODE: NUMBER 1081 */

#line 365 "garden.ceu"
    plot_occupied[(((CEU_Heliconia*)_ceu_org)->plot)] = 1;/* NODE: Finalize 1091 */

#line 366 "garden.ceu"
    ((CEU_Heliconia*)_ceu_org)->__fin_1250_1 = 1;/* NODE: Stmts 5437 */

#line 369 "garden.ceu"
    {/* NODE: Dcl_var 5434 */
/* NODE: Set 5438 */

#line 369 "garden.ceu"
/* SET: x *//* NODE: Op2_idx 1095 */

#line 369 "garden.ceu"
    (((CEU_Heliconia*)_ceu_org)->x) = plot_x[(((CEU_Heliconia*)_ceu_org)->plot)];
#line 369 "garden.ceu"
    }/* NODE: Stmts 5443 */

#line 370 "garden.ceu"
    {/* NODE: Dcl_var 5440 */
/* NODE: Set 5444 */

#line 370 "garden.ceu"
/* SET: y *//* NODE: Op2_idx 1100 */

#line 370 "garden.ceu"
    (((CEU_Heliconia*)_ceu_org)->y) = plot_y[(((CEU_Heliconia*)_ceu_org)->plot)];
#line 370 "garden.ceu"
    }/* NODE: Stmts 5449 */

#line 371 "garden.ceu"
    {/* NODE: Dcl_var 5446 */
/* NODE: Set 5450 */

#line 371 "garden.ceu"
/* SET: layer *//* NODE: Op2_idx 1105 */

#line 371 "garden.ceu"
    (((CEU_Heliconia*)_ceu_org)->layer) = plot_layer[(((CEU_Heliconia*)_ceu_org)->plot)];
#line 371 "garden.ceu"
    }/* NODE: ParOr 1248 */

#line 372 "garden.ceu"
/* ParOr: spawn subs */
#line 372 "garden.ceu"
    {
#ifdef CEU_STACK_CLEAR
    tceu_stk stk_ = { _ceu_stk, _ceu_org, 0, 3, 1 };
#endif

#line 372 "garden.ceu"
        _ceu_org->trls[ 0 ].lbl = Heliconia_ParOr_sub_1_54;
    ceu_app_go(_ceu_app,NULL,_ceu_org,
               &_ceu_org->trls[ 0 ],
#ifdef CEU_STACK_CLEAR
               &stk_
#else
               NULL
#endif
              );

#ifdef CEU_STACK_CLEAR
    if (!stk_.is_alive) {
        return;
    }
#endif

#line 372 "garden.ceu"
        _ceu_trl = &_ceu_org->trls[ 1 ];

#line 372 "garden.ceu"
    }
/* NODE: Block 1247 */

#line 381 "garden.ceu"
    {
#line 381 "garden.ceu"
    #ifdef CEU_ORGS
_ceu_org->trls[ 1 ].evt = CEU_IN__ORG;
_ceu_org->trls[ 1 ].org = NULL;
#endif

#line 381 "garden.ceu"
    _ceu_trl = &_ceu_org->trls[ 2 ];
/* NODE: Stmts 1246 */

#line 381 "garden.ceu"
    {/* NODE: Dcl_var 1150 */

#line 381 "garden.ceu"
/* start org: growing */
#line 381 "garden.ceu"
        /* resets org memory and starts org.trail[0]=Class_XXX */
    /* TODO: BUG: _ceu_org is not necessarily the parent for pool allocations */
    ceu_out_org_init(_ceu_app, ((tceu_org*) &(((CEU_Heliconia*)_ceu_org)->growing_10)),7,Class_Growing,
                     4,
                     0,
                     _ceu_org,1);
/* TODO: currently idx is always "1" for all interfaces access because pools 
 * are all together there. When we have separate trls for pools, we'll have to 
 * indirectly access the offset in the interface. */

#line 381 "garden.ceu"
        _ceu_constr_1149(_ceu_app, ((tceu_org*) &(((CEU_Heliconia*)_ceu_org)->growing_10)), _ceu_org);

#line 381 "garden.ceu"
    {
#ifdef CEU_STACK_CLEAR
    tceu_stk stk_ = { _ceu_stk, _ceu_org, 2, 3, 1 };
    ceu_app_go(_ceu_app,NULL,
               ((tceu_org*) &(((CEU_Heliconia*)_ceu_org)->growing_10)), &((tceu_org*) &(((CEU_Heliconia*)_ceu_org)->growing_10))->trls[0],
               &stk_);
    if (!stk_.is_alive) {
        return;
    }
#else
    ceu_app_go(_ceu_app,NULL,
               ((tceu_org*) &(((CEU_Heliconia*)_ceu_org)->growing_10)), &((tceu_org*) &(((CEU_Heliconia*)_ceu_org)->growing_10))->trls[0],
               NULL);
#endif

#line 381 "garden.ceu"
    }
/* NODE: Stmts 5519 */

#line 387 "garden.ceu"
    {/* NODE: Dcl_var 5516 */
/* NODE: Set 5520 */

#line 387 "garden.ceu"
/* SET: survived *//* NODE: NUMBER 1152 */

#line 387 "garden.ceu"
    (((CEU_Heliconia*)_ceu_org)->survived_11) = 0;
#line 387 "garden.ceu"
    }/* NODE: ParOr 1180 */

#line 388 "garden.ceu"
/* ParOr: spawn subs */
#line 388 "garden.ceu"
    {
#ifdef CEU_STACK_CLEAR
    tceu_stk stk_ = { _ceu_stk, _ceu_org, 2, 3, 1 };
#endif

#line 388 "garden.ceu"
        _ceu_org->trls[ 2 ].lbl = Heliconia_ParOr_sub_1_57;
    ceu_app_go(_ceu_app,NULL,_ceu_org,
               &_ceu_org->trls[ 2 ],
#ifdef CEU_STACK_CLEAR
               &stk_
#else
               NULL
#endif
              );

#ifdef CEU_STACK_CLEAR
    if (!stk_.is_alive) {
        return;
    }
#endif

#line 388 "garden.ceu"
        _ceu_trl = &_ceu_org->trls[ 3 ];

#line 388 "garden.ceu"
    }
/* NODE: Block 1179 */

#line 396 "garden.ceu"
    {/* NODE: Stmts 1178 */

#line 396 "garden.ceu"
    {/* NODE: Stmts 5626 */

#line 396 "garden.ceu"
    {/* NODE: Nothing 5584 */
/* NODE: Set 5583 */

#line 396 "garden.ceu"
/* SET: table: 0xe6d510 *//* NODE: Await 1176 */

#line 396 "garden.ceu"
    _CEU_NO_1176_:
if (0) { goto _CEU_NO_1176_; /* avoids "not used" warning */ }

#line 396 "garden.ceu"
    _ceu_trl->evt = 2;
_ceu_trl->lbl = Heliconia_Awake_ok_60;
_ceu_trl->seqno = _ceu_app->seqno;

#line 396 "garden.ceu"
    #ifdef CEU_ORGS
_ceu_trl->evto  = (&((CEU_Heliconia*)_ceu_org)->growing_10);
#endif

#line 396 "garden.ceu"
    return;

case Heliconia_Awake_ok_60:;

#line 396 "garden.ceu"
    #ifdef CEU_DEBUG_TRAILS
#ifndef CEU_OS
printf("\tOK!\n");
#endif
#endif

#line 396 "garden.ceu"
    {

#line 396 "garden.ceu"
        tceu__bool* __ceu_casted = (tceu__bool*) _ceu_evt->param;

#line 396 "garden.ceu"
        (((CEU_Heliconia*)_ceu_org)->survived_11) = ((__ceu_casted)->_1);
}
/* NODE: Nothing 8218 */
/* NODE: Nothing 8219 */

#line 396 "garden.ceu"
    }
#line 396 "garden.ceu"
    }
#line 396 "garden.ceu"
/* CLEAR: Block (396) */
#line 396 "garden.ceu"
    if (0) {

#line 396 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 388 "garden.ceu"
/* PAROR JOIN */
#line 388 "garden.ceu"
    _ceu_lbl = Heliconia_ParOr_out_58;
goto _CEU_GOTO_;

#line 388 "garden.ceu"
case Heliconia_ParOr_sub_1_57:;/* NODE: Block 1172 */

#line 389 "garden.ceu"
    {/* NODE: Stmts 1171 */

#line 389 "garden.ceu"
    {/* NODE: Block 5524 */

#line 389 "garden.ceu"
    {/* NODE: Stmts 5523 */

#line 389 "garden.ceu"
    {/* NODE: Stmts 5522 */

#line 389 "garden.ceu"
    {
#line 389 "garden.ceu"
    }/* NODE: Loop 5521 */

#line 389 "garden.ceu"
    for (;;) {
/* NODE: Block 1169 */

#line 390 "garden.ceu"
    {
#line 390 "garden.ceu"
    int __ceu_incoming_plot_12;
/* NODE: Stmts 1168 */

#line 390 "garden.ceu"
    {/* NODE: Stmts 5529 */

#line 390 "garden.ceu"
    {/* NODE: Dcl_var 5526 */
/* NODE: Stmts 5574 */

#line 390 "garden.ceu"
    {/* NODE: Nothing 5532 */
/* NODE: Set 5531 */

#line 390 "garden.ceu"
/* SET: table: 0xea0ad0 *//* NODE: Await 1157 */

#line 390 "garden.ceu"
    _CEU_NO_1157_:
if (0) { goto _CEU_NO_1157_; /* avoids "not used" warning */ }

#line 390 "garden.ceu"
    _ceu_trl->evt = 3;
_ceu_trl->lbl = Heliconia_Awake_go_water_59;
_ceu_trl->seqno = _ceu_app->seqno;

#line 390 "garden.ceu"
    #ifdef CEU_ORGS
_ceu_trl->evto  = (((CEU_Heliconia*)_ceu_org)->garden);
#endif

#line 390 "garden.ceu"
    return;

case Heliconia_Awake_go_water_59:;

#line 390 "garden.ceu"
    #ifdef CEU_DEBUG_TRAILS
#ifndef CEU_OS
printf("\tOK!\n");
#endif
#endif

#line 390 "garden.ceu"
    {

#line 390 "garden.ceu"
        tceu__int* __ceu_casted = (tceu__int*) _ceu_evt->param;

#line 390 "garden.ceu"
        (__ceu_incoming_plot_12) = ((__ceu_casted)->_1);
}
/* NODE: Nothing 8214 */
/* NODE: Nothing 8215 */

#line 390 "garden.ceu"
    }
#line 390 "garden.ceu"
    }/* NODE: If 5580 */

#line 391 "garden.ceu"
    if (((__ceu_incoming_plot_12)==(((CEU_Heliconia*)_ceu_org)->plot))) {
/* NODE: Block 1166 */

#line 392 "garden.ceu"
    {/* NODE: Stmts 1165 */

#line 392 "garden.ceu"
    {/* NODE: EmitInt 1164 */

#line 392 "garden.ceu"
    {
#ifdef CEU_STACK_CLEAR
    tceu_stk stk_ = { _ceu_stk, _ceu_org, 2, 2, 1 };
#endif

#line 392 "garden.ceu"
        /* trigger the event */
    tceu_evt evt;
    evt.id = 1;
#ifdef CEU_ORGS
#line 392 "garden.ceu"
    evt.org = (tceu_org*) (&((CEU_Heliconia*)_ceu_org)->growing_10);
#endif

#line 392 "garden.ceu"
        ceu_sys_go_ex(_ceu_app, &evt,
#ifdef CEU_STACK_CLEAR
                  &stk_,
#else
                  NULL,
#endif
                  _ceu_app->data, 0,
#ifdef CEU_ORGS
                  _ceu_app->data->n
#else
                  CEU_NTRAILS
#endif
    );

#ifdef CEU_STACK_CLEAR
    if (!stk_.is_alive) {
        return;
    }
#endif
}

#line 392 "garden.ceu"
    }
#line 392 "garden.ceu"
/* CLEAR: Block (392) */
#line 392 "garden.ceu"
    if (0) {

#line 392 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
} else {
/* NODE: Nothing 5579 */
}

#line 390 "garden.ceu"
    }
#line 390 "garden.ceu"
/* CLEAR: Block (390) */
#line 390 "garden.ceu"
    if (0) {

#line 390 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 389 "garden.ceu"
    }

#line 389 "garden.ceu"
    }
#line 389 "garden.ceu"
/* CLEAR: Block (389) */
#line 389 "garden.ceu"
    if (0) {

#line 389 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 389 "garden.ceu"
    }
#line 389 "garden.ceu"
/* CLEAR: Block (389) */
#line 389 "garden.ceu"
    if (0) {

#line 389 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 388 "garden.ceu"
case Heliconia_ParOr_out_58:;
#line 388 "garden.ceu"
/* CLEAR: ParOr (388) */
#line 388 "garden.ceu"
    {
    /* Reuse current stack frame.
     * We know that CLEAR will not abort anything and return normally.
     * Just save the previous "is_alive", call CLEAR, and restore it.
     */
#ifdef CEU_STACK_CLEAR
    int __ceu_old = _ceu_stk->is_alive;
    _ceu_stk->is_alive = 1;
#endif
    tceu_evt evt;
             evt.id = CEU_IN__CLEAR;
    ceu_sys_go_ex(_ceu_app, &evt,
                  _ceu_stk,
                  _ceu_org,
                  2,
                  4);
#ifdef CEU_STACK_CLEAR
    _ceu_stk->is_alive = __ceu_old;
    ceu_sys_stack_clear(_ceu_stk, _ceu_org,
                        2,3);
#endif
}
/* NODE: If 5632 */

#line 398 "garden.ceu"
    if ((((CEU_Heliconia*)_ceu_org)->survived_11)) {
/* NODE: Block 1244 */

#line 399 "garden.ceu"
    /*  FINALIZE */
_ceu_org->trls[ 3 ].evt = CEU_IN__CLEAR;
_ceu_org->trls[ 3 ].lbl = Heliconia_Block__fin_61;

#line 399 "garden.ceu"
    ((CEU_Heliconia*)_ceu_org)->__fin_1244_1 = 0;
#line 399 "garden.ceu"
    ((CEU_Heliconia*)_ceu_org)->__fin_1244_2 = 0;
#line 399 "garden.ceu"
    {/* NODE: Stmts 1243 */

#line 399 "garden.ceu"
    {/* NODE: Set 5633 */

#line 399 "garden.ceu"
/* SET: . *//* NODE: Op2_+ 1187 */

#line 399 "garden.ceu"
    (((*((CEU_Heliconia*)_ceu_org)->garden).t3_plants)) = ((((*((CEU_Heliconia*)_ceu_org)->garden).t3_plants))+1);/* NODE: Set 5634 */

#line 400 "garden.ceu"
/* SET: . *//* NODE: Op2_+ 1194 */

#line 400 "garden.ceu"
    (((*((CEU_Heliconia*)_ceu_org)->garden).score)) = ((((*((CEU_Heliconia*)_ceu_org)->garden).score))+2.0);/* NODE: Finalize 1213 */

#line 401 "garden.ceu"
    ((CEU_Heliconia*)_ceu_org)->__fin_1244_2 = 1;/* NODE: Stmts 5641 */

#line 405 "garden.ceu"
    {/* NODE: Dcl_var 5638 */
/* NODE: Set 5642 */

#line 405 "garden.ceu"
/* SET: id *//* NODE: Var 1215 */

#line 405 "garden.ceu"
    (((CEU_Heliconia*)_ceu_org)->id_13) = (*((CEU_Heliconia*)_ceu_org)->gensym);
#line 405 "garden.ceu"
    }/* NODE: Set 5643 */

#line 406 "garden.ceu"
/* SET: gensym *//* NODE: Op2_+ 1220 */

#line 406 "garden.ceu"
    (*((CEU_Heliconia*)_ceu_org)->gensym) = ((*((CEU_Heliconia*)_ceu_org)->gensym)+1);/* NODE: EmitExt 1229 */

#line 407 "garden.ceu"
        {

#line 407 "garden.ceu"
    tceu__int__int__int__int__int __ceu_ps_1229;
{
    tceu__int__int__int__int__int __ceu_ps_1229_ =
        { (((CEU_Heliconia*)_ceu_org)->id_13),(((CEU_Heliconia*)_ceu_org)->x),(((CEU_Heliconia*)_ceu_org)->y),11,(((CEU_Heliconia*)_ceu_org)->layer) };
    __ceu_ps_1229 = __ceu_ps_1229_;
}

#line 407 "garden.ceu"
    
#if defined(ceu_out_emit_NEW_SPRITE)
    ceu_out_emit_NEW_SPRITE((&__ceu_ps_1229))

#elif defined(ceu_out_emit)
    (ceu_out_emit(_ceu_app, CEU_OUT_NEW_SPRITE, sizeof(tceu__int__int__int__int__int), (void*)(&__ceu_ps_1229)))

#else
    #error ceu_out_emit_* is not defined
#endif
;
#line 407 "garden.ceu"
        }
/* NODE: Finalize 1241 */

#line 408 "garden.ceu"
    ((CEU_Heliconia*)_ceu_org)->__fin_1244_1 = 1;/* NODE: AwaitN 1242 */

#line 412 "garden.ceu"
    return;
#line 399 "garden.ceu"
    }
#line 399 "garden.ceu"
/* CLEAR: Block (399) */
#line 399 "garden.ceu"
    if (0) {

#line 399 "garden.ceu"
case Heliconia_Block__fin_61:;
#line 399 "garden.ceu"
    if (((CEU_Heliconia*)_ceu_org)->__fin_1244_1) {
    /* NODE: Finally 1240 */
/* NODE: Block 1239 */

#line 409 "garden.ceu"
    {/* NODE: Stmts 1238 */

#line 409 "garden.ceu"
    {/* NODE: CallStmt 1234 */

#line 409 "garden.ceu"
    printf("flouishing over\n");/* NODE: EmitExt 1237 */

#line 410 "garden.ceu"
        {

#line 410 "garden.ceu"
    tceu__int __ceu_ps_1237;
{
    tceu__int __ceu_ps_1237_ =
        { (((CEU_Heliconia*)_ceu_org)->id_13) };
    __ceu_ps_1237 = __ceu_ps_1237_;
}

#line 410 "garden.ceu"
    
#if defined(ceu_out_emit_FREE_SPRITE)
    ceu_out_emit_FREE_SPRITE((&__ceu_ps_1237))

#elif defined(ceu_out_emit)
    (ceu_out_emit(_ceu_app, CEU_OUT_FREE_SPRITE, sizeof(tceu__int), (void*)(&__ceu_ps_1237)))

#else
    #error ceu_out_emit_* is not defined
#endif
;
#line 410 "garden.ceu"
        }

#line 409 "garden.ceu"
    }
#line 409 "garden.ceu"
/* CLEAR: Block (409) */
#line 409 "garden.ceu"
    if (0) {

#line 409 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
}

#line 399 "garden.ceu"
    if (((CEU_Heliconia*)_ceu_org)->__fin_1244_2) {
    /* NODE: Finally 1212 */
/* NODE: Block 1211 */

#line 402 "garden.ceu"
    {/* NODE: Stmts 1210 */

#line 402 "garden.ceu"
    {/* NODE: Set 5635 */

#line 402 "garden.ceu"
/* SET: . *//* NODE: Op2_- 1201 */

#line 402 "garden.ceu"
    (((*((CEU_Heliconia*)_ceu_org)->garden).t3_plants)) = ((((*((CEU_Heliconia*)_ceu_org)->garden).t3_plants))-1);/* NODE: Set 5636 */

#line 403 "garden.ceu"
/* SET: . *//* NODE: Op2_- 1208 */

#line 403 "garden.ceu"
    (((*((CEU_Heliconia*)_ceu_org)->garden).score)) = ((((*((CEU_Heliconia*)_ceu_org)->garden).score))-2.0);
#line 402 "garden.ceu"
    }
#line 402 "garden.ceu"
/* CLEAR: Block (402) */
#line 402 "garden.ceu"
    if (0) {

#line 402 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
}

#line 399 "garden.ceu"
    return;
#line 399 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
} else {
/* NODE: Nothing 5631 */
}

#line 381 "garden.ceu"
    }
#line 381 "garden.ceu"
/* CLEAR: Block (381) */
#line 381 "garden.ceu"
    {
    /* Reuse current stack frame.
     * We know that CLEAR will not abort anything and return normally.
     * Just save the previous "is_alive", call CLEAR, and restore it.
     */
#ifdef CEU_STACK_CLEAR
    int __ceu_old = _ceu_stk->is_alive;
    _ceu_stk->is_alive = 1;
#endif
    tceu_evt evt;
             evt.id = CEU_IN__CLEAR;
    ceu_sys_go_ex(_ceu_app, &evt,
                  _ceu_stk,
                  _ceu_org,
                  1,
                  4);
#ifdef CEU_STACK_CLEAR
    _ceu_stk->is_alive = __ceu_old;
    ceu_sys_stack_clear(_ceu_stk, _ceu_org,
                        1,3);
#endif
}

#line 381 "garden.ceu"
    #ifdef CEU_ORGS_AWAIT
/* signal ok_killed */
{
    tceu_kill ps = { _ceu_org, _ceu_org->ret, 1,3 };
    tceu_evt evt_;
             evt_.id = CEU_IN__ok_killed;
             evt_.param = &ps;
    ceu_sys_go_ex(_ceu_app, &evt_, _ceu_stk,
                  _ceu_app->data, 0, _ceu_app->data->n);
}
#endif

#line 381 "garden.ceu"
    if (0) {

#line 381 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 372 "garden.ceu"
/* PAROR JOIN */
#line 372 "garden.ceu"
    _ceu_lbl = Heliconia_ParOr_out_55;
goto _CEU_GOTO_;

#line 372 "garden.ceu"
case Heliconia_ParOr_sub_1_54:;/* NODE: Block 1128 */

#line 373 "garden.ceu"
    {/* NODE: Stmts 1127 */

#line 373 "garden.ceu"
    {/* NODE: Block 5454 */

#line 373 "garden.ceu"
    {/* NODE: Stmts 5453 */

#line 373 "garden.ceu"
    {/* NODE: Stmts 5452 */

#line 373 "garden.ceu"
    {
#line 373 "garden.ceu"
    }/* NODE: Loop 5451 */

#line 373 "garden.ceu"
    for (;;) {
/* NODE: Block 1125 */

#line 374 "garden.ceu"
    {
#line 374 "garden.ceu"
    int __ceu_incoming_plot_9;
/* NODE: Stmts 1124 */

#line 374 "garden.ceu"
    {/* NODE: Stmts 5459 */

#line 374 "garden.ceu"
    {/* NODE: Dcl_var 5456 */
/* NODE: Stmts 5504 */

#line 374 "garden.ceu"
    {/* NODE: Nothing 5462 */
/* NODE: Set 5461 */

#line 374 "garden.ceu"
/* SET: table: 0xfa3d60 *//* NODE: Await 1110 */

#line 374 "garden.ceu"
    _CEU_NO_1110_:
if (0) { goto _CEU_NO_1110_; /* avoids "not used" warning */ }

#line 374 "garden.ceu"
    _ceu_trl->evt = 1;
_ceu_trl->lbl = Heliconia_Awake_go_dig_56;
_ceu_trl->seqno = _ceu_app->seqno;

#line 374 "garden.ceu"
    #ifdef CEU_ORGS
_ceu_trl->evto  = (((CEU_Heliconia*)_ceu_org)->garden);
#endif

#line 374 "garden.ceu"
    return;

case Heliconia_Awake_go_dig_56:;

#line 374 "garden.ceu"
    #ifdef CEU_DEBUG_TRAILS
#ifndef CEU_OS
printf("\tOK!\n");
#endif
#endif

#line 374 "garden.ceu"
    {

#line 374 "garden.ceu"
        tceu__int* __ceu_casted = (tceu__int*) _ceu_evt->param;

#line 374 "garden.ceu"
        (__ceu_incoming_plot_9) = ((__ceu_casted)->_1);
}
/* NODE: Nothing 8207 */
/* NODE: Nothing 8208 */

#line 374 "garden.ceu"
    }
#line 374 "garden.ceu"
    }/* NODE: If 5510 */

#line 375 "garden.ceu"
    if (((__ceu_incoming_plot_9)==(((CEU_Heliconia*)_ceu_org)->plot))) {
/* NODE: Block 1122 */

#line 376 "garden.ceu"
    {/* NODE: Stmts 1121 */

#line 376 "garden.ceu"
    {/* NODE: CallStmt 1119 */

#line 376 "garden.ceu"
    printf("heliconia dug up\n");/* NODE: Break 1120 */

#line 377 "garden.ceu"
    break;
#line 376 "garden.ceu"
    }
#line 376 "garden.ceu"
/* CLEAR: Block (376) */
#line 376 "garden.ceu"
    if (0) {

#line 376 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
} else {
/* NODE: Nothing 5509 */
}

#line 374 "garden.ceu"
    }
#line 374 "garden.ceu"
/* CLEAR: Block (374) */
#line 374 "garden.ceu"
    if (0) {

#line 374 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 373 "garden.ceu"
    }

#line 373 "garden.ceu"
/* CLEAR: Loop (373) */
#line 373 "garden.ceu"
    }
#line 373 "garden.ceu"
/* CLEAR: Block (373) */
#line 373 "garden.ceu"
    if (0) {

#line 373 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 373 "garden.ceu"
    }
#line 373 "garden.ceu"
/* CLEAR: Block (373) */
#line 373 "garden.ceu"
    if (0) {

#line 373 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 372 "garden.ceu"
/* PAROR JOIN */
#line 372 "garden.ceu"
    _ceu_lbl = Heliconia_ParOr_out_55;
goto _CEU_GOTO_;

#line 372 "garden.ceu"
case Heliconia_ParOr_out_55:;
#line 372 "garden.ceu"
/* CLEAR: ParOr (372) */
#line 372 "garden.ceu"
    {
    /* Reuse current stack frame.
     * We know that CLEAR will not abort anything and return normally.
     * Just save the previous "is_alive", call CLEAR, and restore it.
     */
#ifdef CEU_STACK_CLEAR
    int __ceu_old = _ceu_stk->is_alive;
    _ceu_stk->is_alive = 1;
#endif
    tceu_evt evt;
             evt.id = CEU_IN__CLEAR;
    ceu_sys_go_ex(_ceu_app, &evt,
                  _ceu_stk,
                  _ceu_org,
                  0,
                  4);
#ifdef CEU_STACK_CLEAR
    _ceu_stk->is_alive = __ceu_old;
    ceu_sys_stack_clear(_ceu_stk, _ceu_org,
                        0,3);
#endif
}

#line 372 "garden.ceu"
    #ifdef CEU_ORGS_AWAIT
/* signal ok_killed */
{
    tceu_kill ps = { _ceu_org, _ceu_org->ret, 0,3 };
    tceu_evt evt_;
             evt_.id = CEU_IN__ok_killed;
             evt_.param = &ps;
    ceu_sys_go_ex(_ceu_app, &evt_, _ceu_stk,
                  _ceu_app->data, 0, _ceu_app->data->n);
}
#endif

#line 365 "garden.ceu"
    }
#line 365 "garden.ceu"
/* CLEAR: Block (365) */
#line 365 "garden.ceu"
    {
    /* Reuse current stack frame.
     * We know that CLEAR will not abort anything and return normally.
     * Just save the previous "is_alive", call CLEAR, and restore it.
     */
#ifdef CEU_STACK_CLEAR
    int __ceu_old = _ceu_stk->is_alive;
    _ceu_stk->is_alive = 1;
#endif
    tceu_evt evt;
             evt.id = CEU_IN__CLEAR;
    ceu_sys_go_ex(_ceu_app, &evt,
                  _ceu_stk,
                  _ceu_org,
                  0,
                  5);
#ifdef CEU_STACK_CLEAR
    _ceu_stk->is_alive = __ceu_old;
    ceu_sys_stack_clear(_ceu_stk, _ceu_org,
                        0,4);
#endif
}

#line 365 "garden.ceu"
    #ifdef CEU_ORGS_AWAIT
/* signal ok_killed */
{
    tceu_kill ps = { _ceu_org, _ceu_org->ret, 0,4 };
    tceu_evt evt_;
             evt_.id = CEU_IN__ok_killed;
             evt_.param = &ps;
    ceu_sys_go_ex(_ceu_app, &evt_, _ceu_stk,
                  _ceu_app->data, 0, _ceu_app->data->n);
}
#endif

#line 365 "garden.ceu"
    if (0) {

#line 365 "garden.ceu"
case Heliconia_Block__fin_62:;
#line 365 "garden.ceu"
    if (((CEU_Heliconia*)_ceu_org)->__fin_1250_1) {
    /* NODE: Finally 1090 */
/* NODE: Block 1089 */

#line 367 "garden.ceu"
    {/* NODE: Stmts 1088 */

#line 367 "garden.ceu"
    {/* NODE: Set 5432 */

#line 367 "garden.ceu"
/* SET: idx *//* NODE: NUMBER 1086 */

#line 367 "garden.ceu"
    plot_occupied[(((CEU_Heliconia*)_ceu_org)->plot)] = 0;
#line 367 "garden.ceu"
    }
#line 367 "garden.ceu"
/* CLEAR: Block (367) */
#line 367 "garden.ceu"
    if (0) {

#line 367 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
}

#line 365 "garden.ceu"
    return;
#line 365 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 360 "garden.ceu"
    }
#line 360 "garden.ceu"
/* CLEAR: Block (360) */
#line 360 "garden.ceu"
    if (0) {

#line 360 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 360 "garden.ceu"
    }
#line 360 "garden.ceu"
/* CLEAR: Block (360) */
#line 360 "garden.ceu"
    if (0) {

#line 360 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 360 "garden.ceu"
    ceu_sys_org_free(_ceu_app, _ceu_org);
#ifdef CEU_ORGS_AWAIT
{
    /* signal ok_killed */
#ifdef CEU_STACK_CLEAR
    tceu_stk stk_ = *_ceu_stk;
             stk_.is_alive = 1;
             stk_.down = _ceu_stk;
#endif
    tceu_kill ps = { _ceu_org, _ceu_org->ret, 0, (tceu_ntrl)(_ceu_org->n-1) };
    tceu_evt evt_;
             evt_.id = CEU_IN__ok_killed;
             evt_.param = &ps;
    ceu_sys_go_ex(_ceu_app, &evt_,
#ifdef CEU_STACK_CLEAR
                  &stk_,
#else
                  NULL,
#endif
                  _ceu_app->data, 0, _ceu_app->data->n);
}
#endif

#line 360 "garden.ceu"
    return;/* NODE: Dcl_cls 9 */

#line 450 "garden.ceu"
case Class_BagActive:;/* NODE: Block 5830 */

#line 450 "garden.ceu"
    {/* NODE: Stmts 5829 */

#line 450 "garden.ceu"
    {/* NODE: Block 5654 */

#line 450 "garden.ceu"
    {/* NODE: Stmts 5831 */

#line 450 "garden.ceu"
    {/* NODE: Block 1542 */

#line 458 "garden.ceu"
    /*  FINALIZE */
_ceu_org->trls[ 2 ].evt = CEU_IN__CLEAR;
_ceu_org->trls[ 2 ].lbl = BagActive_Block__fin_68;

#line 458 "garden.ceu"
    ((CEU_BagActive*)_ceu_org)->__fin_1542_1 = 0;
#line 458 "garden.ceu"
    {/* NODE: Stmts 1541 */

#line 458 "garden.ceu"
    {/* NODE: Stmts 5681 */

#line 458 "garden.ceu"
    {/* NODE: Dcl_var 5678 */
/* NODE: Set 5682 */

#line 458 "garden.ceu"
/* SET: patch *//* NODE: Op1_- 1267 */

#line 458 "garden.ceu"
    (((CEU_BagActive*)_ceu_org)->patch) = (-1);
#line 458 "garden.ceu"
    }/* NODE: EmitExt 1274 */

#line 459 "garden.ceu"
        {

#line 459 "garden.ceu"
    tceu__int__float __ceu_ps_1274;
{
    tceu__int__float __ceu_ps_1274_ =
        { (((CEU_BagActive*)_ceu_org)->id),(-1.0) };
    __ceu_ps_1274 = __ceu_ps_1274_;
}

#line 459 "garden.ceu"
    
#if defined(ceu_out_emit_SET_SPRITE_ROTATION)
    ceu_out_emit_SET_SPRITE_ROTATION((&__ceu_ps_1274))

#elif defined(ceu_out_emit)
    (ceu_out_emit(_ceu_app, CEU_OUT_SET_SPRITE_ROTATION, sizeof(tceu__int__float), (void*)(&__ceu_ps_1274)))

#else
    #error ceu_out_emit_* is not defined
#endif
;
#line 459 "garden.ceu"
        }
/* NODE: Finalize 1283 */

#line 460 "garden.ceu"
    ((CEU_BagActive*)_ceu_org)->__fin_1542_1 = 1;/* NODE: ParOr 1538 */

#line 463 "garden.ceu"
/* ParOr: spawn subs */
#line 463 "garden.ceu"
    {
#ifdef CEU_STACK_CLEAR
    tceu_stk stk_ = { _ceu_stk, _ceu_org, 0, 1, 1 };
#endif

#line 463 "garden.ceu"
        _ceu_org->trls[ 0 ].lbl = BagActive_ParOr_sub_1_64;
    ceu_app_go(_ceu_app,NULL,_ceu_org,
               &_ceu_org->trls[ 0 ],
#ifdef CEU_STACK_CLEAR
               &stk_
#else
               NULL
#endif
              );

#ifdef CEU_STACK_CLEAR
    if (!stk_.is_alive) {
        return;
    }
#endif

#line 463 "garden.ceu"
        _ceu_trl = &_ceu_org->trls[ 1 ];

#line 463 "garden.ceu"
    }
/* NODE: Block 1537 */

#line 466 "garden.ceu"
    {/* NODE: Stmts 1536 */

#line 466 "garden.ceu"
    {/* NODE: Block 5730 */

#line 466 "garden.ceu"
    {/* NODE: Stmts 5729 */

#line 466 "garden.ceu"
    {/* NODE: Stmts 5728 */

#line 466 "garden.ceu"
    {
#line 466 "garden.ceu"
    }/* NODE: Loop 5727 */

#line 466 "garden.ceu"
    for (;;) {
/* NODE: Block 1534 */

#line 467 "garden.ceu"
    {/* NODE: Stmts 1533 */

#line 467 "garden.ceu"
    {/* NODE: Stmts 5735 */

#line 467 "garden.ceu"
    {/* NODE: Dcl_var 5732 */
/* NODE: Set 5736 */

#line 467 "garden.ceu"
/* SET: rightborder *//* NODE: Op2_> 1309 */

#line 467 "garden.ceu"
    (((CEU_BagActive*)_ceu_org)->rightborder_10) = ((((1175-1030)*((*((CEU_BagActive*)_ceu_org)->y)-485))-((800-485)*((*((CEU_BagActive*)_ceu_org)->x)-1030)))>0);
#line 467 "garden.ceu"
    }/* NODE: Stmts 5741 */

#line 468 "garden.ceu"
    {/* NODE: Dcl_var 5738 */
/* NODE: Set 5742 */

#line 468 "garden.ceu"
/* SET: rightmidborder *//* NODE: Op2_> 1328 */

#line 468 "garden.ceu"
    (((CEU_BagActive*)_ceu_org)->rightmidborder_11) = ((((828-778)*((*((CEU_BagActive*)_ceu_org)->y)-485))-((800-485)*((*((CEU_BagActive*)_ceu_org)->x)-778)))>0);
#line 468 "garden.ceu"
    }/* NODE: Stmts 5747 */

#line 469 "garden.ceu"
    {/* NODE: Dcl_var 5744 */
/* NODE: Set 5748 */

#line 469 "garden.ceu"
/* SET: leftmidborder *//* NODE: Op2_> 1347 */

#line 469 "garden.ceu"
    (((CEU_BagActive*)_ceu_org)->leftmidborder_12) = ((((461-512)*((*((CEU_BagActive*)_ceu_org)->y)-485))-((800-485)*((*((CEU_BagActive*)_ceu_org)->x)-512)))>0);
#line 469 "garden.ceu"
    }/* NODE: Stmts 5753 */

#line 470 "garden.ceu"
    {/* NODE: Dcl_var 5750 */
/* NODE: Set 5754 */

#line 470 "garden.ceu"
/* SET: leftborder *//* NODE: Op2_> 1366 */

#line 470 "garden.ceu"
    (((CEU_BagActive*)_ceu_org)->leftborder_13) = ((((111-258)*((*((CEU_BagActive*)_ceu_org)->y)-485))-((800-485)*((*((CEU_BagActive*)_ceu_org)->x)-258)))>0);
#line 470 "garden.ceu"
    }/* NODE: If 5757 */

#line 472 "garden.ceu"
    if ((((*((CEU_BagActive*)_ceu_org)->y)>485)&&((*((CEU_BagActive*)_ceu_org)->y)<=614))) {
/* NODE: Block 1446 */

#line 473 "garden.ceu"
    {/* NODE: Stmts 1445 */

#line 473 "garden.ceu"
    {/* NODE: If 5760 */

#line 473 "garden.ceu"
    if (((((CEU_BagActive*)_ceu_org)->rightborder_10)&&(!(((CEU_BagActive*)_ceu_org)->rightmidborder_11)))) {
/* NODE: Block 1395 */

#line 474 "garden.ceu"
    {/* NODE: Stmts 1394 */

#line 474 "garden.ceu"
    {/* NODE: If 5762 */

#line 474 "garden.ceu"
    if (((((CEU_BagActive*)_ceu_org)->patch)!=2)) {
/* NODE: Block 1392 */

#line 475 "garden.ceu"
    {/* NODE: Stmts 1391 */

#line 475 "garden.ceu"
    {/* NODE: Set 5763 */

#line 475 "garden.ceu"
/* SET: patch *//* NODE: NUMBER 1383 */

#line 475 "garden.ceu"
    (((CEU_BagActive*)_ceu_org)->patch) = 2;/* NODE: EmitInt 1390 */

#line 476 "garden.ceu"
    {
#ifdef CEU_STACK_CLEAR
    tceu_stk stk_ = { _ceu_stk, _ceu_org, 1, 1, 1 };
#endif

#line 476 "garden.ceu"
    tceu__int__int __ceu_ps_1390;
{
    tceu__int__int __ceu_ps_1390_ =
        { (((CEU_BagActive*)_ceu_org)->seed),2 };
    __ceu_ps_1390 = __ceu_ps_1390_;
}

#line 476 "garden.ceu"
        /* trigger the event */
    tceu_evt evt;
    evt.id = 2;
#ifdef CEU_ORGS
#line 476 "garden.ceu"
    evt.org = (tceu_org*) (((CEU_BagActive*)_ceu_org)->garden);
#endif

#line 476 "garden.ceu"
        evt.param = (&__ceu_ps_1390);

#line 476 "garden.ceu"
        ceu_sys_go_ex(_ceu_app, &evt,
#ifdef CEU_STACK_CLEAR
                  &stk_,
#else
                  NULL,
#endif
                  _ceu_app->data, 0,
#ifdef CEU_ORGS
                  _ceu_app->data->n
#else
                  CEU_NTRAILS
#endif
    );

#ifdef CEU_STACK_CLEAR
    if (!stk_.is_alive) {
        return;
    }
#endif
}

#line 475 "garden.ceu"
    }
#line 475 "garden.ceu"
/* CLEAR: Block (475) */
#line 475 "garden.ceu"
    if (0) {

#line 475 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
} else {
/* NODE: Nothing 5761 */
}

#line 474 "garden.ceu"
    }
#line 474 "garden.ceu"
/* CLEAR: Block (474) */
#line 474 "garden.ceu"
    if (0) {

#line 474 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
} else {
/* NODE: If 5759 */

#line 478 "garden.ceu"
    if (((((CEU_BagActive*)_ceu_org)->rightmidborder_11)&&(!(((CEU_BagActive*)_ceu_org)->leftmidborder_12)))) {
/* NODE: Block 1416 */

#line 479 "garden.ceu"
    {/* NODE: Stmts 1415 */

#line 479 "garden.ceu"
    {/* NODE: If 5765 */

#line 479 "garden.ceu"
    if (((((CEU_BagActive*)_ceu_org)->patch)!=1)) {
/* NODE: Block 1413 */

#line 480 "garden.ceu"
    {/* NODE: Stmts 1412 */

#line 480 "garden.ceu"
    {/* NODE: Set 5766 */

#line 480 "garden.ceu"
/* SET: patch *//* NODE: NUMBER 1404 */

#line 480 "garden.ceu"
    (((CEU_BagActive*)_ceu_org)->patch) = 1;/* NODE: EmitInt 1411 */

#line 481 "garden.ceu"
    {
#ifdef CEU_STACK_CLEAR
    tceu_stk stk_ = { _ceu_stk, _ceu_org, 1, 1, 1 };
#endif

#line 481 "garden.ceu"
    tceu__int__int __ceu_ps_1411;
{
    tceu__int__int __ceu_ps_1411_ =
        { (((CEU_BagActive*)_ceu_org)->seed),1 };
    __ceu_ps_1411 = __ceu_ps_1411_;
}

#line 481 "garden.ceu"
        /* trigger the event */
    tceu_evt evt;
    evt.id = 2;
#ifdef CEU_ORGS
#line 481 "garden.ceu"
    evt.org = (tceu_org*) (((CEU_BagActive*)_ceu_org)->garden);
#endif

#line 481 "garden.ceu"
        evt.param = (&__ceu_ps_1411);

#line 481 "garden.ceu"
        ceu_sys_go_ex(_ceu_app, &evt,
#ifdef CEU_STACK_CLEAR
                  &stk_,
#else
                  NULL,
#endif
                  _ceu_app->data, 0,
#ifdef CEU_ORGS
                  _ceu_app->data->n
#else
                  CEU_NTRAILS
#endif
    );

#ifdef CEU_STACK_CLEAR
    if (!stk_.is_alive) {
        return;
    }
#endif
}

#line 480 "garden.ceu"
    }
#line 480 "garden.ceu"
/* CLEAR: Block (480) */
#line 480 "garden.ceu"
    if (0) {

#line 480 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
} else {
/* NODE: Nothing 5764 */
}

#line 479 "garden.ceu"
    }
#line 479 "garden.ceu"
/* CLEAR: Block (479) */
#line 479 "garden.ceu"
    if (0) {

#line 479 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
} else {
/* NODE: If 5758 */

#line 483 "garden.ceu"
    if (((((CEU_BagActive*)_ceu_org)->leftmidborder_12)&&(!(((CEU_BagActive*)_ceu_org)->leftborder_13)))) {
/* NODE: Block 1437 */

#line 484 "garden.ceu"
    {/* NODE: Stmts 1436 */

#line 484 "garden.ceu"
    {/* NODE: If 5768 */

#line 484 "garden.ceu"
    if (((((CEU_BagActive*)_ceu_org)->patch)!=0)) {
/* NODE: Block 1434 */

#line 485 "garden.ceu"
    {/* NODE: Stmts 1433 */

#line 485 "garden.ceu"
    {/* NODE: Set 5769 */

#line 485 "garden.ceu"
/* SET: patch *//* NODE: NUMBER 1425 */

#line 485 "garden.ceu"
    (((CEU_BagActive*)_ceu_org)->patch) = 0;/* NODE: EmitInt 1432 */

#line 486 "garden.ceu"
    {
#ifdef CEU_STACK_CLEAR
    tceu_stk stk_ = { _ceu_stk, _ceu_org, 1, 1, 1 };
#endif

#line 486 "garden.ceu"
    tceu__int__int __ceu_ps_1432;
{
    tceu__int__int __ceu_ps_1432_ =
        { (((CEU_BagActive*)_ceu_org)->seed),0 };
    __ceu_ps_1432 = __ceu_ps_1432_;
}

#line 486 "garden.ceu"
        /* trigger the event */
    tceu_evt evt;
    evt.id = 2;
#ifdef CEU_ORGS
#line 486 "garden.ceu"
    evt.org = (tceu_org*) (((CEU_BagActive*)_ceu_org)->garden);
#endif

#line 486 "garden.ceu"
        evt.param = (&__ceu_ps_1432);

#line 486 "garden.ceu"
        ceu_sys_go_ex(_ceu_app, &evt,
#ifdef CEU_STACK_CLEAR
                  &stk_,
#else
                  NULL,
#endif
                  _ceu_app->data, 0,
#ifdef CEU_ORGS
                  _ceu_app->data->n
#else
                  CEU_NTRAILS
#endif
    );

#ifdef CEU_STACK_CLEAR
    if (!stk_.is_alive) {
        return;
    }
#endif
}

#line 485 "garden.ceu"
    }
#line 485 "garden.ceu"
/* CLEAR: Block (485) */
#line 485 "garden.ceu"
    if (0) {

#line 485 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
} else {
/* NODE: Nothing 5767 */
}

#line 484 "garden.ceu"
    }
#line 484 "garden.ceu"
/* CLEAR: Block (484) */
#line 484 "garden.ceu"
    if (0) {

#line 484 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
} else {
/* NODE: Block 1443 */

#line 489 "garden.ceu"
    {/* NODE: Stmts 1442 */

#line 489 "garden.ceu"
    {/* NODE: Set 5770 */

#line 489 "garden.ceu"
/* SET: patch *//* NODE: Op1_- 1440 */

#line 489 "garden.ceu"
    (((CEU_BagActive*)_ceu_org)->patch) = (-1);
#line 489 "garden.ceu"
    }
#line 489 "garden.ceu"
/* CLEAR: Block (489) */
#line 489 "garden.ceu"
    if (0) {

#line 489 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
}
}
}

#line 473 "garden.ceu"
    }
#line 473 "garden.ceu"
/* CLEAR: Block (473) */
#line 473 "garden.ceu"
    if (0) {

#line 473 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
} else {
/* NODE: If 5756 */

#line 491 "garden.ceu"
    if ((((*((CEU_BagActive*)_ceu_org)->y)>614)&&((*((CEU_BagActive*)_ceu_org)->y)<=800))) {
/* NODE: Block 1525 */

#line 492 "garden.ceu"
    {/* NODE: Stmts 1524 */

#line 492 "garden.ceu"
    {/* NODE: If 5773 */

#line 492 "garden.ceu"
    if (((((CEU_BagActive*)_ceu_org)->rightborder_10)&&(!(((CEU_BagActive*)_ceu_org)->rightmidborder_11)))) {
/* NODE: Block 1474 */

#line 493 "garden.ceu"
    {/* NODE: Stmts 1473 */

#line 493 "garden.ceu"
    {/* NODE: If 5775 */

#line 493 "garden.ceu"
    if (((((CEU_BagActive*)_ceu_org)->patch)!=5)) {
/* NODE: Block 1471 */

#line 494 "garden.ceu"
    {/* NODE: Stmts 1470 */

#line 494 "garden.ceu"
    {/* NODE: Set 5776 */

#line 494 "garden.ceu"
/* SET: patch *//* NODE: NUMBER 1462 */

#line 494 "garden.ceu"
    (((CEU_BagActive*)_ceu_org)->patch) = 5;/* NODE: EmitInt 1469 */

#line 495 "garden.ceu"
    {
#ifdef CEU_STACK_CLEAR
    tceu_stk stk_ = { _ceu_stk, _ceu_org, 1, 1, 1 };
#endif

#line 495 "garden.ceu"
    tceu__int__int __ceu_ps_1469;
{
    tceu__int__int __ceu_ps_1469_ =
        { (((CEU_BagActive*)_ceu_org)->seed),5 };
    __ceu_ps_1469 = __ceu_ps_1469_;
}

#line 495 "garden.ceu"
        /* trigger the event */
    tceu_evt evt;
    evt.id = 2;
#ifdef CEU_ORGS
#line 495 "garden.ceu"
    evt.org = (tceu_org*) (((CEU_BagActive*)_ceu_org)->garden);
#endif

#line 495 "garden.ceu"
        evt.param = (&__ceu_ps_1469);

#line 495 "garden.ceu"
        ceu_sys_go_ex(_ceu_app, &evt,
#ifdef CEU_STACK_CLEAR
                  &stk_,
#else
                  NULL,
#endif
                  _ceu_app->data, 0,
#ifdef CEU_ORGS
                  _ceu_app->data->n
#else
                  CEU_NTRAILS
#endif
    );

#ifdef CEU_STACK_CLEAR
    if (!stk_.is_alive) {
        return;
    }
#endif
}

#line 494 "garden.ceu"
    }
#line 494 "garden.ceu"
/* CLEAR: Block (494) */
#line 494 "garden.ceu"
    if (0) {

#line 494 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
} else {
/* NODE: Nothing 5774 */
}

#line 493 "garden.ceu"
    }
#line 493 "garden.ceu"
/* CLEAR: Block (493) */
#line 493 "garden.ceu"
    if (0) {

#line 493 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
} else {
/* NODE: If 5772 */

#line 497 "garden.ceu"
    if (((((CEU_BagActive*)_ceu_org)->rightmidborder_11)&&(!(((CEU_BagActive*)_ceu_org)->leftmidborder_12)))) {
/* NODE: Block 1495 */

#line 498 "garden.ceu"
    {/* NODE: Stmts 1494 */

#line 498 "garden.ceu"
    {/* NODE: If 5778 */

#line 498 "garden.ceu"
    if (((((CEU_BagActive*)_ceu_org)->patch)!=4)) {
/* NODE: Block 1492 */

#line 499 "garden.ceu"
    {/* NODE: Stmts 1491 */

#line 499 "garden.ceu"
    {/* NODE: Set 5779 */

#line 499 "garden.ceu"
/* SET: patch *//* NODE: NUMBER 1483 */

#line 499 "garden.ceu"
    (((CEU_BagActive*)_ceu_org)->patch) = 4;/* NODE: EmitInt 1490 */

#line 500 "garden.ceu"
    {
#ifdef CEU_STACK_CLEAR
    tceu_stk stk_ = { _ceu_stk, _ceu_org, 1, 1, 1 };
#endif

#line 500 "garden.ceu"
    tceu__int__int __ceu_ps_1490;
{
    tceu__int__int __ceu_ps_1490_ =
        { (((CEU_BagActive*)_ceu_org)->seed),4 };
    __ceu_ps_1490 = __ceu_ps_1490_;
}

#line 500 "garden.ceu"
        /* trigger the event */
    tceu_evt evt;
    evt.id = 2;
#ifdef CEU_ORGS
#line 500 "garden.ceu"
    evt.org = (tceu_org*) (((CEU_BagActive*)_ceu_org)->garden);
#endif

#line 500 "garden.ceu"
        evt.param = (&__ceu_ps_1490);

#line 500 "garden.ceu"
        ceu_sys_go_ex(_ceu_app, &evt,
#ifdef CEU_STACK_CLEAR
                  &stk_,
#else
                  NULL,
#endif
                  _ceu_app->data, 0,
#ifdef CEU_ORGS
                  _ceu_app->data->n
#else
                  CEU_NTRAILS
#endif
    );

#ifdef CEU_STACK_CLEAR
    if (!stk_.is_alive) {
        return;
    }
#endif
}

#line 499 "garden.ceu"
    }
#line 499 "garden.ceu"
/* CLEAR: Block (499) */
#line 499 "garden.ceu"
    if (0) {

#line 499 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
} else {
/* NODE: Nothing 5777 */
}

#line 498 "garden.ceu"
    }
#line 498 "garden.ceu"
/* CLEAR: Block (498) */
#line 498 "garden.ceu"
    if (0) {

#line 498 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
} else {
/* NODE: If 5771 */

#line 502 "garden.ceu"
    if (((((CEU_BagActive*)_ceu_org)->leftmidborder_12)&&(!(((CEU_BagActive*)_ceu_org)->leftborder_13)))) {
/* NODE: Block 1516 */

#line 503 "garden.ceu"
    {/* NODE: Stmts 1515 */

#line 503 "garden.ceu"
    {/* NODE: If 5781 */

#line 503 "garden.ceu"
    if (((((CEU_BagActive*)_ceu_org)->patch)!=3)) {
/* NODE: Block 1513 */

#line 504 "garden.ceu"
    {/* NODE: Stmts 1512 */

#line 504 "garden.ceu"
    {/* NODE: Set 5782 */

#line 504 "garden.ceu"
/* SET: patch *//* NODE: NUMBER 1504 */

#line 504 "garden.ceu"
    (((CEU_BagActive*)_ceu_org)->patch) = 3;/* NODE: EmitInt 1511 */

#line 505 "garden.ceu"
    {
#ifdef CEU_STACK_CLEAR
    tceu_stk stk_ = { _ceu_stk, _ceu_org, 1, 1, 1 };
#endif

#line 505 "garden.ceu"
    tceu__int__int __ceu_ps_1511;
{
    tceu__int__int __ceu_ps_1511_ =
        { (((CEU_BagActive*)_ceu_org)->seed),3 };
    __ceu_ps_1511 = __ceu_ps_1511_;
}

#line 505 "garden.ceu"
        /* trigger the event */
    tceu_evt evt;
    evt.id = 2;
#ifdef CEU_ORGS
#line 505 "garden.ceu"
    evt.org = (tceu_org*) (((CEU_BagActive*)_ceu_org)->garden);
#endif

#line 505 "garden.ceu"
        evt.param = (&__ceu_ps_1511);

#line 505 "garden.ceu"
        ceu_sys_go_ex(_ceu_app, &evt,
#ifdef CEU_STACK_CLEAR
                  &stk_,
#else
                  NULL,
#endif
                  _ceu_app->data, 0,
#ifdef CEU_ORGS
                  _ceu_app->data->n
#else
                  CEU_NTRAILS
#endif
    );

#ifdef CEU_STACK_CLEAR
    if (!stk_.is_alive) {
        return;
    }
#endif
}

#line 504 "garden.ceu"
    }
#line 504 "garden.ceu"
/* CLEAR: Block (504) */
#line 504 "garden.ceu"
    if (0) {

#line 504 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
} else {
/* NODE: Nothing 5780 */
}

#line 503 "garden.ceu"
    }
#line 503 "garden.ceu"
/* CLEAR: Block (503) */
#line 503 "garden.ceu"
    if (0) {

#line 503 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
} else {
/* NODE: Block 1522 */

#line 508 "garden.ceu"
    {/* NODE: Stmts 1521 */

#line 508 "garden.ceu"
    {/* NODE: Set 5783 */

#line 508 "garden.ceu"
/* SET: patch *//* NODE: Op1_- 1519 */

#line 508 "garden.ceu"
    (((CEU_BagActive*)_ceu_org)->patch) = (-1);
#line 508 "garden.ceu"
    }
#line 508 "garden.ceu"
/* CLEAR: Block (508) */
#line 508 "garden.ceu"
    if (0) {

#line 508 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
}
}
}

#line 492 "garden.ceu"
    }
#line 492 "garden.ceu"
/* CLEAR: Block (492) */
#line 492 "garden.ceu"
    if (0) {

#line 492 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
} else {
/* NODE: Nothing 5755 */
}
}
/* NODE: Stmts 5823 */

#line 512 "garden.ceu"
    {/* NODE: Nothing 5785 */
/* NODE: Set 5784 */

#line 512 "garden.ceu"
/* SET: table: 0xe7baf0 *//* NODE: Await 1531 */

#line 512 "garden.ceu"
    _CEU_NO_1531_:
if (0) { goto _CEU_NO_1531_; /* avoids "not used" warning */ }

#line 512 "garden.ceu"
    _ceu_trl->evt = CEU_IN_MOUSE_MOVE;
_ceu_trl->lbl = BagActive_Awake_MOUSE_MOVE_67;
_ceu_trl->seqno = _ceu_app->seqno;

#line 512 "garden.ceu"
    return;

case BagActive_Awake_MOUSE_MOVE_67:;

#line 512 "garden.ceu"
    #ifdef CEU_DEBUG_TRAILS
#ifndef CEU_OS
printf("\tOK!\n");
#endif
#endif

#line 512 "garden.ceu"
    {

#line 512 "garden.ceu"
        tceu__int__int** __ceu_casted = (tceu__int__int**) _ceu_evt->param;

#line 512 "garden.ceu"
        (*((CEU_BagActive*)_ceu_org)->x) = ((*(__ceu_casted))->_1);
}

#line 512 "garden.ceu"
    {

#line 512 "garden.ceu"
        tceu__int__int** __ceu_casted = (tceu__int__int**) _ceu_evt->param;

#line 512 "garden.ceu"
        (*((CEU_BagActive*)_ceu_org)->y) = ((*(__ceu_casted))->_2);
}
/* NODE: Nothing 8236 */
/* NODE: Nothing 8237 */

#line 512 "garden.ceu"
    }
#line 467 "garden.ceu"
    }
#line 467 "garden.ceu"
/* CLEAR: Block (467) */
#line 467 "garden.ceu"
    if (0) {

#line 467 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 466 "garden.ceu"
    }

#line 466 "garden.ceu"
    }
#line 466 "garden.ceu"
/* CLEAR: Block (466) */
#line 466 "garden.ceu"
    if (0) {

#line 466 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 466 "garden.ceu"
    }
#line 466 "garden.ceu"
/* CLEAR: Block (466) */
#line 466 "garden.ceu"
    if (0) {

#line 466 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 463 "garden.ceu"
case BagActive_ParOr_sub_1_64:;/* NODE: Block 1291 */

#line 464 "garden.ceu"
    {/* NODE: Stmts 1290 */

#line 464 "garden.ceu"
    {/* NODE: Stmts 5722 */

#line 464 "garden.ceu"
    {/* NODE: Nothing 5684 */
/* NODE: Set 5683 */

#line 464 "garden.ceu"
/* SET: table: 0xe75c90 *//* NODE: Await 1288 */

#line 464 "garden.ceu"
    _CEU_NO_1288_:
if (0) { goto _CEU_NO_1288_; /* avoids "not used" warning */ }

#line 464 "garden.ceu"
    _ceu_trl->evt = CEU_IN_MOUSE_UP;
_ceu_trl->lbl = BagActive_Awake_MOUSE_UP_66;
_ceu_trl->seqno = _ceu_app->seqno;

#line 464 "garden.ceu"
    return;

case BagActive_Awake_MOUSE_UP_66:;

#line 464 "garden.ceu"
    #ifdef CEU_DEBUG_TRAILS
#ifndef CEU_OS
printf("\tOK!\n");
#endif
#endif

#line 464 "garden.ceu"
    {

#line 464 "garden.ceu"
        tceu__int__int** __ceu_casted = (tceu__int__int**) _ceu_evt->param;

#line 464 "garden.ceu"
        (*((CEU_BagActive*)_ceu_org)->x) = ((*(__ceu_casted))->_1);
}

#line 464 "garden.ceu"
    {

#line 464 "garden.ceu"
        tceu__int__int** __ceu_casted = (tceu__int__int**) _ceu_evt->param;

#line 464 "garden.ceu"
        (*((CEU_BagActive*)_ceu_org)->y) = ((*(__ceu_casted))->_2);
}
/* NODE: Nothing 8228 */
/* NODE: Nothing 8229 */

#line 464 "garden.ceu"
    }
#line 464 "garden.ceu"
    }
#line 464 "garden.ceu"
/* CLEAR: Block (464) */
#line 464 "garden.ceu"
    if (0) {

#line 464 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 463 "garden.ceu"
/* PAROR JOIN */
#line 463 "garden.ceu"
    _ceu_lbl = BagActive_ParOr_out_65;
goto _CEU_GOTO_;

#line 463 "garden.ceu"
case BagActive_ParOr_out_65:;
#line 463 "garden.ceu"
/* CLEAR: ParOr (463) */
#line 463 "garden.ceu"
    {
    /* Reuse current stack frame.
     * We know that CLEAR will not abort anything and return normally.
     * Just save the previous "is_alive", call CLEAR, and restore it.
     */
#ifdef CEU_STACK_CLEAR
    int __ceu_old = _ceu_stk->is_alive;
    _ceu_stk->is_alive = 1;
#endif
    tceu_evt evt;
             evt.id = CEU_IN__CLEAR;
    ceu_sys_go_ex(_ceu_app, &evt,
                  _ceu_stk,
                  _ceu_org,
                  0,
                  2);
#ifdef CEU_STACK_CLEAR
    _ceu_stk->is_alive = __ceu_old;
    ceu_sys_stack_clear(_ceu_stk, _ceu_org,
                        0,1);
#endif
}
/* NODE: EmitInt 1540 */

#line 515 "garden.ceu"
    {
#ifdef CEU_STACK_CLEAR
    tceu_stk stk_ = { _ceu_stk, _ceu_org, 0, 1, 1 };
#endif

#line 515 "garden.ceu"
        /* trigger the event */
    tceu_evt evt;
    evt.id = 1;
#ifdef CEU_ORGS
#line 515 "garden.ceu"
    evt.org = (tceu_org*) _ceu_org;
#endif

#line 515 "garden.ceu"
        ceu_sys_go_ex(_ceu_app, &evt,
#ifdef CEU_STACK_CLEAR
                  &stk_,
#else
                  NULL,
#endif
                  _ceu_app->data, 0,
#ifdef CEU_ORGS
                  _ceu_app->data->n
#else
                  CEU_NTRAILS
#endif
    );

#ifdef CEU_STACK_CLEAR
    if (!stk_.is_alive) {
        return;
    }
#endif
}

#line 458 "garden.ceu"
    }
#line 458 "garden.ceu"
/* CLEAR: Block (458) */
#line 458 "garden.ceu"
    {
    /* Reuse current stack frame.
     * We know that CLEAR will not abort anything and return normally.
     * Just save the previous "is_alive", call CLEAR, and restore it.
     */
#ifdef CEU_STACK_CLEAR
    int __ceu_old = _ceu_stk->is_alive;
    _ceu_stk->is_alive = 1;
#endif
    tceu_evt evt;
             evt.id = CEU_IN__CLEAR;
    ceu_sys_go_ex(_ceu_app, &evt,
                  _ceu_stk,
                  _ceu_org,
                  0,
                  3);
#ifdef CEU_STACK_CLEAR
    _ceu_stk->is_alive = __ceu_old;
    ceu_sys_stack_clear(_ceu_stk, _ceu_org,
                        0,2);
#endif
}

#line 458 "garden.ceu"
    if (0) {

#line 458 "garden.ceu"
case BagActive_Block__fin_68:;
#line 458 "garden.ceu"
    if (((CEU_BagActive*)_ceu_org)->__fin_1542_1) {
    /* NODE: Finally 1282 */
/* NODE: Block 1281 */

#line 461 "garden.ceu"
    {/* NODE: Stmts 1280 */

#line 461 "garden.ceu"
    {/* NODE: EmitExt 1279 */

#line 461 "garden.ceu"
        {

#line 461 "garden.ceu"
    tceu__int__float __ceu_ps_1279;
{
    tceu__int__float __ceu_ps_1279_ =
        { (((CEU_BagActive*)_ceu_org)->id),0.0 };
    __ceu_ps_1279 = __ceu_ps_1279_;
}

#line 461 "garden.ceu"
    
#if defined(ceu_out_emit_SET_SPRITE_ROTATION)
    ceu_out_emit_SET_SPRITE_ROTATION((&__ceu_ps_1279))

#elif defined(ceu_out_emit)
    (ceu_out_emit(_ceu_app, CEU_OUT_SET_SPRITE_ROTATION, sizeof(tceu__int__float), (void*)(&__ceu_ps_1279)))

#else
    #error ceu_out_emit_* is not defined
#endif
;
#line 461 "garden.ceu"
        }

#line 461 "garden.ceu"
    }
#line 461 "garden.ceu"
/* CLEAR: Block (461) */
#line 461 "garden.ceu"
    if (0) {

#line 461 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
}

#line 458 "garden.ceu"
    return;
#line 458 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 450 "garden.ceu"
    }
#line 450 "garden.ceu"
/* CLEAR: Block (450) */
#line 450 "garden.ceu"
    if (0) {

#line 450 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 450 "garden.ceu"
    }
#line 450 "garden.ceu"
/* CLEAR: Block (450) */
#line 450 "garden.ceu"
    if (0) {

#line 450 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 450 "garden.ceu"
    ceu_sys_org_free(_ceu_app, _ceu_org);
#ifdef CEU_ORGS_AWAIT
{
    /* signal ok_killed */
#ifdef CEU_STACK_CLEAR
    tceu_stk stk_ = *_ceu_stk;
             stk_.is_alive = 1;
             stk_.down = _ceu_stk;
#endif
    tceu_kill ps = { _ceu_org, _ceu_org->ret, 0, (tceu_ntrl)(_ceu_org->n-1) };
    tceu_evt evt_;
             evt_.id = CEU_IN__ok_killed;
             evt_.param = &ps;
    ceu_sys_go_ex(_ceu_app, &evt_,
#ifdef CEU_STACK_CLEAR
                  &stk_,
#else
                  NULL,
#endif
                  _ceu_app->data, 0, _ceu_app->data->n);
}
#endif

#line 450 "garden.ceu"
    return;/* NODE: Dcl_cls 10 */

#line 518 "garden.ceu"
case Class_Bag:;/* NODE: Block 6050 */

#line 518 "garden.ceu"
    {/* NODE: Stmts 6049 */

#line 518 "garden.ceu"
    {/* NODE: Block 5838 */

#line 518 "garden.ceu"
    {/* NODE: Stmts 6051 */

#line 518 "garden.ceu"
    {/* NODE: Block 1652 */

#line 526 "garden.ceu"
    /*  FINALIZE */
_ceu_org->trls[ 3 ].evt = CEU_IN__CLEAR;
_ceu_org->trls[ 3 ].lbl = Bag_Block__fin_78;

#line 526 "garden.ceu"
    ((CEU_Bag*)_ceu_org)->__fin_1652_1 = 0;
#line 526 "garden.ceu"
    {/* NODE: Stmts 1651 */

#line 526 "garden.ceu"
    {/* NODE: Stmts 5865 */

#line 526 "garden.ceu"
    {/* NODE: Dcl_var 5862 */
/* NODE: Set 5866 */

#line 526 "garden.ceu"
/* SET: id *//* NODE: Var 1558 */

#line 526 "garden.ceu"
    (((CEU_Bag*)_ceu_org)->id) = (*((CEU_Bag*)_ceu_org)->gensym);
#line 526 "garden.ceu"
    }/* NODE: Set 5867 */

#line 527 "garden.ceu"
/* SET: gensym *//* NODE: Op2_+ 1563 */

#line 527 "garden.ceu"
    (*((CEU_Bag*)_ceu_org)->gensym) = ((*((CEU_Bag*)_ceu_org)->gensym)+1);/* NODE: EmitExt 1572 */

#line 528 "garden.ceu"
        {

#line 528 "garden.ceu"
    tceu__int__int__int__int__int __ceu_ps_1572;
{
    tceu__int__int__int__int__int __ceu_ps_1572_ =
        { (((CEU_Bag*)_ceu_org)->id),(((CEU_Bag*)_ceu_org)->x),(((CEU_Bag*)_ceu_org)->y),14,3 };
    __ceu_ps_1572 = __ceu_ps_1572_;
}

#line 528 "garden.ceu"
    
#if defined(ceu_out_emit_NEW_SPRITE)
    ceu_out_emit_NEW_SPRITE((&__ceu_ps_1572))

#elif defined(ceu_out_emit)
    (ceu_out_emit(_ceu_app, CEU_OUT_NEW_SPRITE, sizeof(tceu__int__int__int__int__int), (void*)(&__ceu_ps_1572)))

#else
    #error ceu_out_emit_* is not defined
#endif
;
#line 528 "garden.ceu"
        }
/* NODE: Finalize 1579 */

#line 529 "garden.ceu"
    ((CEU_Bag*)_ceu_org)->__fin_1652_1 = 1;/* NODE: ParOr 1648 */

#line 533 "garden.ceu"
/* ParOr: spawn subs */
#line 533 "garden.ceu"
    {
#ifdef CEU_STACK_CLEAR
    tceu_stk stk_ = { _ceu_stk, _ceu_org, 0, 2, 1 };
#endif

#line 533 "garden.ceu"
        _ceu_org->trls[ 0 ].lbl = Bag_ParOr_sub_1_70;
    ceu_app_go(_ceu_app,NULL,_ceu_org,
               &_ceu_org->trls[ 0 ],
#ifdef CEU_STACK_CLEAR
               &stk_
#else
               NULL
#endif
              );

#ifdef CEU_STACK_CLEAR
    if (!stk_.is_alive) {
        return;
    }
#endif

#line 533 "garden.ceu"
        _ceu_trl = &_ceu_org->trls[ 1 ];

#line 533 "garden.ceu"
    }
/* NODE: Block 1647 */

#line 539 "garden.ceu"
    {/* NODE: Stmts 1646 */

#line 539 "garden.ceu"
    {/* NODE: Block 5920 */

#line 539 "garden.ceu"
    {/* NODE: Stmts 5919 */

#line 539 "garden.ceu"
    {/* NODE: Stmts 5918 */

#line 539 "garden.ceu"
    {
#line 539 "garden.ceu"
    }/* NODE: Loop 5917 */

#line 539 "garden.ceu"
    for (;;) {
/* NODE: Block 1644 */

#line 540 "garden.ceu"
    {/* NODE: Stmts 1643 */

#line 540 "garden.ceu"
    {/* NODE: ParOr 1615 */

#line 540 "garden.ceu"
/* ParOr: spawn subs */
#line 540 "garden.ceu"
    {
#ifdef CEU_STACK_CLEAR
    tceu_stk stk_ = { _ceu_stk, _ceu_org, 1, 2, 1 };
#endif

#line 540 "garden.ceu"
        _ceu_org->trls[ 1 ].lbl = Bag_ParOr_sub_1_73;
    ceu_app_go(_ceu_app,NULL,_ceu_org,
               &_ceu_org->trls[ 1 ],
#ifdef CEU_STACK_CLEAR
               &stk_
#else
               NULL
#endif
              );

#ifdef CEU_STACK_CLEAR
    if (!stk_.is_alive) {
        return;
    }
#endif

#line 540 "garden.ceu"
        _ceu_trl = &_ceu_org->trls[ 2 ];

#line 540 "garden.ceu"
    }
/* NODE: Block 1614 */

#line 544 "garden.ceu"
    {/* NODE: Stmts 1613 */

#line 544 "garden.ceu"
    {/* NODE: Stmts 6004 */

#line 544 "garden.ceu"
    {/* NODE: Nothing 5966 */
/* NODE: Set 5965 */

#line 544 "garden.ceu"
/* SET: table: 0xe8f210 *//* NODE: Await 1611 */

#line 544 "garden.ceu"
    _CEU_NO_1611_:
if (0) { goto _CEU_NO_1611_; /* avoids "not used" warning */ }

#line 544 "garden.ceu"
    _ceu_trl->evt = CEU_IN_MOUSE_DOWN;
_ceu_trl->lbl = Bag_Awake_MOUSE_DOWN_76;
_ceu_trl->seqno = _ceu_app->seqno;

#line 544 "garden.ceu"
    return;

case Bag_Awake_MOUSE_DOWN_76:;

#line 544 "garden.ceu"
    #ifdef CEU_DEBUG_TRAILS
#ifndef CEU_OS
printf("\tOK!\n");
#endif
#endif

#line 544 "garden.ceu"
    {

#line 544 "garden.ceu"
        tceu__int__int** __ceu_casted = (tceu__int__int**) _ceu_evt->param;

#line 544 "garden.ceu"
        (((CEU_Bag*)_ceu_org)->x) = ((*(__ceu_casted))->_1);
}

#line 544 "garden.ceu"
    {

#line 544 "garden.ceu"
        tceu__int__int** __ceu_casted = (tceu__int__int**) _ceu_evt->param;

#line 544 "garden.ceu"
        (((CEU_Bag*)_ceu_org)->y) = ((*(__ceu_casted))->_2);
}
/* NODE: Nothing 8242 */
/* NODE: Nothing 8243 */

#line 544 "garden.ceu"
    }
#line 544 "garden.ceu"
    }
#line 544 "garden.ceu"
/* CLEAR: Block (544) */
#line 544 "garden.ceu"
    if (0) {

#line 544 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 540 "garden.ceu"
/* PAROR JOIN */
#line 540 "garden.ceu"
    _ceu_lbl = Bag_ParOr_out_74;
goto _CEU_GOTO_;

#line 540 "garden.ceu"
case Bag_ParOr_sub_1_73:;/* NODE: Block 1606 */

#line 541 "garden.ceu"
    {/* NODE: Stmts 1605 */

#line 541 "garden.ceu"
    {/* NODE: Stmts 5960 */

#line 541 "garden.ceu"
    {/* NODE: Nothing 5922 */
/* NODE: Set 5921 */

#line 541 "garden.ceu"
/* SET: table: 0xe8e790 *//* NODE: Await 1602 */

#line 541 "garden.ceu"
    _CEU_NO_1602_:
if (0) { goto _CEU_NO_1602_; /* avoids "not used" warning */ }

#line 541 "garden.ceu"
    _ceu_trl->evt = CEU_IN_MOUSE_UP;
_ceu_trl->lbl = Bag_Awake_MOUSE_UP_75;
_ceu_trl->seqno = _ceu_app->seqno;

#line 541 "garden.ceu"
    return;

case Bag_Awake_MOUSE_UP_75:;

#line 541 "garden.ceu"
    #ifdef CEU_DEBUG_TRAILS
#ifndef CEU_OS
printf("\tOK!\n");
#endif
#endif

#line 541 "garden.ceu"
    {

#line 541 "garden.ceu"
        tceu__int__int** __ceu_casted = (tceu__int__int**) _ceu_evt->param;

#line 541 "garden.ceu"
        (((CEU_Bag*)_ceu_org)->x) = ((*(__ceu_casted))->_1);
}

#line 541 "garden.ceu"
    {

#line 541 "garden.ceu"
        tceu__int__int** __ceu_casted = (tceu__int__int**) _ceu_evt->param;

#line 541 "garden.ceu"
        (((CEU_Bag*)_ceu_org)->y) = ((*(__ceu_casted))->_2);
}
/* NODE: Nothing 8240 */
/* NODE: Nothing 8241 */

#line 541 "garden.ceu"
    }/* NODE: Break 1604 */

#line 542 "garden.ceu"
    break;
#line 541 "garden.ceu"
    }
#line 541 "garden.ceu"
/* CLEAR: Block (541) */
#line 541 "garden.ceu"
    if (0) {

#line 541 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 540 "garden.ceu"
case Bag_ParOr_out_74:;
#line 540 "garden.ceu"
/* CLEAR: ParOr (540) */
#line 540 "garden.ceu"
    {
    /* Reuse current stack frame.
     * We know that CLEAR will not abort anything and return normally.
     * Just save the previous "is_alive", call CLEAR, and restore it.
     */
#ifdef CEU_STACK_CLEAR
    int __ceu_old = _ceu_stk->is_alive;
    _ceu_stk->is_alive = 1;
#endif
    tceu_evt evt;
             evt.id = CEU_IN__CLEAR;
    ceu_sys_go_ex(_ceu_app, &evt,
                  _ceu_stk,
                  _ceu_org,
                  1,
                  3);
#ifdef CEU_STACK_CLEAR
    _ceu_stk->is_alive = __ceu_old;
    ceu_sys_stack_clear(_ceu_stk, _ceu_org,
                        1,2);
#endif
}
/* NODE: Do 6015 */
/* NODE: Block 6014 */

#line 546 "garden.ceu"
    {
#line 546 "garden.ceu"
    #ifdef CEU_ORGS
_ceu_org->trls[ 1 ].evt = CEU_IN__ORG;
_ceu_org->trls[ 1 ].org = NULL;
#endif

#line 546 "garden.ceu"
    _ceu_trl = &_ceu_org->trls[ 2 ];
/* NODE: Stmts 6013 */

#line 546 "garden.ceu"
    {/* NODE: Dcl_var 6012 */

#line 546 "garden.ceu"
/* start org: _org_1642 */
#line 546 "garden.ceu"
        /* resets org memory and starts org.trail[0]=Class_XXX */
    /* TODO: BUG: _ceu_org is not necessarily the parent for pool allocations */
    ceu_out_org_init(_ceu_app, ((tceu_org*) &(((CEU_Bag*)_ceu_org)->_org_1642_10)),4,Class_BagActive,
                     9,
                     0,
                     _ceu_org,1);
/* TODO: currently idx is always "1" for all interfaces access because pools 
 * are all together there. When we have separate trls for pools, we'll have to 
 * indirectly access the offset in the interface. */

#line 546 "garden.ceu"
        _ceu_constr_1641(_ceu_app, ((tceu_org*) &(((CEU_Bag*)_ceu_org)->_org_1642_10)), _ceu_org);

#line 546 "garden.ceu"
    {
#ifdef CEU_STACK_CLEAR
    tceu_stk stk_ = { _ceu_stk, _ceu_org, 2, 2, 1 };
    ceu_app_go(_ceu_app,NULL,
               ((tceu_org*) &(((CEU_Bag*)_ceu_org)->_org_1642_10)), &((tceu_org*) &(((CEU_Bag*)_ceu_org)->_org_1642_10))->trls[0],
               &stk_);
    if (!stk_.is_alive) {
        return;
    }
#else
    ceu_app_go(_ceu_app,NULL,
               ((tceu_org*) &(((CEU_Bag*)_ceu_org)->_org_1642_10)), &((tceu_org*) &(((CEU_Bag*)_ceu_org)->_org_1642_10))->trls[0],
               NULL);
#endif

#line 546 "garden.ceu"
    }
/* NODE: Stmts 6047 */

#line 546 "garden.ceu"
    {/* NODE: Nothing 6021 */
/* NODE: Nothing 8249 */
/* NODE: Nothing 8250 */
/* NODE: Stmts 6046 */

#line 546 "garden.ceu"
    {/* NODE: If 6045 */

#line 546 "garden.ceu"
    if ((!(((*((tceu_org*)(&((CEU_Bag*)_ceu_org)->_org_1642_10))).isAlive)))) {
/* NODE: Block 6042 */

#line 546 "garden.ceu"
    {/* NODE: Stmts 6041 */

#line 546 "garden.ceu"
    {/* NODE: Nothing 6025 */

#line 546 "garden.ceu"
    }
#line 546 "garden.ceu"
/* CLEAR: Block (546) */
#line 546 "garden.ceu"
    if (0) {

#line 546 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
} else {
/* NODE: Block 6044 */

#line 546 "garden.ceu"
    {/* NODE: Stmts 6043 */

#line 546 "garden.ceu"
    {/* NODE: Await 6024 */

#line 546 "garden.ceu"
    _CEU_NO_6024_:
if (0) { goto _CEU_NO_6024_; /* avoids "not used" warning */ }

#line 546 "garden.ceu"
    _ceu_trl->evt = CEU_IN__ok_killed;
_ceu_trl->lbl = Bag_Awake__ok_killed_77;
_ceu_trl->seqno = _ceu_app->seqno;

#line 546 "garden.ceu"
    #ifdef CEU_ORGS_AWAIT
#ifdef CEU_ADTS_AWAIT
_ceu_trl->is_org = 1;
#endif
#endif
_ceu_trl->org_or_adt = (void*)(&((CEU_Bag*)_ceu_org)->_org_1642_10);

#line 546 "garden.ceu"
    return;

case Bag_Awake__ok_killed_77:;

#line 546 "garden.ceu"
    #ifdef CEU_DEBUG_TRAILS
#ifndef CEU_OS
printf("\tOK!\n");
#endif
#endif

#line 546 "garden.ceu"
    }
#line 546 "garden.ceu"
/* CLEAR: Block (546) */
#line 546 "garden.ceu"
    if (0) {

#line 546 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
}

#line 546 "garden.ceu"
    }
#line 546 "garden.ceu"
    }
#line 546 "garden.ceu"
    }
#line 546 "garden.ceu"
/* CLEAR: Block (546) */
#line 546 "garden.ceu"
    {
    /* Reuse current stack frame.
     * We know that CLEAR will not abort anything and return normally.
     * Just save the previous "is_alive", call CLEAR, and restore it.
     */
#ifdef CEU_STACK_CLEAR
    int __ceu_old = _ceu_stk->is_alive;
    _ceu_stk->is_alive = 1;
#endif
    tceu_evt evt;
             evt.id = CEU_IN__CLEAR;
    ceu_sys_go_ex(_ceu_app, &evt,
                  _ceu_stk,
                  _ceu_org,
                  1,
                  3);
#ifdef CEU_STACK_CLEAR
    _ceu_stk->is_alive = __ceu_old;
    ceu_sys_stack_clear(_ceu_stk, _ceu_org,
                        1,2);
#endif
}

#line 546 "garden.ceu"
    #ifdef CEU_ORGS_AWAIT
/* signal ok_killed */
{
    tceu_kill ps = { _ceu_org, _ceu_org->ret, 1,2 };
    tceu_evt evt_;
             evt_.id = CEU_IN__ok_killed;
             evt_.param = &ps;
    ceu_sys_go_ex(_ceu_app, &evt_, _ceu_stk,
                  _ceu_app->data, 0, _ceu_app->data->n);
}
#endif

#line 546 "garden.ceu"
    if (0) {

#line 546 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 540 "garden.ceu"
    }
#line 540 "garden.ceu"
/* CLEAR: Block (540) */
#line 540 "garden.ceu"
    if (0) {

#line 540 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 539 "garden.ceu"
    }

#line 539 "garden.ceu"
/* CLEAR: Loop (539) */
#line 539 "garden.ceu"
    {
    /* Reuse current stack frame.
     * We know that CLEAR will not abort anything and return normally.
     * Just save the previous "is_alive", call CLEAR, and restore it.
     */
#ifdef CEU_STACK_CLEAR
    int __ceu_old = _ceu_stk->is_alive;
    _ceu_stk->is_alive = 1;
#endif
    tceu_evt evt;
             evt.id = CEU_IN__CLEAR;
    ceu_sys_go_ex(_ceu_app, &evt,
                  _ceu_stk,
                  _ceu_org,
                  1,
                  3);
#ifdef CEU_STACK_CLEAR
    _ceu_stk->is_alive = __ceu_old;
    ceu_sys_stack_clear(_ceu_stk, _ceu_org,
                        1,2);
#endif
}

#line 539 "garden.ceu"
    #ifdef CEU_ORGS_AWAIT
/* signal ok_killed */
{
    tceu_kill ps = { _ceu_org, _ceu_org->ret, 1,2 };
    tceu_evt evt_;
             evt_.id = CEU_IN__ok_killed;
             evt_.param = &ps;
    ceu_sys_go_ex(_ceu_app, &evt_, _ceu_stk,
                  _ceu_app->data, 0, _ceu_app->data->n);
}
#endif

#line 539 "garden.ceu"
    }
#line 539 "garden.ceu"
/* CLEAR: Block (539) */
#line 539 "garden.ceu"
    if (0) {

#line 539 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 539 "garden.ceu"
    }
#line 539 "garden.ceu"
/* CLEAR: Block (539) */
#line 539 "garden.ceu"
    if (0) {

#line 539 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 533 "garden.ceu"
/* PAROR JOIN */
#line 533 "garden.ceu"
    _ceu_lbl = Bag_ParOr_out_71;
goto _CEU_GOTO_;

#line 533 "garden.ceu"
case Bag_ParOr_sub_1_70:;/* NODE: Block 1597 */

#line 534 "garden.ceu"
    {/* NODE: Stmts 1596 */

#line 534 "garden.ceu"
    {/* NODE: Block 5872 */

#line 534 "garden.ceu"
    {/* NODE: Stmts 5871 */

#line 534 "garden.ceu"
    {/* NODE: Stmts 5870 */

#line 534 "garden.ceu"
    {
#line 534 "garden.ceu"
    }/* NODE: Loop 5869 */

#line 534 "garden.ceu"
    for (;;) {
/* NODE: Block 1594 */

#line 535 "garden.ceu"
    {/* NODE: Stmts 1593 */

#line 535 "garden.ceu"
    {/* NODE: Stmts 5912 */

#line 535 "garden.ceu"
    {/* NODE: Nothing 5874 */
/* NODE: Set 5873 */

#line 535 "garden.ceu"
/* SET: table: 0xe8d1f0 *//* NODE: Await 1584 */

#line 535 "garden.ceu"
    _CEU_NO_1584_:
if (0) { goto _CEU_NO_1584_; /* avoids "not used" warning */ }

#line 535 "garden.ceu"
    _ceu_trl->evt = CEU_IN_MOUSE_MOVE;
_ceu_trl->lbl = Bag_Awake_MOUSE_MOVE_72;
_ceu_trl->seqno = _ceu_app->seqno;

#line 535 "garden.ceu"
    return;

case Bag_Awake_MOUSE_MOVE_72:;

#line 535 "garden.ceu"
    #ifdef CEU_DEBUG_TRAILS
#ifndef CEU_OS
printf("\tOK!\n");
#endif
#endif

#line 535 "garden.ceu"
    {

#line 535 "garden.ceu"
        tceu__int__int** __ceu_casted = (tceu__int__int**) _ceu_evt->param;

#line 535 "garden.ceu"
        (((CEU_Bag*)_ceu_org)->x) = ((*(__ceu_casted))->_1);
}

#line 535 "garden.ceu"
    {

#line 535 "garden.ceu"
        tceu__int__int** __ceu_casted = (tceu__int__int**) _ceu_evt->param;

#line 535 "garden.ceu"
        (((CEU_Bag*)_ceu_org)->y) = ((*(__ceu_casted))->_2);
}
/* NODE: Nothing 8238 */
/* NODE: Nothing 8239 */

#line 535 "garden.ceu"
    }/* NODE: EmitExt 1592 */

#line 536 "garden.ceu"
        {

#line 536 "garden.ceu"
    tceu__int__int__int__int __ceu_ps_1592;
{
    tceu__int__int__int__int __ceu_ps_1592_ =
        { (((CEU_Bag*)_ceu_org)->id),(((CEU_Bag*)_ceu_org)->x),(((CEU_Bag*)_ceu_org)->y),1 };
    __ceu_ps_1592 = __ceu_ps_1592_;
}

#line 536 "garden.ceu"
    
#if defined(ceu_out_emit_SET_SPRITE_POSITION)
    ceu_out_emit_SET_SPRITE_POSITION((&__ceu_ps_1592))

#elif defined(ceu_out_emit)
    (ceu_out_emit(_ceu_app, CEU_OUT_SET_SPRITE_POSITION, sizeof(tceu__int__int__int__int), (void*)(&__ceu_ps_1592)))

#else
    #error ceu_out_emit_* is not defined
#endif
;
#line 536 "garden.ceu"
        }

#line 535 "garden.ceu"
    }
#line 535 "garden.ceu"
/* CLEAR: Block (535) */
#line 535 "garden.ceu"
    if (0) {

#line 535 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 534 "garden.ceu"
    }

#line 534 "garden.ceu"
    }
#line 534 "garden.ceu"
/* CLEAR: Block (534) */
#line 534 "garden.ceu"
    if (0) {

#line 534 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 534 "garden.ceu"
    }
#line 534 "garden.ceu"
/* CLEAR: Block (534) */
#line 534 "garden.ceu"
    if (0) {

#line 534 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 533 "garden.ceu"
case Bag_ParOr_out_71:;
#line 533 "garden.ceu"
/* CLEAR: ParOr (533) */
#line 533 "garden.ceu"
    {
    /* Reuse current stack frame.
     * We know that CLEAR will not abort anything and return normally.
     * Just save the previous "is_alive", call CLEAR, and restore it.
     */
#ifdef CEU_STACK_CLEAR
    int __ceu_old = _ceu_stk->is_alive;
    _ceu_stk->is_alive = 1;
#endif
    tceu_evt evt;
             evt.id = CEU_IN__CLEAR;
    ceu_sys_go_ex(_ceu_app, &evt,
                  _ceu_stk,
                  _ceu_org,
                  0,
                  3);
#ifdef CEU_STACK_CLEAR
    _ceu_stk->is_alive = __ceu_old;
    ceu_sys_stack_clear(_ceu_stk, _ceu_org,
                        0,2);
#endif
}

#line 533 "garden.ceu"
    #ifdef CEU_ORGS_AWAIT
/* signal ok_killed */
{
    tceu_kill ps = { _ceu_org, _ceu_org->ret, 0,2 };
    tceu_evt evt_;
             evt_.id = CEU_IN__ok_killed;
             evt_.param = &ps;
    ceu_sys_go_ex(_ceu_app, &evt_, _ceu_stk,
                  _ceu_app->data, 0, _ceu_app->data->n);
}
#endif
/* NODE: EmitInt 1650 */

#line 555 "garden.ceu"
    {
#ifdef CEU_STACK_CLEAR
    tceu_stk stk_ = { _ceu_stk, _ceu_org, 0, 2, 1 };
#endif

#line 555 "garden.ceu"
        /* trigger the event */
    tceu_evt evt;
    evt.id = 1;
#ifdef CEU_ORGS
#line 555 "garden.ceu"
    evt.org = (tceu_org*) _ceu_org;
#endif

#line 555 "garden.ceu"
        ceu_sys_go_ex(_ceu_app, &evt,
#ifdef CEU_STACK_CLEAR
                  &stk_,
#else
                  NULL,
#endif
                  _ceu_app->data, 0,
#ifdef CEU_ORGS
                  _ceu_app->data->n
#else
                  CEU_NTRAILS
#endif
    );

#ifdef CEU_STACK_CLEAR
    if (!stk_.is_alive) {
        return;
    }
#endif
}

#line 526 "garden.ceu"
    }
#line 526 "garden.ceu"
/* CLEAR: Block (526) */
#line 526 "garden.ceu"
    {
    /* Reuse current stack frame.
     * We know that CLEAR will not abort anything and return normally.
     * Just save the previous "is_alive", call CLEAR, and restore it.
     */
#ifdef CEU_STACK_CLEAR
    int __ceu_old = _ceu_stk->is_alive;
    _ceu_stk->is_alive = 1;
#endif
    tceu_evt evt;
             evt.id = CEU_IN__CLEAR;
    ceu_sys_go_ex(_ceu_app, &evt,
                  _ceu_stk,
                  _ceu_org,
                  0,
                  4);
#ifdef CEU_STACK_CLEAR
    _ceu_stk->is_alive = __ceu_old;
    ceu_sys_stack_clear(_ceu_stk, _ceu_org,
                        0,3);
#endif
}

#line 526 "garden.ceu"
    #ifdef CEU_ORGS_AWAIT
/* signal ok_killed */
{
    tceu_kill ps = { _ceu_org, _ceu_org->ret, 0,3 };
    tceu_evt evt_;
             evt_.id = CEU_IN__ok_killed;
             evt_.param = &ps;
    ceu_sys_go_ex(_ceu_app, &evt_, _ceu_stk,
                  _ceu_app->data, 0, _ceu_app->data->n);
}
#endif

#line 526 "garden.ceu"
    if (0) {

#line 526 "garden.ceu"
case Bag_Block__fin_78:;
#line 526 "garden.ceu"
    if (((CEU_Bag*)_ceu_org)->__fin_1652_1) {
    /* NODE: Finally 1578 */
/* NODE: Block 1577 */

#line 530 "garden.ceu"
    {/* NODE: Stmts 1576 */

#line 530 "garden.ceu"
    {/* NODE: EmitExt 1575 */

#line 530 "garden.ceu"
        {

#line 530 "garden.ceu"
    tceu__int __ceu_ps_1575;
{
    tceu__int __ceu_ps_1575_ =
        { (((CEU_Bag*)_ceu_org)->id) };
    __ceu_ps_1575 = __ceu_ps_1575_;
}

#line 530 "garden.ceu"
    
#if defined(ceu_out_emit_FREE_SPRITE)
    ceu_out_emit_FREE_SPRITE((&__ceu_ps_1575))

#elif defined(ceu_out_emit)
    (ceu_out_emit(_ceu_app, CEU_OUT_FREE_SPRITE, sizeof(tceu__int), (void*)(&__ceu_ps_1575)))

#else
    #error ceu_out_emit_* is not defined
#endif
;
#line 530 "garden.ceu"
        }

#line 530 "garden.ceu"
    }
#line 530 "garden.ceu"
/* CLEAR: Block (530) */
#line 530 "garden.ceu"
    if (0) {

#line 530 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
}

#line 526 "garden.ceu"
    return;
#line 526 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 518 "garden.ceu"
    }
#line 518 "garden.ceu"
/* CLEAR: Block (518) */
#line 518 "garden.ceu"
    if (0) {

#line 518 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 518 "garden.ceu"
    }
#line 518 "garden.ceu"
/* CLEAR: Block (518) */
#line 518 "garden.ceu"
    if (0) {

#line 518 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 518 "garden.ceu"
    ceu_sys_org_free(_ceu_app, _ceu_org);
#ifdef CEU_ORGS_AWAIT
{
    /* signal ok_killed */
#ifdef CEU_STACK_CLEAR
    tceu_stk stk_ = *_ceu_stk;
             stk_.is_alive = 1;
             stk_.down = _ceu_stk;
#endif
    tceu_kill ps = { _ceu_org, _ceu_org->ret, 0, (tceu_ntrl)(_ceu_org->n-1) };
    tceu_evt evt_;
             evt_.id = CEU_IN__ok_killed;
             evt_.param = &ps;
    ceu_sys_go_ex(_ceu_app, &evt_,
#ifdef CEU_STACK_CLEAR
                  &stk_,
#else
                  NULL,
#endif
                  _ceu_app->data, 0, _ceu_app->data->n);
}
#endif

#line 518 "garden.ceu"
    return;/* NODE: Dcl_cls 11 */

#line 558 "garden.ceu"
case Class_WateringCanActive:;/* NODE: Block 6213 */

#line 558 "garden.ceu"
    {/* NODE: Stmts 6212 */

#line 558 "garden.ceu"
    {/* NODE: Block 6058 */

#line 558 "garden.ceu"
    {/* NODE: Stmts 6214 */

#line 558 "garden.ceu"
    {/* NODE: Block 1860 */

#line 565 "garden.ceu"
    /*  FINALIZE */
_ceu_org->trls[ 2 ].evt = CEU_IN__CLEAR;
_ceu_org->trls[ 2 ].lbl = WateringCanActive_Block__fin_84;

#line 565 "garden.ceu"
    ((CEU_WateringCanActive*)_ceu_org)->__fin_1860_1 = 0;
#line 565 "garden.ceu"
    {/* NODE: Stmts 1859 */

#line 565 "garden.ceu"
    {/* NODE: EmitExt 1670 */

#line 565 "garden.ceu"
        {

#line 565 "garden.ceu"
    tceu__int__float __ceu_ps_1670;
{
    tceu__int__float __ceu_ps_1670_ =
        { (((CEU_WateringCanActive*)_ceu_org)->id),(-1.0) };
    __ceu_ps_1670 = __ceu_ps_1670_;
}

#line 565 "garden.ceu"
    
#if defined(ceu_out_emit_SET_SPRITE_ROTATION)
    ceu_out_emit_SET_SPRITE_ROTATION((&__ceu_ps_1670))

#elif defined(ceu_out_emit)
    (ceu_out_emit(_ceu_app, CEU_OUT_SET_SPRITE_ROTATION, sizeof(tceu__int__float), (void*)(&__ceu_ps_1670)))

#else
    #error ceu_out_emit_* is not defined
#endif
;
#line 565 "garden.ceu"
        }
/* NODE: Finalize 1679 */

#line 566 "garden.ceu"
    ((CEU_WateringCanActive*)_ceu_org)->__fin_1860_1 = 1;/* NODE: ParOr 1856 */

#line 569 "garden.ceu"
/* ParOr: spawn subs */
#line 569 "garden.ceu"
    {
#ifdef CEU_STACK_CLEAR
    tceu_stk stk_ = { _ceu_stk, _ceu_org, 0, 1, 1 };
#endif

#line 569 "garden.ceu"
        _ceu_org->trls[ 0 ].lbl = WateringCanActive_ParOr_sub_1_80;
    ceu_app_go(_ceu_app,NULL,_ceu_org,
               &_ceu_org->trls[ 0 ],
#ifdef CEU_STACK_CLEAR
               &stk_
#else
               NULL
#endif
              );

#ifdef CEU_STACK_CLEAR
    if (!stk_.is_alive) {
        return;
    }
#endif

#line 569 "garden.ceu"
        _ceu_trl = &_ceu_org->trls[ 1 ];

#line 569 "garden.ceu"
    }
/* NODE: Block 1855 */

#line 572 "garden.ceu"
    {/* NODE: Stmts 1854 */

#line 572 "garden.ceu"
    {/* NODE: Block 6125 */

#line 572 "garden.ceu"
    {/* NODE: Stmts 6124 */

#line 572 "garden.ceu"
    {/* NODE: Stmts 6123 */

#line 572 "garden.ceu"
    {
#line 572 "garden.ceu"
    }/* NODE: Loop 6122 */

#line 572 "garden.ceu"
    for (;;) {
/* NODE: Block 1852 */

#line 573 "garden.ceu"
    {/* NODE: Stmts 1851 */

#line 573 "garden.ceu"
    {/* NODE: Stmts 6130 */

#line 573 "garden.ceu"
    {/* NODE: Dcl_var 6127 */
/* NODE: Set 6131 */

#line 573 "garden.ceu"
/* SET: rightborder *//* NODE: Op2_> 1705 */

#line 573 "garden.ceu"
    (((CEU_WateringCanActive*)_ceu_org)->rightborder_8) = ((((1175-1030)*((*((CEU_WateringCanActive*)_ceu_org)->y)-485))-((800-485)*((*((CEU_WateringCanActive*)_ceu_org)->x)-1030)))>0);
#line 573 "garden.ceu"
    }/* NODE: Stmts 6136 */

#line 574 "garden.ceu"
    {/* NODE: Dcl_var 6133 */
/* NODE: Set 6137 */

#line 574 "garden.ceu"
/* SET: rightmidborder *//* NODE: Op2_> 1724 */

#line 574 "garden.ceu"
    (((CEU_WateringCanActive*)_ceu_org)->rightmidborder_9) = ((((828-778)*((*((CEU_WateringCanActive*)_ceu_org)->y)-485))-((800-485)*((*((CEU_WateringCanActive*)_ceu_org)->x)-778)))>0);
#line 574 "garden.ceu"
    }/* NODE: Stmts 6142 */

#line 575 "garden.ceu"
    {/* NODE: Dcl_var 6139 */
/* NODE: Set 6143 */

#line 575 "garden.ceu"
/* SET: leftmidborder *//* NODE: Op2_> 1743 */

#line 575 "garden.ceu"
    (((CEU_WateringCanActive*)_ceu_org)->leftmidborder_10) = ((((461-512)*((*((CEU_WateringCanActive*)_ceu_org)->y)-485))-((800-485)*((*((CEU_WateringCanActive*)_ceu_org)->x)-512)))>0);
#line 575 "garden.ceu"
    }/* NODE: Stmts 6148 */

#line 576 "garden.ceu"
    {/* NODE: Dcl_var 6145 */
/* NODE: Set 6149 */

#line 576 "garden.ceu"
/* SET: leftborder *//* NODE: Op2_> 1762 */

#line 576 "garden.ceu"
    (((CEU_WateringCanActive*)_ceu_org)->leftborder_11) = ((((111-258)*((*((CEU_WateringCanActive*)_ceu_org)->y)-485))-((800-485)*((*((CEU_WateringCanActive*)_ceu_org)->x)-258)))>0);
#line 576 "garden.ceu"
    }/* NODE: If 6152 */

#line 578 "garden.ceu"
    if ((((*((CEU_WateringCanActive*)_ceu_org)->y)>485)&&((*((CEU_WateringCanActive*)_ceu_org)->y)<=614))) {
/* NODE: Block 1803 */

#line 579 "garden.ceu"
    {/* NODE: Stmts 1802 */

#line 579 "garden.ceu"
    {/* NODE: If 6156 */

#line 579 "garden.ceu"
    if (((((CEU_WateringCanActive*)_ceu_org)->rightborder_8)&&(!(((CEU_WateringCanActive*)_ceu_org)->rightmidborder_9)))) {
/* NODE: Block 1780 */

#line 580 "garden.ceu"
    {/* NODE: Stmts 1779 */

#line 580 "garden.ceu"
    {/* NODE: EmitInt 1778 */

#line 580 "garden.ceu"
    {
#ifdef CEU_STACK_CLEAR
    tceu_stk stk_ = { _ceu_stk, _ceu_org, 1, 1, 1 };
#endif

#line 580 "garden.ceu"
    tceu__int __ceu_ps_1778;
{
    tceu__int __ceu_ps_1778_ =
        { 2 };
    __ceu_ps_1778 = __ceu_ps_1778_;
}

#line 580 "garden.ceu"
        /* trigger the event */
    tceu_evt evt;
    evt.id = 3;
#ifdef CEU_ORGS
#line 580 "garden.ceu"
    evt.org = (tceu_org*) (((CEU_WateringCanActive*)_ceu_org)->garden);
#endif

#line 580 "garden.ceu"
        evt.param = (&__ceu_ps_1778);

#line 580 "garden.ceu"
        ceu_sys_go_ex(_ceu_app, &evt,
#ifdef CEU_STACK_CLEAR
                  &stk_,
#else
                  NULL,
#endif
                  _ceu_app->data, 0,
#ifdef CEU_ORGS
                  _ceu_app->data->n
#else
                  CEU_NTRAILS
#endif
    );

#ifdef CEU_STACK_CLEAR
    if (!stk_.is_alive) {
        return;
    }
#endif
}

#line 580 "garden.ceu"
    }
#line 580 "garden.ceu"
/* CLEAR: Block (580) */
#line 580 "garden.ceu"
    if (0) {

#line 580 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
} else {
/* NODE: If 6155 */

#line 581 "garden.ceu"
    if (((((CEU_WateringCanActive*)_ceu_org)->rightmidborder_9)&&(!(((CEU_WateringCanActive*)_ceu_org)->leftmidborder_10)))) {
/* NODE: Block 1790 */

#line 582 "garden.ceu"
    {/* NODE: Stmts 1789 */

#line 582 "garden.ceu"
    {/* NODE: EmitInt 1788 */

#line 582 "garden.ceu"
    {
#ifdef CEU_STACK_CLEAR
    tceu_stk stk_ = { _ceu_stk, _ceu_org, 1, 1, 1 };
#endif

#line 582 "garden.ceu"
    tceu__int __ceu_ps_1788;
{
    tceu__int __ceu_ps_1788_ =
        { 1 };
    __ceu_ps_1788 = __ceu_ps_1788_;
}

#line 582 "garden.ceu"
        /* trigger the event */
    tceu_evt evt;
    evt.id = 3;
#ifdef CEU_ORGS
#line 582 "garden.ceu"
    evt.org = (tceu_org*) (((CEU_WateringCanActive*)_ceu_org)->garden);
#endif

#line 582 "garden.ceu"
        evt.param = (&__ceu_ps_1788);

#line 582 "garden.ceu"
        ceu_sys_go_ex(_ceu_app, &evt,
#ifdef CEU_STACK_CLEAR
                  &stk_,
#else
                  NULL,
#endif
                  _ceu_app->data, 0,
#ifdef CEU_ORGS
                  _ceu_app->data->n
#else
                  CEU_NTRAILS
#endif
    );

#ifdef CEU_STACK_CLEAR
    if (!stk_.is_alive) {
        return;
    }
#endif
}

#line 582 "garden.ceu"
    }
#line 582 "garden.ceu"
/* CLEAR: Block (582) */
#line 582 "garden.ceu"
    if (0) {

#line 582 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
} else {
/* NODE: If 6154 */

#line 583 "garden.ceu"
    if (((((CEU_WateringCanActive*)_ceu_org)->leftmidborder_10)&&(!(((CEU_WateringCanActive*)_ceu_org)->leftborder_11)))) {
/* NODE: Block 1800 */

#line 584 "garden.ceu"
    {/* NODE: Stmts 1799 */

#line 584 "garden.ceu"
    {/* NODE: EmitInt 1798 */

#line 584 "garden.ceu"
    {
#ifdef CEU_STACK_CLEAR
    tceu_stk stk_ = { _ceu_stk, _ceu_org, 1, 1, 1 };
#endif

#line 584 "garden.ceu"
    tceu__int __ceu_ps_1798;
{
    tceu__int __ceu_ps_1798_ =
        { 0 };
    __ceu_ps_1798 = __ceu_ps_1798_;
}

#line 584 "garden.ceu"
        /* trigger the event */
    tceu_evt evt;
    evt.id = 3;
#ifdef CEU_ORGS
#line 584 "garden.ceu"
    evt.org = (tceu_org*) (((CEU_WateringCanActive*)_ceu_org)->garden);
#endif

#line 584 "garden.ceu"
        evt.param = (&__ceu_ps_1798);

#line 584 "garden.ceu"
        ceu_sys_go_ex(_ceu_app, &evt,
#ifdef CEU_STACK_CLEAR
                  &stk_,
#else
                  NULL,
#endif
                  _ceu_app->data, 0,
#ifdef CEU_ORGS
                  _ceu_app->data->n
#else
                  CEU_NTRAILS
#endif
    );

#ifdef CEU_STACK_CLEAR
    if (!stk_.is_alive) {
        return;
    }
#endif
}

#line 584 "garden.ceu"
    }
#line 584 "garden.ceu"
/* CLEAR: Block (584) */
#line 584 "garden.ceu"
    if (0) {

#line 584 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
} else {
/* NODE: Nothing 6153 */
}
}
}

#line 579 "garden.ceu"
    }
#line 579 "garden.ceu"
/* CLEAR: Block (579) */
#line 579 "garden.ceu"
    if (0) {

#line 579 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
} else {
/* NODE: If 6151 */

#line 586 "garden.ceu"
    if ((((*((CEU_WateringCanActive*)_ceu_org)->y)>614)&&((*((CEU_WateringCanActive*)_ceu_org)->y)<=800))) {
/* NODE: Block 1843 */

#line 587 "garden.ceu"
    {/* NODE: Stmts 1842 */

#line 587 "garden.ceu"
    {/* NODE: If 6163 */

#line 587 "garden.ceu"
    if (((((CEU_WateringCanActive*)_ceu_org)->rightborder_8)&&(!(((CEU_WateringCanActive*)_ceu_org)->rightmidborder_9)))) {
/* NODE: Block 1820 */

#line 588 "garden.ceu"
    {/* NODE: Stmts 1819 */

#line 588 "garden.ceu"
    {/* NODE: EmitInt 1818 */

#line 588 "garden.ceu"
    {
#ifdef CEU_STACK_CLEAR
    tceu_stk stk_ = { _ceu_stk, _ceu_org, 1, 1, 1 };
#endif

#line 588 "garden.ceu"
    tceu__int __ceu_ps_1818;
{
    tceu__int __ceu_ps_1818_ =
        { 5 };
    __ceu_ps_1818 = __ceu_ps_1818_;
}

#line 588 "garden.ceu"
        /* trigger the event */
    tceu_evt evt;
    evt.id = 3;
#ifdef CEU_ORGS
#line 588 "garden.ceu"
    evt.org = (tceu_org*) (((CEU_WateringCanActive*)_ceu_org)->garden);
#endif

#line 588 "garden.ceu"
        evt.param = (&__ceu_ps_1818);

#line 588 "garden.ceu"
        ceu_sys_go_ex(_ceu_app, &evt,
#ifdef CEU_STACK_CLEAR
                  &stk_,
#else
                  NULL,
#endif
                  _ceu_app->data, 0,
#ifdef CEU_ORGS
                  _ceu_app->data->n
#else
                  CEU_NTRAILS
#endif
    );

#ifdef CEU_STACK_CLEAR
    if (!stk_.is_alive) {
        return;
    }
#endif
}

#line 588 "garden.ceu"
    }
#line 588 "garden.ceu"
/* CLEAR: Block (588) */
#line 588 "garden.ceu"
    if (0) {

#line 588 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
} else {
/* NODE: If 6162 */

#line 589 "garden.ceu"
    if (((((CEU_WateringCanActive*)_ceu_org)->rightmidborder_9)&&(!(((CEU_WateringCanActive*)_ceu_org)->leftmidborder_10)))) {
/* NODE: Block 1830 */

#line 590 "garden.ceu"
    {/* NODE: Stmts 1829 */

#line 590 "garden.ceu"
    {/* NODE: EmitInt 1828 */

#line 590 "garden.ceu"
    {
#ifdef CEU_STACK_CLEAR
    tceu_stk stk_ = { _ceu_stk, _ceu_org, 1, 1, 1 };
#endif

#line 590 "garden.ceu"
    tceu__int __ceu_ps_1828;
{
    tceu__int __ceu_ps_1828_ =
        { 4 };
    __ceu_ps_1828 = __ceu_ps_1828_;
}

#line 590 "garden.ceu"
        /* trigger the event */
    tceu_evt evt;
    evt.id = 3;
#ifdef CEU_ORGS
#line 590 "garden.ceu"
    evt.org = (tceu_org*) (((CEU_WateringCanActive*)_ceu_org)->garden);
#endif

#line 590 "garden.ceu"
        evt.param = (&__ceu_ps_1828);

#line 590 "garden.ceu"
        ceu_sys_go_ex(_ceu_app, &evt,
#ifdef CEU_STACK_CLEAR
                  &stk_,
#else
                  NULL,
#endif
                  _ceu_app->data, 0,
#ifdef CEU_ORGS
                  _ceu_app->data->n
#else
                  CEU_NTRAILS
#endif
    );

#ifdef CEU_STACK_CLEAR
    if (!stk_.is_alive) {
        return;
    }
#endif
}

#line 590 "garden.ceu"
    }
#line 590 "garden.ceu"
/* CLEAR: Block (590) */
#line 590 "garden.ceu"
    if (0) {

#line 590 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
} else {
/* NODE: If 6161 */

#line 591 "garden.ceu"
    if (((((CEU_WateringCanActive*)_ceu_org)->leftmidborder_10)&&(!(((CEU_WateringCanActive*)_ceu_org)->leftborder_11)))) {
/* NODE: Block 1840 */

#line 592 "garden.ceu"
    {/* NODE: Stmts 1839 */

#line 592 "garden.ceu"
    {/* NODE: EmitInt 1838 */

#line 592 "garden.ceu"
    {
#ifdef CEU_STACK_CLEAR
    tceu_stk stk_ = { _ceu_stk, _ceu_org, 1, 1, 1 };
#endif

#line 592 "garden.ceu"
    tceu__int __ceu_ps_1838;
{
    tceu__int __ceu_ps_1838_ =
        { 3 };
    __ceu_ps_1838 = __ceu_ps_1838_;
}

#line 592 "garden.ceu"
        /* trigger the event */
    tceu_evt evt;
    evt.id = 3;
#ifdef CEU_ORGS
#line 592 "garden.ceu"
    evt.org = (tceu_org*) (((CEU_WateringCanActive*)_ceu_org)->garden);
#endif

#line 592 "garden.ceu"
        evt.param = (&__ceu_ps_1838);

#line 592 "garden.ceu"
        ceu_sys_go_ex(_ceu_app, &evt,
#ifdef CEU_STACK_CLEAR
                  &stk_,
#else
                  NULL,
#endif
                  _ceu_app->data, 0,
#ifdef CEU_ORGS
                  _ceu_app->data->n
#else
                  CEU_NTRAILS
#endif
    );

#ifdef CEU_STACK_CLEAR
    if (!stk_.is_alive) {
        return;
    }
#endif
}

#line 592 "garden.ceu"
    }
#line 592 "garden.ceu"
/* CLEAR: Block (592) */
#line 592 "garden.ceu"
    if (0) {

#line 592 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
} else {
/* NODE: Nothing 6160 */
}
}
}

#line 587 "garden.ceu"
    }
#line 587 "garden.ceu"
/* CLEAR: Block (587) */
#line 587 "garden.ceu"
    if (0) {

#line 587 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
} else {
/* NODE: Nothing 6150 */
}
}
/* NODE: Stmts 6206 */

#line 596 "garden.ceu"
    {/* NODE: Nothing 6168 */
/* NODE: Set 6167 */

#line 596 "garden.ceu"
/* SET: table: 0xc4fd20 *//* NODE: Await 1849 */

#line 596 "garden.ceu"
    _CEU_NO_1849_:
if (0) { goto _CEU_NO_1849_; /* avoids "not used" warning */ }

#line 596 "garden.ceu"
    _ceu_trl->evt = CEU_IN_MOUSE_MOVE;
_ceu_trl->lbl = WateringCanActive_Awake_MOUSE_MOVE_83;
_ceu_trl->seqno = _ceu_app->seqno;

#line 596 "garden.ceu"
    return;

case WateringCanActive_Awake_MOUSE_MOVE_83:;

#line 596 "garden.ceu"
    #ifdef CEU_DEBUG_TRAILS
#ifndef CEU_OS
printf("\tOK!\n");
#endif
#endif

#line 596 "garden.ceu"
    {

#line 596 "garden.ceu"
        tceu__int__int** __ceu_casted = (tceu__int__int**) _ceu_evt->param;

#line 596 "garden.ceu"
        (*((CEU_WateringCanActive*)_ceu_org)->x) = ((*(__ceu_casted))->_1);
}

#line 596 "garden.ceu"
    {

#line 596 "garden.ceu"
        tceu__int__int** __ceu_casted = (tceu__int__int**) _ceu_evt->param;

#line 596 "garden.ceu"
        (*((CEU_WateringCanActive*)_ceu_org)->y) = ((*(__ceu_casted))->_2);
}
/* NODE: Nothing 8259 */
/* NODE: Nothing 8260 */

#line 596 "garden.ceu"
    }
#line 573 "garden.ceu"
    }
#line 573 "garden.ceu"
/* CLEAR: Block (573) */
#line 573 "garden.ceu"
    if (0) {

#line 573 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 572 "garden.ceu"
    }

#line 572 "garden.ceu"
    }
#line 572 "garden.ceu"
/* CLEAR: Block (572) */
#line 572 "garden.ceu"
    if (0) {

#line 572 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 572 "garden.ceu"
    }
#line 572 "garden.ceu"
/* CLEAR: Block (572) */
#line 572 "garden.ceu"
    if (0) {

#line 572 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 569 "garden.ceu"
case WateringCanActive_ParOr_sub_1_80:;/* NODE: Block 1687 */

#line 570 "garden.ceu"
    {/* NODE: Stmts 1686 */

#line 570 "garden.ceu"
    {/* NODE: Stmts 6117 */

#line 570 "garden.ceu"
    {/* NODE: Nothing 6079 */
/* NODE: Set 6078 */

#line 570 "garden.ceu"
/* SET: table: 0xc205a0 *//* NODE: Await 1684 */

#line 570 "garden.ceu"
    _CEU_NO_1684_:
if (0) { goto _CEU_NO_1684_; /* avoids "not used" warning */ }

#line 570 "garden.ceu"
    _ceu_trl->evt = CEU_IN_MOUSE_UP;
_ceu_trl->lbl = WateringCanActive_Awake_MOUSE_UP_82;
_ceu_trl->seqno = _ceu_app->seqno;

#line 570 "garden.ceu"
    return;

case WateringCanActive_Awake_MOUSE_UP_82:;

#line 570 "garden.ceu"
    #ifdef CEU_DEBUG_TRAILS
#ifndef CEU_OS
printf("\tOK!\n");
#endif
#endif

#line 570 "garden.ceu"
    {

#line 570 "garden.ceu"
        tceu__int__int** __ceu_casted = (tceu__int__int**) _ceu_evt->param;

#line 570 "garden.ceu"
        (*((CEU_WateringCanActive*)_ceu_org)->x) = ((*(__ceu_casted))->_1);
}

#line 570 "garden.ceu"
    {

#line 570 "garden.ceu"
        tceu__int__int** __ceu_casted = (tceu__int__int**) _ceu_evt->param;

#line 570 "garden.ceu"
        (*((CEU_WateringCanActive*)_ceu_org)->y) = ((*(__ceu_casted))->_2);
}
/* NODE: Nothing 8251 */
/* NODE: Nothing 8252 */

#line 570 "garden.ceu"
    }
#line 570 "garden.ceu"
    }
#line 570 "garden.ceu"
/* CLEAR: Block (570) */
#line 570 "garden.ceu"
    if (0) {

#line 570 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 569 "garden.ceu"
/* PAROR JOIN */
#line 569 "garden.ceu"
    _ceu_lbl = WateringCanActive_ParOr_out_81;
goto _CEU_GOTO_;

#line 569 "garden.ceu"
case WateringCanActive_ParOr_out_81:;
#line 569 "garden.ceu"
/* CLEAR: ParOr (569) */
#line 569 "garden.ceu"
    {
    /* Reuse current stack frame.
     * We know that CLEAR will not abort anything and return normally.
     * Just save the previous "is_alive", call CLEAR, and restore it.
     */
#ifdef CEU_STACK_CLEAR
    int __ceu_old = _ceu_stk->is_alive;
    _ceu_stk->is_alive = 1;
#endif
    tceu_evt evt;
             evt.id = CEU_IN__CLEAR;
    ceu_sys_go_ex(_ceu_app, &evt,
                  _ceu_stk,
                  _ceu_org,
                  0,
                  2);
#ifdef CEU_STACK_CLEAR
    _ceu_stk->is_alive = __ceu_old;
    ceu_sys_stack_clear(_ceu_stk, _ceu_org,
                        0,1);
#endif
}
/* NODE: EmitInt 1858 */

#line 599 "garden.ceu"
    {
#ifdef CEU_STACK_CLEAR
    tceu_stk stk_ = { _ceu_stk, _ceu_org, 0, 1, 1 };
#endif

#line 599 "garden.ceu"
        /* trigger the event */
    tceu_evt evt;
    evt.id = 1;
#ifdef CEU_ORGS
#line 599 "garden.ceu"
    evt.org = (tceu_org*) _ceu_org;
#endif

#line 599 "garden.ceu"
        ceu_sys_go_ex(_ceu_app, &evt,
#ifdef CEU_STACK_CLEAR
                  &stk_,
#else
                  NULL,
#endif
                  _ceu_app->data, 0,
#ifdef CEU_ORGS
                  _ceu_app->data->n
#else
                  CEU_NTRAILS
#endif
    );

#ifdef CEU_STACK_CLEAR
    if (!stk_.is_alive) {
        return;
    }
#endif
}

#line 565 "garden.ceu"
    }
#line 565 "garden.ceu"
/* CLEAR: Block (565) */
#line 565 "garden.ceu"
    {
    /* Reuse current stack frame.
     * We know that CLEAR will not abort anything and return normally.
     * Just save the previous "is_alive", call CLEAR, and restore it.
     */
#ifdef CEU_STACK_CLEAR
    int __ceu_old = _ceu_stk->is_alive;
    _ceu_stk->is_alive = 1;
#endif
    tceu_evt evt;
             evt.id = CEU_IN__CLEAR;
    ceu_sys_go_ex(_ceu_app, &evt,
                  _ceu_stk,
                  _ceu_org,
                  0,
                  3);
#ifdef CEU_STACK_CLEAR
    _ceu_stk->is_alive = __ceu_old;
    ceu_sys_stack_clear(_ceu_stk, _ceu_org,
                        0,2);
#endif
}

#line 565 "garden.ceu"
    if (0) {

#line 565 "garden.ceu"
case WateringCanActive_Block__fin_84:;
#line 565 "garden.ceu"
    if (((CEU_WateringCanActive*)_ceu_org)->__fin_1860_1) {
    /* NODE: Finally 1678 */
/* NODE: Block 1677 */

#line 567 "garden.ceu"
    {/* NODE: Stmts 1676 */

#line 567 "garden.ceu"
    {/* NODE: EmitExt 1675 */

#line 567 "garden.ceu"
        {

#line 567 "garden.ceu"
    tceu__int__float __ceu_ps_1675;
{
    tceu__int__float __ceu_ps_1675_ =
        { (((CEU_WateringCanActive*)_ceu_org)->id),0.0 };
    __ceu_ps_1675 = __ceu_ps_1675_;
}

#line 567 "garden.ceu"
    
#if defined(ceu_out_emit_SET_SPRITE_ROTATION)
    ceu_out_emit_SET_SPRITE_ROTATION((&__ceu_ps_1675))

#elif defined(ceu_out_emit)
    (ceu_out_emit(_ceu_app, CEU_OUT_SET_SPRITE_ROTATION, sizeof(tceu__int__float), (void*)(&__ceu_ps_1675)))

#else
    #error ceu_out_emit_* is not defined
#endif
;
#line 567 "garden.ceu"
        }

#line 567 "garden.ceu"
    }
#line 567 "garden.ceu"
/* CLEAR: Block (567) */
#line 567 "garden.ceu"
    if (0) {

#line 567 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
}

#line 565 "garden.ceu"
    return;
#line 565 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 558 "garden.ceu"
    }
#line 558 "garden.ceu"
/* CLEAR: Block (558) */
#line 558 "garden.ceu"
    if (0) {

#line 558 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 558 "garden.ceu"
    }
#line 558 "garden.ceu"
/* CLEAR: Block (558) */
#line 558 "garden.ceu"
    if (0) {

#line 558 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 558 "garden.ceu"
    ceu_sys_org_free(_ceu_app, _ceu_org);
#ifdef CEU_ORGS_AWAIT
{
    /* signal ok_killed */
#ifdef CEU_STACK_CLEAR
    tceu_stk stk_ = *_ceu_stk;
             stk_.is_alive = 1;
             stk_.down = _ceu_stk;
#endif
    tceu_kill ps = { _ceu_org, _ceu_org->ret, 0, (tceu_ntrl)(_ceu_org->n-1) };
    tceu_evt evt_;
             evt_.id = CEU_IN__ok_killed;
             evt_.param = &ps;
    ceu_sys_go_ex(_ceu_app, &evt_,
#ifdef CEU_STACK_CLEAR
                  &stk_,
#else
                  NULL,
#endif
                  _ceu_app->data, 0, _ceu_app->data->n);
}
#endif

#line 558 "garden.ceu"
    return;/* NODE: Dcl_cls 12 */

#line 602 "garden.ceu"
case Class_WateringCan:;/* NODE: Block 6429 */

#line 602 "garden.ceu"
    {/* NODE: Stmts 6428 */

#line 602 "garden.ceu"
    {/* NODE: Block 6221 */

#line 602 "garden.ceu"
    {/* NODE: Stmts 6430 */

#line 602 "garden.ceu"
    {/* NODE: Block 1964 */

#line 609 "garden.ceu"
    /*  FINALIZE */
_ceu_org->trls[ 3 ].evt = CEU_IN__CLEAR;
_ceu_org->trls[ 3 ].lbl = WateringCan_Block__fin_94;

#line 609 "garden.ceu"
    ((CEU_WateringCan*)_ceu_org)->__fin_1964_1 = 0;
#line 609 "garden.ceu"
    {/* NODE: Stmts 1963 */

#line 609 "garden.ceu"
    {/* NODE: Stmts 6245 */

#line 609 "garden.ceu"
    {/* NODE: Dcl_var 6242 */
/* NODE: Set 6246 */

#line 609 "garden.ceu"
/* SET: id *//* NODE: Var 1874 */

#line 609 "garden.ceu"
    (((CEU_WateringCan*)_ceu_org)->id) = (*((CEU_WateringCan*)_ceu_org)->gensym);
#line 609 "garden.ceu"
    }/* NODE: Set 6247 */

#line 610 "garden.ceu"
/* SET: gensym *//* NODE: Op2_+ 1879 */

#line 610 "garden.ceu"
    (*((CEU_WateringCan*)_ceu_org)->gensym) = ((*((CEU_WateringCan*)_ceu_org)->gensym)+1);/* NODE: EmitExt 1888 */

#line 611 "garden.ceu"
        {

#line 611 "garden.ceu"
    tceu__int__int__int__int__int __ceu_ps_1888;
{
    tceu__int__int__int__int__int __ceu_ps_1888_ =
        { (((CEU_WateringCan*)_ceu_org)->id),(((CEU_WateringCan*)_ceu_org)->x),(((CEU_WateringCan*)_ceu_org)->y),5,3 };
    __ceu_ps_1888 = __ceu_ps_1888_;
}

#line 611 "garden.ceu"
    
#if defined(ceu_out_emit_NEW_SPRITE)
    ceu_out_emit_NEW_SPRITE((&__ceu_ps_1888))

#elif defined(ceu_out_emit)
    (ceu_out_emit(_ceu_app, CEU_OUT_NEW_SPRITE, sizeof(tceu__int__int__int__int__int), (void*)(&__ceu_ps_1888)))

#else
    #error ceu_out_emit_* is not defined
#endif
;
#line 611 "garden.ceu"
        }
/* NODE: Finalize 1895 */

#line 612 "garden.ceu"
    ((CEU_WateringCan*)_ceu_org)->__fin_1964_1 = 1;/* NODE: ParOr 1960 */

#line 616 "garden.ceu"
/* ParOr: spawn subs */
#line 616 "garden.ceu"
    {
#ifdef CEU_STACK_CLEAR
    tceu_stk stk_ = { _ceu_stk, _ceu_org, 0, 2, 1 };
#endif

#line 616 "garden.ceu"
        _ceu_org->trls[ 0 ].lbl = WateringCan_ParOr_sub_1_86;
    ceu_app_go(_ceu_app,NULL,_ceu_org,
               &_ceu_org->trls[ 0 ],
#ifdef CEU_STACK_CLEAR
               &stk_
#else
               NULL
#endif
              );

#ifdef CEU_STACK_CLEAR
    if (!stk_.is_alive) {
        return;
    }
#endif

#line 616 "garden.ceu"
        _ceu_trl = &_ceu_org->trls[ 1 ];

#line 616 "garden.ceu"
    }
/* NODE: Block 1959 */

#line 622 "garden.ceu"
    {/* NODE: Stmts 1958 */

#line 622 "garden.ceu"
    {/* NODE: Block 6300 */

#line 622 "garden.ceu"
    {/* NODE: Stmts 6299 */

#line 622 "garden.ceu"
    {/* NODE: Stmts 6298 */

#line 622 "garden.ceu"
    {
#line 622 "garden.ceu"
    }/* NODE: Loop 6297 */

#line 622 "garden.ceu"
    for (;;) {
/* NODE: Block 1956 */

#line 623 "garden.ceu"
    {/* NODE: Stmts 1955 */

#line 623 "garden.ceu"
    {/* NODE: ParOr 1931 */

#line 623 "garden.ceu"
/* ParOr: spawn subs */
#line 623 "garden.ceu"
    {
#ifdef CEU_STACK_CLEAR
    tceu_stk stk_ = { _ceu_stk, _ceu_org, 1, 2, 1 };
#endif

#line 623 "garden.ceu"
        _ceu_org->trls[ 1 ].lbl = WateringCan_ParOr_sub_1_89;
    ceu_app_go(_ceu_app,NULL,_ceu_org,
               &_ceu_org->trls[ 1 ],
#ifdef CEU_STACK_CLEAR
               &stk_
#else
               NULL
#endif
              );

#ifdef CEU_STACK_CLEAR
    if (!stk_.is_alive) {
        return;
    }
#endif

#line 623 "garden.ceu"
        _ceu_trl = &_ceu_org->trls[ 2 ];

#line 623 "garden.ceu"
    }
/* NODE: Block 1930 */

#line 627 "garden.ceu"
    {/* NODE: Stmts 1929 */

#line 627 "garden.ceu"
    {/* NODE: Stmts 6384 */

#line 627 "garden.ceu"
    {/* NODE: Nothing 6346 */
/* NODE: Set 6345 */

#line 627 "garden.ceu"
/* SET: table: 0xf1c9e0 *//* NODE: Await 1927 */

#line 627 "garden.ceu"
    _CEU_NO_1927_:
if (0) { goto _CEU_NO_1927_; /* avoids "not used" warning */ }

#line 627 "garden.ceu"
    _ceu_trl->evt = CEU_IN_MOUSE_DOWN;
_ceu_trl->lbl = WateringCan_Awake_MOUSE_DOWN_92;
_ceu_trl->seqno = _ceu_app->seqno;

#line 627 "garden.ceu"
    return;

case WateringCan_Awake_MOUSE_DOWN_92:;

#line 627 "garden.ceu"
    #ifdef CEU_DEBUG_TRAILS
#ifndef CEU_OS
printf("\tOK!\n");
#endif
#endif

#line 627 "garden.ceu"
    {

#line 627 "garden.ceu"
        tceu__int__int** __ceu_casted = (tceu__int__int**) _ceu_evt->param;

#line 627 "garden.ceu"
        (((CEU_WateringCan*)_ceu_org)->x) = ((*(__ceu_casted))->_1);
}

#line 627 "garden.ceu"
    {

#line 627 "garden.ceu"
        tceu__int__int** __ceu_casted = (tceu__int__int**) _ceu_evt->param;

#line 627 "garden.ceu"
        (((CEU_WateringCan*)_ceu_org)->y) = ((*(__ceu_casted))->_2);
}
/* NODE: Nothing 8265 */
/* NODE: Nothing 8266 */

#line 627 "garden.ceu"
    }
#line 627 "garden.ceu"
    }
#line 627 "garden.ceu"
/* CLEAR: Block (627) */
#line 627 "garden.ceu"
    if (0) {

#line 627 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 623 "garden.ceu"
/* PAROR JOIN */
#line 623 "garden.ceu"
    _ceu_lbl = WateringCan_ParOr_out_90;
goto _CEU_GOTO_;

#line 623 "garden.ceu"
case WateringCan_ParOr_sub_1_89:;/* NODE: Block 1922 */

#line 624 "garden.ceu"
    {/* NODE: Stmts 1921 */

#line 624 "garden.ceu"
    {/* NODE: Stmts 6340 */

#line 624 "garden.ceu"
    {/* NODE: Nothing 6302 */
/* NODE: Set 6301 */

#line 624 "garden.ceu"
/* SET: table: 0xf1c040 *//* NODE: Await 1918 */

#line 624 "garden.ceu"
    _CEU_NO_1918_:
if (0) { goto _CEU_NO_1918_; /* avoids "not used" warning */ }

#line 624 "garden.ceu"
    _ceu_trl->evt = CEU_IN_MOUSE_UP;
_ceu_trl->lbl = WateringCan_Awake_MOUSE_UP_91;
_ceu_trl->seqno = _ceu_app->seqno;

#line 624 "garden.ceu"
    return;

case WateringCan_Awake_MOUSE_UP_91:;

#line 624 "garden.ceu"
    #ifdef CEU_DEBUG_TRAILS
#ifndef CEU_OS
printf("\tOK!\n");
#endif
#endif

#line 624 "garden.ceu"
    {

#line 624 "garden.ceu"
        tceu__int__int** __ceu_casted = (tceu__int__int**) _ceu_evt->param;

#line 624 "garden.ceu"
        (((CEU_WateringCan*)_ceu_org)->x) = ((*(__ceu_casted))->_1);
}

#line 624 "garden.ceu"
    {

#line 624 "garden.ceu"
        tceu__int__int** __ceu_casted = (tceu__int__int**) _ceu_evt->param;

#line 624 "garden.ceu"
        (((CEU_WateringCan*)_ceu_org)->y) = ((*(__ceu_casted))->_2);
}
/* NODE: Nothing 8263 */
/* NODE: Nothing 8264 */

#line 624 "garden.ceu"
    }/* NODE: Break 1920 */

#line 625 "garden.ceu"
    break;
#line 624 "garden.ceu"
    }
#line 624 "garden.ceu"
/* CLEAR: Block (624) */
#line 624 "garden.ceu"
    if (0) {

#line 624 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 623 "garden.ceu"
case WateringCan_ParOr_out_90:;
#line 623 "garden.ceu"
/* CLEAR: ParOr (623) */
#line 623 "garden.ceu"
    {
    /* Reuse current stack frame.
     * We know that CLEAR will not abort anything and return normally.
     * Just save the previous "is_alive", call CLEAR, and restore it.
     */
#ifdef CEU_STACK_CLEAR
    int __ceu_old = _ceu_stk->is_alive;
    _ceu_stk->is_alive = 1;
#endif
    tceu_evt evt;
             evt.id = CEU_IN__CLEAR;
    ceu_sys_go_ex(_ceu_app, &evt,
                  _ceu_stk,
                  _ceu_org,
                  1,
                  3);
#ifdef CEU_STACK_CLEAR
    _ceu_stk->is_alive = __ceu_old;
    ceu_sys_stack_clear(_ceu_stk, _ceu_org,
                        1,2);
#endif
}
/* NODE: Do 6395 */
/* NODE: Block 6394 */

#line 629 "garden.ceu"
    {
#line 629 "garden.ceu"
    #ifdef CEU_ORGS
_ceu_org->trls[ 1 ].evt = CEU_IN__ORG;
_ceu_org->trls[ 1 ].org = NULL;
#endif

#line 629 "garden.ceu"
    _ceu_trl = &_ceu_org->trls[ 2 ];
/* NODE: Stmts 6393 */

#line 629 "garden.ceu"
    {/* NODE: Dcl_var 6392 */

#line 629 "garden.ceu"
/* start org: _org_1954 */
#line 629 "garden.ceu"
        /* resets org memory and starts org.trail[0]=Class_XXX */
    /* TODO: BUG: _ceu_org is not necessarily the parent for pool allocations */
    ceu_out_org_init(_ceu_app, ((tceu_org*) &(((CEU_WateringCan*)_ceu_org)->_org_1954_9)),4,Class_WateringCanActive,
                     11,
                     0,
                     _ceu_org,1);
/* TODO: currently idx is always "1" for all interfaces access because pools 
 * are all together there. When we have separate trls for pools, we'll have to 
 * indirectly access the offset in the interface. */

#line 629 "garden.ceu"
        _ceu_constr_1953(_ceu_app, ((tceu_org*) &(((CEU_WateringCan*)_ceu_org)->_org_1954_9)), _ceu_org);

#line 629 "garden.ceu"
    {
#ifdef CEU_STACK_CLEAR
    tceu_stk stk_ = { _ceu_stk, _ceu_org, 2, 2, 1 };
    ceu_app_go(_ceu_app,NULL,
               ((tceu_org*) &(((CEU_WateringCan*)_ceu_org)->_org_1954_9)), &((tceu_org*) &(((CEU_WateringCan*)_ceu_org)->_org_1954_9))->trls[0],
               &stk_);
    if (!stk_.is_alive) {
        return;
    }
#else
    ceu_app_go(_ceu_app,NULL,
               ((tceu_org*) &(((CEU_WateringCan*)_ceu_org)->_org_1954_9)), &((tceu_org*) &(((CEU_WateringCan*)_ceu_org)->_org_1954_9))->trls[0],
               NULL);
#endif

#line 629 "garden.ceu"
    }
/* NODE: Stmts 6426 */

#line 629 "garden.ceu"
    {/* NODE: Nothing 6400 */
/* NODE: Nothing 8271 */
/* NODE: Nothing 8272 */
/* NODE: Stmts 6425 */

#line 629 "garden.ceu"
    {/* NODE: If 6424 */

#line 629 "garden.ceu"
    if ((!(((*((tceu_org*)(&((CEU_WateringCan*)_ceu_org)->_org_1954_9))).isAlive)))) {
/* NODE: Block 6421 */

#line 629 "garden.ceu"
    {/* NODE: Stmts 6420 */

#line 629 "garden.ceu"
    {/* NODE: Nothing 6404 */

#line 629 "garden.ceu"
    }
#line 629 "garden.ceu"
/* CLEAR: Block (629) */
#line 629 "garden.ceu"
    if (0) {

#line 629 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
} else {
/* NODE: Block 6423 */

#line 629 "garden.ceu"
    {/* NODE: Stmts 6422 */

#line 629 "garden.ceu"
    {/* NODE: Await 6403 */

#line 629 "garden.ceu"
    _CEU_NO_6403_:
if (0) { goto _CEU_NO_6403_; /* avoids "not used" warning */ }

#line 629 "garden.ceu"
    _ceu_trl->evt = CEU_IN__ok_killed;
_ceu_trl->lbl = WateringCan_Awake__ok_killed_93;
_ceu_trl->seqno = _ceu_app->seqno;

#line 629 "garden.ceu"
    #ifdef CEU_ORGS_AWAIT
#ifdef CEU_ADTS_AWAIT
_ceu_trl->is_org = 1;
#endif
#endif
_ceu_trl->org_or_adt = (void*)(&((CEU_WateringCan*)_ceu_org)->_org_1954_9);

#line 629 "garden.ceu"
    return;

case WateringCan_Awake__ok_killed_93:;

#line 629 "garden.ceu"
    #ifdef CEU_DEBUG_TRAILS
#ifndef CEU_OS
printf("\tOK!\n");
#endif
#endif

#line 629 "garden.ceu"
    }
#line 629 "garden.ceu"
/* CLEAR: Block (629) */
#line 629 "garden.ceu"
    if (0) {

#line 629 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
}

#line 629 "garden.ceu"
    }
#line 629 "garden.ceu"
    }
#line 629 "garden.ceu"
    }
#line 629 "garden.ceu"
/* CLEAR: Block (629) */
#line 629 "garden.ceu"
    {
    /* Reuse current stack frame.
     * We know that CLEAR will not abort anything and return normally.
     * Just save the previous "is_alive", call CLEAR, and restore it.
     */
#ifdef CEU_STACK_CLEAR
    int __ceu_old = _ceu_stk->is_alive;
    _ceu_stk->is_alive = 1;
#endif
    tceu_evt evt;
             evt.id = CEU_IN__CLEAR;
    ceu_sys_go_ex(_ceu_app, &evt,
                  _ceu_stk,
                  _ceu_org,
                  1,
                  3);
#ifdef CEU_STACK_CLEAR
    _ceu_stk->is_alive = __ceu_old;
    ceu_sys_stack_clear(_ceu_stk, _ceu_org,
                        1,2);
#endif
}

#line 629 "garden.ceu"
    #ifdef CEU_ORGS_AWAIT
/* signal ok_killed */
{
    tceu_kill ps = { _ceu_org, _ceu_org->ret, 1,2 };
    tceu_evt evt_;
             evt_.id = CEU_IN__ok_killed;
             evt_.param = &ps;
    ceu_sys_go_ex(_ceu_app, &evt_, _ceu_stk,
                  _ceu_app->data, 0, _ceu_app->data->n);
}
#endif

#line 629 "garden.ceu"
    if (0) {

#line 629 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 623 "garden.ceu"
    }
#line 623 "garden.ceu"
/* CLEAR: Block (623) */
#line 623 "garden.ceu"
    if (0) {

#line 623 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 622 "garden.ceu"
    }

#line 622 "garden.ceu"
/* CLEAR: Loop (622) */
#line 622 "garden.ceu"
    {
    /* Reuse current stack frame.
     * We know that CLEAR will not abort anything and return normally.
     * Just save the previous "is_alive", call CLEAR, and restore it.
     */
#ifdef CEU_STACK_CLEAR
    int __ceu_old = _ceu_stk->is_alive;
    _ceu_stk->is_alive = 1;
#endif
    tceu_evt evt;
             evt.id = CEU_IN__CLEAR;
    ceu_sys_go_ex(_ceu_app, &evt,
                  _ceu_stk,
                  _ceu_org,
                  1,
                  3);
#ifdef CEU_STACK_CLEAR
    _ceu_stk->is_alive = __ceu_old;
    ceu_sys_stack_clear(_ceu_stk, _ceu_org,
                        1,2);
#endif
}

#line 622 "garden.ceu"
    #ifdef CEU_ORGS_AWAIT
/* signal ok_killed */
{
    tceu_kill ps = { _ceu_org, _ceu_org->ret, 1,2 };
    tceu_evt evt_;
             evt_.id = CEU_IN__ok_killed;
             evt_.param = &ps;
    ceu_sys_go_ex(_ceu_app, &evt_, _ceu_stk,
                  _ceu_app->data, 0, _ceu_app->data->n);
}
#endif

#line 622 "garden.ceu"
    }
#line 622 "garden.ceu"
/* CLEAR: Block (622) */
#line 622 "garden.ceu"
    if (0) {

#line 622 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 622 "garden.ceu"
    }
#line 622 "garden.ceu"
/* CLEAR: Block (622) */
#line 622 "garden.ceu"
    if (0) {

#line 622 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 616 "garden.ceu"
/* PAROR JOIN */
#line 616 "garden.ceu"
    _ceu_lbl = WateringCan_ParOr_out_87;
goto _CEU_GOTO_;

#line 616 "garden.ceu"
case WateringCan_ParOr_sub_1_86:;/* NODE: Block 1913 */

#line 617 "garden.ceu"
    {/* NODE: Stmts 1912 */

#line 617 "garden.ceu"
    {/* NODE: Block 6252 */

#line 617 "garden.ceu"
    {/* NODE: Stmts 6251 */

#line 617 "garden.ceu"
    {/* NODE: Stmts 6250 */

#line 617 "garden.ceu"
    {
#line 617 "garden.ceu"
    }/* NODE: Loop 6249 */

#line 617 "garden.ceu"
    for (;;) {
/* NODE: Block 1910 */

#line 618 "garden.ceu"
    {/* NODE: Stmts 1909 */

#line 618 "garden.ceu"
    {/* NODE: Stmts 6292 */

#line 618 "garden.ceu"
    {/* NODE: Nothing 6254 */
/* NODE: Set 6253 */

#line 618 "garden.ceu"
/* SET: table: 0xb8f900 *//* NODE: Await 1900 */

#line 618 "garden.ceu"
    _CEU_NO_1900_:
if (0) { goto _CEU_NO_1900_; /* avoids "not used" warning */ }

#line 618 "garden.ceu"
    _ceu_trl->evt = CEU_IN_MOUSE_MOVE;
_ceu_trl->lbl = WateringCan_Awake_MOUSE_MOVE_88;
_ceu_trl->seqno = _ceu_app->seqno;

#line 618 "garden.ceu"
    return;

case WateringCan_Awake_MOUSE_MOVE_88:;

#line 618 "garden.ceu"
    #ifdef CEU_DEBUG_TRAILS
#ifndef CEU_OS
printf("\tOK!\n");
#endif
#endif

#line 618 "garden.ceu"
    {

#line 618 "garden.ceu"
        tceu__int__int** __ceu_casted = (tceu__int__int**) _ceu_evt->param;

#line 618 "garden.ceu"
        (((CEU_WateringCan*)_ceu_org)->x) = ((*(__ceu_casted))->_1);
}

#line 618 "garden.ceu"
    {

#line 618 "garden.ceu"
        tceu__int__int** __ceu_casted = (tceu__int__int**) _ceu_evt->param;

#line 618 "garden.ceu"
        (((CEU_WateringCan*)_ceu_org)->y) = ((*(__ceu_casted))->_2);
}
/* NODE: Nothing 8261 */
/* NODE: Nothing 8262 */

#line 618 "garden.ceu"
    }/* NODE: EmitExt 1908 */

#line 619 "garden.ceu"
        {

#line 619 "garden.ceu"
    tceu__int__int__int__int __ceu_ps_1908;
{
    tceu__int__int__int__int __ceu_ps_1908_ =
        { (((CEU_WateringCan*)_ceu_org)->id),(((CEU_WateringCan*)_ceu_org)->x),(((CEU_WateringCan*)_ceu_org)->y),1 };
    __ceu_ps_1908 = __ceu_ps_1908_;
}

#line 619 "garden.ceu"
    
#if defined(ceu_out_emit_SET_SPRITE_POSITION)
    ceu_out_emit_SET_SPRITE_POSITION((&__ceu_ps_1908))

#elif defined(ceu_out_emit)
    (ceu_out_emit(_ceu_app, CEU_OUT_SET_SPRITE_POSITION, sizeof(tceu__int__int__int__int), (void*)(&__ceu_ps_1908)))

#else
    #error ceu_out_emit_* is not defined
#endif
;
#line 619 "garden.ceu"
        }

#line 618 "garden.ceu"
    }
#line 618 "garden.ceu"
/* CLEAR: Block (618) */
#line 618 "garden.ceu"
    if (0) {

#line 618 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 617 "garden.ceu"
    }

#line 617 "garden.ceu"
    }
#line 617 "garden.ceu"
/* CLEAR: Block (617) */
#line 617 "garden.ceu"
    if (0) {

#line 617 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 617 "garden.ceu"
    }
#line 617 "garden.ceu"
/* CLEAR: Block (617) */
#line 617 "garden.ceu"
    if (0) {

#line 617 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 616 "garden.ceu"
case WateringCan_ParOr_out_87:;
#line 616 "garden.ceu"
/* CLEAR: ParOr (616) */
#line 616 "garden.ceu"
    {
    /* Reuse current stack frame.
     * We know that CLEAR will not abort anything and return normally.
     * Just save the previous "is_alive", call CLEAR, and restore it.
     */
#ifdef CEU_STACK_CLEAR
    int __ceu_old = _ceu_stk->is_alive;
    _ceu_stk->is_alive = 1;
#endif
    tceu_evt evt;
             evt.id = CEU_IN__CLEAR;
    ceu_sys_go_ex(_ceu_app, &evt,
                  _ceu_stk,
                  _ceu_org,
                  0,
                  3);
#ifdef CEU_STACK_CLEAR
    _ceu_stk->is_alive = __ceu_old;
    ceu_sys_stack_clear(_ceu_stk, _ceu_org,
                        0,2);
#endif
}

#line 616 "garden.ceu"
    #ifdef CEU_ORGS_AWAIT
/* signal ok_killed */
{
    tceu_kill ps = { _ceu_org, _ceu_org->ret, 0,2 };
    tceu_evt evt_;
             evt_.id = CEU_IN__ok_killed;
             evt_.param = &ps;
    ceu_sys_go_ex(_ceu_app, &evt_, _ceu_stk,
                  _ceu_app->data, 0, _ceu_app->data->n);
}
#endif
/* NODE: EmitInt 1962 */

#line 637 "garden.ceu"
    {
#ifdef CEU_STACK_CLEAR
    tceu_stk stk_ = { _ceu_stk, _ceu_org, 0, 2, 1 };
#endif

#line 637 "garden.ceu"
        /* trigger the event */
    tceu_evt evt;
    evt.id = 1;
#ifdef CEU_ORGS
#line 637 "garden.ceu"
    evt.org = (tceu_org*) _ceu_org;
#endif

#line 637 "garden.ceu"
        ceu_sys_go_ex(_ceu_app, &evt,
#ifdef CEU_STACK_CLEAR
                  &stk_,
#else
                  NULL,
#endif
                  _ceu_app->data, 0,
#ifdef CEU_ORGS
                  _ceu_app->data->n
#else
                  CEU_NTRAILS
#endif
    );

#ifdef CEU_STACK_CLEAR
    if (!stk_.is_alive) {
        return;
    }
#endif
}

#line 609 "garden.ceu"
    }
#line 609 "garden.ceu"
/* CLEAR: Block (609) */
#line 609 "garden.ceu"
    {
    /* Reuse current stack frame.
     * We know that CLEAR will not abort anything and return normally.
     * Just save the previous "is_alive", call CLEAR, and restore it.
     */
#ifdef CEU_STACK_CLEAR
    int __ceu_old = _ceu_stk->is_alive;
    _ceu_stk->is_alive = 1;
#endif
    tceu_evt evt;
             evt.id = CEU_IN__CLEAR;
    ceu_sys_go_ex(_ceu_app, &evt,
                  _ceu_stk,
                  _ceu_org,
                  0,
                  4);
#ifdef CEU_STACK_CLEAR
    _ceu_stk->is_alive = __ceu_old;
    ceu_sys_stack_clear(_ceu_stk, _ceu_org,
                        0,3);
#endif
}

#line 609 "garden.ceu"
    #ifdef CEU_ORGS_AWAIT
/* signal ok_killed */
{
    tceu_kill ps = { _ceu_org, _ceu_org->ret, 0,3 };
    tceu_evt evt_;
             evt_.id = CEU_IN__ok_killed;
             evt_.param = &ps;
    ceu_sys_go_ex(_ceu_app, &evt_, _ceu_stk,
                  _ceu_app->data, 0, _ceu_app->data->n);
}
#endif

#line 609 "garden.ceu"
    if (0) {

#line 609 "garden.ceu"
case WateringCan_Block__fin_94:;
#line 609 "garden.ceu"
    if (((CEU_WateringCan*)_ceu_org)->__fin_1964_1) {
    /* NODE: Finally 1894 */
/* NODE: Block 1893 */

#line 613 "garden.ceu"
    {/* NODE: Stmts 1892 */

#line 613 "garden.ceu"
    {/* NODE: EmitExt 1891 */

#line 613 "garden.ceu"
        {

#line 613 "garden.ceu"
    tceu__int __ceu_ps_1891;
{
    tceu__int __ceu_ps_1891_ =
        { (((CEU_WateringCan*)_ceu_org)->id) };
    __ceu_ps_1891 = __ceu_ps_1891_;
}

#line 613 "garden.ceu"
    
#if defined(ceu_out_emit_FREE_SPRITE)
    ceu_out_emit_FREE_SPRITE((&__ceu_ps_1891))

#elif defined(ceu_out_emit)
    (ceu_out_emit(_ceu_app, CEU_OUT_FREE_SPRITE, sizeof(tceu__int), (void*)(&__ceu_ps_1891)))

#else
    #error ceu_out_emit_* is not defined
#endif
;
#line 613 "garden.ceu"
        }

#line 613 "garden.ceu"
    }
#line 613 "garden.ceu"
/* CLEAR: Block (613) */
#line 613 "garden.ceu"
    if (0) {

#line 613 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
}

#line 609 "garden.ceu"
    return;
#line 609 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 602 "garden.ceu"
    }
#line 602 "garden.ceu"
/* CLEAR: Block (602) */
#line 602 "garden.ceu"
    if (0) {

#line 602 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 602 "garden.ceu"
    }
#line 602 "garden.ceu"
/* CLEAR: Block (602) */
#line 602 "garden.ceu"
    if (0) {

#line 602 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 602 "garden.ceu"
    ceu_sys_org_free(_ceu_app, _ceu_org);
#ifdef CEU_ORGS_AWAIT
{
    /* signal ok_killed */
#ifdef CEU_STACK_CLEAR
    tceu_stk stk_ = *_ceu_stk;
             stk_.is_alive = 1;
             stk_.down = _ceu_stk;
#endif
    tceu_kill ps = { _ceu_org, _ceu_org->ret, 0, (tceu_ntrl)(_ceu_org->n-1) };
    tceu_evt evt_;
             evt_.id = CEU_IN__ok_killed;
             evt_.param = &ps;
    ceu_sys_go_ex(_ceu_app, &evt_,
#ifdef CEU_STACK_CLEAR
                  &stk_,
#else
                  NULL,
#endif
                  _ceu_app->data, 0, _ceu_app->data->n);
}
#endif

#line 602 "garden.ceu"
    return;/* NODE: Dcl_cls 13 */

#line 640 "garden.ceu"
case Class_ShovelActive:;/* NODE: Block 6592 */

#line 640 "garden.ceu"
    {/* NODE: Stmts 6591 */

#line 640 "garden.ceu"
    {/* NODE: Block 6437 */

#line 640 "garden.ceu"
    {/* NODE: Stmts 6593 */

#line 640 "garden.ceu"
    {/* NODE: Block 2202 */

#line 647 "garden.ceu"
    /*  FINALIZE */
_ceu_org->trls[ 2 ].evt = CEU_IN__CLEAR;
_ceu_org->trls[ 2 ].lbl = ShovelActive_Block__fin_100;

#line 647 "garden.ceu"
    ((CEU_ShovelActive*)_ceu_org)->__fin_2202_1 = 0;
#line 647 "garden.ceu"
    {/* NODE: Stmts 2201 */

#line 647 "garden.ceu"
    {/* NODE: EmitExt 1982 */

#line 647 "garden.ceu"
        {

#line 647 "garden.ceu"
    tceu__int__float __ceu_ps_1982;
{
    tceu__int__float __ceu_ps_1982_ =
        { (((CEU_ShovelActive*)_ceu_org)->id),(-1.0) };
    __ceu_ps_1982 = __ceu_ps_1982_;
}

#line 647 "garden.ceu"
    
#if defined(ceu_out_emit_SET_SPRITE_ROTATION)
    ceu_out_emit_SET_SPRITE_ROTATION((&__ceu_ps_1982))

#elif defined(ceu_out_emit)
    (ceu_out_emit(_ceu_app, CEU_OUT_SET_SPRITE_ROTATION, sizeof(tceu__int__float), (void*)(&__ceu_ps_1982)))

#else
    #error ceu_out_emit_* is not defined
#endif
;
#line 647 "garden.ceu"
        }
/* NODE: Finalize 1991 */

#line 648 "garden.ceu"
    ((CEU_ShovelActive*)_ceu_org)->__fin_2202_1 = 1;/* NODE: ParOr 2198 */

#line 651 "garden.ceu"
/* ParOr: spawn subs */
#line 651 "garden.ceu"
    {
#ifdef CEU_STACK_CLEAR
    tceu_stk stk_ = { _ceu_stk, _ceu_org, 0, 1, 1 };
#endif

#line 651 "garden.ceu"
        _ceu_org->trls[ 0 ].lbl = ShovelActive_ParOr_sub_1_96;
    ceu_app_go(_ceu_app,NULL,_ceu_org,
               &_ceu_org->trls[ 0 ],
#ifdef CEU_STACK_CLEAR
               &stk_
#else
               NULL
#endif
              );

#ifdef CEU_STACK_CLEAR
    if (!stk_.is_alive) {
        return;
    }
#endif

#line 651 "garden.ceu"
        _ceu_trl = &_ceu_org->trls[ 1 ];

#line 651 "garden.ceu"
    }
/* NODE: Block 2197 */

#line 654 "garden.ceu"
    {/* NODE: Stmts 2196 */

#line 654 "garden.ceu"
    {/* NODE: Block 6504 */

#line 654 "garden.ceu"
    {/* NODE: Stmts 6503 */

#line 654 "garden.ceu"
    {/* NODE: Stmts 6502 */

#line 654 "garden.ceu"
    {
#line 654 "garden.ceu"
    }/* NODE: Loop 6501 */

#line 654 "garden.ceu"
    for (;;) {
/* NODE: Block 2194 */

#line 655 "garden.ceu"
    {/* NODE: Stmts 2193 */

#line 655 "garden.ceu"
    {/* NODE: Stmts 6509 */

#line 655 "garden.ceu"
    {/* NODE: Dcl_var 6506 */
/* NODE: Set 6510 */

#line 655 "garden.ceu"
/* SET: rightborder *//* NODE: Op2_> 2017 */

#line 655 "garden.ceu"
    (((CEU_ShovelActive*)_ceu_org)->rightborder_8) = ((((1175-1030)*((*((CEU_ShovelActive*)_ceu_org)->y)-485))-((800-485)*((*((CEU_ShovelActive*)_ceu_org)->x)-1030)))>0);
#line 655 "garden.ceu"
    }/* NODE: Stmts 6515 */

#line 656 "garden.ceu"
    {/* NODE: Dcl_var 6512 */
/* NODE: Set 6516 */

#line 656 "garden.ceu"
/* SET: rightmidborder *//* NODE: Op2_> 2036 */

#line 656 "garden.ceu"
    (((CEU_ShovelActive*)_ceu_org)->rightmidborder_9) = ((((828-778)*((*((CEU_ShovelActive*)_ceu_org)->y)-485))-((800-485)*((*((CEU_ShovelActive*)_ceu_org)->x)-778)))>0);
#line 656 "garden.ceu"
    }/* NODE: Stmts 6521 */

#line 657 "garden.ceu"
    {/* NODE: Dcl_var 6518 */
/* NODE: Set 6522 */

#line 657 "garden.ceu"
/* SET: leftmidborder *//* NODE: Op2_> 2055 */

#line 657 "garden.ceu"
    (((CEU_ShovelActive*)_ceu_org)->leftmidborder_10) = ((((461-512)*((*((CEU_ShovelActive*)_ceu_org)->y)-485))-((800-485)*((*((CEU_ShovelActive*)_ceu_org)->x)-512)))>0);
#line 657 "garden.ceu"
    }/* NODE: Stmts 6527 */

#line 658 "garden.ceu"
    {/* NODE: Dcl_var 6524 */
/* NODE: Set 6528 */

#line 658 "garden.ceu"
/* SET: leftborder *//* NODE: Op2_> 2074 */

#line 658 "garden.ceu"
    (((CEU_ShovelActive*)_ceu_org)->leftborder_11) = ((((111-258)*((*((CEU_ShovelActive*)_ceu_org)->y)-485))-((800-485)*((*((CEU_ShovelActive*)_ceu_org)->x)-258)))>0);
#line 658 "garden.ceu"
    }/* NODE: If 6531 */

#line 660 "garden.ceu"
    if ((((*((CEU_ShovelActive*)_ceu_org)->y)>485)&&((*((CEU_ShovelActive*)_ceu_org)->y)<=614))) {
/* NODE: Block 2130 */

#line 661 "garden.ceu"
    {/* NODE: Stmts 2129 */

#line 661 "garden.ceu"
    {/* NODE: If 6535 */

#line 661 "garden.ceu"
    if (((((CEU_ShovelActive*)_ceu_org)->rightborder_8)&&(!(((CEU_ShovelActive*)_ceu_org)->rightmidborder_9)))) {
/* NODE: Block 2097 */

#line 662 "garden.ceu"
    {/* NODE: Stmts 2096 */

#line 662 "garden.ceu"
    {/* NODE: CallStmt 2091 */

#line 662 "garden.ceu"
    printf("dig plot 2\n");/* NODE: EmitInt 2095 */

#line 663 "garden.ceu"
    {
#ifdef CEU_STACK_CLEAR
    tceu_stk stk_ = { _ceu_stk, _ceu_org, 1, 1, 1 };
#endif

#line 663 "garden.ceu"
    tceu__int __ceu_ps_2095;
{
    tceu__int __ceu_ps_2095_ =
        { 2 };
    __ceu_ps_2095 = __ceu_ps_2095_;
}

#line 663 "garden.ceu"
        /* trigger the event */
    tceu_evt evt;
    evt.id = 1;
#ifdef CEU_ORGS
#line 663 "garden.ceu"
    evt.org = (tceu_org*) (((CEU_ShovelActive*)_ceu_org)->garden);
#endif

#line 663 "garden.ceu"
        evt.param = (&__ceu_ps_2095);

#line 663 "garden.ceu"
        ceu_sys_go_ex(_ceu_app, &evt,
#ifdef CEU_STACK_CLEAR
                  &stk_,
#else
                  NULL,
#endif
                  _ceu_app->data, 0,
#ifdef CEU_ORGS
                  _ceu_app->data->n
#else
                  CEU_NTRAILS
#endif
    );

#ifdef CEU_STACK_CLEAR
    if (!stk_.is_alive) {
        return;
    }
#endif
}

#line 662 "garden.ceu"
    }
#line 662 "garden.ceu"
/* CLEAR: Block (662) */
#line 662 "garden.ceu"
    if (0) {

#line 662 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
} else {
/* NODE: If 6534 */

#line 664 "garden.ceu"
    if (((((CEU_ShovelActive*)_ceu_org)->rightmidborder_9)&&(!(((CEU_ShovelActive*)_ceu_org)->leftmidborder_10)))) {
/* NODE: Block 2112 */

#line 665 "garden.ceu"
    {/* NODE: Stmts 2111 */

#line 665 "garden.ceu"
    {/* NODE: CallStmt 2106 */

#line 665 "garden.ceu"
    printf("dig plot 1\n");/* NODE: EmitInt 2110 */

#line 666 "garden.ceu"
    {
#ifdef CEU_STACK_CLEAR
    tceu_stk stk_ = { _ceu_stk, _ceu_org, 1, 1, 1 };
#endif

#line 666 "garden.ceu"
    tceu__int __ceu_ps_2110;
{
    tceu__int __ceu_ps_2110_ =
        { 1 };
    __ceu_ps_2110 = __ceu_ps_2110_;
}

#line 666 "garden.ceu"
        /* trigger the event */
    tceu_evt evt;
    evt.id = 1;
#ifdef CEU_ORGS
#line 666 "garden.ceu"
    evt.org = (tceu_org*) (((CEU_ShovelActive*)_ceu_org)->garden);
#endif

#line 666 "garden.ceu"
        evt.param = (&__ceu_ps_2110);

#line 666 "garden.ceu"
        ceu_sys_go_ex(_ceu_app, &evt,
#ifdef CEU_STACK_CLEAR
                  &stk_,
#else
                  NULL,
#endif
                  _ceu_app->data, 0,
#ifdef CEU_ORGS
                  _ceu_app->data->n
#else
                  CEU_NTRAILS
#endif
    );

#ifdef CEU_STACK_CLEAR
    if (!stk_.is_alive) {
        return;
    }
#endif
}

#line 665 "garden.ceu"
    }
#line 665 "garden.ceu"
/* CLEAR: Block (665) */
#line 665 "garden.ceu"
    if (0) {

#line 665 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
} else {
/* NODE: If 6533 */

#line 667 "garden.ceu"
    if (((((CEU_ShovelActive*)_ceu_org)->leftmidborder_10)&&(!(((CEU_ShovelActive*)_ceu_org)->leftborder_11)))) {
/* NODE: Block 2127 */

#line 668 "garden.ceu"
    {/* NODE: Stmts 2126 */

#line 668 "garden.ceu"
    {/* NODE: CallStmt 2121 */

#line 668 "garden.ceu"
    printf("dig plot 0\n");/* NODE: EmitInt 2125 */

#line 669 "garden.ceu"
    {
#ifdef CEU_STACK_CLEAR
    tceu_stk stk_ = { _ceu_stk, _ceu_org, 1, 1, 1 };
#endif

#line 669 "garden.ceu"
    tceu__int __ceu_ps_2125;
{
    tceu__int __ceu_ps_2125_ =
        { 0 };
    __ceu_ps_2125 = __ceu_ps_2125_;
}

#line 669 "garden.ceu"
        /* trigger the event */
    tceu_evt evt;
    evt.id = 1;
#ifdef CEU_ORGS
#line 669 "garden.ceu"
    evt.org = (tceu_org*) (((CEU_ShovelActive*)_ceu_org)->garden);
#endif

#line 669 "garden.ceu"
        evt.param = (&__ceu_ps_2125);

#line 669 "garden.ceu"
        ceu_sys_go_ex(_ceu_app, &evt,
#ifdef CEU_STACK_CLEAR
                  &stk_,
#else
                  NULL,
#endif
                  _ceu_app->data, 0,
#ifdef CEU_ORGS
                  _ceu_app->data->n
#else
                  CEU_NTRAILS
#endif
    );

#ifdef CEU_STACK_CLEAR
    if (!stk_.is_alive) {
        return;
    }
#endif
}

#line 668 "garden.ceu"
    }
#line 668 "garden.ceu"
/* CLEAR: Block (668) */
#line 668 "garden.ceu"
    if (0) {

#line 668 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
} else {
/* NODE: Nothing 6532 */
}
}
}

#line 661 "garden.ceu"
    }
#line 661 "garden.ceu"
/* CLEAR: Block (661) */
#line 661 "garden.ceu"
    if (0) {

#line 661 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
} else {
/* NODE: If 6530 */

#line 671 "garden.ceu"
    if ((((*((CEU_ShovelActive*)_ceu_org)->y)>614)&&((*((CEU_ShovelActive*)_ceu_org)->y)<=800))) {
/* NODE: Block 2185 */

#line 672 "garden.ceu"
    {/* NODE: Stmts 2184 */

#line 672 "garden.ceu"
    {/* NODE: If 6542 */

#line 672 "garden.ceu"
    if (((((CEU_ShovelActive*)_ceu_org)->rightborder_8)&&(!(((CEU_ShovelActive*)_ceu_org)->rightmidborder_9)))) {
/* NODE: Block 2152 */

#line 673 "garden.ceu"
    {/* NODE: Stmts 2151 */

#line 673 "garden.ceu"
    {/* NODE: CallStmt 2146 */

#line 673 "garden.ceu"
    printf("dig plot 5\n");/* NODE: EmitInt 2150 */

#line 674 "garden.ceu"
    {
#ifdef CEU_STACK_CLEAR
    tceu_stk stk_ = { _ceu_stk, _ceu_org, 1, 1, 1 };
#endif

#line 674 "garden.ceu"
    tceu__int __ceu_ps_2150;
{
    tceu__int __ceu_ps_2150_ =
        { 5 };
    __ceu_ps_2150 = __ceu_ps_2150_;
}

#line 674 "garden.ceu"
        /* trigger the event */
    tceu_evt evt;
    evt.id = 1;
#ifdef CEU_ORGS
#line 674 "garden.ceu"
    evt.org = (tceu_org*) (((CEU_ShovelActive*)_ceu_org)->garden);
#endif

#line 674 "garden.ceu"
        evt.param = (&__ceu_ps_2150);

#line 674 "garden.ceu"
        ceu_sys_go_ex(_ceu_app, &evt,
#ifdef CEU_STACK_CLEAR
                  &stk_,
#else
                  NULL,
#endif
                  _ceu_app->data, 0,
#ifdef CEU_ORGS
                  _ceu_app->data->n
#else
                  CEU_NTRAILS
#endif
    );

#ifdef CEU_STACK_CLEAR
    if (!stk_.is_alive) {
        return;
    }
#endif
}

#line 673 "garden.ceu"
    }
#line 673 "garden.ceu"
/* CLEAR: Block (673) */
#line 673 "garden.ceu"
    if (0) {

#line 673 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
} else {
/* NODE: If 6541 */

#line 675 "garden.ceu"
    if (((((CEU_ShovelActive*)_ceu_org)->rightmidborder_9)&&(!(((CEU_ShovelActive*)_ceu_org)->leftmidborder_10)))) {
/* NODE: Block 2167 */

#line 676 "garden.ceu"
    {/* NODE: Stmts 2166 */

#line 676 "garden.ceu"
    {/* NODE: CallStmt 2161 */

#line 676 "garden.ceu"
    printf("dig plot 4\n");/* NODE: EmitInt 2165 */

#line 677 "garden.ceu"
    {
#ifdef CEU_STACK_CLEAR
    tceu_stk stk_ = { _ceu_stk, _ceu_org, 1, 1, 1 };
#endif

#line 677 "garden.ceu"
    tceu__int __ceu_ps_2165;
{
    tceu__int __ceu_ps_2165_ =
        { 4 };
    __ceu_ps_2165 = __ceu_ps_2165_;
}

#line 677 "garden.ceu"
        /* trigger the event */
    tceu_evt evt;
    evt.id = 1;
#ifdef CEU_ORGS
#line 677 "garden.ceu"
    evt.org = (tceu_org*) (((CEU_ShovelActive*)_ceu_org)->garden);
#endif

#line 677 "garden.ceu"
        evt.param = (&__ceu_ps_2165);

#line 677 "garden.ceu"
        ceu_sys_go_ex(_ceu_app, &evt,
#ifdef CEU_STACK_CLEAR
                  &stk_,
#else
                  NULL,
#endif
                  _ceu_app->data, 0,
#ifdef CEU_ORGS
                  _ceu_app->data->n
#else
                  CEU_NTRAILS
#endif
    );

#ifdef CEU_STACK_CLEAR
    if (!stk_.is_alive) {
        return;
    }
#endif
}

#line 676 "garden.ceu"
    }
#line 676 "garden.ceu"
/* CLEAR: Block (676) */
#line 676 "garden.ceu"
    if (0) {

#line 676 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
} else {
/* NODE: If 6540 */

#line 678 "garden.ceu"
    if (((((CEU_ShovelActive*)_ceu_org)->leftmidborder_10)&&(!(((CEU_ShovelActive*)_ceu_org)->leftborder_11)))) {
/* NODE: Block 2182 */

#line 679 "garden.ceu"
    {/* NODE: Stmts 2181 */

#line 679 "garden.ceu"
    {/* NODE: CallStmt 2176 */

#line 679 "garden.ceu"
    printf("dig plot 3\n");/* NODE: EmitInt 2180 */

#line 680 "garden.ceu"
    {
#ifdef CEU_STACK_CLEAR
    tceu_stk stk_ = { _ceu_stk, _ceu_org, 1, 1, 1 };
#endif

#line 680 "garden.ceu"
    tceu__int __ceu_ps_2180;
{
    tceu__int __ceu_ps_2180_ =
        { 3 };
    __ceu_ps_2180 = __ceu_ps_2180_;
}

#line 680 "garden.ceu"
        /* trigger the event */
    tceu_evt evt;
    evt.id = 1;
#ifdef CEU_ORGS
#line 680 "garden.ceu"
    evt.org = (tceu_org*) (((CEU_ShovelActive*)_ceu_org)->garden);
#endif

#line 680 "garden.ceu"
        evt.param = (&__ceu_ps_2180);

#line 680 "garden.ceu"
        ceu_sys_go_ex(_ceu_app, &evt,
#ifdef CEU_STACK_CLEAR
                  &stk_,
#else
                  NULL,
#endif
                  _ceu_app->data, 0,
#ifdef CEU_ORGS
                  _ceu_app->data->n
#else
                  CEU_NTRAILS
#endif
    );

#ifdef CEU_STACK_CLEAR
    if (!stk_.is_alive) {
        return;
    }
#endif
}

#line 679 "garden.ceu"
    }
#line 679 "garden.ceu"
/* CLEAR: Block (679) */
#line 679 "garden.ceu"
    if (0) {

#line 679 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
} else {
/* NODE: Nothing 6539 */
}
}
}

#line 672 "garden.ceu"
    }
#line 672 "garden.ceu"
/* CLEAR: Block (672) */
#line 672 "garden.ceu"
    if (0) {

#line 672 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
} else {
/* NODE: Nothing 6529 */
}
}
/* NODE: Stmts 6585 */

#line 684 "garden.ceu"
    {/* NODE: Nothing 6547 */
/* NODE: Set 6546 */

#line 684 "garden.ceu"
/* SET: table: 0xf26210 *//* NODE: Await 2191 */

#line 684 "garden.ceu"
    _CEU_NO_2191_:
if (0) { goto _CEU_NO_2191_; /* avoids "not used" warning */ }

#line 684 "garden.ceu"
    _ceu_trl->evt = CEU_IN_MOUSE_MOVE;
_ceu_trl->lbl = ShovelActive_Awake_MOUSE_MOVE_99;
_ceu_trl->seqno = _ceu_app->seqno;

#line 684 "garden.ceu"
    return;

case ShovelActive_Awake_MOUSE_MOVE_99:;

#line 684 "garden.ceu"
    #ifdef CEU_DEBUG_TRAILS
#ifndef CEU_OS
printf("\tOK!\n");
#endif
#endif

#line 684 "garden.ceu"
    {

#line 684 "garden.ceu"
        tceu__int__int** __ceu_casted = (tceu__int__int**) _ceu_evt->param;

#line 684 "garden.ceu"
        (*((CEU_ShovelActive*)_ceu_org)->x) = ((*(__ceu_casted))->_1);
}

#line 684 "garden.ceu"
    {

#line 684 "garden.ceu"
        tceu__int__int** __ceu_casted = (tceu__int__int**) _ceu_evt->param;

#line 684 "garden.ceu"
        (*((CEU_ShovelActive*)_ceu_org)->y) = ((*(__ceu_casted))->_2);
}
/* NODE: Nothing 8281 */
/* NODE: Nothing 8282 */

#line 684 "garden.ceu"
    }
#line 655 "garden.ceu"
    }
#line 655 "garden.ceu"
/* CLEAR: Block (655) */
#line 655 "garden.ceu"
    if (0) {

#line 655 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 654 "garden.ceu"
    }

#line 654 "garden.ceu"
    }
#line 654 "garden.ceu"
/* CLEAR: Block (654) */
#line 654 "garden.ceu"
    if (0) {

#line 654 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 654 "garden.ceu"
    }
#line 654 "garden.ceu"
/* CLEAR: Block (654) */
#line 654 "garden.ceu"
    if (0) {

#line 654 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 651 "garden.ceu"
case ShovelActive_ParOr_sub_1_96:;/* NODE: Block 1999 */

#line 652 "garden.ceu"
    {/* NODE: Stmts 1998 */

#line 652 "garden.ceu"
    {/* NODE: Stmts 6496 */

#line 652 "garden.ceu"
    {/* NODE: Nothing 6458 */
/* NODE: Set 6457 */

#line 652 "garden.ceu"
/* SET: table: 0xf216f0 *//* NODE: Await 1996 */

#line 652 "garden.ceu"
    _CEU_NO_1996_:
if (0) { goto _CEU_NO_1996_; /* avoids "not used" warning */ }

#line 652 "garden.ceu"
    _ceu_trl->evt = CEU_IN_MOUSE_UP;
_ceu_trl->lbl = ShovelActive_Awake_MOUSE_UP_98;
_ceu_trl->seqno = _ceu_app->seqno;

#line 652 "garden.ceu"
    return;

case ShovelActive_Awake_MOUSE_UP_98:;

#line 652 "garden.ceu"
    #ifdef CEU_DEBUG_TRAILS
#ifndef CEU_OS
printf("\tOK!\n");
#endif
#endif

#line 652 "garden.ceu"
    {

#line 652 "garden.ceu"
        tceu__int__int** __ceu_casted = (tceu__int__int**) _ceu_evt->param;

#line 652 "garden.ceu"
        (*((CEU_ShovelActive*)_ceu_org)->x) = ((*(__ceu_casted))->_1);
}

#line 652 "garden.ceu"
    {

#line 652 "garden.ceu"
        tceu__int__int** __ceu_casted = (tceu__int__int**) _ceu_evt->param;

#line 652 "garden.ceu"
        (*((CEU_ShovelActive*)_ceu_org)->y) = ((*(__ceu_casted))->_2);
}
/* NODE: Nothing 8273 */
/* NODE: Nothing 8274 */

#line 652 "garden.ceu"
    }
#line 652 "garden.ceu"
    }
#line 652 "garden.ceu"
/* CLEAR: Block (652) */
#line 652 "garden.ceu"
    if (0) {

#line 652 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 651 "garden.ceu"
/* PAROR JOIN */
#line 651 "garden.ceu"
    _ceu_lbl = ShovelActive_ParOr_out_97;
goto _CEU_GOTO_;

#line 651 "garden.ceu"
case ShovelActive_ParOr_out_97:;
#line 651 "garden.ceu"
/* CLEAR: ParOr (651) */
#line 651 "garden.ceu"
    {
    /* Reuse current stack frame.
     * We know that CLEAR will not abort anything and return normally.
     * Just save the previous "is_alive", call CLEAR, and restore it.
     */
#ifdef CEU_STACK_CLEAR
    int __ceu_old = _ceu_stk->is_alive;
    _ceu_stk->is_alive = 1;
#endif
    tceu_evt evt;
             evt.id = CEU_IN__CLEAR;
    ceu_sys_go_ex(_ceu_app, &evt,
                  _ceu_stk,
                  _ceu_org,
                  0,
                  2);
#ifdef CEU_STACK_CLEAR
    _ceu_stk->is_alive = __ceu_old;
    ceu_sys_stack_clear(_ceu_stk, _ceu_org,
                        0,1);
#endif
}
/* NODE: EmitInt 2200 */

#line 687 "garden.ceu"
    {
#ifdef CEU_STACK_CLEAR
    tceu_stk stk_ = { _ceu_stk, _ceu_org, 0, 1, 1 };
#endif

#line 687 "garden.ceu"
        /* trigger the event */
    tceu_evt evt;
    evt.id = 1;
#ifdef CEU_ORGS
#line 687 "garden.ceu"
    evt.org = (tceu_org*) _ceu_org;
#endif

#line 687 "garden.ceu"
        ceu_sys_go_ex(_ceu_app, &evt,
#ifdef CEU_STACK_CLEAR
                  &stk_,
#else
                  NULL,
#endif
                  _ceu_app->data, 0,
#ifdef CEU_ORGS
                  _ceu_app->data->n
#else
                  CEU_NTRAILS
#endif
    );

#ifdef CEU_STACK_CLEAR
    if (!stk_.is_alive) {
        return;
    }
#endif
}

#line 647 "garden.ceu"
    }
#line 647 "garden.ceu"
/* CLEAR: Block (647) */
#line 647 "garden.ceu"
    {
    /* Reuse current stack frame.
     * We know that CLEAR will not abort anything and return normally.
     * Just save the previous "is_alive", call CLEAR, and restore it.
     */
#ifdef CEU_STACK_CLEAR
    int __ceu_old = _ceu_stk->is_alive;
    _ceu_stk->is_alive = 1;
#endif
    tceu_evt evt;
             evt.id = CEU_IN__CLEAR;
    ceu_sys_go_ex(_ceu_app, &evt,
                  _ceu_stk,
                  _ceu_org,
                  0,
                  3);
#ifdef CEU_STACK_CLEAR
    _ceu_stk->is_alive = __ceu_old;
    ceu_sys_stack_clear(_ceu_stk, _ceu_org,
                        0,2);
#endif
}

#line 647 "garden.ceu"
    if (0) {

#line 647 "garden.ceu"
case ShovelActive_Block__fin_100:;
#line 647 "garden.ceu"
    if (((CEU_ShovelActive*)_ceu_org)->__fin_2202_1) {
    /* NODE: Finally 1990 */
/* NODE: Block 1989 */

#line 649 "garden.ceu"
    {/* NODE: Stmts 1988 */

#line 649 "garden.ceu"
    {/* NODE: EmitExt 1987 */

#line 649 "garden.ceu"
        {

#line 649 "garden.ceu"
    tceu__int__float __ceu_ps_1987;
{
    tceu__int__float __ceu_ps_1987_ =
        { (((CEU_ShovelActive*)_ceu_org)->id),0.0 };
    __ceu_ps_1987 = __ceu_ps_1987_;
}

#line 649 "garden.ceu"
    
#if defined(ceu_out_emit_SET_SPRITE_ROTATION)
    ceu_out_emit_SET_SPRITE_ROTATION((&__ceu_ps_1987))

#elif defined(ceu_out_emit)
    (ceu_out_emit(_ceu_app, CEU_OUT_SET_SPRITE_ROTATION, sizeof(tceu__int__float), (void*)(&__ceu_ps_1987)))

#else
    #error ceu_out_emit_* is not defined
#endif
;
#line 649 "garden.ceu"
        }

#line 649 "garden.ceu"
    }
#line 649 "garden.ceu"
/* CLEAR: Block (649) */
#line 649 "garden.ceu"
    if (0) {

#line 649 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
}

#line 647 "garden.ceu"
    return;
#line 647 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 640 "garden.ceu"
    }
#line 640 "garden.ceu"
/* CLEAR: Block (640) */
#line 640 "garden.ceu"
    if (0) {

#line 640 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 640 "garden.ceu"
    }
#line 640 "garden.ceu"
/* CLEAR: Block (640) */
#line 640 "garden.ceu"
    if (0) {

#line 640 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 640 "garden.ceu"
    ceu_sys_org_free(_ceu_app, _ceu_org);
#ifdef CEU_ORGS_AWAIT
{
    /* signal ok_killed */
#ifdef CEU_STACK_CLEAR
    tceu_stk stk_ = *_ceu_stk;
             stk_.is_alive = 1;
             stk_.down = _ceu_stk;
#endif
    tceu_kill ps = { _ceu_org, _ceu_org->ret, 0, (tceu_ntrl)(_ceu_org->n-1) };
    tceu_evt evt_;
             evt_.id = CEU_IN__ok_killed;
             evt_.param = &ps;
    ceu_sys_go_ex(_ceu_app, &evt_,
#ifdef CEU_STACK_CLEAR
                  &stk_,
#else
                  NULL,
#endif
                  _ceu_app->data, 0, _ceu_app->data->n);
}
#endif

#line 640 "garden.ceu"
    return;/* NODE: Dcl_cls 14 */

#line 690 "garden.ceu"
case Class_Shovel:;/* NODE: Block 6808 */

#line 690 "garden.ceu"
    {/* NODE: Stmts 6807 */

#line 690 "garden.ceu"
    {/* NODE: Block 6600 */

#line 690 "garden.ceu"
    {/* NODE: Stmts 6809 */

#line 690 "garden.ceu"
    {/* NODE: Block 2306 */

#line 697 "garden.ceu"
    /*  FINALIZE */
_ceu_org->trls[ 3 ].evt = CEU_IN__CLEAR;
_ceu_org->trls[ 3 ].lbl = Shovel_Block__fin_110;

#line 697 "garden.ceu"
    ((CEU_Shovel*)_ceu_org)->__fin_2306_1 = 0;
#line 697 "garden.ceu"
    {/* NODE: Stmts 2305 */

#line 697 "garden.ceu"
    {/* NODE: Stmts 6624 */

#line 697 "garden.ceu"
    {/* NODE: Dcl_var 6621 */
/* NODE: Set 6625 */

#line 697 "garden.ceu"
/* SET: id *//* NODE: Var 2216 */

#line 697 "garden.ceu"
    (((CEU_Shovel*)_ceu_org)->id) = (*((CEU_Shovel*)_ceu_org)->gensym);
#line 697 "garden.ceu"
    }/* NODE: Set 6626 */

#line 698 "garden.ceu"
/* SET: gensym *//* NODE: Op2_+ 2221 */

#line 698 "garden.ceu"
    (*((CEU_Shovel*)_ceu_org)->gensym) = ((*((CEU_Shovel*)_ceu_org)->gensym)+1);/* NODE: EmitExt 2230 */

#line 699 "garden.ceu"
        {

#line 699 "garden.ceu"
    tceu__int__int__int__int__int __ceu_ps_2230;
{
    tceu__int__int__int__int__int __ceu_ps_2230_ =
        { (((CEU_Shovel*)_ceu_org)->id),(((CEU_Shovel*)_ceu_org)->x),(((CEU_Shovel*)_ceu_org)->y),13,3 };
    __ceu_ps_2230 = __ceu_ps_2230_;
}

#line 699 "garden.ceu"
    
#if defined(ceu_out_emit_NEW_SPRITE)
    ceu_out_emit_NEW_SPRITE((&__ceu_ps_2230))

#elif defined(ceu_out_emit)
    (ceu_out_emit(_ceu_app, CEU_OUT_NEW_SPRITE, sizeof(tceu__int__int__int__int__int), (void*)(&__ceu_ps_2230)))

#else
    #error ceu_out_emit_* is not defined
#endif
;
#line 699 "garden.ceu"
        }
/* NODE: Finalize 2237 */

#line 700 "garden.ceu"
    ((CEU_Shovel*)_ceu_org)->__fin_2306_1 = 1;/* NODE: ParOr 2302 */

#line 704 "garden.ceu"
/* ParOr: spawn subs */
#line 704 "garden.ceu"
    {
#ifdef CEU_STACK_CLEAR
    tceu_stk stk_ = { _ceu_stk, _ceu_org, 0, 2, 1 };
#endif

#line 704 "garden.ceu"
        _ceu_org->trls[ 0 ].lbl = Shovel_ParOr_sub_1_102;
    ceu_app_go(_ceu_app,NULL,_ceu_org,
               &_ceu_org->trls[ 0 ],
#ifdef CEU_STACK_CLEAR
               &stk_
#else
               NULL
#endif
              );

#ifdef CEU_STACK_CLEAR
    if (!stk_.is_alive) {
        return;
    }
#endif

#line 704 "garden.ceu"
        _ceu_trl = &_ceu_org->trls[ 1 ];

#line 704 "garden.ceu"
    }
/* NODE: Block 2301 */

#line 710 "garden.ceu"
    {/* NODE: Stmts 2300 */

#line 710 "garden.ceu"
    {/* NODE: Block 6679 */

#line 710 "garden.ceu"
    {/* NODE: Stmts 6678 */

#line 710 "garden.ceu"
    {/* NODE: Stmts 6677 */

#line 710 "garden.ceu"
    {
#line 710 "garden.ceu"
    }/* NODE: Loop 6676 */

#line 710 "garden.ceu"
    for (;;) {
/* NODE: Block 2298 */

#line 711 "garden.ceu"
    {/* NODE: Stmts 2297 */

#line 711 "garden.ceu"
    {/* NODE: ParOr 2273 */

#line 711 "garden.ceu"
/* ParOr: spawn subs */
#line 711 "garden.ceu"
    {
#ifdef CEU_STACK_CLEAR
    tceu_stk stk_ = { _ceu_stk, _ceu_org, 1, 2, 1 };
#endif

#line 711 "garden.ceu"
        _ceu_org->trls[ 1 ].lbl = Shovel_ParOr_sub_1_105;
    ceu_app_go(_ceu_app,NULL,_ceu_org,
               &_ceu_org->trls[ 1 ],
#ifdef CEU_STACK_CLEAR
               &stk_
#else
               NULL
#endif
              );

#ifdef CEU_STACK_CLEAR
    if (!stk_.is_alive) {
        return;
    }
#endif

#line 711 "garden.ceu"
        _ceu_trl = &_ceu_org->trls[ 2 ];

#line 711 "garden.ceu"
    }
/* NODE: Block 2272 */

#line 715 "garden.ceu"
    {/* NODE: Stmts 2271 */

#line 715 "garden.ceu"
    {/* NODE: Stmts 6763 */

#line 715 "garden.ceu"
    {/* NODE: Nothing 6725 */
/* NODE: Set 6724 */

#line 715 "garden.ceu"
/* SET: table: 0xf35590 *//* NODE: Await 2269 */

#line 715 "garden.ceu"
    _CEU_NO_2269_:
if (0) { goto _CEU_NO_2269_; /* avoids "not used" warning */ }

#line 715 "garden.ceu"
    _ceu_trl->evt = CEU_IN_MOUSE_DOWN;
_ceu_trl->lbl = Shovel_Awake_MOUSE_DOWN_108;
_ceu_trl->seqno = _ceu_app->seqno;

#line 715 "garden.ceu"
    return;

case Shovel_Awake_MOUSE_DOWN_108:;

#line 715 "garden.ceu"
    #ifdef CEU_DEBUG_TRAILS
#ifndef CEU_OS
printf("\tOK!\n");
#endif
#endif

#line 715 "garden.ceu"
    {

#line 715 "garden.ceu"
        tceu__int__int** __ceu_casted = (tceu__int__int**) _ceu_evt->param;

#line 715 "garden.ceu"
        (((CEU_Shovel*)_ceu_org)->x) = ((*(__ceu_casted))->_1);
}

#line 715 "garden.ceu"
    {

#line 715 "garden.ceu"
        tceu__int__int** __ceu_casted = (tceu__int__int**) _ceu_evt->param;

#line 715 "garden.ceu"
        (((CEU_Shovel*)_ceu_org)->y) = ((*(__ceu_casted))->_2);
}
/* NODE: Nothing 8287 */
/* NODE: Nothing 8288 */

#line 715 "garden.ceu"
    }
#line 715 "garden.ceu"
    }
#line 715 "garden.ceu"
/* CLEAR: Block (715) */
#line 715 "garden.ceu"
    if (0) {

#line 715 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 711 "garden.ceu"
/* PAROR JOIN */
#line 711 "garden.ceu"
    _ceu_lbl = Shovel_ParOr_out_106;
goto _CEU_GOTO_;

#line 711 "garden.ceu"
case Shovel_ParOr_sub_1_105:;/* NODE: Block 2264 */

#line 712 "garden.ceu"
    {/* NODE: Stmts 2263 */

#line 712 "garden.ceu"
    {/* NODE: Stmts 6719 */

#line 712 "garden.ceu"
    {/* NODE: Nothing 6681 */
/* NODE: Set 6680 */

#line 712 "garden.ceu"
/* SET: table: 0xf34b10 *//* NODE: Await 2260 */

#line 712 "garden.ceu"
    _CEU_NO_2260_:
if (0) { goto _CEU_NO_2260_; /* avoids "not used" warning */ }

#line 712 "garden.ceu"
    _ceu_trl->evt = CEU_IN_MOUSE_UP;
_ceu_trl->lbl = Shovel_Awake_MOUSE_UP_107;
_ceu_trl->seqno = _ceu_app->seqno;

#line 712 "garden.ceu"
    return;

case Shovel_Awake_MOUSE_UP_107:;

#line 712 "garden.ceu"
    #ifdef CEU_DEBUG_TRAILS
#ifndef CEU_OS
printf("\tOK!\n");
#endif
#endif

#line 712 "garden.ceu"
    {

#line 712 "garden.ceu"
        tceu__int__int** __ceu_casted = (tceu__int__int**) _ceu_evt->param;

#line 712 "garden.ceu"
        (((CEU_Shovel*)_ceu_org)->x) = ((*(__ceu_casted))->_1);
}

#line 712 "garden.ceu"
    {

#line 712 "garden.ceu"
        tceu__int__int** __ceu_casted = (tceu__int__int**) _ceu_evt->param;

#line 712 "garden.ceu"
        (((CEU_Shovel*)_ceu_org)->y) = ((*(__ceu_casted))->_2);
}
/* NODE: Nothing 8285 */
/* NODE: Nothing 8286 */

#line 712 "garden.ceu"
    }/* NODE: Break 2262 */

#line 713 "garden.ceu"
    break;
#line 712 "garden.ceu"
    }
#line 712 "garden.ceu"
/* CLEAR: Block (712) */
#line 712 "garden.ceu"
    if (0) {

#line 712 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 711 "garden.ceu"
case Shovel_ParOr_out_106:;
#line 711 "garden.ceu"
/* CLEAR: ParOr (711) */
#line 711 "garden.ceu"
    {
    /* Reuse current stack frame.
     * We know that CLEAR will not abort anything and return normally.
     * Just save the previous "is_alive", call CLEAR, and restore it.
     */
#ifdef CEU_STACK_CLEAR
    int __ceu_old = _ceu_stk->is_alive;
    _ceu_stk->is_alive = 1;
#endif
    tceu_evt evt;
             evt.id = CEU_IN__CLEAR;
    ceu_sys_go_ex(_ceu_app, &evt,
                  _ceu_stk,
                  _ceu_org,
                  1,
                  3);
#ifdef CEU_STACK_CLEAR
    _ceu_stk->is_alive = __ceu_old;
    ceu_sys_stack_clear(_ceu_stk, _ceu_org,
                        1,2);
#endif
}
/* NODE: Do 6774 */
/* NODE: Block 6773 */

#line 717 "garden.ceu"
    {
#line 717 "garden.ceu"
    #ifdef CEU_ORGS
_ceu_org->trls[ 1 ].evt = CEU_IN__ORG;
_ceu_org->trls[ 1 ].org = NULL;
#endif

#line 717 "garden.ceu"
    _ceu_trl = &_ceu_org->trls[ 2 ];
/* NODE: Stmts 6772 */

#line 717 "garden.ceu"
    {/* NODE: Dcl_var 6771 */

#line 717 "garden.ceu"
/* start org: _org_2296 */
#line 717 "garden.ceu"
        /* resets org memory and starts org.trail[0]=Class_XXX */
    /* TODO: BUG: _ceu_org is not necessarily the parent for pool allocations */
    ceu_out_org_init(_ceu_app, ((tceu_org*) &(((CEU_Shovel*)_ceu_org)->_org_2296_9)),4,Class_ShovelActive,
                     13,
                     0,
                     _ceu_org,1);
/* TODO: currently idx is always "1" for all interfaces access because pools 
 * are all together there. When we have separate trls for pools, we'll have to 
 * indirectly access the offset in the interface. */

#line 717 "garden.ceu"
        _ceu_constr_2295(_ceu_app, ((tceu_org*) &(((CEU_Shovel*)_ceu_org)->_org_2296_9)), _ceu_org);

#line 717 "garden.ceu"
    {
#ifdef CEU_STACK_CLEAR
    tceu_stk stk_ = { _ceu_stk, _ceu_org, 2, 2, 1 };
    ceu_app_go(_ceu_app,NULL,
               ((tceu_org*) &(((CEU_Shovel*)_ceu_org)->_org_2296_9)), &((tceu_org*) &(((CEU_Shovel*)_ceu_org)->_org_2296_9))->trls[0],
               &stk_);
    if (!stk_.is_alive) {
        return;
    }
#else
    ceu_app_go(_ceu_app,NULL,
               ((tceu_org*) &(((CEU_Shovel*)_ceu_org)->_org_2296_9)), &((tceu_org*) &(((CEU_Shovel*)_ceu_org)->_org_2296_9))->trls[0],
               NULL);
#endif

#line 717 "garden.ceu"
    }
/* NODE: Stmts 6805 */

#line 717 "garden.ceu"
    {/* NODE: Nothing 6779 */
/* NODE: Nothing 8293 */
/* NODE: Nothing 8294 */
/* NODE: Stmts 6804 */

#line 717 "garden.ceu"
    {/* NODE: If 6803 */

#line 717 "garden.ceu"
    if ((!(((*((tceu_org*)(&((CEU_Shovel*)_ceu_org)->_org_2296_9))).isAlive)))) {
/* NODE: Block 6800 */

#line 717 "garden.ceu"
    {/* NODE: Stmts 6799 */

#line 717 "garden.ceu"
    {/* NODE: Nothing 6783 */

#line 717 "garden.ceu"
    }
#line 717 "garden.ceu"
/* CLEAR: Block (717) */
#line 717 "garden.ceu"
    if (0) {

#line 717 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
} else {
/* NODE: Block 6802 */

#line 717 "garden.ceu"
    {/* NODE: Stmts 6801 */

#line 717 "garden.ceu"
    {/* NODE: Await 6782 */

#line 717 "garden.ceu"
    _CEU_NO_6782_:
if (0) { goto _CEU_NO_6782_; /* avoids "not used" warning */ }

#line 717 "garden.ceu"
    _ceu_trl->evt = CEU_IN__ok_killed;
_ceu_trl->lbl = Shovel_Awake__ok_killed_109;
_ceu_trl->seqno = _ceu_app->seqno;

#line 717 "garden.ceu"
    #ifdef CEU_ORGS_AWAIT
#ifdef CEU_ADTS_AWAIT
_ceu_trl->is_org = 1;
#endif
#endif
_ceu_trl->org_or_adt = (void*)(&((CEU_Shovel*)_ceu_org)->_org_2296_9);

#line 717 "garden.ceu"
    return;

case Shovel_Awake__ok_killed_109:;

#line 717 "garden.ceu"
    #ifdef CEU_DEBUG_TRAILS
#ifndef CEU_OS
printf("\tOK!\n");
#endif
#endif

#line 717 "garden.ceu"
    }
#line 717 "garden.ceu"
/* CLEAR: Block (717) */
#line 717 "garden.ceu"
    if (0) {

#line 717 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
}

#line 717 "garden.ceu"
    }
#line 717 "garden.ceu"
    }
#line 717 "garden.ceu"
    }
#line 717 "garden.ceu"
/* CLEAR: Block (717) */
#line 717 "garden.ceu"
    {
    /* Reuse current stack frame.
     * We know that CLEAR will not abort anything and return normally.
     * Just save the previous "is_alive", call CLEAR, and restore it.
     */
#ifdef CEU_STACK_CLEAR
    int __ceu_old = _ceu_stk->is_alive;
    _ceu_stk->is_alive = 1;
#endif
    tceu_evt evt;
             evt.id = CEU_IN__CLEAR;
    ceu_sys_go_ex(_ceu_app, &evt,
                  _ceu_stk,
                  _ceu_org,
                  1,
                  3);
#ifdef CEU_STACK_CLEAR
    _ceu_stk->is_alive = __ceu_old;
    ceu_sys_stack_clear(_ceu_stk, _ceu_org,
                        1,2);
#endif
}

#line 717 "garden.ceu"
    #ifdef CEU_ORGS_AWAIT
/* signal ok_killed */
{
    tceu_kill ps = { _ceu_org, _ceu_org->ret, 1,2 };
    tceu_evt evt_;
             evt_.id = CEU_IN__ok_killed;
             evt_.param = &ps;
    ceu_sys_go_ex(_ceu_app, &evt_, _ceu_stk,
                  _ceu_app->data, 0, _ceu_app->data->n);
}
#endif

#line 717 "garden.ceu"
    if (0) {

#line 717 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 711 "garden.ceu"
    }
#line 711 "garden.ceu"
/* CLEAR: Block (711) */
#line 711 "garden.ceu"
    if (0) {

#line 711 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 710 "garden.ceu"
    }

#line 710 "garden.ceu"
/* CLEAR: Loop (710) */
#line 710 "garden.ceu"
    {
    /* Reuse current stack frame.
     * We know that CLEAR will not abort anything and return normally.
     * Just save the previous "is_alive", call CLEAR, and restore it.
     */
#ifdef CEU_STACK_CLEAR
    int __ceu_old = _ceu_stk->is_alive;
    _ceu_stk->is_alive = 1;
#endif
    tceu_evt evt;
             evt.id = CEU_IN__CLEAR;
    ceu_sys_go_ex(_ceu_app, &evt,
                  _ceu_stk,
                  _ceu_org,
                  1,
                  3);
#ifdef CEU_STACK_CLEAR
    _ceu_stk->is_alive = __ceu_old;
    ceu_sys_stack_clear(_ceu_stk, _ceu_org,
                        1,2);
#endif
}

#line 710 "garden.ceu"
    #ifdef CEU_ORGS_AWAIT
/* signal ok_killed */
{
    tceu_kill ps = { _ceu_org, _ceu_org->ret, 1,2 };
    tceu_evt evt_;
             evt_.id = CEU_IN__ok_killed;
             evt_.param = &ps;
    ceu_sys_go_ex(_ceu_app, &evt_, _ceu_stk,
                  _ceu_app->data, 0, _ceu_app->data->n);
}
#endif

#line 710 "garden.ceu"
    }
#line 710 "garden.ceu"
/* CLEAR: Block (710) */
#line 710 "garden.ceu"
    if (0) {

#line 710 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 710 "garden.ceu"
    }
#line 710 "garden.ceu"
/* CLEAR: Block (710) */
#line 710 "garden.ceu"
    if (0) {

#line 710 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 704 "garden.ceu"
/* PAROR JOIN */
#line 704 "garden.ceu"
    _ceu_lbl = Shovel_ParOr_out_103;
goto _CEU_GOTO_;

#line 704 "garden.ceu"
case Shovel_ParOr_sub_1_102:;/* NODE: Block 2255 */

#line 705 "garden.ceu"
    {/* NODE: Stmts 2254 */

#line 705 "garden.ceu"
    {/* NODE: Block 6631 */

#line 705 "garden.ceu"
    {/* NODE: Stmts 6630 */

#line 705 "garden.ceu"
    {/* NODE: Stmts 6629 */

#line 705 "garden.ceu"
    {
#line 705 "garden.ceu"
    }/* NODE: Loop 6628 */

#line 705 "garden.ceu"
    for (;;) {
/* NODE: Block 2252 */

#line 706 "garden.ceu"
    {/* NODE: Stmts 2251 */

#line 706 "garden.ceu"
    {/* NODE: Stmts 6671 */

#line 706 "garden.ceu"
    {/* NODE: Nothing 6633 */
/* NODE: Set 6632 */

#line 706 "garden.ceu"
/* SET: table: 0xf33570 *//* NODE: Await 2242 */

#line 706 "garden.ceu"
    _CEU_NO_2242_:
if (0) { goto _CEU_NO_2242_; /* avoids "not used" warning */ }

#line 706 "garden.ceu"
    _ceu_trl->evt = CEU_IN_MOUSE_MOVE;
_ceu_trl->lbl = Shovel_Awake_MOUSE_MOVE_104;
_ceu_trl->seqno = _ceu_app->seqno;

#line 706 "garden.ceu"
    return;

case Shovel_Awake_MOUSE_MOVE_104:;

#line 706 "garden.ceu"
    #ifdef CEU_DEBUG_TRAILS
#ifndef CEU_OS
printf("\tOK!\n");
#endif
#endif

#line 706 "garden.ceu"
    {

#line 706 "garden.ceu"
        tceu__int__int** __ceu_casted = (tceu__int__int**) _ceu_evt->param;

#line 706 "garden.ceu"
        (((CEU_Shovel*)_ceu_org)->x) = ((*(__ceu_casted))->_1);
}

#line 706 "garden.ceu"
    {

#line 706 "garden.ceu"
        tceu__int__int** __ceu_casted = (tceu__int__int**) _ceu_evt->param;

#line 706 "garden.ceu"
        (((CEU_Shovel*)_ceu_org)->y) = ((*(__ceu_casted))->_2);
}
/* NODE: Nothing 8283 */
/* NODE: Nothing 8284 */

#line 706 "garden.ceu"
    }/* NODE: EmitExt 2250 */

#line 707 "garden.ceu"
        {

#line 707 "garden.ceu"
    tceu__int__int__int__int __ceu_ps_2250;
{
    tceu__int__int__int__int __ceu_ps_2250_ =
        { (((CEU_Shovel*)_ceu_org)->id),(((CEU_Shovel*)_ceu_org)->x),(((CEU_Shovel*)_ceu_org)->y),1 };
    __ceu_ps_2250 = __ceu_ps_2250_;
}

#line 707 "garden.ceu"
    
#if defined(ceu_out_emit_SET_SPRITE_POSITION)
    ceu_out_emit_SET_SPRITE_POSITION((&__ceu_ps_2250))

#elif defined(ceu_out_emit)
    (ceu_out_emit(_ceu_app, CEU_OUT_SET_SPRITE_POSITION, sizeof(tceu__int__int__int__int), (void*)(&__ceu_ps_2250)))

#else
    #error ceu_out_emit_* is not defined
#endif
;
#line 707 "garden.ceu"
        }

#line 706 "garden.ceu"
    }
#line 706 "garden.ceu"
/* CLEAR: Block (706) */
#line 706 "garden.ceu"
    if (0) {

#line 706 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 705 "garden.ceu"
    }

#line 705 "garden.ceu"
    }
#line 705 "garden.ceu"
/* CLEAR: Block (705) */
#line 705 "garden.ceu"
    if (0) {

#line 705 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 705 "garden.ceu"
    }
#line 705 "garden.ceu"
/* CLEAR: Block (705) */
#line 705 "garden.ceu"
    if (0) {

#line 705 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 704 "garden.ceu"
case Shovel_ParOr_out_103:;
#line 704 "garden.ceu"
/* CLEAR: ParOr (704) */
#line 704 "garden.ceu"
    {
    /* Reuse current stack frame.
     * We know that CLEAR will not abort anything and return normally.
     * Just save the previous "is_alive", call CLEAR, and restore it.
     */
#ifdef CEU_STACK_CLEAR
    int __ceu_old = _ceu_stk->is_alive;
    _ceu_stk->is_alive = 1;
#endif
    tceu_evt evt;
             evt.id = CEU_IN__CLEAR;
    ceu_sys_go_ex(_ceu_app, &evt,
                  _ceu_stk,
                  _ceu_org,
                  0,
                  3);
#ifdef CEU_STACK_CLEAR
    _ceu_stk->is_alive = __ceu_old;
    ceu_sys_stack_clear(_ceu_stk, _ceu_org,
                        0,2);
#endif
}

#line 704 "garden.ceu"
    #ifdef CEU_ORGS_AWAIT
/* signal ok_killed */
{
    tceu_kill ps = { _ceu_org, _ceu_org->ret, 0,2 };
    tceu_evt evt_;
             evt_.id = CEU_IN__ok_killed;
             evt_.param = &ps;
    ceu_sys_go_ex(_ceu_app, &evt_, _ceu_stk,
                  _ceu_app->data, 0, _ceu_app->data->n);
}
#endif
/* NODE: EmitInt 2304 */

#line 725 "garden.ceu"
    {
#ifdef CEU_STACK_CLEAR
    tceu_stk stk_ = { _ceu_stk, _ceu_org, 0, 2, 1 };
#endif

#line 725 "garden.ceu"
        /* trigger the event */
    tceu_evt evt;
    evt.id = 1;
#ifdef CEU_ORGS
#line 725 "garden.ceu"
    evt.org = (tceu_org*) _ceu_org;
#endif

#line 725 "garden.ceu"
        ceu_sys_go_ex(_ceu_app, &evt,
#ifdef CEU_STACK_CLEAR
                  &stk_,
#else
                  NULL,
#endif
                  _ceu_app->data, 0,
#ifdef CEU_ORGS
                  _ceu_app->data->n
#else
                  CEU_NTRAILS
#endif
    );

#ifdef CEU_STACK_CLEAR
    if (!stk_.is_alive) {
        return;
    }
#endif
}

#line 697 "garden.ceu"
    }
#line 697 "garden.ceu"
/* CLEAR: Block (697) */
#line 697 "garden.ceu"
    {
    /* Reuse current stack frame.
     * We know that CLEAR will not abort anything and return normally.
     * Just save the previous "is_alive", call CLEAR, and restore it.
     */
#ifdef CEU_STACK_CLEAR
    int __ceu_old = _ceu_stk->is_alive;
    _ceu_stk->is_alive = 1;
#endif
    tceu_evt evt;
             evt.id = CEU_IN__CLEAR;
    ceu_sys_go_ex(_ceu_app, &evt,
                  _ceu_stk,
                  _ceu_org,
                  0,
                  4);
#ifdef CEU_STACK_CLEAR
    _ceu_stk->is_alive = __ceu_old;
    ceu_sys_stack_clear(_ceu_stk, _ceu_org,
                        0,3);
#endif
}

#line 697 "garden.ceu"
    #ifdef CEU_ORGS_AWAIT
/* signal ok_killed */
{
    tceu_kill ps = { _ceu_org, _ceu_org->ret, 0,3 };
    tceu_evt evt_;
             evt_.id = CEU_IN__ok_killed;
             evt_.param = &ps;
    ceu_sys_go_ex(_ceu_app, &evt_, _ceu_stk,
                  _ceu_app->data, 0, _ceu_app->data->n);
}
#endif

#line 697 "garden.ceu"
    if (0) {

#line 697 "garden.ceu"
case Shovel_Block__fin_110:;
#line 697 "garden.ceu"
    if (((CEU_Shovel*)_ceu_org)->__fin_2306_1) {
    /* NODE: Finally 2236 */
/* NODE: Block 2235 */

#line 701 "garden.ceu"
    {/* NODE: Stmts 2234 */

#line 701 "garden.ceu"
    {/* NODE: EmitExt 2233 */

#line 701 "garden.ceu"
        {

#line 701 "garden.ceu"
    tceu__int __ceu_ps_2233;
{
    tceu__int __ceu_ps_2233_ =
        { (((CEU_Shovel*)_ceu_org)->id) };
    __ceu_ps_2233 = __ceu_ps_2233_;
}

#line 701 "garden.ceu"
    
#if defined(ceu_out_emit_FREE_SPRITE)
    ceu_out_emit_FREE_SPRITE((&__ceu_ps_2233))

#elif defined(ceu_out_emit)
    (ceu_out_emit(_ceu_app, CEU_OUT_FREE_SPRITE, sizeof(tceu__int), (void*)(&__ceu_ps_2233)))

#else
    #error ceu_out_emit_* is not defined
#endif
;
#line 701 "garden.ceu"
        }

#line 701 "garden.ceu"
    }
#line 701 "garden.ceu"
/* CLEAR: Block (701) */
#line 701 "garden.ceu"
    if (0) {

#line 701 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
}

#line 697 "garden.ceu"
    return;
#line 697 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 690 "garden.ceu"
    }
#line 690 "garden.ceu"
/* CLEAR: Block (690) */
#line 690 "garden.ceu"
    if (0) {

#line 690 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 690 "garden.ceu"
    }
#line 690 "garden.ceu"
/* CLEAR: Block (690) */
#line 690 "garden.ceu"
    if (0) {

#line 690 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 690 "garden.ceu"
    ceu_sys_org_free(_ceu_app, _ceu_org);
#ifdef CEU_ORGS_AWAIT
{
    /* signal ok_killed */
#ifdef CEU_STACK_CLEAR
    tceu_stk stk_ = *_ceu_stk;
             stk_.is_alive = 1;
             stk_.down = _ceu_stk;
#endif
    tceu_kill ps = { _ceu_org, _ceu_org->ret, 0, (tceu_ntrl)(_ceu_org->n-1) };
    tceu_evt evt_;
             evt_.id = CEU_IN__ok_killed;
             evt_.param = &ps;
    ceu_sys_go_ex(_ceu_app, &evt_,
#ifdef CEU_STACK_CLEAR
                  &stk_,
#else
                  NULL,
#endif
                  _ceu_app->data, 0, _ceu_app->data->n);
}
#endif

#line 690 "garden.ceu"
    return;/* NODE: Dcl_cls 15 */

#line 728 "garden.ceu"
case Class_Tween:;/* NODE: Block 6899 */

#line 728 "garden.ceu"
    {/* NODE: Stmts 6898 */

#line 728 "garden.ceu"
    {/* NODE: Block 6816 */

#line 728 "garden.ceu"
    {/* NODE: Stmts 6900 */

#line 728 "garden.ceu"
    {/* NODE: Block 2427 */

#line 737 "garden.ceu"
    {/* NODE: Stmts 2426 */

#line 737 "garden.ceu"
    {/* NODE: Block 6845 */

#line 737 "garden.ceu"
    {/* NODE: Stmts 6844 */

#line 737 "garden.ceu"
    {/* NODE: Stmts 6843 */

#line 737 "garden.ceu"
    {
#line 737 "garden.ceu"
    }/* NODE: Loop 6842 */

#line 737 "garden.ceu"
    for (;;) {
/* NODE: Block 2422 */

#line 738 "garden.ceu"
    {/* NODE: Stmts 2421 */

#line 738 "garden.ceu"
    {/* NODE: If 6847 */

#line 738 "garden.ceu"
    if ((((*((CEU_Tween*)_ceu_org)->x)==(((CEU_Tween*)_ceu_org)->target_x))&&((*((CEU_Tween*)_ceu_org)->y)==(((CEU_Tween*)_ceu_org)->target_y)))) {
/* NODE: Block 2332 */

#line 739 "garden.ceu"
    {/* NODE: Stmts 2331 */

#line 739 "garden.ceu"
    {/* NODE: Break 2330 */

#line 739 "garden.ceu"
    break;
#line 739 "garden.ceu"
    }
#line 739 "garden.ceu"
/* CLEAR: Block (739) */
#line 739 "garden.ceu"
    if (0) {

#line 739 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
} else {
/* NODE: Nothing 6846 */
}
/* NODE: Stmts 6874 */

#line 741 "garden.ceu"
    {/* NODE: Nothing 6848 */
/* NODE: Await 2335 */

#line 741 "garden.ceu"
    _CEU_NO_2335_:
if (0) { goto _CEU_NO_2335_; /* avoids "not used" warning */ }

#line 741 "garden.ceu"
    _ceu_trl->evt = CEU_IN_UPDATE;
_ceu_trl->lbl = Tween_Awake_UPDATE_112;
_ceu_trl->seqno = _ceu_app->seqno;

#line 741 "garden.ceu"
    return;

case Tween_Awake_UPDATE_112:;

#line 741 "garden.ceu"
    #ifdef CEU_DEBUG_TRAILS
#ifndef CEU_OS
printf("\tOK!\n");
#endif
#endif
/* NODE: Nothing 8295 */
/* NODE: Nothing 8296 */

#line 741 "garden.ceu"
    }/* NODE: Stmts 6879 */

#line 743 "garden.ceu"
    {/* NODE: Dcl_var 6876 */
/* NODE: Set 6880 */

#line 743 "garden.ceu"
/* SET: dx *//* NODE: Op2_- 2339 */

#line 743 "garden.ceu"
    (((CEU_Tween*)_ceu_org)->dx_10) = ((((CEU_Tween*)_ceu_org)->target_x)-(*((CEU_Tween*)_ceu_org)->x));
#line 743 "garden.ceu"
    }/* NODE: Stmts 6885 */

#line 744 "garden.ceu"
    {/* NODE: Dcl_var 6882 */
/* NODE: Set 6886 */

#line 744 "garden.ceu"
/* SET: dy *//* NODE: Op2_- 2344 */

#line 744 "garden.ceu"
    (((CEU_Tween*)_ceu_org)->dy_11) = ((((CEU_Tween*)_ceu_org)->target_y)-(*((CEU_Tween*)_ceu_org)->y));
#line 744 "garden.ceu"
    }/* NODE: Stmts 6891 */

#line 745 "garden.ceu"
    {/* NODE: Dcl_var 6888 */
/* NODE: Set 6892 */

#line 745 "garden.ceu"
/* SET: dist *//* NODE: Op2_call 2356 */

#line 745 "garden.ceu"
    (((CEU_Tween*)_ceu_org)->dist_12) = sqrt((((((CEU_Tween*)_ceu_org)->dx_10)*(((CEU_Tween*)_ceu_org)->dx_10))+((((CEU_Tween*)_ceu_org)->dy_11)*(((CEU_Tween*)_ceu_org)->dy_11))));
#line 745 "garden.ceu"
    }/* NODE: If 2389 */

#line 746 "garden.ceu"
    if (((((CEU_Tween*)_ceu_org)->dist_12)>(((CEU_Tween*)_ceu_org)->speed))) {
/* NODE: Block 2380 */

#line 747 "garden.ceu"
    {/* NODE: Stmts 2379 */

#line 747 "garden.ceu"
    {/* NODE: Set 6893 */

#line 747 "garden.ceu"
/* SET: x *//* NODE: Op2_+ 2368 */

#line 747 "garden.ceu"
    (*((CEU_Tween*)_ceu_org)->x) = ((*((CEU_Tween*)_ceu_org)->x)+(((((CEU_Tween*)_ceu_org)->speed)*(((CEU_Tween*)_ceu_org)->dx_10))/(((CEU_Tween*)_ceu_org)->dist_12)));/* NODE: Set 6894 */

#line 748 "garden.ceu"
/* SET: y *//* NODE: Op2_+ 2377 */

#line 748 "garden.ceu"
    (*((CEU_Tween*)_ceu_org)->y) = ((*((CEU_Tween*)_ceu_org)->y)+(((((CEU_Tween*)_ceu_org)->speed)*(((CEU_Tween*)_ceu_org)->dy_11))/(((CEU_Tween*)_ceu_org)->dist_12)));
#line 747 "garden.ceu"
    }
#line 747 "garden.ceu"
/* CLEAR: Block (747) */
#line 747 "garden.ceu"
    if (0) {

#line 747 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
} else {
/* NODE: Block 2388 */

#line 750 "garden.ceu"
    {/* NODE: Stmts 2387 */

#line 750 "garden.ceu"
    {/* NODE: Set 6895 */

#line 750 "garden.ceu"
/* SET: x *//* NODE: Var 2382 */

#line 750 "garden.ceu"
    (*((CEU_Tween*)_ceu_org)->x) = (((CEU_Tween*)_ceu_org)->target_x);/* NODE: Set 6896 */

#line 751 "garden.ceu"
/* SET: y *//* NODE: Var 2385 */

#line 751 "garden.ceu"
    (*((CEU_Tween*)_ceu_org)->y) = (((CEU_Tween*)_ceu_org)->target_y);
#line 750 "garden.ceu"
    }
#line 750 "garden.ceu"
/* CLEAR: Block (750) */
#line 750 "garden.ceu"
    if (0) {

#line 750 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
}
/* NODE: If 2420 */

#line 754 "garden.ceu"
    if (((((CEU_Tween*)_ceu_org)->dx_10)<0)) {
/* NODE: Block 2406 */

#line 755 "garden.ceu"
    {/* NODE: Stmts 2405 */

#line 755 "garden.ceu"
    {/* NODE: EmitExt 2404 */

#line 755 "garden.ceu"
        {

#line 755 "garden.ceu"
    tceu__int__int__int__int __ceu_ps_2404;
{
    tceu__int__int__int__int __ceu_ps_2404_ =
        { (((CEU_Tween*)_ceu_org)->id),((int)(*((CEU_Tween*)_ceu_org)->x)),((int)(*((CEU_Tween*)_ceu_org)->y)),(-1) };
    __ceu_ps_2404 = __ceu_ps_2404_;
}

#line 755 "garden.ceu"
    
#if defined(ceu_out_emit_SET_SPRITE_POSITION)
    ceu_out_emit_SET_SPRITE_POSITION((&__ceu_ps_2404))

#elif defined(ceu_out_emit)
    (ceu_out_emit(_ceu_app, CEU_OUT_SET_SPRITE_POSITION, sizeof(tceu__int__int__int__int), (void*)(&__ceu_ps_2404)))

#else
    #error ceu_out_emit_* is not defined
#endif
;
#line 755 "garden.ceu"
        }

#line 755 "garden.ceu"
    }
#line 755 "garden.ceu"
/* CLEAR: Block (755) */
#line 755 "garden.ceu"
    if (0) {

#line 755 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
} else {
/* NODE: Block 2419 */

#line 757 "garden.ceu"
    {/* NODE: Stmts 2418 */

#line 757 "garden.ceu"
    {/* NODE: EmitExt 2417 */

#line 757 "garden.ceu"
        {

#line 757 "garden.ceu"
    tceu__int__int__int__int __ceu_ps_2417;
{
    tceu__int__int__int__int __ceu_ps_2417_ =
        { (((CEU_Tween*)_ceu_org)->id),((int)(*((CEU_Tween*)_ceu_org)->x)),((int)(*((CEU_Tween*)_ceu_org)->y)),1 };
    __ceu_ps_2417 = __ceu_ps_2417_;
}

#line 757 "garden.ceu"
    
#if defined(ceu_out_emit_SET_SPRITE_POSITION)
    ceu_out_emit_SET_SPRITE_POSITION((&__ceu_ps_2417))

#elif defined(ceu_out_emit)
    (ceu_out_emit(_ceu_app, CEU_OUT_SET_SPRITE_POSITION, sizeof(tceu__int__int__int__int), (void*)(&__ceu_ps_2417)))

#else
    #error ceu_out_emit_* is not defined
#endif
;
#line 757 "garden.ceu"
        }

#line 757 "garden.ceu"
    }
#line 757 "garden.ceu"
/* CLEAR: Block (757) */
#line 757 "garden.ceu"
    if (0) {

#line 757 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
}

#line 738 "garden.ceu"
    }
#line 738 "garden.ceu"
/* CLEAR: Block (738) */
#line 738 "garden.ceu"
    if (0) {

#line 738 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 737 "garden.ceu"
    }

#line 737 "garden.ceu"
/* CLEAR: Loop (737) */
#line 737 "garden.ceu"
    }
#line 737 "garden.ceu"
/* CLEAR: Block (737) */
#line 737 "garden.ceu"
    if (0) {

#line 737 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
/* NODE: EmitInt 2425 */

#line 760 "garden.ceu"
    {
#ifdef CEU_STACK_CLEAR
    tceu_stk stk_ = { _ceu_stk, _ceu_org, 0, 0, 1 };
#endif

#line 760 "garden.ceu"
        /* trigger the event */
    tceu_evt evt;
    evt.id = 1;
#ifdef CEU_ORGS
#line 760 "garden.ceu"
    evt.org = (tceu_org*) _ceu_org;
#endif

#line 760 "garden.ceu"
        ceu_sys_go_ex(_ceu_app, &evt,
#ifdef CEU_STACK_CLEAR
                  &stk_,
#else
                  NULL,
#endif
                  _ceu_app->data, 0,
#ifdef CEU_ORGS
                  _ceu_app->data->n
#else
                  CEU_NTRAILS
#endif
    );

#ifdef CEU_STACK_CLEAR
    if (!stk_.is_alive) {
        return;
    }
#endif
}

#line 737 "garden.ceu"
    }
#line 737 "garden.ceu"
/* CLEAR: Block (737) */
#line 737 "garden.ceu"
    if (0) {

#line 737 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 728 "garden.ceu"
    }
#line 728 "garden.ceu"
/* CLEAR: Block (728) */
#line 728 "garden.ceu"
    if (0) {

#line 728 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 728 "garden.ceu"
    }
#line 728 "garden.ceu"
/* CLEAR: Block (728) */
#line 728 "garden.ceu"
    if (0) {

#line 728 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 728 "garden.ceu"
    ceu_sys_org_free(_ceu_app, _ceu_org);
#ifdef CEU_ORGS_AWAIT
{
    /* signal ok_killed */
#ifdef CEU_STACK_CLEAR
    tceu_stk stk_ = *_ceu_stk;
             stk_.is_alive = 1;
             stk_.down = _ceu_stk;
#endif
    tceu_kill ps = { _ceu_org, _ceu_org->ret, 0, (tceu_ntrl)(_ceu_org->n-1) };
    tceu_evt evt_;
             evt_.id = CEU_IN__ok_killed;
             evt_.param = &ps;
    ceu_sys_go_ex(_ceu_app, &evt_,
#ifdef CEU_STACK_CLEAR
                  &stk_,
#else
                  NULL,
#endif
                  _ceu_app->data, 0, _ceu_app->data->n);
}
#endif

#line 728 "garden.ceu"
    return;/* NODE: Dcl_cls 16 */

#line 763 "garden.ceu"
case Class_Fly:;/* NODE: Block 7030 */

#line 763 "garden.ceu"
    {/* NODE: Stmts 7029 */

#line 763 "garden.ceu"
    {/* NODE: Block 6907 */

#line 763 "garden.ceu"
    {/* NODE: Stmts 7031 */

#line 763 "garden.ceu"
    {/* NODE: Block 2546 */

#line 771 "garden.ceu"
    {/* NODE: Stmts 2545 */

#line 771 "garden.ceu"
    {/* NODE: Stmts 6934 */

#line 771 "garden.ceu"
    {/* NODE: Dcl_var 6931 */
/* NODE: Set 6935 */

#line 771 "garden.ceu"
/* SET: speed *//* NODE: Op2_+ 2460 */

#line 771 "garden.ceu"
    (((CEU_Fly*)_ceu_org)->speed) = (4.0+(((d(6)+d(6))+d(6))*0.1));
#line 771 "garden.ceu"
    }/* NODE: Stmts 6940 */

#line 772 "garden.ceu"
    {/* NODE: Dcl_var 6937 */
/* NODE: Set 6941 */

#line 772 "garden.ceu"
/* SET: intermediate_y *//* NODE: Op2_- 2474 */

#line 772 "garden.ceu"
    (((CEU_Fly*)_ceu_org)->intermediate_y) = ((((*((CEU_Fly*)_ceu_org)->y)+(((CEU_Fly*)_ceu_org)->target_y))/2)-(d(50)+10));
#line 772 "garden.ceu"
    }/* NODE: Stmts 6946 */

#line 773 "garden.ceu"
    {/* NODE: Dcl_var 6943 */
/* NODE: Set 6947 */

#line 773 "garden.ceu"
/* SET: intermediate_x *//* NODE: Op2_/ 2481 */

#line 773 "garden.ceu"
    (((CEU_Fly*)_ceu_org)->intermediate_x) = (((*((CEU_Fly*)_ceu_org)->x)+(((CEU_Fly*)_ceu_org)->target_x))/2);
#line 773 "garden.ceu"
    }/* NODE: Do 6954 */
/* NODE: Block 6953 */

#line 774 "garden.ceu"
    {
#line 774 "garden.ceu"
    #ifdef CEU_ORGS
_ceu_org->trls[ 0 ].evt = CEU_IN__ORG;
_ceu_org->trls[ 0 ].org = NULL;
#endif

#line 774 "garden.ceu"
    _ceu_trl = &_ceu_org->trls[ 1 ];
/* NODE: Stmts 6952 */

#line 774 "garden.ceu"
    {/* NODE: Dcl_var 6951 */

#line 774 "garden.ceu"
/* start org: _org_2512 */
#line 774 "garden.ceu"
        /* resets org memory and starts org.trail[0]=Class_XXX */
    /* TODO: BUG: _ceu_org is not necessarily the parent for pool allocations */
    ceu_out_org_init(_ceu_app, ((tceu_org*) &(((CEU_Fly*)_ceu_org)->_org_2512_12)),2,Class_Tween,
                     15,
                     0,
                     _ceu_org,0);
/* TODO: currently idx is always "1" for all interfaces access because pools 
 * are all together there. When we have separate trls for pools, we'll have to 
 * indirectly access the offset in the interface. */

#line 774 "garden.ceu"
        _ceu_constr_2511(_ceu_app, ((tceu_org*) &(((CEU_Fly*)_ceu_org)->_org_2512_12)), _ceu_org);

#line 774 "garden.ceu"
    {
#ifdef CEU_STACK_CLEAR
    tceu_stk stk_ = { _ceu_stk, _ceu_org, 1, 1, 1 };
    ceu_app_go(_ceu_app,NULL,
               ((tceu_org*) &(((CEU_Fly*)_ceu_org)->_org_2512_12)), &((tceu_org*) &(((CEU_Fly*)_ceu_org)->_org_2512_12))->trls[0],
               &stk_);
    if (!stk_.is_alive) {
        return;
    }
#else
    ceu_app_go(_ceu_app,NULL,
               ((tceu_org*) &(((CEU_Fly*)_ceu_org)->_org_2512_12)), &((tceu_org*) &(((CEU_Fly*)_ceu_org)->_org_2512_12))->trls[0],
               NULL);
#endif

#line 774 "garden.ceu"
    }
/* NODE: Stmts 6987 */

#line 774 "garden.ceu"
    {/* NODE: Nothing 6961 */
/* NODE: Nothing 8303 */
/* NODE: Nothing 8304 */
/* NODE: Stmts 6986 */

#line 774 "garden.ceu"
    {/* NODE: If 6985 */

#line 774 "garden.ceu"
    if ((!(((*((tceu_org*)(&((CEU_Fly*)_ceu_org)->_org_2512_12))).isAlive)))) {
/* NODE: Block 6982 */

#line 774 "garden.ceu"
    {/* NODE: Stmts 6981 */

#line 774 "garden.ceu"
    {/* NODE: Nothing 6965 */

#line 774 "garden.ceu"
    }
#line 774 "garden.ceu"
/* CLEAR: Block (774) */
#line 774 "garden.ceu"
    if (0) {

#line 774 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
} else {
/* NODE: Block 6984 */

#line 774 "garden.ceu"
    {/* NODE: Stmts 6983 */

#line 774 "garden.ceu"
    {/* NODE: Await 6964 */

#line 774 "garden.ceu"
    _CEU_NO_6964_:
if (0) { goto _CEU_NO_6964_; /* avoids "not used" warning */ }

#line 774 "garden.ceu"
    _ceu_trl->evt = CEU_IN__ok_killed;
_ceu_trl->lbl = Fly_Awake__ok_killed_114;
_ceu_trl->seqno = _ceu_app->seqno;

#line 774 "garden.ceu"
    #ifdef CEU_ORGS_AWAIT
#ifdef CEU_ADTS_AWAIT
_ceu_trl->is_org = 1;
#endif
#endif
_ceu_trl->org_or_adt = (void*)(&((CEU_Fly*)_ceu_org)->_org_2512_12);

#line 774 "garden.ceu"
    return;

case Fly_Awake__ok_killed_114:;

#line 774 "garden.ceu"
    #ifdef CEU_DEBUG_TRAILS
#ifndef CEU_OS
printf("\tOK!\n");
#endif
#endif

#line 774 "garden.ceu"
    }
#line 774 "garden.ceu"
/* CLEAR: Block (774) */
#line 774 "garden.ceu"
    if (0) {

#line 774 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
}

#line 774 "garden.ceu"
    }
#line 774 "garden.ceu"
    }
#line 774 "garden.ceu"
    }
#line 774 "garden.ceu"
/* CLEAR: Block (774) */
#line 774 "garden.ceu"
    {
    /* Reuse current stack frame.
     * We know that CLEAR will not abort anything and return normally.
     * Just save the previous "is_alive", call CLEAR, and restore it.
     */
#ifdef CEU_STACK_CLEAR
    int __ceu_old = _ceu_stk->is_alive;
    _ceu_stk->is_alive = 1;
#endif
    tceu_evt evt;
             evt.id = CEU_IN__CLEAR;
    ceu_sys_go_ex(_ceu_app, &evt,
                  _ceu_stk,
                  _ceu_org,
                  0,
                  2);
#ifdef CEU_STACK_CLEAR
    _ceu_stk->is_alive = __ceu_old;
    ceu_sys_stack_clear(_ceu_stk, _ceu_org,
                        0,1);
#endif
}

#line 774 "garden.ceu"
    #ifdef CEU_ORGS_AWAIT
/* signal ok_killed */
{
    tceu_kill ps = { _ceu_org, _ceu_org->ret, 0,1 };
    tceu_evt evt_;
             evt_.id = CEU_IN__ok_killed;
             evt_.param = &ps;
    ceu_sys_go_ex(_ceu_app, &evt_, _ceu_stk,
                  _ceu_app->data, 0, _ceu_app->data->n);
}
#endif

#line 774 "garden.ceu"
    if (0) {

#line 774 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
/* NODE: Do 6994 */
/* NODE: Block 6993 */

#line 782 "garden.ceu"
    {
#line 782 "garden.ceu"
    #ifdef CEU_ORGS
_ceu_org->trls[ 0 ].evt = CEU_IN__ORG;
_ceu_org->trls[ 0 ].org = NULL;
#endif

#line 782 "garden.ceu"
    _ceu_trl = &_ceu_org->trls[ 1 ];
/* NODE: Stmts 6992 */

#line 782 "garden.ceu"
    {/* NODE: Dcl_var 6991 */

#line 782 "garden.ceu"
/* start org: _org_2542 */
#line 782 "garden.ceu"
        /* resets org memory and starts org.trail[0]=Class_XXX */
    /* TODO: BUG: _ceu_org is not necessarily the parent for pool allocations */
    ceu_out_org_init(_ceu_app, ((tceu_org*) &(((CEU_Fly*)_ceu_org)->_org_2542_13)),2,Class_Tween,
                     15,
                     0,
                     _ceu_org,0);
/* TODO: currently idx is always "1" for all interfaces access because pools 
 * are all together there. When we have separate trls for pools, we'll have to 
 * indirectly access the offset in the interface. */

#line 782 "garden.ceu"
        _ceu_constr_2541(_ceu_app, ((tceu_org*) &(((CEU_Fly*)_ceu_org)->_org_2542_13)), _ceu_org);

#line 782 "garden.ceu"
    {
#ifdef CEU_STACK_CLEAR
    tceu_stk stk_ = { _ceu_stk, _ceu_org, 1, 1, 1 };
    ceu_app_go(_ceu_app,NULL,
               ((tceu_org*) &(((CEU_Fly*)_ceu_org)->_org_2542_13)), &((tceu_org*) &(((CEU_Fly*)_ceu_org)->_org_2542_13))->trls[0],
               &stk_);
    if (!stk_.is_alive) {
        return;
    }
#else
    ceu_app_go(_ceu_app,NULL,
               ((tceu_org*) &(((CEU_Fly*)_ceu_org)->_org_2542_13)), &((tceu_org*) &(((CEU_Fly*)_ceu_org)->_org_2542_13))->trls[0],
               NULL);
#endif

#line 782 "garden.ceu"
    }
/* NODE: Stmts 7027 */

#line 782 "garden.ceu"
    {/* NODE: Nothing 7001 */
/* NODE: Nothing 8311 */
/* NODE: Nothing 8312 */
/* NODE: Stmts 7026 */

#line 782 "garden.ceu"
    {/* NODE: If 7025 */

#line 782 "garden.ceu"
    if ((!(((*((tceu_org*)(&((CEU_Fly*)_ceu_org)->_org_2542_13))).isAlive)))) {
/* NODE: Block 7022 */

#line 782 "garden.ceu"
    {/* NODE: Stmts 7021 */

#line 782 "garden.ceu"
    {/* NODE: Nothing 7005 */

#line 782 "garden.ceu"
    }
#line 782 "garden.ceu"
/* CLEAR: Block (782) */
#line 782 "garden.ceu"
    if (0) {

#line 782 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
} else {
/* NODE: Block 7024 */

#line 782 "garden.ceu"
    {/* NODE: Stmts 7023 */

#line 782 "garden.ceu"
    {/* NODE: Await 7004 */

#line 782 "garden.ceu"
    _CEU_NO_7004_:
if (0) { goto _CEU_NO_7004_; /* avoids "not used" warning */ }

#line 782 "garden.ceu"
    _ceu_trl->evt = CEU_IN__ok_killed;
_ceu_trl->lbl = Fly_Awake__ok_killed_115;
_ceu_trl->seqno = _ceu_app->seqno;

#line 782 "garden.ceu"
    #ifdef CEU_ORGS_AWAIT
#ifdef CEU_ADTS_AWAIT
_ceu_trl->is_org = 1;
#endif
#endif
_ceu_trl->org_or_adt = (void*)(&((CEU_Fly*)_ceu_org)->_org_2542_13);

#line 782 "garden.ceu"
    return;

case Fly_Awake__ok_killed_115:;

#line 782 "garden.ceu"
    #ifdef CEU_DEBUG_TRAILS
#ifndef CEU_OS
printf("\tOK!\n");
#endif
#endif

#line 782 "garden.ceu"
    }
#line 782 "garden.ceu"
/* CLEAR: Block (782) */
#line 782 "garden.ceu"
    if (0) {

#line 782 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
}

#line 782 "garden.ceu"
    }
#line 782 "garden.ceu"
    }
#line 782 "garden.ceu"
    }
#line 782 "garden.ceu"
/* CLEAR: Block (782) */
#line 782 "garden.ceu"
    {
    /* Reuse current stack frame.
     * We know that CLEAR will not abort anything and return normally.
     * Just save the previous "is_alive", call CLEAR, and restore it.
     */
#ifdef CEU_STACK_CLEAR
    int __ceu_old = _ceu_stk->is_alive;
    _ceu_stk->is_alive = 1;
#endif
    tceu_evt evt;
             evt.id = CEU_IN__CLEAR;
    ceu_sys_go_ex(_ceu_app, &evt,
                  _ceu_stk,
                  _ceu_org,
                  0,
                  2);
#ifdef CEU_STACK_CLEAR
    _ceu_stk->is_alive = __ceu_old;
    ceu_sys_stack_clear(_ceu_stk, _ceu_org,
                        0,1);
#endif
}

#line 782 "garden.ceu"
    #ifdef CEU_ORGS_AWAIT
/* signal ok_killed */
{
    tceu_kill ps = { _ceu_org, _ceu_org->ret, 0,1 };
    tceu_evt evt_;
             evt_.id = CEU_IN__ok_killed;
             evt_.param = &ps;
    ceu_sys_go_ex(_ceu_app, &evt_, _ceu_stk,
                  _ceu_app->data, 0, _ceu_app->data->n);
}
#endif

#line 782 "garden.ceu"
    if (0) {

#line 782 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
/* NODE: EmitInt 2544 */

#line 790 "garden.ceu"
    {
#ifdef CEU_STACK_CLEAR
    tceu_stk stk_ = { _ceu_stk, _ceu_org, 0, 1, 1 };
#endif

#line 790 "garden.ceu"
        /* trigger the event */
    tceu_evt evt;
    evt.id = 1;
#ifdef CEU_ORGS
#line 790 "garden.ceu"
    evt.org = (tceu_org*) _ceu_org;
#endif

#line 790 "garden.ceu"
        ceu_sys_go_ex(_ceu_app, &evt,
#ifdef CEU_STACK_CLEAR
                  &stk_,
#else
                  NULL,
#endif
                  _ceu_app->data, 0,
#ifdef CEU_ORGS
                  _ceu_app->data->n
#else
                  CEU_NTRAILS
#endif
    );

#ifdef CEU_STACK_CLEAR
    if (!stk_.is_alive) {
        return;
    }
#endif
}

#line 771 "garden.ceu"
    }
#line 771 "garden.ceu"
/* CLEAR: Block (771) */
#line 771 "garden.ceu"
    if (0) {

#line 771 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 763 "garden.ceu"
    }
#line 763 "garden.ceu"
/* CLEAR: Block (763) */
#line 763 "garden.ceu"
    if (0) {

#line 763 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 763 "garden.ceu"
    }
#line 763 "garden.ceu"
/* CLEAR: Block (763) */
#line 763 "garden.ceu"
    if (0) {

#line 763 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 763 "garden.ceu"
    ceu_sys_org_free(_ceu_app, _ceu_org);
#ifdef CEU_ORGS_AWAIT
{
    /* signal ok_killed */
#ifdef CEU_STACK_CLEAR
    tceu_stk stk_ = *_ceu_stk;
             stk_.is_alive = 1;
             stk_.down = _ceu_stk;
#endif
    tceu_kill ps = { _ceu_org, _ceu_org->ret, 0, (tceu_ntrl)(_ceu_org->n-1) };
    tceu_evt evt_;
             evt_.id = CEU_IN__ok_killed;
             evt_.param = &ps;
    ceu_sys_go_ex(_ceu_app, &evt_,
#ifdef CEU_STACK_CLEAR
                  &stk_,
#else
                  NULL,
#endif
                  _ceu_app->data, 0, _ceu_app->data->n);
}
#endif

#line 763 "garden.ceu"
    return;/* NODE: Dcl_cls 17 */

#line 793 "garden.ceu"
case Class_Seed:;/* NODE: Block 7212 */

#line 793 "garden.ceu"
    {/* NODE: Stmts 7211 */

#line 793 "garden.ceu"
    {/* NODE: Block 7038 */

#line 793 "garden.ceu"
    {/* NODE: Stmts 7213 */

#line 793 "garden.ceu"
    {/* NODE: Block 2741 */

#line 799 "garden.ceu"
    /*  FINALIZE */
_ceu_org->trls[ 3 ].evt = CEU_IN__CLEAR;
_ceu_org->trls[ 3 ].lbl = Seed_Block__fin_122;

#line 799 "garden.ceu"
    ((CEU_Seed*)_ceu_org)->__fin_2741_1 = 0;
#line 799 "garden.ceu"
    {/* NODE: Stmts 2740 */

#line 799 "garden.ceu"
    {/* NODE: Stmts 7058 */

#line 799 "garden.ceu"
    {/* NODE: Dcl_var 7055 */
/* NODE: Set 7059 */

#line 799 "garden.ceu"
/* SET: id *//* NODE: Var 2558 */

#line 799 "garden.ceu"
    (((CEU_Seed*)_ceu_org)->id) = (*((CEU_Seed*)_ceu_org)->gensym);
#line 799 "garden.ceu"
    }/* NODE: Set 7060 */

#line 800 "garden.ceu"
/* SET: gensym *//* NODE: Op2_+ 2563 */

#line 800 "garden.ceu"
    (*((CEU_Seed*)_ceu_org)->gensym) = ((*((CEU_Seed*)_ceu_org)->gensym)+1);/* NODE: EmitExt 2572 */

#line 802 "garden.ceu"
        {

#line 802 "garden.ceu"
    tceu__int__int__int__int__int __ceu_ps_2572;
{
    tceu__int__int__int__int__int __ceu_ps_2572_ =
        { (((CEU_Seed*)_ceu_org)->id),(((CEU_Seed*)_ceu_org)->x),(((CEU_Seed*)_ceu_org)->y),21,2 };
    __ceu_ps_2572 = __ceu_ps_2572_;
}

#line 802 "garden.ceu"
    
#if defined(ceu_out_emit_NEW_SPRITE)
    ceu_out_emit_NEW_SPRITE((&__ceu_ps_2572))

#elif defined(ceu_out_emit)
    (ceu_out_emit(_ceu_app, CEU_OUT_NEW_SPRITE, sizeof(tceu__int__int__int__int__int), (void*)(&__ceu_ps_2572)))

#else
    #error ceu_out_emit_* is not defined
#endif
;
#line 802 "garden.ceu"
        }
/* NODE: If 7064 */

#line 803 "garden.ceu"
    if (((((CEU_Seed*)_ceu_org)->tier)==1)) {
/* NODE: Block 2582 */

#line 804 "garden.ceu"
    {/* NODE: Stmts 2581 */

#line 804 "garden.ceu"
    {/* NODE: EmitExt 2580 */

#line 804 "garden.ceu"
        {

#line 804 "garden.ceu"
    tceu__int__int __ceu_ps_2580;
{
    tceu__int__int __ceu_ps_2580_ =
        { (((CEU_Seed*)_ceu_org)->id),0x1C451F };
    __ceu_ps_2580 = __ceu_ps_2580_;
}

#line 804 "garden.ceu"
    
#if defined(ceu_out_emit_SET_SPRITE_TINT)
    ceu_out_emit_SET_SPRITE_TINT((&__ceu_ps_2580))

#elif defined(ceu_out_emit)
    (ceu_out_emit(_ceu_app, CEU_OUT_SET_SPRITE_TINT, sizeof(tceu__int__int), (void*)(&__ceu_ps_2580)))

#else
    #error ceu_out_emit_* is not defined
#endif
;
#line 804 "garden.ceu"
        }

#line 804 "garden.ceu"
    }
#line 804 "garden.ceu"
/* CLEAR: Block (804) */
#line 804 "garden.ceu"
    if (0) {

#line 804 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
} else {
/* NODE: If 7063 */

#line 805 "garden.ceu"
    if (((((CEU_Seed*)_ceu_org)->tier)==2)) {
/* NODE: Block 2592 */

#line 806 "garden.ceu"
    {/* NODE: Stmts 2591 */

#line 806 "garden.ceu"
    {/* NODE: EmitExt 2590 */

#line 806 "garden.ceu"
        {

#line 806 "garden.ceu"
    tceu__int__int __ceu_ps_2590;
{
    tceu__int__int __ceu_ps_2590_ =
        { (((CEU_Seed*)_ceu_org)->id),0x34291C };
    __ceu_ps_2590 = __ceu_ps_2590_;
}

#line 806 "garden.ceu"
    
#if defined(ceu_out_emit_SET_SPRITE_TINT)
    ceu_out_emit_SET_SPRITE_TINT((&__ceu_ps_2590))

#elif defined(ceu_out_emit)
    (ceu_out_emit(_ceu_app, CEU_OUT_SET_SPRITE_TINT, sizeof(tceu__int__int), (void*)(&__ceu_ps_2590)))

#else
    #error ceu_out_emit_* is not defined
#endif
;
#line 806 "garden.ceu"
        }

#line 806 "garden.ceu"
    }
#line 806 "garden.ceu"
/* CLEAR: Block (806) */
#line 806 "garden.ceu"
    if (0) {

#line 806 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
} else {
/* NODE: If 7062 */

#line 807 "garden.ceu"
    if (((((CEU_Seed*)_ceu_org)->tier)==3)) {
/* NODE: Block 2602 */

#line 808 "garden.ceu"
    {/* NODE: Stmts 2601 */

#line 808 "garden.ceu"
    {/* NODE: EmitExt 2600 */

#line 808 "garden.ceu"
        {

#line 808 "garden.ceu"
    tceu__int__int __ceu_ps_2600;
{
    tceu__int__int __ceu_ps_2600_ =
        { (((CEU_Seed*)_ceu_org)->id),0x8E9769 };
    __ceu_ps_2600 = __ceu_ps_2600_;
}

#line 808 "garden.ceu"
    
#if defined(ceu_out_emit_SET_SPRITE_TINT)
    ceu_out_emit_SET_SPRITE_TINT((&__ceu_ps_2600))

#elif defined(ceu_out_emit)
    (ceu_out_emit(_ceu_app, CEU_OUT_SET_SPRITE_TINT, sizeof(tceu__int__int), (void*)(&__ceu_ps_2600)))

#else
    #error ceu_out_emit_* is not defined
#endif
;
#line 808 "garden.ceu"
        }

#line 808 "garden.ceu"
    }
#line 808 "garden.ceu"
/* CLEAR: Block (808) */
#line 808 "garden.ceu"
    if (0) {

#line 808 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
} else {
/* NODE: Nothing 7061 */
}
}
}
/* NODE: Finalize 2610 */

#line 811 "garden.ceu"
    ((CEU_Seed*)_ceu_org)->__fin_2741_1 = 1;/* NODE: Stmts 7070 */

#line 815 "garden.ceu"
    {/* NODE: Dcl_var 7067 */
/* NODE: Set 7071 */

#line 815 "garden.ceu"
/* SET: touched *//* NODE: NUMBER 2612 */

#line 815 "garden.ceu"
    (((CEU_Seed*)_ceu_org)->touched) = 0;
#line 815 "garden.ceu"
    }/* NODE: ParOr 2683 */

#line 816 "garden.ceu"
/* ParOr: spawn subs */
#line 816 "garden.ceu"
    {
#ifdef CEU_STACK_CLEAR
    tceu_stk stk_ = { _ceu_stk, _ceu_org, 0, 2, 1 };
#endif

#line 816 "garden.ceu"
        _ceu_org->trls[ 0 ].lbl = Seed_ParOr_sub_1_117;
    ceu_app_go(_ceu_app,NULL,_ceu_org,
               &_ceu_org->trls[ 0 ],
#ifdef CEU_STACK_CLEAR
               &stk_
#else
               NULL
#endif
              );

#ifdef CEU_STACK_CLEAR
    if (!stk_.is_alive) {
        return;
    }
#endif

#line 816 "garden.ceu"
        _ceu_trl = &_ceu_org->trls[ 2 ];

#line 816 "garden.ceu"
    }
/* NODE: Block 2682 */

#line 826 "garden.ceu"
    {/* NODE: Stmts 2681 */

#line 826 "garden.ceu"
    {/* NODE: Block 7115 */

#line 826 "garden.ceu"
    {/* NODE: Stmts 7114 */

#line 826 "garden.ceu"
    {/* NODE: Stmts 7113 */

#line 826 "garden.ceu"
    {
#line 826 "garden.ceu"
    }/* NODE: Loop 7112 */

#line 826 "garden.ceu"
    for (;;) {
/* NODE: Block 2679 */

#line 827 "garden.ceu"
    {
#line 827 "garden.ceu"
    int __ceu_mx_10;

#line 827 "garden.ceu"
    int __ceu_my_11;
/* NODE: Stmts 2678 */

#line 827 "garden.ceu"
    {/* NODE: Stmts 7120 */

#line 827 "garden.ceu"
    {/* NODE: Dcl_var 7117 */
/* NODE: Dcl_var 7119 */

#line 827 "garden.ceu"
    }/* NODE: Stmts 7160 */

#line 828 "garden.ceu"
    {/* NODE: Nothing 7122 */
/* NODE: Set 7121 */

#line 828 "garden.ceu"
/* SET: table: 0xf52d50 *//* NODE: Await 2652 */

#line 828 "garden.ceu"
    _CEU_NO_2652_:
if (0) { goto _CEU_NO_2652_; /* avoids "not used" warning */ }

#line 828 "garden.ceu"
    _ceu_trl->evt = CEU_IN_MOUSE_MOVE;
_ceu_trl->lbl = Seed_Awake_MOUSE_MOVE_120;
_ceu_trl->seqno = _ceu_app->seqno;

#line 828 "garden.ceu"
    return;

case Seed_Awake_MOUSE_MOVE_120:;

#line 828 "garden.ceu"
    #ifdef CEU_DEBUG_TRAILS
#ifndef CEU_OS
printf("\tOK!\n");
#endif
#endif

#line 828 "garden.ceu"
    {

#line 828 "garden.ceu"
        tceu__int__int** __ceu_casted = (tceu__int__int**) _ceu_evt->param;

#line 828 "garden.ceu"
        (__ceu_mx_10) = ((*(__ceu_casted))->_1);
}

#line 828 "garden.ceu"
    {

#line 828 "garden.ceu"
        tceu__int__int** __ceu_casted = (tceu__int__int**) _ceu_evt->param;

#line 828 "garden.ceu"
        (__ceu_my_11) = ((*(__ceu_casted))->_2);
}
/* NODE: Nothing 8321 */
/* NODE: Nothing 8322 */

#line 828 "garden.ceu"
    }/* NODE: If 7166 */

#line 829 "garden.ceu"
    if ((((((__ceu_mx_10)-(((CEU_Seed*)_ceu_org)->x))*((__ceu_mx_10)-(((CEU_Seed*)_ceu_org)->x)))+(((__ceu_my_11)-(((CEU_Seed*)_ceu_org)->y))*((__ceu_my_11)-(((CEU_Seed*)_ceu_org)->y))))<100)) {
/* NODE: Block 2676 */

#line 830 "garden.ceu"
    {/* NODE: Stmts 2675 */

#line 830 "garden.ceu"
    {/* NODE: Set 7167 */

#line 830 "garden.ceu"
/* SET: touched *//* NODE: NUMBER 2672 */

#line 830 "garden.ceu"
    (((CEU_Seed*)_ceu_org)->touched) = 1;/* NODE: Break 2674 */

#line 831 "garden.ceu"
    break;
#line 830 "garden.ceu"
    }
#line 830 "garden.ceu"
/* CLEAR: Block (830) */
#line 830 "garden.ceu"
    if (0) {

#line 830 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
} else {
/* NODE: Nothing 7165 */
}

#line 827 "garden.ceu"
    }
#line 827 "garden.ceu"
/* CLEAR: Block (827) */
#line 827 "garden.ceu"
    if (0) {

#line 827 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 826 "garden.ceu"
    }

#line 826 "garden.ceu"
/* CLEAR: Loop (826) */
#line 826 "garden.ceu"
    }
#line 826 "garden.ceu"
/* CLEAR: Block (826) */
#line 826 "garden.ceu"
    if (0) {

#line 826 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 826 "garden.ceu"
    }
#line 826 "garden.ceu"
/* CLEAR: Block (826) */
#line 826 "garden.ceu"
    if (0) {

#line 826 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 816 "garden.ceu"
/* PAROR JOIN */
#line 816 "garden.ceu"
    _ceu_lbl = Seed_ParOr_out_118;
goto _CEU_GOTO_;

#line 816 "garden.ceu"
case Seed_ParOr_sub_1_117:;/* NODE: Block 2645 */

#line 817 "garden.ceu"
    {/* NODE: Stmts 2644 */

#line 817 "garden.ceu"
    {/* NODE: Do 7078 */
/* NODE: Block 7077 */

#line 817 "garden.ceu"
    {
#line 817 "garden.ceu"
    #ifdef CEU_ORGS
_ceu_org->trls[ 0 ].evt = CEU_IN__ORG;
_ceu_org->trls[ 0 ].org = NULL;
#endif

#line 817 "garden.ceu"
    _ceu_trl = &_ceu_org->trls[ 1 ];
/* NODE: Stmts 7076 */

#line 817 "garden.ceu"
    {/* NODE: Dcl_var 7075 */

#line 817 "garden.ceu"
/* start org: _org_2643 */
#line 817 "garden.ceu"
        /* resets org memory and starts org.trail[0]=Class_XXX */
    /* TODO: BUG: _ceu_org is not necessarily the parent for pool allocations */
    ceu_out_org_init(_ceu_app, ((tceu_org*) &(((CEU_Seed*)_ceu_org)->_org_2643_9)),2,Class_Tween,
                     15,
                     0,
                     _ceu_org,0);
/* TODO: currently idx is always "1" for all interfaces access because pools 
 * are all together there. When we have separate trls for pools, we'll have to 
 * indirectly access the offset in the interface. */

#line 817 "garden.ceu"
        _ceu_constr_2642(_ceu_app, ((tceu_org*) &(((CEU_Seed*)_ceu_org)->_org_2643_9)), _ceu_org);

#line 817 "garden.ceu"
    {
#ifdef CEU_STACK_CLEAR
    tceu_stk stk_ = { _ceu_stk, _ceu_org, 1, 1, 1 };
    ceu_app_go(_ceu_app,NULL,
               ((tceu_org*) &(((CEU_Seed*)_ceu_org)->_org_2643_9)), &((tceu_org*) &(((CEU_Seed*)_ceu_org)->_org_2643_9))->trls[0],
               &stk_);
    if (!stk_.is_alive) {
        return;
    }
#else
    ceu_app_go(_ceu_app,NULL,
               ((tceu_org*) &(((CEU_Seed*)_ceu_org)->_org_2643_9)), &((tceu_org*) &(((CEU_Seed*)_ceu_org)->_org_2643_9))->trls[0],
               NULL);
#endif

#line 817 "garden.ceu"
    }
/* NODE: Stmts 7111 */

#line 817 "garden.ceu"
    {/* NODE: Nothing 7085 */
/* NODE: Nothing 8319 */
/* NODE: Nothing 8320 */
/* NODE: Stmts 7110 */

#line 817 "garden.ceu"
    {/* NODE: If 7109 */

#line 817 "garden.ceu"
    if ((!(((*((tceu_org*)(&((CEU_Seed*)_ceu_org)->_org_2643_9))).isAlive)))) {
/* NODE: Block 7106 */

#line 817 "garden.ceu"
    {/* NODE: Stmts 7105 */

#line 817 "garden.ceu"
    {/* NODE: Nothing 7089 */

#line 817 "garden.ceu"
    }
#line 817 "garden.ceu"
/* CLEAR: Block (817) */
#line 817 "garden.ceu"
    if (0) {

#line 817 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
} else {
/* NODE: Block 7108 */

#line 817 "garden.ceu"
    {/* NODE: Stmts 7107 */

#line 817 "garden.ceu"
    {/* NODE: Await 7088 */

#line 817 "garden.ceu"
    _CEU_NO_7088_:
if (0) { goto _CEU_NO_7088_; /* avoids "not used" warning */ }

#line 817 "garden.ceu"
    _ceu_trl->evt = CEU_IN__ok_killed;
_ceu_trl->lbl = Seed_Awake__ok_killed_119;
_ceu_trl->seqno = _ceu_app->seqno;

#line 817 "garden.ceu"
    #ifdef CEU_ORGS_AWAIT
#ifdef CEU_ADTS_AWAIT
_ceu_trl->is_org = 1;
#endif
#endif
_ceu_trl->org_or_adt = (void*)(&((CEU_Seed*)_ceu_org)->_org_2643_9);

#line 817 "garden.ceu"
    return;

case Seed_Awake__ok_killed_119:;

#line 817 "garden.ceu"
    #ifdef CEU_DEBUG_TRAILS
#ifndef CEU_OS
printf("\tOK!\n");
#endif
#endif

#line 817 "garden.ceu"
    }
#line 817 "garden.ceu"
/* CLEAR: Block (817) */
#line 817 "garden.ceu"
    if (0) {

#line 817 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
}

#line 817 "garden.ceu"
    }
#line 817 "garden.ceu"
    }
#line 817 "garden.ceu"
    }
#line 817 "garden.ceu"
/* CLEAR: Block (817) */
#line 817 "garden.ceu"
    {
    /* Reuse current stack frame.
     * We know that CLEAR will not abort anything and return normally.
     * Just save the previous "is_alive", call CLEAR, and restore it.
     */
#ifdef CEU_STACK_CLEAR
    int __ceu_old = _ceu_stk->is_alive;
    _ceu_stk->is_alive = 1;
#endif
    tceu_evt evt;
             evt.id = CEU_IN__CLEAR;
    ceu_sys_go_ex(_ceu_app, &evt,
                  _ceu_stk,
                  _ceu_org,
                  0,
                  2);
#ifdef CEU_STACK_CLEAR
    _ceu_stk->is_alive = __ceu_old;
    ceu_sys_stack_clear(_ceu_stk, _ceu_org,
                        0,1);
#endif
}

#line 817 "garden.ceu"
    #ifdef CEU_ORGS_AWAIT
/* signal ok_killed */
{
    tceu_kill ps = { _ceu_org, _ceu_org->ret, 0,1 };
    tceu_evt evt_;
             evt_.id = CEU_IN__ok_killed;
             evt_.param = &ps;
    ceu_sys_go_ex(_ceu_app, &evt_, _ceu_stk,
                  _ceu_app->data, 0, _ceu_app->data->n);
}
#endif

#line 817 "garden.ceu"
    if (0) {

#line 817 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 817 "garden.ceu"
    }
#line 817 "garden.ceu"
/* CLEAR: Block (817) */
#line 817 "garden.ceu"
    if (0) {

#line 817 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 816 "garden.ceu"
/* PAROR JOIN */
#line 816 "garden.ceu"
    _ceu_lbl = Seed_ParOr_out_118;
goto _CEU_GOTO_;

#line 816 "garden.ceu"
case Seed_ParOr_out_118:;
#line 816 "garden.ceu"
/* CLEAR: ParOr (816) */
#line 816 "garden.ceu"
    {
    /* Reuse current stack frame.
     * We know that CLEAR will not abort anything and return normally.
     * Just save the previous "is_alive", call CLEAR, and restore it.
     */
#ifdef CEU_STACK_CLEAR
    int __ceu_old = _ceu_stk->is_alive;
    _ceu_stk->is_alive = 1;
#endif
    tceu_evt evt;
             evt.id = CEU_IN__CLEAR;
    ceu_sys_go_ex(_ceu_app, &evt,
                  _ceu_stk,
                  _ceu_org,
                  0,
                  3);
#ifdef CEU_STACK_CLEAR
    _ceu_stk->is_alive = __ceu_old;
    ceu_sys_stack_clear(_ceu_stk, _ceu_org,
                        0,2);
#endif
}

#line 816 "garden.ceu"
    #ifdef CEU_ORGS_AWAIT
/* signal ok_killed */
{
    tceu_kill ps = { _ceu_org, _ceu_org->ret, 0,2 };
    tceu_evt evt_;
             evt_.id = CEU_IN__ok_killed;
             evt_.param = &ps;
    ceu_sys_go_ex(_ceu_app, &evt_, _ceu_stk,
                  _ceu_app->data, 0, _ceu_app->data->n);
}
#endif
/* NODE: If 7169 */

#line 836 "garden.ceu"
    if ((((CEU_Seed*)_ceu_org)->touched)) {
/* NODE: Block 2738 */

#line 837 "garden.ceu"
    {/* NODE: Stmts 2737 */

#line 837 "garden.ceu"
    {/* NODE: Do 7176 */
/* NODE: Block 7175 */

#line 837 "garden.ceu"
    {
#line 837 "garden.ceu"
    #ifdef CEU_ORGS
_ceu_org->trls[ 0 ].evt = CEU_IN__ORG;
_ceu_org->trls[ 0 ].org = NULL;
#endif

#line 837 "garden.ceu"
    _ceu_trl = &_ceu_org->trls[ 1 ];
/* NODE: Stmts 7174 */

#line 837 "garden.ceu"
    {/* NODE: Dcl_var 7173 */

#line 837 "garden.ceu"
/* start org: _org_2720 */
#line 837 "garden.ceu"
        /* resets org memory and starts org.trail[0]=Class_XXX */
    /* TODO: BUG: _ceu_org is not necessarily the parent for pool allocations */
    ceu_out_org_init(_ceu_app, ((tceu_org*) &(((CEU_Seed*)_ceu_org)->_org_2720_12)),2,Class_Tween,
                     15,
                     0,
                     _ceu_org,0);
/* TODO: currently idx is always "1" for all interfaces access because pools 
 * are all together there. When we have separate trls for pools, we'll have to 
 * indirectly access the offset in the interface. */

#line 837 "garden.ceu"
        _ceu_constr_2719(_ceu_app, ((tceu_org*) &(((CEU_Seed*)_ceu_org)->_org_2720_12)), _ceu_org);

#line 837 "garden.ceu"
    {
#ifdef CEU_STACK_CLEAR
    tceu_stk stk_ = { _ceu_stk, _ceu_org, 1, 1, 1 };
    ceu_app_go(_ceu_app,NULL,
               ((tceu_org*) &(((CEU_Seed*)_ceu_org)->_org_2720_12)), &((tceu_org*) &(((CEU_Seed*)_ceu_org)->_org_2720_12))->trls[0],
               &stk_);
    if (!stk_.is_alive) {
        return;
    }
#else
    ceu_app_go(_ceu_app,NULL,
               ((tceu_org*) &(((CEU_Seed*)_ceu_org)->_org_2720_12)), &((tceu_org*) &(((CEU_Seed*)_ceu_org)->_org_2720_12))->trls[0],
               NULL);
#endif

#line 837 "garden.ceu"
    }
/* NODE: Stmts 7209 */

#line 837 "garden.ceu"
    {/* NODE: Nothing 7183 */
/* NODE: Nothing 8329 */
/* NODE: Nothing 8330 */
/* NODE: Stmts 7208 */

#line 837 "garden.ceu"
    {/* NODE: If 7207 */

#line 837 "garden.ceu"
    if ((!(((*((tceu_org*)(&((CEU_Seed*)_ceu_org)->_org_2720_12))).isAlive)))) {
/* NODE: Block 7204 */

#line 837 "garden.ceu"
    {/* NODE: Stmts 7203 */

#line 837 "garden.ceu"
    {/* NODE: Nothing 7187 */

#line 837 "garden.ceu"
    }
#line 837 "garden.ceu"
/* CLEAR: Block (837) */
#line 837 "garden.ceu"
    if (0) {

#line 837 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
} else {
/* NODE: Block 7206 */

#line 837 "garden.ceu"
    {/* NODE: Stmts 7205 */

#line 837 "garden.ceu"
    {/* NODE: Await 7186 */

#line 837 "garden.ceu"
    _CEU_NO_7186_:
if (0) { goto _CEU_NO_7186_; /* avoids "not used" warning */ }

#line 837 "garden.ceu"
    _ceu_trl->evt = CEU_IN__ok_killed;
_ceu_trl->lbl = Seed_Awake__ok_killed_121;
_ceu_trl->seqno = _ceu_app->seqno;

#line 837 "garden.ceu"
    #ifdef CEU_ORGS_AWAIT
#ifdef CEU_ADTS_AWAIT
_ceu_trl->is_org = 1;
#endif
#endif
_ceu_trl->org_or_adt = (void*)(&((CEU_Seed*)_ceu_org)->_org_2720_12);

#line 837 "garden.ceu"
    return;

case Seed_Awake__ok_killed_121:;

#line 837 "garden.ceu"
    #ifdef CEU_DEBUG_TRAILS
#ifndef CEU_OS
printf("\tOK!\n");
#endif
#endif

#line 837 "garden.ceu"
    }
#line 837 "garden.ceu"
/* CLEAR: Block (837) */
#line 837 "garden.ceu"
    if (0) {

#line 837 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
}

#line 837 "garden.ceu"
    }
#line 837 "garden.ceu"
    }
#line 837 "garden.ceu"
    }
#line 837 "garden.ceu"
/* CLEAR: Block (837) */
#line 837 "garden.ceu"
    {
    /* Reuse current stack frame.
     * We know that CLEAR will not abort anything and return normally.
     * Just save the previous "is_alive", call CLEAR, and restore it.
     */
#ifdef CEU_STACK_CLEAR
    int __ceu_old = _ceu_stk->is_alive;
    _ceu_stk->is_alive = 1;
#endif
    tceu_evt evt;
             evt.id = CEU_IN__CLEAR;
    ceu_sys_go_ex(_ceu_app, &evt,
                  _ceu_stk,
                  _ceu_org,
                  0,
                  2);
#ifdef CEU_STACK_CLEAR
    _ceu_stk->is_alive = __ceu_old;
    ceu_sys_stack_clear(_ceu_stk, _ceu_org,
                        0,1);
#endif
}

#line 837 "garden.ceu"
    #ifdef CEU_ORGS_AWAIT
/* signal ok_killed */
{
    tceu_kill ps = { _ceu_org, _ceu_org->ret, 0,1 };
    tceu_evt evt_;
             evt_.id = CEU_IN__ok_killed;
             evt_.param = &ps;
    ceu_sys_go_ex(_ceu_app, &evt_, _ceu_stk,
                  _ceu_app->data, 0, _ceu_app->data->n);
}
#endif

#line 837 "garden.ceu"
    if (0) {

#line 837 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
/* NODE: Set 7210 */

#line 846 "garden.ceu"
/* SET: idx *//* NODE: Op2_+ 2728 */

#line 846 "garden.ceu"
    seeds[(((CEU_Seed*)_ceu_org)->tier)] = (seeds[(((CEU_Seed*)_ceu_org)->tier)]+1);/* NODE: EmitExt 2736 */

#line 847 "garden.ceu"
        {

#line 847 "garden.ceu"
    tceu__int__int __ceu_ps_2736;
{
    tceu__int__int __ceu_ps_2736_ =
        { (((CEU_Seed*)_ceu_org)->tier),seeds[(((CEU_Seed*)_ceu_org)->tier)] };
    __ceu_ps_2736 = __ceu_ps_2736_;
}

#line 847 "garden.ceu"
    
#if defined(ceu_out_emit_SET_COUNT)
    ceu_out_emit_SET_COUNT((&__ceu_ps_2736))

#elif defined(ceu_out_emit)
    (ceu_out_emit(_ceu_app, CEU_OUT_SET_COUNT, sizeof(tceu__int__int), (void*)(&__ceu_ps_2736)))

#else
    #error ceu_out_emit_* is not defined
#endif
;
#line 847 "garden.ceu"
        }

#line 837 "garden.ceu"
    }
#line 837 "garden.ceu"
/* CLEAR: Block (837) */
#line 837 "garden.ceu"
    if (0) {

#line 837 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
} else {
/* NODE: Nothing 7168 */
}

#line 799 "garden.ceu"
    }
#line 799 "garden.ceu"
/* CLEAR: Block (799) */
#line 799 "garden.ceu"
    {
    /* Reuse current stack frame.
     * We know that CLEAR will not abort anything and return normally.
     * Just save the previous "is_alive", call CLEAR, and restore it.
     */
#ifdef CEU_STACK_CLEAR
    int __ceu_old = _ceu_stk->is_alive;
    _ceu_stk->is_alive = 1;
#endif
    tceu_evt evt;
             evt.id = CEU_IN__CLEAR;
    ceu_sys_go_ex(_ceu_app, &evt,
                  _ceu_stk,
                  _ceu_org,
                  0,
                  4);
#ifdef CEU_STACK_CLEAR
    _ceu_stk->is_alive = __ceu_old;
    ceu_sys_stack_clear(_ceu_stk, _ceu_org,
                        0,3);
#endif
}

#line 799 "garden.ceu"
    #ifdef CEU_ORGS_AWAIT
/* signal ok_killed */
{
    tceu_kill ps = { _ceu_org, _ceu_org->ret, 0,3 };
    tceu_evt evt_;
             evt_.id = CEU_IN__ok_killed;
             evt_.param = &ps;
    ceu_sys_go_ex(_ceu_app, &evt_, _ceu_stk,
                  _ceu_app->data, 0, _ceu_app->data->n);
}
#endif

#line 799 "garden.ceu"
    if (0) {

#line 799 "garden.ceu"
case Seed_Block__fin_122:;
#line 799 "garden.ceu"
    if (((CEU_Seed*)_ceu_org)->__fin_2741_1) {
    /* NODE: Finally 2609 */
/* NODE: Block 2608 */

#line 812 "garden.ceu"
    {/* NODE: Stmts 2607 */

#line 812 "garden.ceu"
    {/* NODE: EmitExt 2606 */

#line 812 "garden.ceu"
        {

#line 812 "garden.ceu"
    tceu__int __ceu_ps_2606;
{
    tceu__int __ceu_ps_2606_ =
        { (((CEU_Seed*)_ceu_org)->id) };
    __ceu_ps_2606 = __ceu_ps_2606_;
}

#line 812 "garden.ceu"
    
#if defined(ceu_out_emit_FREE_SPRITE)
    ceu_out_emit_FREE_SPRITE((&__ceu_ps_2606))

#elif defined(ceu_out_emit)
    (ceu_out_emit(_ceu_app, CEU_OUT_FREE_SPRITE, sizeof(tceu__int), (void*)(&__ceu_ps_2606)))

#else
    #error ceu_out_emit_* is not defined
#endif
;
#line 812 "garden.ceu"
        }

#line 812 "garden.ceu"
    }
#line 812 "garden.ceu"
/* CLEAR: Block (812) */
#line 812 "garden.ceu"
    if (0) {

#line 812 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
}

#line 799 "garden.ceu"
    return;
#line 799 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 793 "garden.ceu"
    }
#line 793 "garden.ceu"
/* CLEAR: Block (793) */
#line 793 "garden.ceu"
    if (0) {

#line 793 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 793 "garden.ceu"
    }
#line 793 "garden.ceu"
/* CLEAR: Block (793) */
#line 793 "garden.ceu"
    if (0) {

#line 793 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 793 "garden.ceu"
    ceu_sys_org_free(_ceu_app, _ceu_org);
#ifdef CEU_ORGS_AWAIT
{
    /* signal ok_killed */
#ifdef CEU_STACK_CLEAR
    tceu_stk stk_ = *_ceu_stk;
             stk_.is_alive = 1;
             stk_.down = _ceu_stk;
#endif
    tceu_kill ps = { _ceu_org, _ceu_org->ret, 0, (tceu_ntrl)(_ceu_org->n-1) };
    tceu_evt evt_;
             evt_.id = CEU_IN__ok_killed;
             evt_.param = &ps;
    ceu_sys_go_ex(_ceu_app, &evt_,
#ifdef CEU_STACK_CLEAR
                  &stk_,
#else
                  NULL,
#endif
                  _ceu_app->data, 0, _ceu_app->data->n);
}
#endif

#line 793 "garden.ceu"
    return;/* NODE: Dcl_cls 18 */

#line 857 "garden.ceu"
case Class_Birb:;/* NODE: Block 7442 */

#line 857 "garden.ceu"
    /*  FINALIZE */
_ceu_org->trls[ 5 ].evt = CEU_IN__CLEAR;
_ceu_org->trls[ 5 ].lbl = Birb_Block__fin_132;

#line 857 "garden.ceu"
    {/* NODE: Stmts 7441 */

#line 857 "garden.ceu"
    {/* NODE: Block 7220 */

#line 857 "garden.ceu"
    {/* NODE: Stmts 7443 */

#line 857 "garden.ceu"
    {/* NODE: Block 3022 */

#line 863 "garden.ceu"
    /*  FINALIZE */
_ceu_org->trls[ 4 ].evt = CEU_IN__CLEAR;
_ceu_org->trls[ 4 ].lbl = Birb_Block__fin_131;

#line 863 "garden.ceu"
    ((CEU_Birb*)_ceu_org)->__fin_3022_1 = 0;
#line 863 "garden.ceu"
    {/* NODE: Stmts 3021 */

#line 863 "garden.ceu"
    {/* NODE: Set 7236 */

#line 863 "garden.ceu"
/* SET: birb_count *//* NODE: Op2_+ 2756 */

#line 863 "garden.ceu"
    (*((CEU_Birb*)_ceu_org)->birb_count) = ((*((CEU_Birb*)_ceu_org)->birb_count)+1);/* NODE: Stmts 7241 */

#line 865 "garden.ceu"
    {/* NODE: Dcl_var 7238 */
/* NODE: Set 7242 */

#line 865 "garden.ceu"
/* SET: id *//* NODE: Var 2759 */

#line 865 "garden.ceu"
    (((CEU_Birb*)_ceu_org)->id) = (*((CEU_Birb*)_ceu_org)->gensym);
#line 865 "garden.ceu"
    }/* NODE: Stmts 7247 */

#line 866 "garden.ceu"
    {/* NODE: Dcl_var 7244 */
/* NODE: Set 7248 */

#line 866 "garden.ceu"
/* SET: perched_id *//* NODE: Var 2762 */

#line 866 "garden.ceu"
    (((CEU_Birb*)_ceu_org)->perched_id) = (*((CEU_Birb*)_ceu_org)->gensym);
#line 866 "garden.ceu"
    }/* NODE: Set 7249 */

#line 867 "garden.ceu"
/* SET: gensym *//* NODE: Op2_+ 2767 */

#line 867 "garden.ceu"
    (*((CEU_Birb*)_ceu_org)->gensym) = ((*((CEU_Birb*)_ceu_org)->gensym)+2);/* NODE: Stmts 7254 */

#line 868 "garden.ceu"
    {/* NODE: Dcl_var 7251 */
/* NODE: Set 7255 */

#line 868 "garden.ceu"
/* SET: x *//* NODE: Op2_call 2773 */

#line 868 "garden.ceu"
    (((CEU_Birb*)_ceu_org)->x) = d(1280);
#line 868 "garden.ceu"
    }/* NODE: Stmts 7260 */

#line 869 "garden.ceu"
    {/* NODE: Dcl_var 7257 */
/* NODE: Set 7261 */

#line 869 "garden.ceu"
/* SET: y *//* NODE: Op2_* 2782 */

#line 869 "garden.ceu"
    (((CEU_Birb*)_ceu_org)->y) = ((-1)*d(100));
#line 869 "garden.ceu"
    }/* NODE: Stmts 7266 */

#line 870 "garden.ceu"
    {/* NODE: Dcl_var 7263 */
/* NODE: Set 7267 */

#line 870 "garden.ceu"
/* SET: texture *//* NODE: Op2_+ 2789 */

#line 870 "garden.ceu"
    (((CEU_Birb*)_ceu_org)->texture) = (((((CEU_Birb*)_ceu_org)->tier)*2)+13);
#line 870 "garden.ceu"
    }/* NODE: EmitExt 2802 */

#line 871 "garden.ceu"
        {

#line 871 "garden.ceu"
    tceu__int__int__int__int__int __ceu_ps_2802;
{
    tceu__int__int__int__int__int __ceu_ps_2802_ =
        { (((CEU_Birb*)_ceu_org)->id),((int)(((CEU_Birb*)_ceu_org)->x)),((int)(((CEU_Birb*)_ceu_org)->y)),(((CEU_Birb*)_ceu_org)->texture),2 };
    __ceu_ps_2802 = __ceu_ps_2802_;
}

#line 871 "garden.ceu"
    
#if defined(ceu_out_emit_NEW_SPRITE)
    ceu_out_emit_NEW_SPRITE((&__ceu_ps_2802))

#elif defined(ceu_out_emit)
    (ceu_out_emit(_ceu_app, CEU_OUT_NEW_SPRITE, sizeof(tceu__int__int__int__int__int), (void*)(&__ceu_ps_2802)))

#else
    #error ceu_out_emit_* is not defined
#endif
;
#line 871 "garden.ceu"
        }
/* NODE: Finalize 2814 */

#line 872 "garden.ceu"
    ((CEU_Birb*)_ceu_org)->__fin_3022_1 = 1;/* NODE: ParOr 2952 */

#line 877 "garden.ceu"
/* ParOr: spawn subs */
#line 877 "garden.ceu"
    {
#ifdef CEU_STACK_CLEAR
    tceu_stk stk_ = { _ceu_stk, _ceu_org, 0, 3, 1 };
#endif

#line 877 "garden.ceu"
        _ceu_org->trls[ 0 ].lbl = Birb_ParOr_sub_1_124;
    ceu_app_go(_ceu_app,NULL,_ceu_org,
               &_ceu_org->trls[ 0 ],
#ifdef CEU_STACK_CLEAR
               &stk_
#else
               NULL
#endif
              );

#ifdef CEU_STACK_CLEAR
    if (!stk_.is_alive) {
        return;
    }
#endif

#line 877 "garden.ceu"
        _ceu_trl = &_ceu_org->trls[ 1 ];

#line 877 "garden.ceu"
    }
/* NODE: Block 2951 */

#line 887 "garden.ceu"
    {/* NODE: Stmts 2950 */

#line 887 "garden.ceu"
    {/* NODE: Block 7306 */

#line 887 "garden.ceu"
    {/* NODE: Stmts 7305 */

#line 887 "garden.ceu"
    {/* NODE: Stmts 7304 */

#line 887 "garden.ceu"
    {
#line 887 "garden.ceu"
    }/* NODE: Loop 7303 */

#line 887 "garden.ceu"
    for (;;) {
/* NODE: Block 2948 */

#line 888 "garden.ceu"
    {/* NODE: Stmts 2947 */

#line 888 "garden.ceu"
    {/* NODE: Stmts 7311 */

#line 888 "garden.ceu"
    {/* NODE: Dcl_var 7308 */
/* NODE: Set 7312 */

#line 888 "garden.ceu"
/* SET: target_perch *//* NODE: Op2_call 2838 */

#line 888 "garden.ceu"
    (((CEU_Birb*)_ceu_org)->target_perch_12) = d(6);
#line 888 "garden.ceu"
    }/* NODE: Do 7319 */
/* NODE: Block 7318 */

#line 889 "garden.ceu"
    {
#line 889 "garden.ceu"
    #ifdef CEU_ORGS
_ceu_org->trls[ 1 ].evt = CEU_IN__ORG;
_ceu_org->trls[ 1 ].org = NULL;
#endif

#line 889 "garden.ceu"
    _ceu_trl = &_ceu_org->trls[ 2 ];
/* NODE: Stmts 7317 */

#line 889 "garden.ceu"
    {/* NODE: Dcl_var 7316 */

#line 889 "garden.ceu"
/* start org: _org_2869 */
#line 889 "garden.ceu"
        /* resets org memory and starts org.trail[0]=Class_XXX */
    /* TODO: BUG: _ceu_org is not necessarily the parent for pool allocations */
    ceu_out_org_init(_ceu_app, ((tceu_org*) &(((CEU_Birb*)_ceu_org)->_org_2869_13)),3,Class_Fly,
                     16,
                     0,
                     _ceu_org,1);
/* TODO: currently idx is always "1" for all interfaces access because pools 
 * are all together there. When we have separate trls for pools, we'll have to 
 * indirectly access the offset in the interface. */

#line 889 "garden.ceu"
        _ceu_constr_2868(_ceu_app, ((tceu_org*) &(((CEU_Birb*)_ceu_org)->_org_2869_13)), _ceu_org);

#line 889 "garden.ceu"
    {
#ifdef CEU_STACK_CLEAR
    tceu_stk stk_ = { _ceu_stk, _ceu_org, 2, 2, 1 };
    ceu_app_go(_ceu_app,NULL,
               ((tceu_org*) &(((CEU_Birb*)_ceu_org)->_org_2869_13)), &((tceu_org*) &(((CEU_Birb*)_ceu_org)->_org_2869_13))->trls[0],
               &stk_);
    if (!stk_.is_alive) {
        return;
    }
#else
    ceu_app_go(_ceu_app,NULL,
               ((tceu_org*) &(((CEU_Birb*)_ceu_org)->_org_2869_13)), &((tceu_org*) &(((CEU_Birb*)_ceu_org)->_org_2869_13))->trls[0],
               NULL);
#endif

#line 889 "garden.ceu"
    }
/* NODE: Stmts 7351 */

#line 889 "garden.ceu"
    {/* NODE: Nothing 7325 */
/* NODE: Nothing 8338 */
/* NODE: Nothing 8339 */
/* NODE: Stmts 7350 */

#line 889 "garden.ceu"
    {/* NODE: If 7349 */

#line 889 "garden.ceu"
    if ((!(((*((tceu_org*)(&((CEU_Birb*)_ceu_org)->_org_2869_13))).isAlive)))) {
/* NODE: Block 7346 */

#line 889 "garden.ceu"
    {/* NODE: Stmts 7345 */

#line 889 "garden.ceu"
    {/* NODE: Nothing 7329 */

#line 889 "garden.ceu"
    }
#line 889 "garden.ceu"
/* CLEAR: Block (889) */
#line 889 "garden.ceu"
    if (0) {

#line 889 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
} else {
/* NODE: Block 7348 */

#line 889 "garden.ceu"
    {/* NODE: Stmts 7347 */

#line 889 "garden.ceu"
    {/* NODE: Await 7328 */

#line 889 "garden.ceu"
    _CEU_NO_7328_:
if (0) { goto _CEU_NO_7328_; /* avoids "not used" warning */ }

#line 889 "garden.ceu"
    _ceu_trl->evt = CEU_IN__ok_killed;
_ceu_trl->lbl = Birb_Awake__ok_killed_127;
_ceu_trl->seqno = _ceu_app->seqno;

#line 889 "garden.ceu"
    #ifdef CEU_ORGS_AWAIT
#ifdef CEU_ADTS_AWAIT
_ceu_trl->is_org = 1;
#endif
#endif
_ceu_trl->org_or_adt = (void*)(&((CEU_Birb*)_ceu_org)->_org_2869_13);

#line 889 "garden.ceu"
    return;

case Birb_Awake__ok_killed_127:;

#line 889 "garden.ceu"
    #ifdef CEU_DEBUG_TRAILS
#ifndef CEU_OS
printf("\tOK!\n");
#endif
#endif

#line 889 "garden.ceu"
    }
#line 889 "garden.ceu"
/* CLEAR: Block (889) */
#line 889 "garden.ceu"
    if (0) {

#line 889 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
}

#line 889 "garden.ceu"
    }
#line 889 "garden.ceu"
    }
#line 889 "garden.ceu"
    }
#line 889 "garden.ceu"
/* CLEAR: Block (889) */
#line 889 "garden.ceu"
    {
    /* Reuse current stack frame.
     * We know that CLEAR will not abort anything and return normally.
     * Just save the previous "is_alive", call CLEAR, and restore it.
     */
#ifdef CEU_STACK_CLEAR
    int __ceu_old = _ceu_stk->is_alive;
    _ceu_stk->is_alive = 1;
#endif
    tceu_evt evt;
             evt.id = CEU_IN__CLEAR;
    ceu_sys_go_ex(_ceu_app, &evt,
                  _ceu_stk,
                  _ceu_org,
                  1,
                  4);
#ifdef CEU_STACK_CLEAR
    _ceu_stk->is_alive = __ceu_old;
    ceu_sys_stack_clear(_ceu_stk, _ceu_org,
                        1,3);
#endif
}

#line 889 "garden.ceu"
    #ifdef CEU_ORGS_AWAIT
/* signal ok_killed */
{
    tceu_kill ps = { _ceu_org, _ceu_org->ret, 1,3 };
    tceu_evt evt_;
             evt_.id = CEU_IN__ok_killed;
             evt_.param = &ps;
    ceu_sys_go_ex(_ceu_app, &evt_, _ceu_stk,
                  _ceu_app->data, 0, _ceu_app->data->n);
}
#endif

#line 889 "garden.ceu"
    if (0) {

#line 889 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
/* NODE: If 7353 */

#line 896 "garden.ceu"
    if (occupied[(((CEU_Birb*)_ceu_org)->target_perch_12)]) {
/* NODE: Block 2875 */

#line 897 "garden.ceu"
    {/* NODE: Stmts 2874 */

#line 897 "garden.ceu"
    {/* NODE: Nothing 7354 */

#line 897 "garden.ceu"
    }
#line 897 "garden.ceu"
/* CLEAR: Block (897) */
#line 897 "garden.ceu"
    if (0) {

#line 897 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
} else {
/* NODE: Block 7395 */

#line 887 "garden.ceu"
    {/* NODE: Stmts 7394 */

#line 896 "garden.ceu"
    {/* NODE: Do 2946 */
/* NODE: Block 2945 */

#line 901 "garden.ceu"
    /*  FINALIZE */
_ceu_org->trls[ 3 ].evt = CEU_IN__CLEAR;
_ceu_org->trls[ 3 ].lbl = Birb_Block__fin_129;

#line 901 "garden.ceu"
    ((CEU_Birb*)_ceu_org)->__fin_2945_1 = 0;
#line 901 "garden.ceu"
    {/* NODE: Stmts 2944 */

#line 901 "garden.ceu"
    {/* NODE: Set 7355 */

#line 901 "garden.ceu"
/* SET: idx *//* NODE: NUMBER 2880 */

#line 901 "garden.ceu"
    occupied[(((CEU_Birb*)_ceu_org)->target_perch_12)] = 1;/* NODE: EmitExt 2884 */

#line 902 "garden.ceu"
        {

#line 902 "garden.ceu"
    tceu__int __ceu_ps_2884;
{
    tceu__int __ceu_ps_2884_ =
        { (((CEU_Birb*)_ceu_org)->id) };
    __ceu_ps_2884 = __ceu_ps_2884_;
}

#line 902 "garden.ceu"
    
#if defined(ceu_out_emit_FREE_SPRITE)
    ceu_out_emit_FREE_SPRITE((&__ceu_ps_2884))

#elif defined(ceu_out_emit)
    (ceu_out_emit(_ceu_app, CEU_OUT_FREE_SPRITE, sizeof(tceu__int), (void*)(&__ceu_ps_2884)))

#else
    #error ceu_out_emit_* is not defined
#endif
;
#line 902 "garden.ceu"
        }
/* NODE: EmitExt 2898 */

#line 903 "garden.ceu"
        {

#line 903 "garden.ceu"
    tceu__int__int__int__int__int __ceu_ps_2898;
{
    tceu__int__int__int__int__int __ceu_ps_2898_ =
        { (((CEU_Birb*)_ceu_org)->perched_id),((int)(((CEU_Birb*)_ceu_org)->x)),((int)(((CEU_Birb*)_ceu_org)->y)),((((CEU_Birb*)_ceu_org)->texture)+1),2 };
    __ceu_ps_2898 = __ceu_ps_2898_;
}

#line 903 "garden.ceu"
    
#if defined(ceu_out_emit_NEW_SPRITE)
    ceu_out_emit_NEW_SPRITE((&__ceu_ps_2898))

#elif defined(ceu_out_emit)
    (ceu_out_emit(_ceu_app, CEU_OUT_NEW_SPRITE, sizeof(tceu__int__int__int__int__int), (void*)(&__ceu_ps_2898)))

#else
    #error ceu_out_emit_* is not defined
#endif
;
#line 903 "garden.ceu"
        }
/* NODE: Finalize 2922 */

#line 904 "garden.ceu"
    ((CEU_Birb*)_ceu_org)->__fin_2945_1 = 1;/* NODE: Do 7365 */
/* NODE: Block 7364 */

#line 910 "garden.ceu"
    {
#line 910 "garden.ceu"
    #ifdef CEU_ORGS
_ceu_org->trls[ 1 ].evt = CEU_IN__ORG;
_ceu_org->trls[ 1 ].org = NULL;
#endif

#line 910 "garden.ceu"
    _ceu_trl = &_ceu_org->trls[ 2 ];
/* NODE: Stmts 7363 */

#line 910 "garden.ceu"
    {/* NODE: Dcl_var 7362 */

#line 910 "garden.ceu"
/* start org: _org_2943 */
#line 910 "garden.ceu"
        /* resets org memory and starts org.trail[0]=Class_XXX */
    /* TODO: BUG: _ceu_org is not necessarily the parent for pool allocations */
    ceu_out_org_init(_ceu_app, ((tceu_org*) &(((CEU_Birb*)_ceu_org)->_org_2943_14)),2,Class_Delay,
                     1,
                     0,
                     _ceu_org,1);
/* TODO: currently idx is always "1" for all interfaces access because pools 
 * are all together there. When we have separate trls for pools, we'll have to 
 * indirectly access the offset in the interface. */

#line 910 "garden.ceu"
        _ceu_pre_1(_ceu_app, ((tceu_org*) &(((CEU_Birb*)_ceu_org)->_org_2943_14)));

#line 910 "garden.ceu"
        _ceu_constr_2942(_ceu_app, ((tceu_org*) &(((CEU_Birb*)_ceu_org)->_org_2943_14)), _ceu_org);

#line 910 "garden.ceu"
    {
#ifdef CEU_STACK_CLEAR
    tceu_stk stk_ = { _ceu_stk, _ceu_org, 2, 2, 1 };
    ceu_app_go(_ceu_app,NULL,
               ((tceu_org*) &(((CEU_Birb*)_ceu_org)->_org_2943_14)), &((tceu_org*) &(((CEU_Birb*)_ceu_org)->_org_2943_14))->trls[0],
               &stk_);
    if (!stk_.is_alive) {
        return;
    }
#else
    ceu_app_go(_ceu_app,NULL,
               ((tceu_org*) &(((CEU_Birb*)_ceu_org)->_org_2943_14)), &((tceu_org*) &(((CEU_Birb*)_ceu_org)->_org_2943_14))->trls[0],
               NULL);
#endif

#line 910 "garden.ceu"
    }
/* NODE: Stmts 7393 */

#line 910 "garden.ceu"
    {/* NODE: Nothing 7367 */
/* NODE: Nothing 8341 */
/* NODE: Nothing 8342 */
/* NODE: Stmts 7392 */

#line 910 "garden.ceu"
    {/* NODE: If 7391 */

#line 910 "garden.ceu"
    if ((!(((*((tceu_org*)(&((CEU_Birb*)_ceu_org)->_org_2943_14))).isAlive)))) {
/* NODE: Block 7388 */

#line 910 "garden.ceu"
    {/* NODE: Stmts 7387 */

#line 910 "garden.ceu"
    {/* NODE: Nothing 7371 */

#line 910 "garden.ceu"
    }
#line 910 "garden.ceu"
/* CLEAR: Block (910) */
#line 910 "garden.ceu"
    if (0) {

#line 910 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
} else {
/* NODE: Block 7390 */

#line 910 "garden.ceu"
    {/* NODE: Stmts 7389 */

#line 910 "garden.ceu"
    {/* NODE: Await 7370 */

#line 910 "garden.ceu"
    _CEU_NO_7370_:
if (0) { goto _CEU_NO_7370_; /* avoids "not used" warning */ }

#line 910 "garden.ceu"
    _ceu_trl->evt = CEU_IN__ok_killed;
_ceu_trl->lbl = Birb_Awake__ok_killed_128;
_ceu_trl->seqno = _ceu_app->seqno;

#line 910 "garden.ceu"
    #ifdef CEU_ORGS_AWAIT
#ifdef CEU_ADTS_AWAIT
_ceu_trl->is_org = 1;
#endif
#endif
_ceu_trl->org_or_adt = (void*)(&((CEU_Birb*)_ceu_org)->_org_2943_14);

#line 910 "garden.ceu"
    return;

case Birb_Awake__ok_killed_128:;

#line 910 "garden.ceu"
    #ifdef CEU_DEBUG_TRAILS
#ifndef CEU_OS
printf("\tOK!\n");
#endif
#endif

#line 910 "garden.ceu"
    }
#line 910 "garden.ceu"
/* CLEAR: Block (910) */
#line 910 "garden.ceu"
    if (0) {

#line 910 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
}

#line 910 "garden.ceu"
    }
#line 910 "garden.ceu"
    }
#line 910 "garden.ceu"
    }
#line 910 "garden.ceu"
/* CLEAR: Block (910) */
#line 910 "garden.ceu"
    {
    /* Reuse current stack frame.
     * We know that CLEAR will not abort anything and return normally.
     * Just save the previous "is_alive", call CLEAR, and restore it.
     */
#ifdef CEU_STACK_CLEAR
    int __ceu_old = _ceu_stk->is_alive;
    _ceu_stk->is_alive = 1;
#endif
    tceu_evt evt;
             evt.id = CEU_IN__CLEAR;
    ceu_sys_go_ex(_ceu_app, &evt,
                  _ceu_stk,
                  _ceu_org,
                  1,
                  3);
#ifdef CEU_STACK_CLEAR
    _ceu_stk->is_alive = __ceu_old;
    ceu_sys_stack_clear(_ceu_stk, _ceu_org,
                        1,2);
#endif
}

#line 910 "garden.ceu"
    #ifdef CEU_ORGS_AWAIT
/* signal ok_killed */
{
    tceu_kill ps = { _ceu_org, _ceu_org->ret, 1,2 };
    tceu_evt evt_;
             evt_.id = CEU_IN__ok_killed;
             evt_.param = &ps;
    ceu_sys_go_ex(_ceu_app, &evt_, _ceu_stk,
                  _ceu_app->data, 0, _ceu_app->data->n);
}
#endif

#line 910 "garden.ceu"
    if (0) {

#line 910 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 901 "garden.ceu"
    }
#line 901 "garden.ceu"
/* CLEAR: Block (901) */
#line 901 "garden.ceu"
    {
    /* Reuse current stack frame.
     * We know that CLEAR will not abort anything and return normally.
     * Just save the previous "is_alive", call CLEAR, and restore it.
     */
#ifdef CEU_STACK_CLEAR
    int __ceu_old = _ceu_stk->is_alive;
    _ceu_stk->is_alive = 1;
#endif
    tceu_evt evt;
             evt.id = CEU_IN__CLEAR;
    ceu_sys_go_ex(_ceu_app, &evt,
                  _ceu_stk,
                  _ceu_org,
                  1,
                  4);
#ifdef CEU_STACK_CLEAR
    _ceu_stk->is_alive = __ceu_old;
    ceu_sys_stack_clear(_ceu_stk, _ceu_org,
                        1,3);
#endif
}

#line 901 "garden.ceu"
    #ifdef CEU_ORGS_AWAIT
/* signal ok_killed */
{
    tceu_kill ps = { _ceu_org, _ceu_org->ret, 1,3 };
    tceu_evt evt_;
             evt_.id = CEU_IN__ok_killed;
             evt_.param = &ps;
    ceu_sys_go_ex(_ceu_app, &evt_, _ceu_stk,
                  _ceu_app->data, 0, _ceu_app->data->n);
}
#endif

#line 901 "garden.ceu"
    if (0) {

#line 901 "garden.ceu"
case Birb_Block__fin_129:;
#line 901 "garden.ceu"
    if (((CEU_Birb*)_ceu_org)->__fin_2945_1) {
    /* NODE: Finally 2921 */
/* NODE: Block 2920 */

#line 905 "garden.ceu"
    {/* NODE: Stmts 2919 */

#line 905 "garden.ceu"
    {/* NODE: Set 7357 */

#line 905 "garden.ceu"
/* SET: idx *//* NODE: NUMBER 2902 */

#line 905 "garden.ceu"
    occupied[(((CEU_Birb*)_ceu_org)->target_perch_12)] = 0;/* NODE: EmitExt 2906 */

#line 906 "garden.ceu"
        {

#line 906 "garden.ceu"
    tceu__int __ceu_ps_2906;
{
    tceu__int __ceu_ps_2906_ =
        { (((CEU_Birb*)_ceu_org)->perched_id) };
    __ceu_ps_2906 = __ceu_ps_2906_;
}

#line 906 "garden.ceu"
    
#if defined(ceu_out_emit_FREE_SPRITE)
    ceu_out_emit_FREE_SPRITE((&__ceu_ps_2906))

#elif defined(ceu_out_emit)
    (ceu_out_emit(_ceu_app, CEU_OUT_FREE_SPRITE, sizeof(tceu__int), (void*)(&__ceu_ps_2906)))

#else
    #error ceu_out_emit_* is not defined
#endif
;
#line 906 "garden.ceu"
        }
/* NODE: EmitExt 2918 */

#line 907 "garden.ceu"
        {

#line 907 "garden.ceu"
    tceu__int__int__int__int__int __ceu_ps_2918;
{
    tceu__int__int__int__int__int __ceu_ps_2918_ =
        { (((CEU_Birb*)_ceu_org)->id),((int)(((CEU_Birb*)_ceu_org)->x)),((int)(((CEU_Birb*)_ceu_org)->y)),(((CEU_Birb*)_ceu_org)->texture),2 };
    __ceu_ps_2918 = __ceu_ps_2918_;
}

#line 907 "garden.ceu"
    
#if defined(ceu_out_emit_NEW_SPRITE)
    ceu_out_emit_NEW_SPRITE((&__ceu_ps_2918))

#elif defined(ceu_out_emit)
    (ceu_out_emit(_ceu_app, CEU_OUT_NEW_SPRITE, sizeof(tceu__int__int__int__int__int), (void*)(&__ceu_ps_2918)))

#else
    #error ceu_out_emit_* is not defined
#endif
;
#line 907 "garden.ceu"
        }

#line 905 "garden.ceu"
    }
#line 905 "garden.ceu"
/* CLEAR: Block (905) */
#line 905 "garden.ceu"
    if (0) {

#line 905 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
}

#line 901 "garden.ceu"
    return;
#line 901 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 896 "garden.ceu"
    }
#line 887 "garden.ceu"
/* CLEAR: Block (887) */
#line 887 "garden.ceu"
    if (0) {

#line 887 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
}

#line 888 "garden.ceu"
    }
#line 888 "garden.ceu"
/* CLEAR: Block (888) */
#line 888 "garden.ceu"
    if (0) {

#line 888 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 887 "garden.ceu"
    }

#line 887 "garden.ceu"
    }
#line 887 "garden.ceu"
/* CLEAR: Block (887) */
#line 887 "garden.ceu"
    if (0) {

#line 887 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 887 "garden.ceu"
    }
#line 887 "garden.ceu"
/* CLEAR: Block (887) */
#line 887 "garden.ceu"
    if (0) {

#line 887 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 877 "garden.ceu"
case Birb_ParOr_sub_1_124:;/* NODE: Block 2833 */

#line 880 "garden.ceu"
    {/* NODE: Stmts 2832 */

#line 880 "garden.ceu"
    {/* NODE: Block 7273 */

#line 880 "garden.ceu"
    {/* NODE: Stmts 7272 */

#line 880 "garden.ceu"
    {/* NODE: Stmts 7271 */

#line 880 "garden.ceu"
    {
#line 880 "garden.ceu"
    }/* NODE: Loop 7270 */

#line 880 "garden.ceu"
    for (;;) {
/* NODE: Block 2830 */

#line 881 "garden.ceu"
    {/* NODE: Stmts 2829 */

#line 881 "garden.ceu"
    {/* NODE: Stmts 7300 */

#line 881 "garden.ceu"
    {/* NODE: Nothing 7274 */
/* NODE: Await 2816 */

#line 881 "garden.ceu"
    _CEU_NO_2816_:
if (0) { goto _CEU_NO_2816_; /* avoids "not used" warning */ }

#line 881 "garden.ceu"
    _ceu_trl->evt = CEU_IN_UPDATE;
_ceu_trl->lbl = Birb_Awake_UPDATE_126;
_ceu_trl->seqno = _ceu_app->seqno;

#line 881 "garden.ceu"
    return;

case Birb_Awake_UPDATE_126:;

#line 881 "garden.ceu"
    #ifdef CEU_DEBUG_TRAILS
#ifndef CEU_OS
printf("\tOK!\n");
#endif
#endif
/* NODE: Nothing 8331 */
/* NODE: Nothing 8332 */

#line 881 "garden.ceu"
    }/* NODE: If 7302 */

#line 882 "garden.ceu"
    if ((d((60*5))==0)) {
/* NODE: Block 2827 */

#line 883 "garden.ceu"
    {/* NODE: Stmts 2826 */

#line 883 "garden.ceu"
    {/* NODE: Break 2825 */

#line 883 "garden.ceu"
    break;
#line 883 "garden.ceu"
    }
#line 883 "garden.ceu"
/* CLEAR: Block (883) */
#line 883 "garden.ceu"
    if (0) {

#line 883 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
} else {
/* NODE: Nothing 7301 */
}

#line 881 "garden.ceu"
    }
#line 881 "garden.ceu"
/* CLEAR: Block (881) */
#line 881 "garden.ceu"
    if (0) {

#line 881 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 880 "garden.ceu"
    }

#line 880 "garden.ceu"
/* CLEAR: Loop (880) */
#line 880 "garden.ceu"
    }
#line 880 "garden.ceu"
/* CLEAR: Block (880) */
#line 880 "garden.ceu"
    if (0) {

#line 880 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 880 "garden.ceu"
    }
#line 880 "garden.ceu"
/* CLEAR: Block (880) */
#line 880 "garden.ceu"
    if (0) {

#line 880 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 877 "garden.ceu"
/* PAROR JOIN */
#line 877 "garden.ceu"
    _ceu_lbl = Birb_ParOr_out_125;
goto _CEU_GOTO_;

#line 877 "garden.ceu"
case Birb_ParOr_out_125:;
#line 877 "garden.ceu"
/* CLEAR: ParOr (877) */
#line 877 "garden.ceu"
    {
    /* Reuse current stack frame.
     * We know that CLEAR will not abort anything and return normally.
     * Just save the previous "is_alive", call CLEAR, and restore it.
     */
#ifdef CEU_STACK_CLEAR
    int __ceu_old = _ceu_stk->is_alive;
    _ceu_stk->is_alive = 1;
#endif
    tceu_evt evt;
             evt.id = CEU_IN__CLEAR;
    ceu_sys_go_ex(_ceu_app, &evt,
                  _ceu_stk,
                  _ceu_org,
                  0,
                  4);
#ifdef CEU_STACK_CLEAR
    _ceu_stk->is_alive = __ceu_old;
    ceu_sys_stack_clear(_ceu_stk, _ceu_org,
                        0,3);
#endif
}

#line 877 "garden.ceu"
    #ifdef CEU_ORGS_AWAIT
/* signal ok_killed */
{
    tceu_kill ps = { _ceu_org, _ceu_org->ret, 0,3 };
    tceu_evt evt_;
             evt_.id = CEU_IN__ok_killed;
             evt_.param = &ps;
    ceu_sys_go_ex(_ceu_app, &evt_, _ceu_stk,
                  _ceu_app->data, 0, _ceu_app->data->n);
}
#endif
/* NODE: If 7397 */

#line 917 "garden.ceu"
    if ((d(10)>=seeds[(((CEU_Birb*)_ceu_org)->tier)])) {
/* NODE: Block 2984 */

#line 918 "garden.ceu"
    {/* NODE: Stmts 2983 */

#line 918 "garden.ceu"
    {/* NODE: Spawn 2982 */

#line 918 "garden.ceu"
    /*{*/
    tceu_org* __ceu_new_2982;

#line 918 "garden.ceu"
    #if !defined(CEU_ORGS_NEWS_MALLOC)
    __ceu_new_2982 = (tceu_org*) ceu_pool_alloc(&(*((CEU_Birb*)_ceu_org)->seeds).pool);
#elif !defined(CEU_ORGS_NEWS_POOL)
    __ceu_new_2982 = (tceu_org*) ceu_out_realloc(NULL, sizeof(CEU_Seed));
#else
    if ((*((CEU_Birb*)_ceu_org)->seeds).pool.queue == NULL) {
        __ceu_new_2982 = (tceu_org*) ceu_out_realloc(NULL, sizeof(CEU_Seed));
    } else {
        __ceu_new_2982 = (tceu_org*) ceu_pool_alloc(&(*((CEU_Birb*)_ceu_org)->seeds).pool);
    }
#endif

#line 918 "garden.ceu"
        if (__ceu_new_2982 != NULL) {

#line 918 "garden.ceu"
    #ifdef CEU_ORGS_NEWS_POOL
        __ceu_new_2982->pool = &(*((CEU_Birb*)_ceu_org)->seeds);
#endif

#line 918 "garden.ceu"
/* start org: dyn */
#line 918 "garden.ceu"
        /* resets org memory and starts org.trail[0]=Class_XXX */
    /* TODO: BUG: _ceu_org is not necessarily the parent for pool allocations */
    ceu_out_org_init(_ceu_app, ((tceu_org*) &(*((CEU_Seed*)__ceu_new_2982))),5,Class_Seed,
                     17,
                     1,
                     (*((CEU_Birb*)_ceu_org)->seeds).parent_org,(*((CEU_Birb*)_ceu_org)->seeds).parent_trl);
/* TODO: currently idx is always "1" for all interfaces access because pools 
 * are all together there. When we have separate trls for pools, we'll have to 
 * indirectly access the offset in the interface. */

#line 918 "garden.ceu"
        _ceu_constr_2981(_ceu_app, ((tceu_org*) &(*((CEU_Seed*)__ceu_new_2982))), _ceu_org);

#line 918 "garden.ceu"
    {
#ifdef CEU_STACK_CLEAR
    tceu_stk stk_ = { _ceu_stk, _ceu_org, 0, 0, 1 };
    ceu_app_go(_ceu_app,NULL,
               ((tceu_org*) &(*((CEU_Seed*)__ceu_new_2982))), &((tceu_org*) &(*((CEU_Seed*)__ceu_new_2982)))->trls[0],
               &stk_);
    if (!stk_.is_alive) {
        return;
    }
#else
    ceu_app_go(_ceu_app,NULL,
               ((tceu_org*) &(*((CEU_Seed*)__ceu_new_2982))), &((tceu_org*) &(*((CEU_Seed*)__ceu_new_2982)))->trls[0],
               NULL);
#endif

#line 918 "garden.ceu"
    }

#line 918 "garden.ceu"
        }
/*}*/

#line 918 "garden.ceu"
    }
#line 918 "garden.ceu"
/* CLEAR: Block (918) */
#line 918 "garden.ceu"
    if (0) {

#line 918 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
} else {
/* NODE: Nothing 7396 */
}
/* NODE: Do 7408 */
/* NODE: Block 7407 */

#line 926 "garden.ceu"
    {
#line 926 "garden.ceu"
    #ifdef CEU_ORGS
_ceu_org->trls[ 0 ].evt = CEU_IN__ORG;
_ceu_org->trls[ 0 ].org = NULL;
#endif

#line 926 "garden.ceu"
    _ceu_trl = &_ceu_org->trls[ 1 ];
/* NODE: Stmts 7406 */

#line 926 "garden.ceu"
    {/* NODE: Dcl_var 7405 */

#line 926 "garden.ceu"
/* start org: _org_3020 */
#line 926 "garden.ceu"
        /* resets org memory and starts org.trail[0]=Class_XXX */
    /* TODO: BUG: _ceu_org is not necessarily the parent for pool allocations */
    ceu_out_org_init(_ceu_app, ((tceu_org*) &(((CEU_Birb*)_ceu_org)->_org_3020_15)),3,Class_Fly,
                     16,
                     0,
                     _ceu_org,0);
/* TODO: currently idx is always "1" for all interfaces access because pools 
 * are all together there. When we have separate trls for pools, we'll have to 
 * indirectly access the offset in the interface. */

#line 926 "garden.ceu"
        _ceu_constr_3019(_ceu_app, ((tceu_org*) &(((CEU_Birb*)_ceu_org)->_org_3020_15)), _ceu_org);

#line 926 "garden.ceu"
    {
#ifdef CEU_STACK_CLEAR
    tceu_stk stk_ = { _ceu_stk, _ceu_org, 1, 1, 1 };
    ceu_app_go(_ceu_app,NULL,
               ((tceu_org*) &(((CEU_Birb*)_ceu_org)->_org_3020_15)), &((tceu_org*) &(((CEU_Birb*)_ceu_org)->_org_3020_15))->trls[0],
               &stk_);
    if (!stk_.is_alive) {
        return;
    }
#else
    ceu_app_go(_ceu_app,NULL,
               ((tceu_org*) &(((CEU_Birb*)_ceu_org)->_org_3020_15)), &((tceu_org*) &(((CEU_Birb*)_ceu_org)->_org_3020_15))->trls[0],
               NULL);
#endif

#line 926 "garden.ceu"
    }
/* NODE: Stmts 7440 */

#line 926 "garden.ceu"
    {/* NODE: Nothing 7414 */
/* NODE: Nothing 8352 */
/* NODE: Nothing 8353 */
/* NODE: Stmts 7439 */

#line 926 "garden.ceu"
    {/* NODE: If 7438 */

#line 926 "garden.ceu"
    if ((!(((*((tceu_org*)(&((CEU_Birb*)_ceu_org)->_org_3020_15))).isAlive)))) {
/* NODE: Block 7435 */

#line 926 "garden.ceu"
    {/* NODE: Stmts 7434 */

#line 926 "garden.ceu"
    {/* NODE: Nothing 7418 */

#line 926 "garden.ceu"
    }
#line 926 "garden.ceu"
/* CLEAR: Block (926) */
#line 926 "garden.ceu"
    if (0) {

#line 926 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
} else {
/* NODE: Block 7437 */

#line 926 "garden.ceu"
    {/* NODE: Stmts 7436 */

#line 926 "garden.ceu"
    {/* NODE: Await 7417 */

#line 926 "garden.ceu"
    _CEU_NO_7417_:
if (0) { goto _CEU_NO_7417_; /* avoids "not used" warning */ }

#line 926 "garden.ceu"
    _ceu_trl->evt = CEU_IN__ok_killed;
_ceu_trl->lbl = Birb_Awake__ok_killed_130;
_ceu_trl->seqno = _ceu_app->seqno;

#line 926 "garden.ceu"
    #ifdef CEU_ORGS_AWAIT
#ifdef CEU_ADTS_AWAIT
_ceu_trl->is_org = 1;
#endif
#endif
_ceu_trl->org_or_adt = (void*)(&((CEU_Birb*)_ceu_org)->_org_3020_15);

#line 926 "garden.ceu"
    return;

case Birb_Awake__ok_killed_130:;

#line 926 "garden.ceu"
    #ifdef CEU_DEBUG_TRAILS
#ifndef CEU_OS
printf("\tOK!\n");
#endif
#endif

#line 926 "garden.ceu"
    }
#line 926 "garden.ceu"
/* CLEAR: Block (926) */
#line 926 "garden.ceu"
    if (0) {

#line 926 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
}

#line 926 "garden.ceu"
    }
#line 926 "garden.ceu"
    }
#line 926 "garden.ceu"
    }
#line 926 "garden.ceu"
/* CLEAR: Block (926) */
#line 926 "garden.ceu"
    {
    /* Reuse current stack frame.
     * We know that CLEAR will not abort anything and return normally.
     * Just save the previous "is_alive", call CLEAR, and restore it.
     */
#ifdef CEU_STACK_CLEAR
    int __ceu_old = _ceu_stk->is_alive;
    _ceu_stk->is_alive = 1;
#endif
    tceu_evt evt;
             evt.id = CEU_IN__CLEAR;
    ceu_sys_go_ex(_ceu_app, &evt,
                  _ceu_stk,
                  _ceu_org,
                  0,
                  4);
#ifdef CEU_STACK_CLEAR
    _ceu_stk->is_alive = __ceu_old;
    ceu_sys_stack_clear(_ceu_stk, _ceu_org,
                        0,3);
#endif
}

#line 926 "garden.ceu"
    #ifdef CEU_ORGS_AWAIT
/* signal ok_killed */
{
    tceu_kill ps = { _ceu_org, _ceu_org->ret, 0,3 };
    tceu_evt evt_;
             evt_.id = CEU_IN__ok_killed;
             evt_.param = &ps;
    ceu_sys_go_ex(_ceu_app, &evt_, _ceu_stk,
                  _ceu_app->data, 0, _ceu_app->data->n);
}
#endif

#line 926 "garden.ceu"
    if (0) {

#line 926 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 863 "garden.ceu"
    }
#line 863 "garden.ceu"
/* CLEAR: Block (863) */
#line 863 "garden.ceu"
    {
    /* Reuse current stack frame.
     * We know that CLEAR will not abort anything and return normally.
     * Just save the previous "is_alive", call CLEAR, and restore it.
     */
#ifdef CEU_STACK_CLEAR
    int __ceu_old = _ceu_stk->is_alive;
    _ceu_stk->is_alive = 1;
#endif
    tceu_evt evt;
             evt.id = CEU_IN__CLEAR;
    ceu_sys_go_ex(_ceu_app, &evt,
                  _ceu_stk,
                  _ceu_org,
                  0,
                  5);
#ifdef CEU_STACK_CLEAR
    _ceu_stk->is_alive = __ceu_old;
    ceu_sys_stack_clear(_ceu_stk, _ceu_org,
                        0,4);
#endif
}

#line 863 "garden.ceu"
    #ifdef CEU_ORGS_AWAIT
/* signal ok_killed */
{
    tceu_kill ps = { _ceu_org, _ceu_org->ret, 0,4 };
    tceu_evt evt_;
             evt_.id = CEU_IN__ok_killed;
             evt_.param = &ps;
    ceu_sys_go_ex(_ceu_app, &evt_, _ceu_stk,
                  _ceu_app->data, 0, _ceu_app->data->n);
}
#endif

#line 863 "garden.ceu"
    if (0) {

#line 863 "garden.ceu"
case Birb_Block__fin_131:;
#line 863 "garden.ceu"
    if (((CEU_Birb*)_ceu_org)->__fin_3022_1) {
    /* NODE: Finally 2813 */
/* NODE: Block 2812 */

#line 873 "garden.ceu"
    {/* NODE: Stmts 2811 */

#line 873 "garden.ceu"
    {/* NODE: EmitExt 2805 */

#line 873 "garden.ceu"
        {

#line 873 "garden.ceu"
    tceu__int __ceu_ps_2805;
{
    tceu__int __ceu_ps_2805_ =
        { (((CEU_Birb*)_ceu_org)->id) };
    __ceu_ps_2805 = __ceu_ps_2805_;
}

#line 873 "garden.ceu"
    
#if defined(ceu_out_emit_FREE_SPRITE)
    ceu_out_emit_FREE_SPRITE((&__ceu_ps_2805))

#elif defined(ceu_out_emit)
    (ceu_out_emit(_ceu_app, CEU_OUT_FREE_SPRITE, sizeof(tceu__int), (void*)(&__ceu_ps_2805)))

#else
    #error ceu_out_emit_* is not defined
#endif
;
#line 873 "garden.ceu"
        }
/* NODE: Set 7269 */

#line 874 "garden.ceu"
/* SET: birb_count *//* NODE: Op2_- 2809 */

#line 874 "garden.ceu"
    (*((CEU_Birb*)_ceu_org)->birb_count) = ((*((CEU_Birb*)_ceu_org)->birb_count)-1);
#line 873 "garden.ceu"
    }
#line 873 "garden.ceu"
/* CLEAR: Block (873) */
#line 873 "garden.ceu"
    if (0) {

#line 873 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */
}

#line 863 "garden.ceu"
    return;
#line 863 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 857 "garden.ceu"
    }
#line 857 "garden.ceu"
/* CLEAR: Block (857) */
#line 857 "garden.ceu"
    if (0) {

#line 857 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 857 "garden.ceu"
    }
#line 857 "garden.ceu"
/* CLEAR: Block (857) */
#line 857 "garden.ceu"
    if (0) {

#line 857 "garden.ceu"
case Birb_Block__fin_132:;
#line 857 "garden.ceu"
    return;
#line 857 "garden.ceu"
        }   /* opened in "if (0)" */
}       /* opened in Block_pre */

#line 857 "garden.ceu"
    ceu_sys_org_free(_ceu_app, _ceu_org);
#ifdef CEU_ORGS_AWAIT
{
    /* signal ok_killed */
#ifdef CEU_STACK_CLEAR
    tceu_stk stk_ = *_ceu_stk;
             stk_.is_alive = 1;
             stk_.down = _ceu_stk;
#endif
    tceu_kill ps = { _ceu_org, _ceu_org->ret, 0, (tceu_ntrl)(_ceu_org->n-1) };
    tceu_evt evt_;
             evt_.id = CEU_IN__ok_killed;
             evt_.param = &ps;
    ceu_sys_go_ex(_ceu_app, &evt_,
#ifdef CEU_STACK_CLEAR
                  &stk_,
#else
                  NULL,
#endif
                  _ceu_app->data, 0, _ceu_app->data->n);
}
#endif

#line 857 "garden.ceu"
    return;
    }
#ifdef CEU_DEBUG
    ceu_out_assert_msg(0, "no return");
#endif
}

#ifdef CEU_OS_APP
static __attribute__((noinline))  __attribute__((noclone))
#endif
void
ceu_app_init (tceu_app* app)
{
    app->seqno = 0;
#if defined(CEU_RET) || defined(CEU_OS_APP)
    app->isAlive = 1;
#endif
#ifdef CEU_ASYNCS
    app->pendingAsyncs = 1;
#endif
#if defined(CEU_ORGS_NEWS_MALLOC) && defined(CEU_ORGS_AWAIT)
    app->dont_emit_kill = 0;
#endif
#ifdef CEU_RET
    app->ret = 0;
#endif
#ifdef CEU_ORGS_NEWS_MALLOC
    app->tofree = NULL;
#endif
#ifdef CEU_WCLOCKS
    app->wclk_late = 0;
    app->wclk_min_set = CEU_WCLOCK_INACTIVE;
    app->wclk_min_cmp = CEU_WCLOCK_INACTIVE;
#ifdef CEU_TIMEMACHINE
    app->wclk_late_ = 0;
    app->wclk_min_set_ = CEU_WCLOCK_INACTIVE;
    app->wclk_min_cmp_ = CEU_WCLOCK_INACTIVE;
#endif
#endif
#ifdef CEU_THREADS
    pthread_mutex_init(&app->threads_mutex, NULL);
    /*PTHREAD_COND_INITIALIZER,*/
    app->threads_n = 0;

    /* All code run atomically:
     * - the program is always locked as a whole
     * -    thread spawns will unlock => re-lock
     * - but program will still run to completion
     */
    CEU_THREADS_MUTEX_LOCK(&app->threads_mutex);
#endif

    

#ifdef CEU_OS_APP

#ifdef __AVR
    app->code  = (__typeof__(ceu_app_go)*)    (((word)app->addr>>1) + &ceu_app_go);
    app->calls = (__typeof__(ceu_app_calls)*) (((word)app->addr>>1) + &ceu_app_calls);
#else
    app->code  = (__typeof__(ceu_app_go)*)    (&ceu_app_go);
    app->calls = (__typeof__(ceu_app_calls)*) (&ceu_app_calls);
#endif

#else   /* !CEU_OS_APP */

    app->code  = (__typeof__(ceu_app_go)*)    (&ceu_app_go);

#endif  /* CEU_OS_APP */

#ifndef CEU_OS_APP
#ifdef CEU_DEBUG
    CEU_APP_SIG = app;
    signal(SIGSEGV, ceu_segfault);
#endif
#endif

    ceu_out_org_init(app, app->data, CEU_NTRAILS, Class_Main,
                     0, 0,
                     NULL, 0);

#ifdef CEU_LUA
    ceu_luaL_newstate(app->lua);
    ceu_out_assert(app->lua != NULL);
    ceu_luaL_openlibs(app->lua);
    ceu_lua_atpanic(app->lua, ceu_lua_atpanic_f);    /* TODO: CEU_OS */
#endif

    app->data->trls[0].evt = CEU_IN__INIT;
    app->data->trls[0].seqno = 0;
    ceu_sys_go(app, CEU_IN__INIT, NULL);
}

/* EXPORTED ENTRY POINT
 * CEU_EXPORT is put in a separate section ".export".
 * "gcc-ld" should place it at 0x00, before ".text".
 */

#ifdef CEU_OS_APP
__attribute__ ((section (".export")))
void CEU_EXPORT (uint* size, tceu_init** init
#ifdef CEU_OS_LUAIFC
                , char** luaifc
#endif
) {
    *size = sizeof(CEU_Main);
    *init = (tceu_init*) &ceu_app_init;
#ifdef CEU_OS_LUAIFC
    *luaifc = (=== APP_LUAIFC ===);
#endif
}
#endif
